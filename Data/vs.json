{"sceneFolders":["C:\\Users\\parkm\\Dropbox\\synScenes"],"sceneSources":{"ASCII Art":"custom","Acid Jelly":"custom","Alien Cavern":"built-in","Beamers":"built-in","Bezier Runes":"custom","Biopsy":"built-in","Biopsy_V2":"built-in","CandyWarp":"custom","Canvas":"built-in","Chroma Cascade":"marketplace","Churning":"built-in","Circles5":"built-in","Circuit Bending":"built-in","Cloud Ten":"built-in","Cloud Toonscape Lo-Fi":"custom","Compound Iris":"built-in","Conc Circles":"custom","ContinuaVariation":"custom","CubeCluster":"custom","Cubes+Spheres":"custom","CubicMatrixModulatorRedux":"custom","Deep Field (Star Nest)":"custom","Deeper":"built-in","DiamondVision":"custom","DimensionMorphingTopography":"custom","Dispersion":"built-in","Dynamical Flame":"built-in","EXOplanet":"built-in","Equirectangular":"built-in","Filter Blown":"built-in","Fire Tunnel":"built-in","Fluid Body":"built-in","Fractilian Foundation":"built-in","FractilianParabolicCircleInversion":"custom","Fuzzy Signal":"built-in","GPU_Melter":"built-in","Gaussian SmoothLife":"built-in","Glassier":"built-in","Glitch":"built-in","Glob":"built-in","HEXOplanet":"built-in","HelloWorld":"custom","Hex Array":"built-in","HexTunnel":"built-in","HexVortex":"custom","Hills, Eels":"built-in","Hoop Dreams":"custom","Hue Review":"built-in","IQ_ApollonianFractal":"custom","Ink Shot":"built-in","KIFS Flythrough":"built-in","KaleidoWHOA, MAN":"built-in","KaliCircuitsExplorer":"custom","Linescape":"custom","Lost in the Sauce":"built-in","MIDI_MAPPING":"built-in","Magnetismic":"marketplace","MandalaScope":"custom","Mandelbrot Decoration":"built-in","Meta Experiment 3":"built-in","Milk, Honey, Smoke, Bile":"built-in","Min Max Hex":"built-in","Molten":"built-in","Myoplasm":"built-in","Neuron Proximitors":"built-in","Nova":"built-in","OpArtExp1":"custom","PLUS":"built-in","PRIMITIV_logik":"built-in","Pattern_DataBlocks_03":"custom","Pop":"built-in","QuaziCrystal":"custom","Quicksand":"built-in","REDRUM":"built-in","RGBMandlish":"custom","RainbowRingCubicTwist":"custom","Raw Video":"built-in","Ray Marching Experiment 62":"built-in","Raymarched Reflections":"built-in","Rearranged":"built-in","Scaffold Fractal":"built-in","SearchingForSomething":"custom","Shrouded":"built-in","Sinusoidal Warp":"built-in","SpaceSpore":"custom","SpiralSurface1":"custom","Sprinkles":"built-in","Square Tunnel":"custom","SquareCellStructureScan":"custom","SquareShoals":"built-in","Stained Glass":"built-in","StringArt":"custom","Sun_Set":"built-in","Swarm":"built-in","Tapestry Fract +":"custom","Terrain Lattice":"built-in","Test Card":"built-in","Thresholder":"built-in","Thresholder_dup":"custom","Traced Tunnel":"built-in","Transparent Isoslices":"built-in","TruchetDualLevelSpin":"custom","Tunnel Beauty 6":"built-in","Turbo Encabulator Fluid":"built-in","TwistyColoredBars":"custom","UltimateKaliCircuits":"custom","Untitled Sketch":"custom","Vein Melter":"built-in","VideoFX_1":"built-in","VideoFX_1_dup":"custom","VideoFX_DirectionalBlur":"built-in","Voronoi Geode":"built-in","VoronoiCubes":"custom","VoronoiLines":"custom","Waterly":"built-in","WaveLines":"custom","Welcome Scene":"built-in","Wessels":"custom","Wisps":"custom","Zebre":"custom","flythrough":"custom","lattix":"built-in","pxl_sort_1":"built-in","replik8":"built-in"},"scenes":[{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"amount","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by IMIMOT (Ported from https://www.shadertoy.com/view/lssGDj)","DESCRIPTION":"ASCII Art","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\ascii_art.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"ASCII Art","IMAGES":null,"IMAGE_PATH":"ascii_art.synScene\\ascii_art.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"amount\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by IMIMOT (Ported from https://www.shadertoy.com/view/lssGDj)\",\n\t\"DESCRIPTION\" : \"ASCII Art\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"ascii_art.png\",\n\t\"TITLE\" : \"ASCII Art\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"float character(float n, vec2 p)\r\n{\r\n    p = floor(p * vec2(4.0, 4.0) + 2.5);\r\n    p.y = 4.0 - p.y; // Flip the y-coordinate\r\n    if (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\r\n    {\r\n        if (int(mod(n / exp2(p.x + 5.0 * p.y), 2.0)) == 1) return 1.0;\r\n    }\t\r\n    return 0.0;\r\n}\r\n\r\nvec4 renderMain() { \r\n    vec4 out_FragColor = vec4(0.0);\r\n\r\n    float _amount = amount * 36.0 + 8.0;\r\n    vec2 uv = _xy.xy;\r\n    uv.y = 1.0 - uv.y; // Flip the y-coordinate\r\n    vec3 col = IMG_NORM_PIXEL(syn_UserImage, (floor(uv / _amount) * _amount / RENDERSIZE.xy)).rgb;\r\n\t\r\n    float gray = (col.r + col.g + col.b) / 3.0;\r\n\t\r\n    float n =  65536.0;             // .\r\n    if (gray > 0.2) n = 65600.0;    // :\r\n    if (gray > 0.3) n = 332772.0;   // *\r\n    if (gray > 0.4) n = 15255086.0; // o \r\n    if (gray > 0.5) n = 23385164.0; // T\r\n    if (gray > 0.6) n = 15252014.0; // C\r\n    if (gray > 0.7) n = 13199452.0; // A\r\n    if (gray > 0.8) n = 11512810.0; // G\r\n\t\t\r\n    vec2 p = mod(uv / (_amount / 2.0), 2.0) - vec2(1.0);\r\n    col = col * character(n, p);\t\r\n    out_FragColor = vec4(col, 1.0);\r\n\r\n    return out_FragColor; \r\n}\r\n\r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"ASCII Art","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.0700000002980232,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.129999995231628,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"contrast","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":11,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"radius","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":10.3199996948242,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"colorShift","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"rotation","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":10,"MIN":-10,"NAME":"sinMul","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.38000011444092,"DESCRIPTION":"","MAX":10,"MIN":-10,"NAME":"cosMul","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"yMul","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.280000001192093,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"xMul","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"xSpeed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"ySpeed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00300000002607703,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"gloop","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":4.98999977111816,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"yDivide","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":6.26999998092651,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"xDivide","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"https://www.shadertoy.com/user/yozic","DESCRIPTION":"From: https://www.shadertoy.com/view/WtGfRw","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\acid_jelly.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Acid Jelly","IMAGES":null,"IMAGE_PATH":"acid_jelly.synScene\\acid_jelly.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.07,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.13,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"contrast\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 11,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"radius\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 10.32,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"colorShift\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rotation\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : -10,\n\t\t\t\"NAME\" : \"sinMul\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.38,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : -10,\n\t\t\t\"NAME\" : \"cosMul\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"yMul\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.28,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"xMul\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"xSpeed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"ySpeed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.003,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"gloop\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 4.99,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"yDivide\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 6.27,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"xDivide\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"https://www.shadertoy.com/user/yozic\",\n\t\"DESCRIPTION\" : \"From: https://www.shadertoy.com/view/WtGfRw\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"acid_jelly.png\",\n\t\"TITLE\" : \"Acid Jelly\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\nfloat iTime = TIME;\n\n#define PI 3.141592\n#define orbs 20.\n\n\n\n\n#define orbSize 6.46\n#define sides 1.\n\n\n\n\n\n\nvec4 orb(vec2 uv, float s, vec2 p, vec3 color, float c) {\n  return pow(vec4(s / length(uv + p) * color, 1.), vec4(c));\n}\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation * iTime / 10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + iTime * xSpeed) + cos(uv.y / yDivide - iTime);\n    uv.y += cosMul * cos(uv.x * xMul - iTime * ySpeed) - sin(uv.x / xDivide - iTime);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + iTime / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    fragColor += .65 - orb(uv, orbSize, position, 1. - color, contrast);\n  }\n  fragColor.a = 1.0;\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n    mainImage(out_FragColor, _xy.xy);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Acid Jelly","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Adds falling objects that morph into the ceiling and floor.","MAX":0,"MIN":1,"NAME":"droppers","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":1,"DESCRIPTION":"Add cylinders that cut through the room and out into the sky above.","MAX":0,"MIN":1,"NAME":"cylinders","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Jumps when it detects a beat.","MAX":1,"MIN":0,"NAME":"beat_twitching","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Lights in certain ridges flash on drum hits.","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Removes the walls and ceiling to reveal full sky. Warning: This plus cylinders or droppers can get very laggy!","MAX":1,"MIN":0,"NAME":"astral_plane","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Render the scene in 3D-pixels for a low-fi look.","MAX":1,"MIN":0,"NAME":"voxelate","PARAMS":0.300000011920929,"TYPE":"slider smooth","UI_GROUP":"voxelation"},{"DEFAULT":50,"DESCRIPTION":"Increase to make the voxelation effect much more pronounced, with larger voxels.","MAX":1,"MIN":50,"NAME":"voxel_size","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"voxelation"},{"DEFAULT":[0,0],"DESCRIPTION":"If manual_camera is on, use this XY to look around.","MAX":[1,1],"MIN":[-1,-1],"NAME":"camera_look","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Moves camera in and looks up into the sky, which is filled with your media.","MAX":-3,"MIN":0,"NAME":"gaze_into_the_abyss","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Camera automatically rotates around the room, but turn this on to take manual control.","MAX":1,"MIN":0,"NAME":"manual_camera","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Instead of the default color scheme, turning this up lets you select slight variations.","MAX":1,"MIN":0,"NAME":"color_mod","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Once color_mod is all the way up, select from one of 6 color schemes here.","MAX":5,"MIN":0,"NAME":"palette_select","TYPE":"slider","UI_GROUP":"color"}],"CREDIT":"aiekick","DESCRIPTION":"Alien Cavern","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\alien_cavern.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Alien Cavern","IMAGES":null,"IMAGE_PATH":"alien_cavern.synScene\\alien_cavern.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.0,\n         \"MIN\" : 1.0,\n         \"NAME\" : \"droppers\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"action\",\n         \"DESCRIPTION\":\"Adds falling objects that morph into the ceiling and floor.\"\n      },\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.0,\n         \"MIN\" : 1.0,\n         \"NAME\" : \"cylinders\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"action\",\n         \"DESCRIPTION\":\"Add cylinders that cut through the room and out into the sky above.\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"beat_twitching\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"action\",\n         \"DESCRIPTION\":\"Jumps when it detects a beat.\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flashing\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"action\",\n         \"DESCRIPTION\":\"Lights in certain ridges flash on drum hits.\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"astral_plane\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"action\",\n         \"DESCRIPTION\":\"Removes the walls and ceiling to reveal full sky. Warning: This plus cylinders or droppers can get very laggy!\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"voxelate\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.3,\n         \"UI_GROUP\" : \"voxelation\",\n         \"DESCRIPTION\":\"Render the scene in 3D-pixels for a low-fi look.\"\n      },\n      {\n         \"DEFAULT\" : 50.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 50.0,\n         \"NAME\" : \"voxel_size\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"voxelation\",\n         \"DESCRIPTION\":\"Increase to make the voxelation effect much more pronounced, with larger voxels.\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"camera_look\",\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"camera\",\n         \"DESCRIPTION\":\"If manual_camera is on, use this XY to look around.\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : -3.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"gaze_into_the_abyss\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"camera\",\n         \"DESCRIPTION\":\"Moves camera in and looks up into the sky, which is filled with your media.\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"manual_camera\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"camera\",\n         \"DESCRIPTION\":\"Camera automatically rotates around the room, but turn this on to take manual control.\"\n      },\n\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"color_mod\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"color\",\n         \"DESCRIPTION\":\"Instead of the default color scheme, turning this up lets you select slight variations.\"\n      },      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 5.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"palette_select\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"color\",\n         \"DESCRIPTION\":\"Once color_mod is all the way up, select from one of 6 color schemes here.\"\n      }\n   ],\n   \"CREDIT\" : \"aiekick\",\n   \"DESCRIPTION\" : \"Alien Cavern\",\n   \"HEIGHT\" : 720,\n   \"IMAGE_PATH\" : \"alien_cavern.png\",\n   \"TITLE\" : \"Alien Cavern\",\n   \"WIDTH\" : 1280\n}\n","PASSES":null,"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nfunction CameraPos () {\n  this.x = 0.0;\n  this.y = 0.0;\n  this.z = 0.0;\n}\n\nfunction CameraLook () {\n  this.x = 0.0;\n  this.y = 0.0;\n  this.z = 0.0;\n}\n\n\nvar bpmcount = new BPMCounter();\nvar cPos = new CameraPos();\nvar cLook = new CameraLook();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar bpmTime = 0;\nvar bassT = 0.0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM/4.0;\n  bpmcount.updateTime(bpm, dt);\n\n  uniforms.script_time = bpmcount.time;\n\n\n  // if (bpmcount.didIncrement == 1.0){\n  //   tAtLast0 = bpmTime;\n  // }\n  // bpmTime = tAtLast0;\n  // bpmTime += (1. - Math.exp(-bpmcount.timeWithinBeat*3.))*inputs.amount_to_step;\n  // uniforms.script_time = bpmTime;\n\n  bassT = bassT + Math.pow(inputs.syn_BassLevel*0.5,2.0)*(dt*60);\n  uniforms.script_bass_time = bassT;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"\n\n// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat dstepf = 0.0;\n#define uScreenSize RENDERSIZE.xy\n#define uTime TIME\n\nconst vec2 RMPrec = vec2(0.6, 0.01); // ray marching tolerance precision // low, high\nconst vec2 DPrec = vec2(1e-3, 30.); // ray marching distance precision // low, high\n    \n// light\nconst vec3 LCol = vec3(0.8,0.5,0.2);\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n// material\nconst vec3 MCol = vec3(0.);\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n    \n#define mPi 3.14159\n#define m2Pi 6.28318\n\nfloat flashLevel = mix(0.0, pow(syn_HighHits, 2.0), flashing);\n\nvec2 s,g,uv,m;\n\nvec2 uvs(vec3 p) // uv sphere\n{\n\tp = normalize(p);\n\tvec2 sp;\n\tsp.x = atan(p.z, p.x) / (m2Pi+1.27);\n\tsp.y = asin(p.y) / (mPi);\n\treturn sp;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( .5+.5*(b-a)/k, 0., 1. );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat sdCyl( vec3 p, vec2 h )\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 getHotColor(float Temp) // blackbody temperature color\n{\n\tvec3 col = vec3(255.);\n\tcol.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n\tif (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvec2 getTemp(vec3 p)\n{\n\tp*=2.;\n\tfloat r = fract(p.x+p.z);\n\treturn vec2(dot(p,p)*(1000.)*r,r);\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\tsky += _loadUserImage(sunDir.xz*vec2(0.89,1.0)+vec2(0.175,0.0)).rgb*syn_HighHits;\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec3 colorPaletteChooser(float colReg, float var){\n  vec3 paletteCol = vec3(0.5);\n  if (colReg < 1.0){\n    paletteCol = _palette(var, vec3(0.500, 0.500, 0.520), vec3(0.500, 0.500, 0.500), vec3(0.780, 0.765, 0.750), vec3(0.360, 0.570, 0.680));\n  } else if (colReg < 2.0){\n    paletteCol = _palette(var, vec3(0.500, 0.580, 0.500), vec3(0.190, 0.460, 0.500), vec3(0.760, 0.740, 0.580), vec3(1.000, 0.300, 0.490));\n  } else if (colReg < 3.0){\n    paletteCol = _palette(var,vec3(0.129, 0.359, 0.072), vec3(0.933, 0.561, 0.616), vec3(0.334, 1.013, 0.882), vec3(0.597, 0.050, 0.885));\n  } else if (colReg < 4.0){\n    paletteCol = _palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.7191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 5.0){\n    paletteCol = _palette(1.0-var,vec3(1.040, 0.180, 0.260), vec3(0.053, 0.775, 0.330), vec3(0.142, 0.523, 0.800), vec3(0.242, 0.887, 0.000));\n  }\n  return paletteCol;\n}\n\nvec3 getCol(vec3 p){\n\tfloat temp = getTemp(p).x;\n\tvec3 col = getHotColor(temp);\n\tcol = mix(col, colorPaletteChooser(palette_select, clamp(temp,0.0,1.0))*sin(p.z*0.2+TIME*0.1), color_mod);\n\treturn col;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return mix(length(q)-t.y, length(p)-t.x*0.5, 1.0-syn_Presence);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec2 map(vec3 p)\n{\n\tp = mix(p, floor(p)+_pixelate(fract(p), voxel_size), voxelate);\n\n\tvec2 res = vec2(0.);\n    \n\tfloat t = sin(uTime*0.2)*.5+.5;\n\tt*=2.;\n\n\tfloat rugo = cos(2.*p.x+syn_BassTime*0.3+syn_Time*0.1+TIME*0.1)*sin(1.5*p.z)*sin(3.*p.y+syn_BeatTime*beat_twitching)*cos(1.3);\n    \n\tvec3 sci = vec3(1.0-syn_Presence,2.,0.9);// scale in\n\tvec3 pob = vec3(0.,5.,0.);// pos bottom\n\tvec3 pocy = vec3(0.,-5.,0.);//pos cyl\n        \n\tvec3 col = getCol(p);\n\n\tfloat diamhole = 2.1*syn_Presence;\n\tfloat spi = length(p*sci) - 4.5 - rugo;//in\n\tfloat spb = length(p+pob) - 4.5 + dot(col, vec3(0.01));//bottom\n\tfloat spo = spi - 1. + flashLevel*0.8 + 2.0*astral_plane;//out\n\n\tfloat cyl = sdCyl(p+pocy, vec2(diamhole,4.));//top hole\n    \n\tfloat disp = dot(col, vec3(0.03));\n    \n\tfloat spicyl = smin(spi,cyl,0.6) + disp;\n\tfloat cavern = smin(max(-spicyl, spo ), spb, 3.5);\n  \n\tvec3 dotPos = opRep(p+vec3(0.0, TIME, 0.0), vec3(5.0, 4.0, 3.0));\n\n\tcavern = smin(cavern, sdTorus(dotPos+0.25, vec2(0.1,0.001))+step(5.0, p.y)*1000.0+droppers*10000.0, 2.0);\n\tcavern = smin(cavern, sdCylinder(dotPos+0.25, vec3(0.1,0.001, 0.05))+step(5.0, p.y)*1000.0+cylinders*100000.0, 0.5+syn_BPMSin4*0.5);\n\n  dstepf += 0.01;\n    \n\treturn vec2(cavern, 1.0);\n}\n\n\nvec3 nor(vec3 p, float prec)\n{\n\tvec2 e = vec2(prec, 0.);\n    \n\tvec3 n;\n    \n\tn.x = map(p+e.xyy).x - map(p-e.xyy).x; \n\tn.y = map(p+e.yxy).x - map(p-e.yxy).x; \n\tn.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n\treturn normalize(n); \n}\n\nvec3 ads( vec3 p, vec3 n )\n{\n\tvec3 ldif = normalize( LPos - p);\n\tvec3 vv = normalize( vec3(0.) - p );\n\tvec3 refl = reflect( vec3(0.) - ldif, n );\n    \n\tvec3 amb = MAmb*LAmb;\n\tvec3 dif = max(0., dot(ldif, n.xyz)) * MDif * LDif;\n\tvec3 spe = vec3( 0. );\n\tif( dot(ldif, vv) > 0.)\n\t\tspe = pow(max(0., dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n\tvec3 col = amb*1.2 + dif*1.5 + spe*0.8;\n    \n\treturn col;\n}\n\nvec4 scn(vec4 col, vec3 ro, vec3 rd)\n{\n\tfloat s = DPrec.x;\n\tfloat d = 0.;\n\tvec3 p = ro+rd*d;\n\tvec4 c = col;\n    \n\tfloat b = 0.35;\n    \n\tvec4 glow = vec4(0.0);\n\n\t//MAPPING\n\tfor(int i=0;i<200;i++)\n\t{\n\t\tif(s<DPrec.x||s>DPrec.y) break;\n\t\tvec2 dat = map(p);\n\t\ts = dat.x;\n\t\t// glow += d*texture(syn_UserImage, p.xz*0.2);\n\t\td += s*(s>DPrec.x?RMPrec.x:RMPrec.y);\n\t\tp = ro+rd*d;\n\t}\t\n    \n\tfloat lightIntensity = sin(uTime*0.2)*.5;\n\n\tif (s<DPrec.x)\n\t{\n\t\tvec2 r = getTemp(p);\n\t\n\t\tvec3 n = nor(p, r.y); \n      \t\n\t\tc.rgb = getCol(p) + dot(n,rd) + ads(p,n) * lightIntensity;\n\t}\n\telse\n\t{\n\t\tvec3 dir = -normalize(vec3(2.,10.,0.));\n\t\tvec3 col = vec3(lightIntensity);\n\t\tc.rgb = GetSky(rd, dir, col);\n\t}\n\tc+=glow*0.01;\n\treturn c;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro);\n\tvec3 u =  normalize(cross(cu, rorg));\n\tvec3 v =  normalize(cross(rorg, u));\n\tvec3 rd = normalize(rorg + u*uv.x + v*uv.y);\n\treturn rd;\n}\n\nvec4 Image(in vec2 fragCoord )\n{\n\ts = uScreenSize;\n\tg = fragCoord;\n\tuv = (2.*g-s)/s.y;\n\t\n\tfloat t = uTime*.2;\n\tfloat ts = sin(t)*.5+.5;\n    \n\tfloat axz = -t/2; // angle XZ\n\tfloat axy = 2.6 + 0.42*ts; // angle XY // inf 3.02 // sup 2.60\n\taxz = mix(axz, camera_look.x*PI, manual_camera); // angle XZ\n\taxy = mix(axy, camera_look.y, manual_camera); // angle XY // inf 3.02 // sup 2.60\n\tfloat cd = 3.+gaze_into_the_abyss;// cam dist to scene origine\n\n\t//axy = 2.6; // on bloque la camera an haut pour mise au point\n    \n\tfloat ap = 1.; // angle de perspective\n\tvec3 cu = vec3(0.,1.,0.); // cam up \n\tvec3 org = vec3(0., 0.8, 0.); // scn org\n\tvec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; // cam org\n    \n\tvec3 rd = cam(uv, ro, cu, org, ap);\n    \n\tvec4 c = vec4(0.,0.,0.,1.); // col\n    \n\tc = scn(c, ro, rd);//scene\n\t\n  c += dstepf;\n    \n\treturn c;\n}\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n  fragColor = Image(fragCoord);\n\n  fragColor = _gamma(fragColor, 0.3);\n\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Alien Cavern","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":21,"DESCRIPTION":"Number of beams. More beams means slower performance.","MAX":30,"MIN":1,"NAME":"num_beams","TYPE":"slider","UI_GROUP":"beams"},{"DEFAULT":0.0149999996647239,"DESCRIPTION":"","MAX":0.400000005960464,"MIN":-0.100000001490116,"NAME":"beam_width","TYPE":"slider","UI_GROUP":"beams"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.400000005960464,"MIN":0,"NAME":"wobble_on","TYPE":"toggle","UI_GROUP":"beams"},{"DEFAULT":10,"DESCRIPTION":"Separation and speed of flight.","MAX":50,"MIN":-50,"NAME":"separation","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"beams"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"spiral","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"direct_shot","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"random","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"monochrome","TYPE":"toggle","UI_GROUP":"monochrome"},{"DEFAULT":[1,1,1],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"monochrome_color","TYPE":"color","UI_GROUP":"monochrome"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"color_palette","TYPE":"bang counter","UI_GROUP":"color"}],"CREDIT":"sheltron","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\beamers.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Beamers","IMAGES":null,"IMAGE_PATH":"beamers.synScene\\beamers.png","JSON_CODE":"{\n  \"TITLE\": \"Beamers\",\n  \"DESCRIPTION\": \"\",\n  \"CREDIT\": \"sheltron\",\n  \"IMAGE_PATH\": \"beamers.png\",\n  \"CATEGORIES\": [\n    \"Generator\"\n  ],\n  \"PASSES\":[{\"TARGET\": \"limitSize\", \"WIDTH\":1200, \"HEIGHT\":720}],\n  \"CONTROLS\": [\n    {\n      \"NAME\": \"num_beams\",\n      \"DESCRIPTION\": \"Number of beams. More beams means slower performance.\",\n      \"TYPE\": \"slider\",\n      \"MIN\": 1,\n      \"MAX\": 30,\n      \"DEFAULT\": 21,\n      \"UI_GROUP\": \"beams\"\n    },\n    {\n      \"NAME\": \"beam_width\",\n      \"TYPE\": \"slider\",\n      \"MIN\": -0.1,\n      \"MAX\": 0.4,\n      \"DEFAULT\": 0.015,\n      \"UI_GROUP\": \"beams\"\n    },\n    {\n      \"NAME\": \"wobble_on\",\n      \"LABEL\": \"Wobble Amount\",\n      \"TYPE\": \"toggle\",\n      \"MIN\": 0,\n      \"MAX\": 0.4,\n      \"DEFAULT\": 0.00,\n      \"UI_GROUP\": \"beams\"\n    },\n    {\n      \"NAME\": \"separation\",\n      \"DESCRIPTION\": \"Separation and speed of flight.\",\n      \"TYPE\": \"slider smooth\",\n      \"PARAMS\": 0.1,\n      \"MIN\": -50.0,\n      \"MAX\": 50.0,\n      \"DEFAULT\": 10.0,\n      \"UI_GROUP\": \"beams\"\n    },\n    {\n      \"NAME\": \"spiral\",\n      \"TYPE\": \"toggle smooth\",\n      \"PARAMS\": 0.2,\n      \"DEFAULT\": 0,\n      \"UI_GROUP\": \"motion\"\n    },\n    {\n      \"NAME\": \"direct_shot\",\n      \"TYPE\": \"toggle smooth\",\n      \"PARAMS\": 0.2,\n      \"DEFAULT\": 0,\n      \"UI_GROUP\": \"motion\"\n    },\n    {\n      \"NAME\": \"random\",\n      \"TYPE\": \"toggle smooth\",\n      \"PARAMS\": 0.2,\n      \"DEFAULT\": 0,\n      \"UI_GROUP\": \"motion\"\n    },\n    {\n      \"NAME\": \"monochrome\",\n      \"TYPE\": \"toggle\",\n      \"DEFAULT\": 0,\n      \"UI_GROUP\": \"monochrome\"\n    },\n    {\n      \"NAME\": \"monochrome_color\",\n      \"TYPE\": \"color\",\n      \"DEF_COLOR\": [1.0,1.0,1.0],\n      \"UI_GROUP\": \"monochrome\"\n    },{\n      \"NAME\": \"color_palette\",\n      \"TYPE\": \"bang counter\",\n      \"DEFAULT\": 0,\n      \"UI_GROUP\": \"color\"\n    }\n  ]\n}","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"limitSize","WIDTH":1200}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nvar bpmcount = new BPMCounter();\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM;\n  bpmcount.updateTime(bpm, dt);\n\n  if (bpmcount.didIncrement == 1.0){\n    tAtLast0 = t;\n  }\n  t = tAtLast0;\n  t += (1. - Math.exp(-bpmcount.timeWithinBeat*9.));\n  uniforms.script_time = t;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"vec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n           dot(p,vec2(269.5,183.3)), \n           dot(p,vec2(419.2,371.9)) );\n  return fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise(vec2 x, float u, float v )\n{\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n    \n  float k = 1.0+63.0*pow(1.0-v,4.0);\n  \n  float va = 0.0;\n  float wt = 0.0;\n  for( int j=-2; j<=2; j++ )\n  for( int i=-2; i<=2; i++ )\n  {\n    vec2 g = vec2( float(i),float(j) );\n    vec3 o = hash3( p + g )*vec3(u,u,1.0);\n    vec2 r = g - f + o.xy;\n    float d = dot(r,r);\n    float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n    va += o.z*ww;\n    wt += ww;\n  }\n\n  return va/wt;\n}\n\nvec3 colorPaletteChooser(float colReg, float var){\n  vec3 paletteCol = vec3(0.5);\n  if (colReg < 1.0){\n    paletteCol = _palette(var, vec3(0.500, 0.500, 0.520), vec3(0.500, 0.500, 0.500), vec3(0.780, 0.765, 0.750), vec3(0.360, 0.570, 0.680));\n  } else if (colReg < 2.0){\n    paletteCol = _palette(var, vec3(0.500, 0.580, 0.500), vec3(0.190, 0.460, 0.500), vec3(0.760, 0.740, 0.580), vec3(1.000, 0.300, 0.490));\n  } else if (colReg < 3.0){\n    paletteCol = _palette(1.0-var,vec3(0.500, 0.940, 0.900), vec3(0.600, 0.640, 0.350), vec3(0.680, 1.020, 0.405), vec3(0.380, 0.440, 0.095));\n  } else if (colReg < 4.0){\n    paletteCol = _palette(var,vec3(0.500, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.825, 0.750), vec3(0.500, 0.500, 0.500));\n  } else if (colReg < 5.0){\n    paletteCol = _palette(1.0-var,vec3(0.000, 0.580, 0.453), vec3(0.848, 0.703, 0.110), vec3(0.700, 0.175, 0.542), vec3(0.000, 0.182, 0.915));\n  } else if (colReg < 6.0){\n    paletteCol = _palette(var,vec3(0.129, 0.359, 0.072), vec3(0.933, 0.561, 0.616), vec3(0.334, 1.013, 0.882), vec3(0.597, 0.050, 0.885));\n  } else if (colReg < 7.0){\n    paletteCol = _palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.7191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 8.0){\n    paletteCol = _palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.2191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 9.0){\n    paletteCol = _palette(var,vec3(0.000, 0.040, 0.073), vec3(0.000, 0.530, 0.420), vec3(0.485, 0.930, 0.931), vec3(0.400, 0.599, 0.520));\n  } else if (colReg < 10.0){\n    paletteCol = _palette(1.0-var,vec3(1.040, 0.180, 0.260), vec3(0.053, 0.775, 0.330), vec3(0.142, 0.523, 0.800), vec3(0.242, 0.887, 0.000));\n  }\n  return paletteCol;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nbool is_point_above_line(vec2 pt, float slope, float intercept) {\n  bool returnMe = false;\n  float y = slope * pt.x + intercept;\n  if (y < pt.y)\n    returnMe = true;\n  return returnMe;\n}\n\n//  returns two values – distrance from the line and the percentage of the way on the line\nfloat distance_from_point_to_line(vec2 pt, vec2 l1, vec2 l2){\n  float returnMe = 0.0;\n  float a = (l2.y - l1.y);\n  float b = (l2.x - l1.x);\n  float c = 0.0;\n  \n  //  if b is zero, this is a vertical line!\n  //  in which case distance is based on x distance alone\n  if (b == 0.0) {\n    float minY = min(l1.y, l2.y);\n    float maxY = max(l1.y, l2.y);\n    \n    //  if we're between the two points distrance is straight up x diff\n    if ((pt.y > minY) && (pt.y < maxY)) {\n      returnMe = abs(pt.x-l1.x);\n    }\n    else  {\n      //returnMe = min(distance(pt, l1), distance(pt, l2));\n      returnMe = -1.0;\n    }\n  }\n  //  if a is zero, this is a horizontal line\n  else if (a == 0.0)  {\n    float minX = min(l1.x, l2.x);\n    float maxX = max(l1.x, l2.x);\n    \n    //  if we're between the two points distrance is straight up y diff\n    if ((pt.x > minX) && (pt.x < maxX)) {\n      returnMe = abs(pt.y - l1.y);\n    }\n    else  {\n      //returnMe = min(distance(pt, l1), distance(pt, l2));\n      returnMe = -1.0;\n    }\n  }\n  //  if b isn't 0, solve for c now that we know a, b, and either l1 or l2\n  else  {   \n    //  here's the tricky bit-\n    //  if pt is beyond l1 and l2, we should switch to distance from those points\n    //  in order to determine this we need to use the perpendicular lines to the segment l1|l2 that pass through l1 & l2\n    //  the slope of the perp line will be -1.0 / slope of original line\n    float m = a / b;\n    float perpm = -b / a;\n    vec2 left_line_pt = l1;\n    vec2 right_line_pt = l2;\n    if (l1.x > l2.x)  {\n      left_line_pt = l2;\n      right_line_pt = l1;\n    }\n    \n    float perp_intercept1 = left_line_pt.y - perpm * left_line_pt.x;\n    float perp_intercept2 = right_line_pt.y - perpm * right_line_pt.x;\n    \n    if (m > 0.0)  {\n      returnMe = abs(a * pt.x - b * pt.y + l2.x * l1.y - l2.y * l1.x) / sqrt(a*a + b*b);\n    }\n    else  {\n      returnMe = abs(a * pt.x - b * pt.y + l2.x * l1.y - l2.y * l1.x) / sqrt(a*a + b*b);\n    }\n  }\n   \n    return returnMe;\n}\n\nvec4 renderMain() {\n  if (PASSINDEX == 0.0){\n  vec4 out_FragColor = vec4(0.0);\n  float   maxWidth = 3.0;\n  float   minWidth = 0.01;\n  \n  vec4    result = vec4(0.0);\n  vec2    thisPoint = _uvc*10.0;\n  vec3    colorHSL;\n  vec2    pt1, pt2;\n  float   baseHue = rand(vec2(floor(num_beams), 1.0));\n  \n  vec2 wobbleVector = vec2(0.0);\n  \n  float width = maxWidth;\n  float timeVar = syn_Time;\n  float j = floor(timeVar);\n\n  float bigNoise = iqnoise(500.0*_uvc, 1.0, 0.0);\n  // float medNoise = iqnoise(1000.0*_uvc, 1.0, 0.0);\n  // float smlNoise = iqnoise(10000.0*_uvc, 1.0, 1.0);\n\n  float currentRegime = floor(j/num_beams);\n\n  for (float i = 0.0; i < 60.0; ++i)  {\n    float currentRank = mod(i+j,num_beams)/num_beams + (1/num_beams)*fract(timeVar);\n    float lineSeed = i+floor((i+j)/num_beams)*3.0;\n    float red = 0.0;\n    // if (mod(i+j, lineCount) == 0){\n    //   lineSeed += floor(timeVar/lineCount);\n    //   red = 1.0;\n    // }\n\n    if (i >= num_beams - 1.0)\n      break;\n\n    vec2 pt1Rand = vec2(-0.5+rand(vec2(lineSeed+1.123,floor(num_beams)+1.321)),-0.5+rand(vec2((1.0+lineSeed)*floor(num_beams)+2.123,lineSeed+1.325)));\n    vec2 pt2Rand = vec2(-0.5+rand(vec2(lineSeed*floor(num_beams)+3.573,lineSeed+6.273)),-0.5+rand(vec2(lineSeed+9.253,lineSeed+7.782)));\n      \n    vec2 pt1Direct = vec2(sin(TIME + 2*PI*i/num_beams), cos(TIME + 2*PI*i/num_beams));\n    vec2 pt2Direct = vec2(sin(TIME + 2*PI*i/num_beams + PI), cos(TIME+ + 2*PI*i/num_beams + PI));\n    \n    vec2 pt1Spiral = vec2(sin(TIME + 2*PI*i/num_beams), cos(TIME + 2*PI*i/num_beams));\n    vec2 pt2Spiral = vec2(sin(TIME + 2*PI*i/num_beams + (2.0-syn_Presence)*PI/2), cos(TIME+ 2*PI*i/num_beams + (2.0-syn_Presence)*PI/2));\n\n    vec2 pt1Dancing = vec2(sin(TIME*0.15+syn_Time*0.075), cos(TIME*0.15+syn_Time*0.075 + 2*PI*i/num_beams + syn_HighTime)+syn_BassPresence);\n    vec2 pt2Dancing = vec2(sin(TIME*0.15+syn_Time*0.075 + 2*PI*i/num_beams + PI/2 + syn_Presence), cos(TIME*0.15+syn_Time*0.075+ + 2*PI*i/num_beams + PI/2 + syn_Presence)+syn_BassPresence);\n\n\n    pt1 = mix(pt1Dancing, pt1Rand, random);\n    pt2 = mix(pt2Dancing, pt2Rand, random);\n\n    pt1 = mix(pt1, pt1Spiral, spiral);\n    pt2 = mix(pt2, pt2Spiral, spiral);\n\n    pt1 = mix(pt1, pt1Direct, direct_shot);\n    pt2 = mix(pt2, pt2Direct, direct_shot);\n\n  \n    pt1 *= (1.0+pow(currentRank,2.0)*separation);\n    pt2 *= (1.0+pow(currentRank,2.0)*separation);\n\n    \n    if (wobble_on > 0.0) {\n      wobbleVector = (syn_BassHits*1.5+syn_BassLevel*0.3)*wobble_on*currentRank * vec2(rand(vec2(i*floor(num_beams)+syn_BassTime*3.123,i*floor(num_beams)+syn_BassTime*3.239)),rand(vec2(i*floor(num_beams)+syn_BassTime*3.321,i*floor(num_beams)+syn_BassTime*2.131))) - vec2(wobble_on / 2.0);\n      pt1 = pt1 + wobbleVector;\n      wobbleVector = (syn_BassHits*1.5+syn_BassLevel*0.3)*wobble_on*currentRank * vec2(rand(vec2(i*floor(num_beams)+syn_BassTime*3.573,i+6.273)),rand(vec2(i+syn_BassTime*9.253,i+syn_BassTime*7.782))) - vec2(wobble_on / 2.0);\n      pt2 = pt2 + wobbleVector;\n    }\n\n    float diffWidth = (maxWidth-minWidth);\n    width = minWidth + diffWidth*currentRank;\n\n    float focus = 1.0-2.0*abs(currentRank-0.5);\n    if (false){\n      focus = 1.0-focus;\n    } else {\n      focus = pow(focus, 4.0);\n    }\n    // focus = 1.0;\n\n    \n    float disty = distance_from_point_to_line(thisPoint, pt1, pt2);\n    float id = i/num_beams;\n\n    vec3 color;\n\n    if (monochrome<0.5){\n      color = colorPaletteChooser(mod(color_palette,10), id);\n    } else {\n      color = monochrome_color;\n    }\n\n    result.rgb = result.rgb + color * pow(clamp((1.0-disty/width)+beam_width,0.0,1.0),5.0)*mix(0.5, _rand(disty), currentRank);\n    // result.rgb = result.rgb + color_in * pow(clamp((1.0-disty/width),0.0,1.0),1.0+focus*5.0);\n\n\n  }\n  \n  if (syn_MediaType > 0.5){\n    result.rgb *= _loadUserImage().rgb;\n  }\n\n  out_FragColor = vec4(result.rgb, 1.0);\n  return out_FragColor;\n\n  } else if (PASSINDEX == 1.0){\n    return texture(limitSize, _uv);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Beamers","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"cmzw","DESCRIPTION":"Based on runes from [url]https://www.shadertoy.com/view/MsXSRn[/url] but replacing line segments with beziers","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\bezier_runes.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Bezier Runes","IMAGES":null,"IMAGE_PATH":"bezier_runes.synScene\\bezier_runes.png","JSON_CODE":"{\n\t\"CREDIT\" : \"cmzw\",\n\t\"DESCRIPTION\" : \"Based on runes from [url]https://www.shadertoy.com/view/MsXSRn[/url] but replacing line segments with beziers\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 720,\n\t\"IMAGE_PATH\" : \"bezier_runes.png\",\n\t\"TITLE\" : \"Bezier Runes\",\n\t\"WIDTH\" : 1280\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n/* \r\n   References\r\n   https://www.shadertoy.com/view/MsXSRn runes\r\n   https://www.shadertoy.com/view/4djSRW hash22\r\n   https://www.shadertoy.com/view/MlKcDD Quadratic Bezier\r\n*/\r\n\r\nvec2 hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yzx+33.33);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\n\r\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\r\n    float kz = kk * dot(d,a);      \r\n    float res = 0.0;\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n    if( h >= 0.0) \r\n    { \r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d + (c + b*t)*t);\r\n    }\r\n    else\r\n    {\r\n        float z = sqrt(-p);\r\n        float v = acos( q/(p*z*2.0) ) / 3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n    }\r\n    return sqrt( res );\r\n}\r\n\r\n\r\nfloat ThickLine(vec2 uv, vec2 posA, vec2 posB, vec2 posC)\r\n{\r\n\treturn smoothstep(.04,.01,sdBezier(uv, posA, posB, posC));\r\n}\r\n\r\nfloat Rune(vec2 uv, int strokes, float scale, vec2 snaps) {\r\n\tfloat finalLine = 0.0;\r\n\tvec2 seed = floor(uv)-hash22(vec2(1));\r\n\tuv = fract(uv);\r\n\tfor (int i = 0; i < strokes; i++)\t\r\n\t{\r\n\t\tvec2 posA = hash22(floor(seed+1.5));\r\n\t\tvec2 posB = hash22(floor(seed+2.0));\r\n\t\tvec2 posC = hash22(floor(seed+3.5));\r\n\t\tseed += 3.0;\r\n\t\tposA = fract(posA * 128.0);\r\n\t\tposB = fract(posB * 128.0);\r\n        posC = fract(posC * 128.0);\r\n\t\tif (i == 0) posA.y = 0.0;\r\n\t\tif (i == 1) posA.x = 0.999;\r\n\t\tif (i == 2) posA.x = 0.0;\r\n\t\tif (i == 3) posA.y = 0.999;\r\n\t\tposA = (floor(posA * snaps) + 0.5) / snaps;\r\n\t\t//posB = (floor(posB * snaps) + 0.5) / snaps;\r\n        posC = (floor(posC * snaps) + 0.5) / snaps;\r\n\t\tfinalLine = max(finalLine, ThickLine(uv, posA, posB, posC));\r\n\t}\r\n\treturn finalLine;\r\n}\r\n\r\nvec4 renderMainImage() {\r\n\tvec4 O = vec4(0.0);\r\n\tvec2 I = _xy;\r\n\r\n    vec2 p = (7.*I - RENDERSIZE.xy ) / RENDERSIZE.y ;\r\n    \r\n    p.x += TIME;\r\n\r\n    O = vec4(Rune(p,4,syn_BassLevel*2.0,vec2(2.0,3.0)));\r\n\treturn O; \r\n } \r\n\r\n\r\nvec4 renderMain(){\r\n\tif(PASSINDEX == 0){\r\n\t\treturn renderMainImage();\r\n\t}\r\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Bezier Runes","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Add a circular 'paint brush' to the scene. Other controls invert the brush, change the brush size, or change the position.","MAX":1,"MIN":0,"NAME":"paint_on","TYPE":"toggle","UI_GROUP":"paint"},{"DEFAULT":0,"DESCRIPTION":"paint on must be on. Inverts the paintbrush from 'cutting out' the simulation or painting where it is on.","MAX":1,"MIN":0,"NAME":"paint_invert","TYPE":"toggle","UI_GROUP":"paint"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"paint on must be on. Brush size.","MAX":0.5,"MIN":-0,"NAME":"paint_size","TYPE":"slider","UI_GROUP":"paint"},{"DEFAULT":[0,0],"DESCRIPTION":"paint on must be on. Move to move the paintbrush.","MAX":[1,1],"MIN":[-1,-1],"NAME":"paint_pos","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"paint"},{"DEFAULT":1,"DESCRIPTION":"Slicing action will automatically happen on the beats in the music with this set to on. Otherwise, turn this off and manually slice with the slice_pos.","MAX":1,"MIN":0,"NAME":"auto_slice","TYPE":"toggle","UI_GROUP":"slice"},{"DEFAULT":[0,0],"DESCRIPTION":"auto slice must be OFF to see this action. Move to manually slice the simulation.","MAX":[1,1],"MIN":[-1,-1],"NAME":"manual_slice","TYPE":"xy","UI_GROUP":"slice"},{"DEFAULT":0,"DESCRIPTION":"Invert the color palette.","MAX":1,"MIN":0,"NAME":"color_mix","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Flash yellow on high hits.","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Changes the simulation to make it more drippy when on.","MAX":1,"MIN":0,"NAME":"drips","TYPE":"toggle","UI_GROUP":"mode"}],"CREDIT":"Meebs ft. Flexi","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\biopsy.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"inOrOut","VALUES":[1,-1,0]},{"UNIFORM":"mode","VALUES":[1,-1,0]}],"HEIGHT":1080,"ID":"Biopsy","IMAGES":[{"NAME":"colornoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"biopsy.synScene\\biopsy.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs ft. Flexi\",\n \"TITLE\": \"Biopsy\",\n \"IMAGE_PATH\": \"biopsy.png\",\n    \"HARD_TRANSITIONS\": [ {\"UNIFORM\":\"inOrOut\", \"VALUES\":[1.0,-1.0,0.0]},\n    {\"UNIFORM\":\"mode\", \"VALUES\":[1.0,-1.0,0.0]}\n    ],\n \"IMAGES\": [{\n    \"PATH\": \"images/colornoise.jpg\",\n    \"NAME\": \"colornoise\"\n  }],\n \"PASSES\": [\n {\"TARGET\":\"buffB\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true},\n {\"TARGET\":\"buffC\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true},\n {\"TARGET\":\"buffD\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true},\n {\"TARGET\":\"coloredSim\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true}  ],\n\n  \"CONTROLS\":[\n  {\"NAME\": \"paint_on\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\": \"paint\",\"DESCRIPTION\": \"Add a circular 'paint brush' to the scene. Other controls invert the brush, change the brush size, or change the position.\"},\n  {\"NAME\": \"paint_invert\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\": \"paint\",\"DESCRIPTION\": \"paint on must be on. Inverts the paintbrush from 'cutting out' the simulation or painting where it is on.\"},\n  {\"NAME\": \"paint_size\", \"DEFAULT\":0.2, \"MIN\":-0.0, \"MAX\":0.5,\n  \"UI_GROUP\": \"paint\",\"DESCRIPTION\": \"paint on must be on. Brush size.\"},\n  {\"NAME\": \"paint_pos\", \"DEFAULT\":0.0, \"MIN\":-1.0, \"MAX\":1.0, \"TYPE\": \"xy smooth\", \"PARAMS\": 0.05,\n  \"UI_GROUP\": \"paint\",\"DESCRIPTION\": \"paint on must be on. Move to move the paintbrush.\"},\n  {\"NAME\": \"auto_slice\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\": \"slice\",\"DESCRIPTION\": \"Slicing action will automatically happen on the beats in the music with this set to on. Otherwise, turn this off and manually slice with the slice_pos.\"},\n  {\"NAME\": \"manual_slice\", \"DEFAULT\":0.0, \"MIN\":-1.0, \"MAX\":1.0, \"TYPE\": \"xy\",\n  \"UI_GROUP\": \"slice\",\"DESCRIPTION\": \"auto slice must be OFF to see this action. Move to manually slice the simulation.\"},\n  {\"NAME\": \"color_mix\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0,\n  \"UI_GROUP\":\"color\",\"DESCRIPTION\": \"Invert the color palette.\"},\n  {\"NAME\": \"flashing\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\", \"UI_GROUP\": \"color\",\n  \"DESCRIPTION\": \"Flash yellow on high hits.\"},\n  {\"NAME\": \"drips\", \"TYPE\": \"toggle\", \"UI_GROUP\":\"mode\",\n  \"DESCRIPTION\": \"Changes the simulation to make it more drippy when on.\"}\n]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"buffB","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"buffC","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"buffD","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"coloredSim","WIDTH":1280}],"SCRIPT_CODE":"function Slicer () {\n  this.laggyX = 0.0;\n  this.laggyY = 0.0;\n\n  this.x = 0;\n  this.y = 0;\n  this.angle = 0;\n  this.motionAmount = 1.0;\n\n\n}\n\nfunction Painter () {\n  this.x = 0;\n  this.y = 0;\n  this.laggyX = 0.0;\n  this.laggyY = 0.0;\n\n}\n\nfunction normalize(x, y) {\n  var magnitude = Math.sqrt(Math.pow(x,2)+Math.pow(y,2));\n  x = x/magnitude;\n  y = y/magnitude;\n}\n\nSlicer.prototype.updateLaggyMotion = function() {\n  this.laggyX = this.laggyX-(this.laggyX-inputs.manual_slice.x)*0.1;\n  this.laggyY = this.laggyY-(this.laggyY-inputs.manual_slice.y)*0.1;\n\n}\n\nSlicer.prototype.getMagDirMotion = function() {\n  var tempX = this.laggyX - inputs.manual_slice.x;\n  var tempY = this.laggyY - inputs.manual_slice.y;\n  var magnitude = Math.sqrt(Math.pow(tempX,2)+Math.pow(tempY,2));\n\n  this.x = tempX/magnitude;\n  this.y = tempY/magnitude;\n\n  this.angle = Math.atan(this.y/this.x);\n\n  this.motionAmount = Math.max(Math.abs(inputs.manual_slice.x-this.laggyX),Math.abs(inputs.manual_slice.y-this.laggyY));\n\n}\n\nvar slicer = new Slicer();\nvar painter = new Painter();\n\nvar decimator = 0;\nfunction update(dt) {\n  slicer.updateLaggyMotion();\n  slicer.getMagDirMotion();\n\n  uniforms.slicerDirection = slicer;\n  uniforms.slicerAngle = slicer.angle;\n  uniforms.slicerMotionAmt = slicer.motionAmount;\n\n  if(decimator%50==0){\n    // console.log(slicer.x);\n    // console.log(slicer.y);\n    // console.log(\"next\");\n\n\n    // console.log(slicer.angle);\n\n    // console.log(slicer.motionAmount);\n\n  }\n  decimator ++;\n\n}\nfunction transition() {\n}","SHADER_CODE":"vec3 iResolution = vec3(RENDERSIZE.x, RENDERSIZE.y, 0.0);\nvec3 iChannelResolution = iResolution;\nfloat iGlobalTime = TIME*1.0;\nint iFrame = int(FRAMECOUNT);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\nvec4 iMouse = vec4(0.5);\n\n// ****************** PASS 0 ***********************\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(buffB, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(buffD, uv);\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurB(uv + vec2(1.,0.)*d, level) - 0.5*BlurB(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurB(uv + vec2(0.,1.)*d, level) - 0.5*BlurB(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float f1lter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, f1lter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.425;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nvec2 autoSliceTransform(vec2 uv)\n{\n    vec2 diagPos = _rotate(_uvc, PI*0.25);\n    float gridderX = floor(mod(diagPos.x*30.0,2.0));\n    float gridderY = floor(mod(diagPos.y*20.0,2.0));\n    float tinyGridX = floor(mod(diagPos.x*40.0,2.0));\n    float tinyGridY = floor(mod(diagPos.y*50.0,2.0));\n    int beatMode = int(mod(syn_BeatTime,4.0));\n    float singer = -1+2.0*floor(mod(syn_BeatTime*0.5,2.0));\n\n    vec2 gridder;\n\n    switch(beatMode)\n    {\n    case 0: gridder = gridderX*vec2(0.0,1.0); break;\n    case 1: gridder = gridderY*vec2(1.0,0.0); break;\n    case 2: gridder = tinyGridX*vec2(0.0,1.0); break;\n    case 3: gridder = tinyGridY*vec2(1.0,0.0); break;\n    }\n// gridder = _rotate(gridder, PI*0.25);\n    return uv+gridder*pow(syn_HighHits,2.0)*0.01*singer*pow(syn_HighPresence+syn_BassPresence,2.0);\n}\n\nvec2 manualSliceTransform(vec2 uv)\n{\n    // vec4 data = texture(pass0, _uv);\n\n    // vec2 direction = normalize(vec2(slice_pos.x, slice_pos.y)-vec2(sliceX, sliceY));\n\n    // float angle = atan(direction.y/direction.x);\n    vec2 direction = slicerDirection;\n    float angle = slicerAngle;\n\n    vec2 diagPos = _rotate(_uvc, angle+PI/2.0);\n\n    vec2 flowDirection = -1.0*direction;\n    float gridderX = floor(mod(diagPos.x*10.0,2.0));\n    float gridderY = floor(mod(diagPos.y*10.0,2.0));\n    float tinyGridX = floor(mod(diagPos.x*30.0,2.0));\n    float tinyGridY = floor(mod(diagPos.y*30.0,2.0));\n    int sliceMode = 3;\n\n    float gridder;\n\n    switch(sliceMode)\n    {\n    case 0: gridder = gridderX; break;\n    case 1: gridder = gridderY; break;\n    case 2: gridder = tinyGridX; break;\n    case 3: gridder = tinyGridY; break;\n    }\n// gridder = _rotate(gridder, PI*0.25);\n    return uv+direction*gridder*pow(slicerMotionAmt*0.01,1.0);\n}\n\n// *************** PASS 1 *****************\n// Turing Sim\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 noise = texture(colornoise, fragCoord.xy / iChannelResolution.xy + fract(vec2(42,56)*iGlobalTime));\n\n    if(iFrame<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    float zoomAmt = 0.999+inOrOut*0.0075*pow(syn_BassLevel,2.0);\n    // float zoomAmt = 1.0;\n\n\n    uv = 0.5 + (uv - 0.5)*zoomAmt;\n    vec2 pixelSize = 1./iResolution.xy;\n    vec2 mouseV = vec2(0.0, -syn_BassLevel*0.01+syn_BPMTri2*0.01);\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    if (auto_slice > 0.5){\n        uv = autoSliceTransform(uv);\n    }\n    else {\n        uv = manualSliceTransform(uv);\n    }\n\n\n    float time = syn_Time;\n    //uv = uv - vec2(0.0,GradientB(uv, pixelSize, vec4(-128,-128.,-128.,-128.), 1)*syn_HighHits*0.0001);\n\n\n    fragColor = BlurB(uv, 0).rbbr;\n    fragColor += ((BlurB(uv+vec2(0.0,length(fragColor)*drips*0.01), 1) - BlurB(uv, 2))*0.5 + (noise-0.5) * 0.004); \n\n    if (paint_on > 0.5){\n        float fbmmer = _fbm(_uvc*10.0+TIME)*0.05;\n\n        if (paint_invert < 0.5){\n            if (distance(_uvc, vec2(paint_pos.x, paint_pos.y)*vec2(1.0,RENDERSIZE.y/RENDERSIZE.x)) < paint_size-fbmmer){\n                fragColor = vec4(length(fragColor)*2.0);\n            }\n        } else {\n            if (distance(_uvc, vec2(paint_pos.x, paint_pos.y)*vec2(1.0,RENDERSIZE.y/RENDERSIZE.x)) > paint_size-fbmmer){\n                fragColor = vec4(length(fragColor)*2.0);\n            }\n        }\n    }\n\n    if (_exists(syn_UserImage)){\n        fragColor = mix(fragColor, 1.0-fragColor,_loadUserImageAsMask());\n    }\n\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n    // fragColor = noise; // reset\n}\n\n\n\n// *************** PASS 2 *****************\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffD, uv1) * 0.05;\n    sum += texture(buffD, uv2) * 0.09;\n    sum += texture(buffD, uv3) * 0.12;\n    sum += texture(buffD, uv4) * 0.15;\n    sum += texture(buffD, uv5) * 0.16;\n    sum += texture(buffD, uv6) * 0.15;\n    sum += texture(buffD, uv7) * 0.12;\n    sum += texture(buffD, uv8) * 0.09;\n    sum += texture(buffD, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(buffB, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(buffB, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}\n\n\n// void mainImage2( out vec4 fragColor, in vec2 fragCoord )\n// {\n//     vec2 uv = fragCoord.xy / iResolution.xy;\n\n//     if(uv.x < 0.5)\n//     {\n//         vec2 uv_half = fract(uv*2.);\n//         // if(uv.y > 0.5)\n//         // {\n//         //     fragColor = blur_horizontal(buffB, uv_half, 1.);\n//         // }\n//         // else\n//         // {\n//             fragColor = blur_horizontal(buffB, uv_half, 1.);\n//         // }\n//     }\n//     else\n//     {\n//         for(int level = 0; level < 8; level++)\n//         {\n//             if((uv.x > 0.25 && uv.y > 0.25) || (uv.x <= 0.5))\n//             {\n//                 break;\n//             }\n//             vec2 uv_half = fract(uv*2.);\n//             fragColor = blur_horizontal_left_column(uv_half, level);\n//             uv = uv_half;\n//         }\n//     }\n// }\n\n// *************** PASS 4 *****************\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffC, uv1) * 0.05;\n    sum += texture(buffC, uv2) * 0.09;\n    sum += texture(buffC, uv3) * 0.12;\n    sum += texture(buffC, uv4) * 0.15;\n    sum += texture(buffC, uv5) * 0.16;\n    sum += texture(buffC, uv6) * 0.15;\n    sum += texture(buffC, uv7) * 0.12;\n    sum += texture(buffC, uv8) * 0.09;\n    sum += texture(buffC, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage3( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(buffC, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(buffC, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }  \n    }\n    uv = uv_orig;\n    float eighth = 1./8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    }\n}\n\n// *************** Main Image Pass *****************\n\nvoid mainImage4( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // if (uv.x*mod(syn_BeatTime*5.0+syn_RandomOnBeat*2.0,8.0)*0.5+uv.y*mod(syn_BeatTime*13.0+syn_RandomOnBeat*1.7,8.0)*0.5 > 1.0){\n    //     uv = 1.0-uv;\n    // }\n\n    // if (uv.x > 0.5){\n    //     uv.x = 1.0-uv.x;\n    // }\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 d = pixelSize*(2.+mode*2.0);\n    vec4 dx = (BlurB(uv + vec2(1,0)*d, 1) - BlurB(uv - vec2(1,0)*d, 1))*0.5;\n    vec4 dy = (BlurB(uv + vec2(0,1)*d, 1) - BlurB(uv - vec2(0,1)*d, 1))*0.5;\n\n    d = pixelSize*1.;\n    dx += BlurB(uv + vec2(1,0)*d, 0) - BlurB(uv - vec2(1,0)*d, 0);\n    dy += BlurB(uv + vec2(0,1)*d, 0) - BlurB(uv - vec2(0,1)*d, 0);\n    vec2 lightSize=vec2(0.5);\n\n    //for B\n    //midHighCol is general color?\n    //bassCol1 is a color in between coral\n    //highCol1 does almost nothing. creeps in on the edges.\n    //bassCol2 is general color \"on\" the life spots\n    //highCol2 does almost nothing when sim is running. creeps in from edges.\n    //midCol is squiggles layer... Its red and white tho. \n\n    //for A\n    //midHighCol is sheen near the wavefronts. like \"newSpawn\"\n    //bassCol1 is big wavefronts and smooth shading\n    //highCol1 is wavefronts\n    //bassCol2 crisp wavefronts and smooth wavefronts, of a diff color probably.\n    //highCol2 sort of ghostly messy wavefronts\n    //midCol sort of a networky layer. Looks brainular.\n\n\n    vec3 midHighCol = vec3(1.0)*4.0;\n    vec3 bassCol1 = vec3(1.0)*2.0;\n    vec3 highCol1 = vec3(1.0)*2.0;\n    vec3 bassCol2 = vec3(1.0)*2.0;\n    vec3 highCol2 = vec3(1.0)*2.0;\n    vec3 midCol = vec3(1.0)*2.0;\n\n    float cReg4 = 1.0;\n\n    // *** Color Regime 4 ***\n    midHighCol = mix(midHighCol, _normalizeRGB(46, 9, 39)*4.0, cReg4);\n    bassCol1 = mix(bassCol1, _normalizeRGB(217, 0, 0)*2.0, cReg4);\n    highCol1 = mix(highCol1, _normalizeRGB(4, 200, 111)*2.0, cReg4);\n    bassCol2 = mix(bassCol2, _normalizeRGB(100, 45, 0)*2.0, cReg4);\n    highCol2 = mix(highCol2, _normalizeRGB(255, 140, 0)*2.0, cReg4);\n    midCol = mix(midCol, _normalizeRGB(4, 117, 111)*2.0, cReg4);\n\n    vec2 zoneMids = vec2(sin(syn_MidTime*0.23), cos(syn_MidTime*0.17));\n    vec2 zoneMidHighs = vec2(sin(syn_MidHighTime*0.23), cos(syn_MidHighTime*0.17));\n    vec2 zoneHighs = vec2(sin(syn_HighTime*0.23), cos(syn_HighTime*0.17));\n\n    midHighCol *= (0.1+0.9*syn_MidHighPresence*distance(zoneMidHighs, _uvc)*0.8);\n    bassCol1 *= (0.3+0.9*(syn_BassPresence)*1.25);\n    highCol1 *= (0.3+0.9*syn_HighPresence);\n    bassCol2 *= (0.3+0.9*syn_BassPresence*1.5);\n    if (flashing > 0.5){\n        highCol2 *= (0.1+0.9*syn_HighHits*(0.5+syn_Presence*0.5)*distance(zoneHighs, _uvc));\n    } else {\n        highCol2 *= (0.2*(0.5+syn_Presence*0.5)*distance(zoneHighs, _uvc));\n    }\n    midCol *= (0.1+0.9*distance(zoneMids, _uvc)*syn_MidPresence);\n\n    float lowIntensity = 1.0-syn_Presence;\n\n    vec3 finalColor = vec3(0.0);\n    finalColor = BlurB(uv+vec2(dx.x,dy.x)*pixelSize*8., 0).x * midHighCol;\n    finalColor = mix(finalColor, bassCol1, BlurB(uv + vec2(dx.x,dy.x)*lightSize, 3).y*0.4*0.75*vec3(1.-BlurB(uv+vec2(dx.x,dy.x)*pixelSize*8., 0).x));\n    finalColor = mix(finalColor, highCol1, BlurB(uv, 1).a*length(GradientB(uv, pixelSize*2., vec4(0.,0.,0., 1.), 0))*5.);\n    finalColor = mix(finalColor, bassCol2, BlurB(uv, 0).x*BlurB(uv + GradientB(uv, pixelSize*2.5, vec4(-256.,32.,-128.,32.), 1)*pixelSize, 2).y);\n    finalColor = mix(finalColor, highCol2, BlurB(uv, 1).x*length(GradientB(uv, pixelSize*2., vec4(0.,0.,0.,5.), 0))*5.);\n    finalColor = mix(finalColor, midCol, 0.5*(1.-BlurB(uv, 0)*1.).g*length(GradientB(uv+GradientB(uv, pixelSize*2., vec4(0.,128.,0.,0.), 1)*pixelSize, pixelSize*1.5, vec4(0.,0.,16.,0.), 0)));\n\n    finalColor *= 0.5+(sin(_uvc.x*5.0+TIME*0.1)*_uv.y+cos(_uvc.x*4.7-TIME*0.47)+cos(_uvc.x*11.0+TIME*0.89)*(1.0-_uv.y))/6.0;\n\n    fragColor = color_mix-vec4(finalColor, 1.0);\n    if (dot(fragColor.rgb, vec3(1.0))<0.0){\n        fragColor = -fragColor;\n    }\n    fragColor = clamp(fragColor, 0.0, 1.0);\n    //fragColor = pow(fragColor, vec4(2.5));\n    fragColor *= (1.0-_uv.y*(2.0-length(fragColor)));\n    // fragColor *= (1.1-_fbm(_uvc*20.0+TIME)*0.2);\n    // fragColor *= 0.0+step(length(_uvc), 0.7-length(fragColor)*0.2);\n\n    //    fragColor = BlurB(uv, 0); // simple bypass\n    //    fragColor = BlurB(uv, 0); // simple bypass\n       // fragColor = texture(buffD, _uv); // raw Gaussian pyramid\n\n}\n\nvoid mainImage5( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor = texture(coloredSim, _uv).rgb;\n    fragColor = vec4(finalColor, 1.0);\n}\n\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    //buffB\n    vec4 fragColor;\n    mainImage1(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 1.0){\n    //buffC\n    vec4 fragColor;\n    mainImage2(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 2.0){\n    //buffD\n    vec4 fragColor;\n    mainImage3(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 3.0){\n    //Image\n    vec4 fragColor;\n    mainImage4(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 4.0){\n    //Image\n    vec4 fragColor;\n    mainImage5(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Biopsy","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Changes the simulation to make it more drippy.","MAX":1,"MIN":0,"NAME":"drips","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Automatically slice the simulation on the beats in the music.","MAX":1,"MIN":0,"NAME":"slicing","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Vertical and horizontal stretching in time with the music.","MAX":1,"MIN":0,"NAME":"stretching","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Adds a slow lens distortion. Add vertical or horizontal mirrors for best effect.","MAX":1,"MIN":0,"NAME":"distort","PARAMS":0.00999999977648258,"TYPE":"toggle smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":-1,"MIN":1,"NAME":"in_or_out","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"If on, only center circle will be 'fiery'.","MAX":1,"MIN":0,"NAME":"circle_on","TYPE":"toggle","UI_GROUP":"circle"},{"DEFAULT":0,"DESCRIPTION":"Size of center circle.","MAX":1,"MIN":-0.300000011920929,"NAME":"circle_size","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"circle"},{"DEFAULT":1,"DESCRIPTION":"Choose from one of three color palettes.","MAX":2,"MIN":0,"NAME":"color_palette","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Flash yellow on high hits.","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"Default scene has a darker, subtly audio reactive shading. Turn this up to use full-color, no shading.","MAX":1,"MIN":0,"NAME":"no_shading","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Send a sweep through the simulation.","MAX":1,"MIN":0,"NAME":"down_sweep","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"sweep"},{"DEFAULT":0,"DESCRIPTION":"Send a sweep through the simulation.","MAX":1,"MIN":0,"NAME":"up_sweep","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"sweep"},{"DEFAULT":0,"DESCRIPTION":"Send a sweep through the simulation.","MAX":1,"MIN":0,"NAME":"left_sweep","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"sweep"},{"DEFAULT":0,"DESCRIPTION":"Send a sweep through the simulation.","MAX":1,"MIN":0,"NAME":"right_sweep","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"sweep"}],"CREDIT":"Meebs ft. Flexi","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\biopsy_v2.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"inOrOut","VALUES":[1,-1,0]},{"UNIFORM":"mode","VALUES":[1,-1,0]}],"HEIGHT":1080,"ID":"Biopsy_V2","IMAGES":[{"NAME":"colornoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"biopsy_v2.synScene\\biopsy_v2.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs ft. Flexi\",\n \"TITLE\": \"Biopsy_V2\",\n \"IMAGE_PATH\": \"biopsy_v2.png\",\n    \"HARD_TRANSITIONS\": [ {\"UNIFORM\":\"inOrOut\", \"VALUES\":[1.0,-1.0,0.0]},\n    {\"UNIFORM\":\"mode\", \"VALUES\":[1.0,-1.0,0.0]}\n    ],\n \"IMAGES\": [{\n    \"PATH\": \"images/colornoise.jpg\",\n    \"NAME\": \"colornoise\"\n  }],\n \"PASSES\": [{\"TARGET\":\"buffB\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true},\n {\"TARGET\":\"buffB2\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true},\n {\"TARGET\":\"buffC\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true},\n {\"TARGET\":\"buffD\", \"WIDTH\":1280, \"HEIGHT\":720, \"FLOAT\": true}\n ],\n\n  \"CONTROLS\":[\n  {\"NAME\": \"drips\", \"TYPE\": \"toggle\", \"UI_GROUP\":\"motion\",\n  \"DESCRIPTION\": \"Changes the simulation to make it more drippy.\"},\n  {\"NAME\": \"slicing\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\": \"motion\",\"DESCRIPTION\": \"Automatically slice the simulation on the beats in the music.\"},\n  {\"NAME\": \"stretching\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"PARAMS\": 0.1, \"TYPE\": \"toggle\", \"UI_GROUP\": \"motion\",\n  \"DESCRIPTION\": \"Vertical and horizontal stretching in time with the music.\"},\n  {\"NAME\": \"distort\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle smooth\", \"UI_GROUP\": \"motion\", \"DESCRIPTION\":\"Adds a slow lens distortion. Add vertical or horizontal mirrors for best effect.\"},\n  {\"NAME\": \"in_or_out\", \"DEFAULT\":0.00, \"MIN\":1.0, \"MAX\":-1.0, \"TYPE\": \"slider\",\n  \"UI_GROUP\": \"motion\"},\n  {\"NAME\": \"circle_on\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\": \"circle\",\"DESCRIPTION\": \"If on, only center circle will be 'fiery'.\"},\n  {\"NAME\": \"circle_size\", \"DEFAULT\":0.0, \"MIN\":-0.3, \"MAX\":1.0, \"TYPE\": \"slider smooth\", \"PARAMS\": 0.01,\n  \"UI_GROUP\": \"circle\",\"DESCRIPTION\": \"Size of center circle.\"},\n  {\"NAME\": \"color_palette\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":2.0,\n  \"UI_GROUP\":\"color\",\"DESCRIPTION\": \"Choose from one of three color palettes.\"},\n  {\"NAME\": \"flashing\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\", \"UI_GROUP\": \"color\",\n  \"DESCRIPTION\": \"Flash yellow on high hits.\"},{\n    \"NAME\": \"no_shading\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.1,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"color\",\n    \"DESCRIPTION\":\"Default scene has a darker, subtly audio reactive shading. Turn this up to use full-color, no shading.\"\n  },\n  {\"NAME\": \"down_sweep\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"PARAMS\": 0.01, \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"sweep\",\n  \"DESCRIPTION\": \"Send a sweep through the simulation.\"},\n  {\"NAME\": \"up_sweep\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"PARAMS\": 0.01, \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"sweep\",\n  \"DESCRIPTION\": \"Send a sweep through the simulation.\"},\n  {\"NAME\": \"left_sweep\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"PARAMS\": 0.01, \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"sweep\",\n  \"DESCRIPTION\": \"Send a sweep through the simulation.\"},\n  {\"NAME\": \"right_sweep\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"PARAMS\": 0.01, \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"sweep\",\n  \"DESCRIPTION\": \"Send a sweep through the simulation.\"}\n]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"buffB","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"buffB2","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"buffC","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"buffD","WIDTH":1280}],"SCRIPT_CODE":"","SHADER_CODE":"\n// ****************** PASS 0 ***********************\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(buffB2, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(buffD, uv);\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurB(uv + vec2(1.,0.)*d, level) - 0.5*BlurB(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurB(uv + vec2(0.,1.)*d, level) - 0.5*BlurB(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,RENDERSIZE.y/RENDERSIZE.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,RENDERSIZE.y/RENDERSIZE.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float f1lter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, f1lter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,RENDERSIZE.y/RENDERSIZE.x);\n    float ramp = 4.;\n\n    float d = 0.425;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nvec2 kaleidoscope(vec2 uvIn, float n) {\n  vec2 uv = uvIn;\n  float angle = PI/n;\n  \n  float r = length(uv);\n  float a = atan(uv.y, uv.x)/angle;\n  \n  a = mix(fract(a), 1.0 - fract(a), mod(floor(a), 2.0))*angle;\n  \n  return vec2(cos(a), sin(a))*r;\n}\n\nvec2 autoSliceTransform(vec2 uv)\n{\n    vec2 diagPos = _rotate(_uvc, PI*0.25);\n    float gridderX = floor(mod(diagPos.x*30.0,2.0));\n    float gridderY = floor(mod(diagPos.y*20.0,2.0));\n    float tinyGridX = floor(mod(diagPos.x*40.0,2.0));\n    float tinyGridY = floor(mod(diagPos.y*50.0,2.0));\n    int beatMode = int(mod(syn_BeatTime,4.0));\n    float singer = -1+2.0*floor(mod(syn_BeatTime*0.5,2.0));\n\n    vec2 gridder;\n\n    switch(beatMode)\n    {\n    case 0: gridder = gridderX*vec2(0.0,1.0); break;\n    case 1: gridder = gridderY*vec2(1.0,0.0); break;\n    case 2: gridder = tinyGridX*vec2(0.0,1.0); break;\n    case 3: gridder = tinyGridY*vec2(1.0,0.0); break;\n    }\n// gridder = _rotate(gridder, PI*0.25);\n    return uv+gridder*pow(syn_HighHits,2.0)*0.01*singer*pow(syn_HighPresence+syn_BassPresence,2.0);\n}\n\n// *************** PASS 0 *****************\n// Turing Sim\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / RENDERSIZE.xy;\n    vec4 noise = texture(colornoise, fragCoord.xy / RENDERSIZE.xy + fract(vec2(42,56)*TIME));\n\n    if(FRAMECOUNT<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    float zoomAmt = 0.999+(inOrOut*(1.0-abs(in_or_out))+in_or_out*2.0)*0.0075*pow(syn_BassLevel,2.0);\n    // float zoomAmt = 1.0;\n\n\n    uv = 0.5 + (uv - 0.5)*zoomAmt;\n    vec2 pixelSize = 1./RENDERSIZE.xy;\n    vec2 aspect = vec2(1.,RENDERSIZE.y/RENDERSIZE.x);\n    if (slicing > 0.5){\n        uv = autoSliceTransform(uv);\n    }\n\n    //uv = uv - vec2(0.0,GradientB(uv, pixelSize, vec4(-128,-128.,-128.,-128.), 1)*syn_HighHits*0.0001);\n    float logo = dot(_loadUserImage().rgb, vec3(1.0))*0.33;\n\n    uv -= vec2(-_uvc.x*0.005*syn_BassHits, _uvc.y*0.005*syn_HighHits)*(1.0-logo)*stretching;\n\n    vec4 old = BlurB(uv, 0).rgbr;\n    fragColor = old;\n    fragColor += ((BlurB(uv+vec2(0.0,length(fragColor)*drips*0.01), 1) - BlurB(uv, 2))*0.5 + (noise-0.5) * 0.004); \n\n    float fbmmer = _fbm(_uvc*10.0+TIME);\n\n    if (circle_on > 0.5){\n        vec2 posSurf = _toPolarTrue(_uvc);\n        \n        posSurf.t = posSurf.t*(20.0);\n\n        float stepper = 1.0;\n\n        // stepper = step(0.2,(distance(_toRect(paintPos*vec2(1.0,2*PI)), _toRect(posSurf*vec2(1.0,2*PI))))*stepper);\n        stepper = smoothstep(0.0, 0.4,posSurf.r-circle_size);\n        fragColor.ra = mix(fragColor.ra, vec2(0.5, length(fragColor)*2.0), stepper);\n    }\n\n    fragColor.ra = mix(fragColor.ra, vec2(0.7, length(fragColor)*2.0), _pulse(_uv.y, down_sweep*1.1-0.1, 0.05)*step(0.001, down_sweep));\n    fragColor.ra = mix(fragColor.ra, vec2(0.7, length(fragColor)*2.0), _pulse(_uv.y, (1.0-up_sweep)*1.1, 0.05)*step(0.001, up_sweep));\n    fragColor.ra = mix(fragColor.ra, vec2(0.7, length(fragColor)*2.0), _pulse(_uv.x, left_sweep*1.1-0.1, 0.05)*step(0.001, left_sweep));\n    fragColor.ra = mix(fragColor.ra, vec2(0.7, length(fragColor)*2.0), _pulse(_uv.x, (1.0-right_sweep)*1.1, 0.05)*step(0.001, right_sweep));\n\n    if (syn_MediaType > 0.5){\n\n        fragColor.r -= fragColor.r*logo*syn_BassLevel;\n        fragColor.b += fragColor.g*logo;\n        fragColor.g = mix(fragColor.g, logo, syn_HighHits);\n\n    }\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n    // fragColor = noise; // reset\n}\n\n\n\n// *************** PASS 2 *****************\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / RENDERSIZE.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / RENDERSIZE.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffD, uv1) * 0.05;\n    sum += texture(buffD, uv2) * 0.09;\n    sum += texture(buffD, uv3) * 0.12;\n    sum += texture(buffD, uv4) * 0.15;\n    sum += texture(buffD, uv5) * 0.16;\n    sum += texture(buffD, uv6) * 0.15;\n    sum += texture(buffD, uv7) * 0.12;\n    sum += texture(buffD, uv8) * 0.09;\n    sum += texture(buffD, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / RENDERSIZE.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(buffB2, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(buffB2, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}\n\n\n// void mainImage2( out vec4 fragColor, in vec2 fragCoord )\n// {\n//     vec2 uv = fragCoord.xy / RENDERSIZE.xy;\n\n//     if(uv.x < 0.5)\n//     {\n//         vec2 uv_half = fract(uv*2.);\n//         // if(uv.y > 0.5)\n//         // {\n//         //     fragColor = blur_horizontal(buffB, uv_half, 1.);\n//         // }\n//         // else\n//         // {\n//             fragColor = blur_horizontal(buffB, uv_half, 1.);\n//         // }\n//     }\n//     else\n//     {\n//         for(int level = 0; level < 8; level++)\n//         {\n//             if((uv.x > 0.25 && uv.y > 0.25) || (uv.x <= 0.5))\n//             {\n//                 break;\n//             }\n//             vec2 uv_half = fract(uv*2.);\n//             fragColor = blur_horizontal_left_column(uv_half, level);\n//             uv = uv_half;\n//         }\n//     }\n// }\n\n// *************** PASS 4 *****************\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / RENDERSIZE.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / RENDERSIZE.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / RENDERSIZE.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffC, uv1) * 0.05;\n    sum += texture(buffC, uv2) * 0.09;\n    sum += texture(buffC, uv3) * 0.12;\n    sum += texture(buffC, uv4) * 0.15;\n    sum += texture(buffC, uv5) * 0.16;\n    sum += texture(buffC, uv6) * 0.15;\n    sum += texture(buffC, uv7) * 0.12;\n    sum += texture(buffC, uv8) * 0.09;\n    sum += texture(buffC, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage3( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / RENDERSIZE.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(buffC, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(buffC, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }  \n    }\n}\n\n// *************** Main Image Pass *****************\n\nvoid mainImage4( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / RENDERSIZE.xy;\n\n    uv /= (1.0+length(_uvc)*(0.5+0.5*sin(TIME*0.35))*distort);\n\n    // if (uv.x*mod(syn_BeatTime*5.0+syn_RandomOnBeat*2.0,8.0)*0.5+uv.y*mod(syn_BeatTime*13.0+syn_RandomOnBeat*1.7,8.0)*0.5 > 1.0){\n    //     uv = 1.0-uv;\n    // }\n\n    // if (uv.x > 0.5){\n    //     uv.x = 1.0-uv.x;\n    // }\n    vec2 pixelSize = 1. / RENDERSIZE.xy;\n    vec2 aspect = vec2(1.,RENDERSIZE.y/RENDERSIZE.x);\n\n    vec2 lightSize=vec2(0.5);\n\n    // *** Color Regime 0 ***\n    vec3 midHighCol = vec3(-1.0)*0.5;\n    vec3 midCol = vec3(1.0)*2.0;\n    vec3 bassCol1 = vec3(1.0)*2.0;    \n    vec3 bassCol2 = vec3(-1.0);\n    vec3 highCol1 = vec3(-1.0);\n    vec3 highCol2 = vec3(1.0);\n\n    float mixer = color_palette;\n    mixer = smoothstep(0.25, 0.75, clamp(mixer, 0.0, 1.0));\n\n    // *** Color Regime 1 ***\n    midHighCol = mix(midHighCol, _normalizeRGB(46, 9, 39), color_palette);\n    bassCol1 = mix(bassCol1, vec3(0.7,0.3,0.1), color_palette);\n    highCol1 = mix(highCol1, _normalizeRGB(4, 117, 111), color_palette);\n    bassCol2 = mix(bassCol2, _normalizeRGB(255, 45, 0), color_palette);\n    highCol2 = mix(highCol2, _normalizeRGB(255, 140, 0), color_palette);\n    midCol = mix(midCol, _normalizeRGB(4, 117, 111), color_palette);\n\n    mixer = color_palette - 1.0;\n    mixer = smoothstep(0.25, 0.75, clamp(mixer, 0.0, 1.0));\n\n    // *** Color Regime 2 ***\n    midHighCol = mix(midHighCol, vec3(0.0,0.0,1.0)*0.5, mixer);\n    bassCol1 = mix(bassCol1,vec3(0.8,0.4,0.0)*2.0, mixer);\n    highCol1 = mix(highCol1,vec3(1.0,0.4,0.0)*2.0, mixer);\n    bassCol2 = mix(bassCol2,vec3(0.8,0.3,0.0), mixer);\n    highCol2 = mix(highCol2,vec3(0.0,0.7,1.0), mixer);\n    midCol = mix(midCol,vec3(0.0,0.8,0.9), mixer);\n\n    vec2 zoneMids = vec2(sin(syn_MidTime*0.23), cos(syn_MidTime*0.17));\n    vec2 zoneMidHighs = vec2(sin(syn_MidHighTime*0.23), cos(syn_MidHighTime*0.17));\n    vec2 zoneHighs = vec2(sin(syn_HighTime*0.23), cos(syn_HighTime*0.17));\n\n    midHighCol *= mix(1.0,(0.4+0.7*syn_MidHighPresence*distance(zoneMidHighs, _uvc)*0.5), 1.0-no_shading);\n    bassCol1 *= mix(1.0,(0.3+0.7*pow(syn_BassLevel,2.0)), 1.0-no_shading);\n    bassCol2 *= mix(1.0,(0.2+0.9*syn_BassPresence*1.0), 1.0-no_shading);\n    highCol1 *= mix(1.0,(0.2+0.9*syn_HighPresence), 1.0-no_shading);\n    midCol *= mix(1.0,(0.2+0.9*distance(zoneMids, _uvc)*syn_MidPresence), 1.0-no_shading);\n\n    if (flashing > 0.5){\n        highCol2 *= (0.1+0.9*syn_HighHits*(0.5+syn_Presence*0.5)*distance(zoneHighs, _uvc));\n    } else {\n        highCol2 *= ((0.5+syn_Presence*0.5)*distance(zoneHighs, _uvc));\n    }\n    \n    float logo = dot(_loadUserImage().rgb, vec3(1.0))/3.0;\n    bassCol2 *= (1.0-logo);\n    bassCol1 *= (1.0-logo);\n\n\n    vec3 finalColor = vec3(0.0);\n    finalColor = mix(finalColor, midCol*1.5, clamp(BlurB(uv + GradientB(uv, pixelSize, vec4(-256.,32.,-128.,32.)*(1.0-logo), 0)*pixelSize, 0).y,0.0,1.0));\n    finalColor = mix(finalColor, bassCol1, clamp(abs(GradientB(uv, pixelSize*2.0, vec4(2.0,0.0,0.0,0.0),0).y),0.0,1.0));\n    finalColor = mix(finalColor, midHighCol, clamp(BlurB(uv, 4).a,0.0,1.0));\n    finalColor = mix(finalColor, bassCol2, clamp(BlurB(uv, 0).x*BlurB(uv + GradientB(uv, pixelSize*2.5, vec4(-256.,32.,-128.,32.)*0.2, 1)*pixelSize, 1).x,0.0,1.0));\n    finalColor = mix(finalColor, highCol1, clamp(dot(GradientB(uv, pixelSize*1., vec4(0., 10., 0., 0.), 1), vec2(sin(syn_HighTime*1.0), cos(syn_HighTime*1.0))),0.0,1.0));\n    finalColor = mix(finalColor, highCol2*2.0, clamp(BlurB(uv, 1).b*dot(GradientB(uv, pixelSize*2.0, vec4(1.,0.,0.,0.), 0), vec2(sin(syn_HighTime*2.0), cos(syn_HighTime*2.0)))*5.,0.0,1.0));\n\n    finalColor *= mix(1.0,(0.6+(sin(_uvc.x*5.0+TIME*0.1)*_uv.y+cos(_uvc.x*4.7-TIME*0.47)+cos(_uvc.x*11.0+TIME*0.89)*(1.0-_uv.y))/6.0),1.0-no_shading);\n    finalColor += pow(finalColor,vec3(2.0))*(0.5+syn_Presence*0.5);\n\n    vec2 vigPos = _uv*(1.0 - uv.yx);   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret !\n    float vig = vigPos.x*vigPos.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n\n    finalColor = clamp(finalColor, 0.0, 1.0);\n\n    // finalColor = _rgb2hsv(finalColor);\n    // finalColor.g += BlurB(uv, 3).r+TIME*0.1;\n    // finalColor = _hsv2rgb(finalColor);\n\n    fragColor = vec4(finalColor,1.0);\n    fragColor *= vig;\n\n       // fragColor = vec4(BlurB(uv, 0)); // simple bypass\n       // fragColor -= vec4(0.5,0.5,0.5,0.0)*fragColor.a;\n       // fragColor = vec4(BlurB(uv, 0).a); // simple bypass\n       // fragColor = texture(buffD, _uv); // raw Gaussian pyramid\n}\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    //buffB\n    vec4 fragColor;\n    mainImage1(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }else if (PASSINDEX == 1.0){\n    return texture(buffB, _uv);\n  }\n  else if (PASSINDEX == 2.0){\n    //buffC\n    vec4 fragColor;\n    mainImage2(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 3.0){\n    //buffD\n    vec4 fragColor;\n    mainImage3(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 4.0){\n    //Image\n    vec4 fragColor;\n    mainImage4(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Biopsy_V2","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":84,"DESCRIPTION":"","MAX":100,"MIN":10,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"","MAX":0.990000009536743,"MIN":0.00999999977648258,"NAME":"cycle","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"","MAX":1,"MIN":-0.5,"NAME":"thickness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":61,"DESCRIPTION":"","MAX":100,"MIN":10,"NAME":"loops","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.5,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"warp","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.330000013113022,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"hue","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"tint","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.25,"DESCRIPTION":"","MAX":3,"MIN":-3,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"invert_bool","TYPE":"toggle","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\candywarp.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"CandyWarp","IMAGES":null,"IMAGE_PATH":"candywarp.synScene\\candywarp.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 84,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 10,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.4,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.99,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"cycle\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"thickness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 61,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 10,\n\t\t\t\"NAME\" : \"loops\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"warp\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.33,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"hue\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"tint\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : -3,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"invert_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"candywarp.png\",\n\t\"TITLE\" : \"CandyWarp\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"bool invert = (invert_bool > 0.5); \r\n\r\n\r\n////////////////////////////////////////////////////////////\r\n// CandyWarp  by mojovideotech\r\n//\r\n// based on :  \r\n// glslsandbox.com/e#38710.0\r\n// Posted by Trisomie21\r\n// modified by @hintz\r\n//\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n////////////////////////////////////////////////////////////\r\n\r\n// float inv_bassHit = (1-syn_BassHits)*(1-syn_BassHits);\r\n// float inv_highHit = (1-syn_HighLevel)*(1-syn_HighLevel);\r\n\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\tfloat s = RENDERSIZE.y / scale;\r\n\tfloat radius = RENDERSIZE.x / cycle;\r\n\tfloat gap = s * (1.0 - thickness);\r\n\tvec2 pos = _xy.xy - RENDERSIZE.xy * 0.5;\r\n\tfloat d = length(pos);\r\n\tfloat T = syn_Time * rate;\r\n\td += clamp(clamp(syn_BassHits*1.5, 0.2,2.0), 0.9, 1.1) * warp * (sin(pos.y * 0.25 / s + T) * sin(pos.x * 0.25 / s + T * 0.5)) * s * 5.0;\r\n\tfloat v = mod(d + radius / (loops * 2.0), radius / loops);\r\n\tv = abs(v - radius / (loops * 2.0));\r\n\tv = clamp(v - gap, 0.0, 1.0);\r\n\td /= radius - T;\r\n\tvec3 m = fract((d - 1.0) * vec3(loops * hue, -loops, loops * tint) * 0.5);\r\n\tif (invert) \tout_FragColor = vec4(m / v, 1.0);\r\n\telse out_FragColor = vec4(m * v, 1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"CandyWarp","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Creates pulses emanating from the center. Moves on BPM with the option bpm pulse, or manually with the button manual pulse.","MAX":1,"MIN":0,"NAME":"pulser_on","TYPE":"toggle","UI_GROUP":"pulser"},{"DEFAULT":1,"DESCRIPTION":"Pulses every two beats, based on bpm.","MAX":1,"MIN":0,"NAME":"bpm_pulse","TYPE":"toggle","UI_GROUP":"pulser"},{"DEFAULT":0,"DESCRIPTION":"bpm pulse should be set to OFF to use this. Manually create a pulse on press.","MAX":1,"MIN":0,"NAME":"manual_pulse","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"pulser"},{"DEFAULT":1,"DESCRIPTION":"Flashes the whole screen when a beat is detected if set to on.","MAX":1,"MIN":0,"NAME":"beat_flasher_on","TYPE":"toggle","UI_GROUP":"flasher"},{"DEFAULT":0,"DESCRIPTION":"Turns the screen into a BPM strobe effect when set to on.","MAX":1,"MIN":0,"NAME":"bpm_flasher_on","TYPE":"toggle","UI_GROUP":"flasher"},{"DEFAULT":1,"DESCRIPTION":"Turns the screen into a BPM strobe effect when set to on.","MAX":1,"MIN":0,"NAME":"painter_on","TYPE":"toggle","UI_GROUP":"painter"},{"DEFAULT":1,"DESCRIPTION":"When set to on, pushes the brush around the screen in time to the music. Disable this to manually control the painter.","MAX":1,"MIN":0,"NAME":"auto_painter","TYPE":"toggle","UI_GROUP":"painter"},{"DEFAULT":0,"DESCRIPTION":"Pulse the size of the brush on button press.","MAX":1,"MIN":0,"NAME":"paint_pulse","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"painter"},{"DEFAULT":[0,0],"DESCRIPTION":"auto painter MUST BE SET TO OFF. Manually move the brush around the screen by using the pad.","MAX":[1,1],"MIN":[-1,-1],"NAME":"manual_painter","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"painter"},{"DEFAULT":0.439999997615814,"DESCRIPTION":"Change the size of the circular paintbrush by moving this slider.","MAX":1,"MIN":0,"NAME":"brush_size","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"painter"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"Add motion blur to everything in the scene. Higher is more blur.","MAX":0.990000009536743,"MIN":0,"NAME":"feedback","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Add a white noise/grain effect to everything in the scene.","MAX":1,"MIN":0,"NAME":"noise_on","TYPE":"toggle","UI_GROUP":"general"},{"DEFAULT":0,"DESCRIPTION":"Change from white on black to black on white.","MAX":1,"MIN":0,"NAME":"invert","PARAMS":0.25,"TYPE":"toggle smooth","UI_GROUP":"general"},{"DEFAULT":1,"DESCRIPTION":"Change brightness of the output. With feedback this can get overdriven to complete whiteout.","MAX":3,"MIN":0,"NAME":"brightness","PARAMS":0.25,"TYPE":"slider smooth","UI_GROUP":"general"}],"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\canvas.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Canvas","IMAGES":null,"IMAGE_PATH":"canvas.synScene\\canvas.png","JSON_CODE":"{\n  \"CREDIT\": \"Synesthesia\",\n  \"TITLE\": \"Canvas\",\n  \"IMAGE_PATH\": \"canvas.png\",\n  \"CONTROLS\": [\n    {\n      \"NAME\": \"pulser_on\",\n      \"DEFAULT\":1.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"Creates pulses emanating from the center. Moves on BPM with the option bpm pulse, or manually with the button manual pulse.\",\n      \"UI_GROUP\": \"pulser\"\n    },{\n      \"NAME\": \"bpm_pulse\",\n      \"DEFAULT\":1.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"Pulses every two beats, based on bpm.\",\n      \"UI_GROUP\": \"pulser\"\n    },{\n      \"NAME\": \"manual_pulse\",\n      \"DEFAULT\":0.0,\n      \"PARAMS\": 0.05,\n      \"TYPE\": \"bang smooth\",\n      \"DESCRIPTION\": \"bpm pulse should be set to OFF to use this. Manually create a pulse on press.\",\n      \"UI_GROUP\": \"pulser\"\n    },{\n      \"NAME\": \"beat_flasher_on\",\n      \"DEFAULT\":1.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"Flashes the whole screen when a beat is detected if set to on.\",\n      \"UI_GROUP\": \"flasher\"\n    },{\n      \"NAME\": \"bpm_flasher_on\",\n      \"DEFAULT\":0.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"Turns the screen into a BPM strobe effect when set to on.\",\n      \"UI_GROUP\": \"flasher\"\n    },{\n      \"NAME\": \"painter_on\",\n      \"DEFAULT\":1.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"Turns the screen into a BPM strobe effect when set to on.\",\n      \"UI_GROUP\": \"painter\"\n    },{\n      \"NAME\": \"auto_painter\",\n      \"DEFAULT\":1.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"When set to on, pushes the brush around the screen in time to the music. Disable this to manually control the painter.\",\n      \"UI_GROUP\": \"painter\"\n    },{\n      \"NAME\": \"paint_pulse\",\n      \"DEFAULT\":0.0,\n      \"PARAMS\": 0.1,\n      \"TYPE\": \"bang smooth\",\n      \"DESCRIPTION\": \"Pulse the size of the brush on button press.\",\n      \"UI_GROUP\": \"painter\"\n    },{\n      \"NAME\": \"manual_painter\",\n      \"MIN\": -1.0,\n      \"MAX\":  1.0,\n      \"DEFAULT\": 0.0,\n      \"TYPE\": \"xy smooth\",\n      \"PARAMS\": 0.05,\n      \"DESCRIPTION\": \"auto painter MUST BE SET TO OFF. Manually move the brush around the screen by using the pad.\",\n      \"UI_GROUP\": \"painter\"\n    },{\n      \"NAME\": \"brush_size\",\n      \"DEFAULT\":0.44,\n      \"MIN\": 0.0,\n      \"MAX\": 1.0,\n      \"TYPE\": \"slider smooth\",\n      \"DESCRIPTION\": \"Change the size of the circular paintbrush by moving this slider.\",\n      \"UI_GROUP\": \"painter\"\n    },{\n      \"NAME\": \"feedback\",\n      \"DEFAULT\":0.4,\n      \"MAX\": 0.99,\n      \"TYPE\": \"slider smooth\",\n      \"PARAMS\": 0.05,\n      \"DESCRIPTION\": \"Add motion blur to everything in the scene. Higher is more blur.\",\n      \"UI_GROUP\": \"feedback\"\n    },{\n      \"NAME\": \"noise_on\",\n      \"DEFAULT\":0.0,\n      \"TYPE\": \"toggle\",\n      \"DESCRIPTION\": \"Add a white noise/grain effect to everything in the scene.\",\n      \"UI_GROUP\": \"general\"\n    },{\n      \"NAME\": \"invert\",\n      \"DEFAULT\":0.0,\n      \"MIN\": 0.0,\n      \"MAX\": 1.0,\n      \"PARAMS\":0.25,\n      \"TYPE\": \"toggle smooth\",\n      \"DESCRIPTION\": \"Change from white on black to black on white.\",\n      \"UI_GROUP\": \"general\"\n    },{\n      \"NAME\": \"brightness\",\n      \"DEFAULT\":1.0,\n      \"MIN\": 0.0,\n      \"MAX\": 3.0,\n      \"PARAMS\":0.25,\n      \"TYPE\": \"slider smooth\",\n      \"DESCRIPTION\": \"Change brightness of the output. With feedback this can get overdriven to complete whiteout.\",\n      \"UI_GROUP\": \"general\"\n    }\n\n  ]\n}\n","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"float triGen(vec2 pos, float grower){\n  pos.x *= (RENDERSIZE.x / RENDERSIZE.y);\n  pos *= vec2(3.0,2.0)*2.0;\n  pos += vec2(0.0,0.2+grower*8.0);\n  pos.y += abs(pos.x);\n\n  //        float r = triRand(sin(pos.y), grower);\n  float r = tan(pos.y);\n  float retVal = r;\n  for (int i=0;i<10;i++){\n    retVal -= sin(syn_BassTime+pos.x*(i+1)/10.0);\n  }\n\n  return retVal;\n}\n\nfloat pulseTime = fract(length(_uvc)*0.9 - (syn_BPMTri2/syn_BPMConfidence)*bpm_pulse + manual_pulse +0.12)*3.5;\nfloat pulse = smoothstep(0.0,0.4,pulseTime)-smoothstep(0.4,0.55,pulseTime);\n\nvec4 renderMain(void)\n{\n  float data = 0.0;\n  data += pulse*pulser_on;\n\n  data += syn_OnBeat*beat_flasher_on;\n  data += clamp(pow(2*syn_BPMTri/syn_BPMConfidence,0.9),0.0,1.0)*bpm_flasher_on;\n\n  float disty = length(_uvc-vec2(manual_painter.x, manual_painter.y)*vec2(1.0, RENDERSIZE.y/RENDERSIZE.x)*0.9);\n  if (auto_painter>0.5){\n    disty = length(_uvc-vec2(sin(syn_Time*2*PI*0.08*0.25+syn_RandomOnBeat),cos(syn_Time*2*PI*0.124*0.25+syn_RandomOnBeat))*0.3);\n  }\n  if(disty < pow(brush_size+paint_pulse*brush_size,3.0)) {\n    data += pow(disty+1.0,4.0)*painter_on;\n  }\n\n  float backbuffer = texture(syn_FinalPass, _uv).r;\n\n  data = mix(data, backbuffer, pow(feedback,0.2));\n\n  data -= clamp(pow(_rand(_uvc*10000.0+TIME+_uvc.x*_uvc.y*1000.0),4.0)*noise_on,0.0,1.0);\n\n  if (_exists(syn_UserImage)){\n    data = mix(data, 1.0-data, _loadUserImageAsMask().r);\n  }\n\n  data *= brightness;\n\n  data = mix(data, 1.0-data, invert);\n\n  vec4 colorOut = vec4(vec3(data), 1.0);\n  return colorOut;\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Canvas","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.400000005960464,"DESCRIPTION":"Adjusts the speed the fluid ebbs and flows.","MAX":1,"MIN":0,"NAME":"fluid_speed","PARAMS":0.150000005960464,"TYPE":"slider smooth","UI_GROUP":"animation"},{"DEFAULT":1,"DESCRIPTION":"Creates a more reactive fluid by adding the audio presence to the fluid speed.","MAX":1,"MIN":0,"NAME":"auto_fluid","TYPE":"toggle","UI_GROUP":"animation"},{"DEFAULT":0,"DESCRIPTION":"Changes the overall appearance of the scene from 2d to 3d.","LABELS":["fluids","X","3D"],"MAX":2,"MIN":0,"NAME":"mode","TYPE":"dropdown","UI_GROUP":"mode","VALUES":[0,1,2]},{"DEFAULT":0,"DESCRIPTION":"Adds a keleidoscope effect to the scene.","LABELS":["none","three","six (four)"],"MAX":2,"MIN":0,"NAME":"symmetry","TYPE":"dropdown","UI_GROUP":"mode","VALUES":[0,1,2]},{"DEFAULT":1,"DESCRIPTION":"Creates flashes of brightness and color on high hits along the fluid contours.","MAX":1,"MIN":0,"NAME":"auto_highlight","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Pulses the brightness and color on high hits along the fluid contours.","MAX":1,"MIN":0,"NAME":"highlight","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Defines the contours of the fluid with bright dynamic lighting.","MAX":1,"MIN":0,"NAME":"contours","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Changes the overall coloring of the scene.","LABELS":["spectrum","laser_tag","lava_lightning","hypercolor"],"MAX":3,"MIN":0,"NAME":"color_scheme","TYPE":"dropdown","UI_GROUP":"color","VALUES":[0,1,2,3]},{"DEFAULT":0,"DESCRIPTION":"Invert the brightness of the media.","MAX":1,"MIN":0,"NAME":"media_invert","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Mixes the media color with the coloring of the scene.","MAX":1,"MIN":0,"NAME":"media_color","PARAMS":0.300000011920929,"TYPE":"slider smooth","UI_GROUP":"color"}],"CREDIT":"Synesthesia","DESCRIPTION":"A colorful dancing fluid that can be seen in both 2d and 3d modes. From the Synesthesia Archive, original artists are Meebs x WAHa_06x36","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\.marketplace\\chroma_cascade.synScene","GPU":2,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Chroma Cascade","IMAGES":null,"IMAGE_PATH":"chroma_cascade.synScene\\chroma_cascade.png","JSON_CODE":"{\n  \"CREDIT\": \"Synesthesia\",\n  \"DESCRIPTION\": \"A colorful dancing fluid that can be seen in both 2d and 3d modes. From the Synesthesia Archive, original artists are Meebs x WAHa_06x36\",\n  \"TITLE\": \"Chroma Cascade\",\n  \"IMAGE_PATH\": \"chroma_cascade.jpg\",\n  \"GPU\": 2,\n  \"TAGS\": [\"dark\", \"media\", \"colorful\", \"groovy\", \"fluid\", \"rainbow\"],\n  \"VERSION\": 2,\n  \"CONTROLS\": [\n    {\n      \"NAME\": \"fluid_speed\",\n      \"DEFAULT\":0.4,\n      \"PARAMS\": 0.15,\n      \"TYPE\": \"slider smooth\",\n      \"UI_GROUP\":\"animation\",\n      \"DESCRIPTION\": \"Adjusts the speed the fluid ebbs and flows.\"\n    },{\n      \"NAME\": \"auto_fluid\",\n      \"DEFAULT\":1.0,\n      \"PARAMS\": 0.15,\n      \"TYPE\": \"toggle\",\n      \"UI_GROUP\":\"animation\",\n      \"DESCRIPTION\": \"Creates a more reactive fluid by adding the audio presence to the fluid speed.\"\n    },{\n      \"NAME\": \"mode\",\n      \"DEFAULT\":0.0,\n      \"LABELS\":[\"fluids\", \"X\", \"3D\"],\n      \"TYPE\": \"dropdown\",\n      \"UI_GROUP\":\"mode\",\n      \"DESCRIPTION\": \"Changes the overall appearance of the scene from 2d to 3d.\"\n    },{\n      \"NAME\": \"symmetry\",\n      \"DEFAULT\":0.0,\n      \"LABELS\":[\"none\", \"three\", \"six (four)\"],\n      \"TYPE\": \"dropdown\",\n      \"UI_GROUP\":\"mode\",\n      \"DESCRIPTION\": \"Adds a keleidoscope effect to the scene.\"\n    },{\n      \"NAME\": \"auto_highlight\",\n      \"DEFAULT\":1.0,\n      \"TYPE\": \"toggle\",\n      \"UI_GROUP\":\"color\",\n      \"DESCRIPTION\": \"Creates flashes of brightness and color on high hits along the fluid contours.\"\n    },{\n      \"NAME\": \"highlight\",\n      \"DEFAULT\":0.0,\n      \"TYPE\": \"bang smooth\",\n      \"PARAMS\":0.1,\n      \"UI_GROUP\":\"color\",\n      \"DESCRIPTION\": \"Pulses the brightness and color on high hits along the fluid contours.\"\n    },{\n      \"NAME\": \"contours\",\n      \"DEFAULT\":0.0,\n      \"TYPE\": \"toggle\",\n      \"UI_GROUP\":\"color\",\n      \"DESCRIPTION\": \"Defines the contours of the fluid with bright dynamic lighting.\"\n    },{\n      \"NAME\": \"color_scheme\",\n      \"LABELS\":[\"spectrum\", \"laser_tag\", \"lava_lightning\", \"hypercolor\"],\n      \"DEFAULT\":0.0,\n      \"TYPE\": \"dropdown\",\n      \"UI_GROUP\":\"color\",\n      \"DESCRIPTION\": \"Changes the overall coloring of the scene.\"\n    },{\n      \"NAME\": \"media_invert\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"TYPE\": \"toggle\",\n      \"UI_GROUP\":\"color\",\n      \"DESCRIPTION\": \"Invert the brightness of the media.\"\n    },{\n      \"NAME\": \"media_color\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"TYPE\": \"slider smooth\",\n      \"PARAMS\":0.3,\n      \"UI_GROUP\":\"color\",\n      \"DESCRIPTION\": \"Mixes the media color with the coloring of the scene.\"\n    }\n  ]\n}\n","PASSES":null,"SCRIPT_CODE":"function TimeVar () {\n  this.rate = 0.0;\n  this.time = 0.0;\n}\n\nTimeVar.prototype.updateTime = function(val, dt) {\n  this.time = this.time+val*this.rate*dt*60;\n}\n\nfunction Accumulator () {\n  this.value = 0.0;\n  this.decay = 0.9;\n}\n\nAccumulator.prototype.update = function(val, dt){\n  this.value += (val - this.value) * (this.decay * dt * 60.0);\n  if (this.value > 1.0){\n    this.value = 1.0;\n  } else if (this.value<0.0){\n    this.value = 0.0;\n  }\n}\n\nvar timevar = new TimeVar();\nvar accumulator = new Accumulator();\nvar roilTime = 0.0;\nvar decimator = 0;\nfunction update(dt) {\n  timevar.rate = inputs.fluid_speed;\n  accumulator.update(1.0, dt);\n  timevar.updateTime(accumulator.value, dt);\n  uniforms.script_time = timevar.time*0.04;\n  roilTime += inputs.fluid_speed*dt+inputs.syn_Presence*dt;\n  uniforms.roil_time = roilTime;\n\n  if(decimator%50==0){\n\n  }\n  decimator ++;\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"float growerIn = mix(0.17, 1.8, 1.0-syn_BassLevel);\nfloat flowTimeUncorrected = syn_Time;\nfloat bassTimeUncorrected = syn_BassTime;\nfloat vuFadeToBlack = syn_FadeInOut;\n\n#define PI 3.14159265359\n#define OCTAVES 20\n\nvec2 resolution = RENDERSIZE; // the rendering resolution (in pixels)\nfloat time = TIME;\nfloat flowTime = flowTimeUncorrected*6 * (0.08);// 60000 to \"correct\", but we want it much smaller actually\nfloat bassTime = bassTimeUncorrected*6 * (0.01);\nfloat fractMotion=(sin(time*0.05)*0.5+0.5)*5-4;\n\nvec3 kaliset(vec3 position, int numIters, float kaliParam){\n  for (int i=0; i<numIters; ++i)\n  {\n    position = abs(position) / dot(position, position-0.5) - kaliParam;\n  }\n  return position;\n}\n\nfloat triGen(vec2 pos, float grower){\n  pos.x *= (resolution.x / resolution.y);\n  pos *= vec2(3.0,2.0)*2.0;\n  if (symmetry == 0.0){\n    pos += vec2(0.0,0.2+grower*3.0);\n  }\n  else {\n    pos += vec2(0.0,0.2+grower*8.0);\n  }\n  pos.y += abs(pos.x);\n\n  //        float r = triRand(sin(pos.y), grower);\n  float r = tan(pos.y);\n  float retVal = r;\n  for (int i=0;i<10;i++){\n    retVal -= sin(bassTime+pos.x*(i+1)/10.0);\n  }\n\n  return retVal;\n}\n\nvec2 getNormPos() {\n  return vec2(-1+2*(gl_FragCoord.x/resolution.x),-1+2*(gl_FragCoord.y/resolution.y));\n}\nvec2 getNormPosBotLeft() {\n  return vec2(gl_FragCoord.xy/resolution.xy);\n}\n\nvec2 getMirrorPos(vec2 pos, int horVert) {\n  vec2 newPos = pos;\n  if (horVert == 0){\n    newPos.x = abs(newPos.x);\n  }\n  if (horVert == 1){\n    newPos.y = abs(newPos.y);\n  }\n  return newPos;\n}\n\nvec2 lissajousWalk(float time, float rate, float offset, float maxX, float maxY){\n  vec2 newPos;\n  newPos = vec2(cos((time*offset/rate)*2*PI)*maxX,sin((time/rate)*2*PI))*maxY;\n  return newPos;\n}\nvec2 sinPuke(vec2 pos, float time, int iterations){\n  vec2 newPos = pos;\n  for(int i=1;i<iterations;i++)\n  {\n    newPos=newPos+vec2(\n                       0.6/float(i)*sin(float(i)*newPos.y+time+0.3*float(i))+1.0,\n                       0.6/float(i)*sin(float(i)*newPos.x+time+0.3*float(i+10))-1.4\n                       );\n  }\n  return newPos-(iterations*0.6);\n}\n\nfloat fireNoise(vec2 pos, float persistence, float scale)\n{\n  float v = 0.0;\n  float p = 1.0;\n  for (int i=OCTAVES-1; i>=0; --i)\n  {\n    v += (sin(pos.x)+cos(pos.y))*p;\n    pos += sin(pos.yx+vec2(flowTime, 0.6));\n    p *= persistence;\n    pos /= scale;\n  }\n  return v;\n}\n\nvec3 spectral_color(float l) // RGB <0,1> <- lambda l <400,700> [nm]\n{\n  l=l*300+400;\n  float r=0.0,g=0.0,b=0.0;\n  if ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n  else if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n  else if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n  else if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n  else if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n  if ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n  else if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n  else if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n  if ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n  else if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n  return vec3(r,g,b);\n}\n\nvec2 kaleidoscope(vec2 uvIn, float n) {\n  vec2 uv = uvIn;\n  float angle = PI/n;\n\n  uv = uv*vec2(resolution.x/resolution.y,1.0);\n  float r = length(uv);\n  float a = atan(uv.y, uv.x)/angle;\n\n  a = mix(fract(a), 1.0 - fract(a), mod(floor(a), 2.0))*angle;\n\n  return vec2(cos(a), sin(a))*r;\n}\n\n//For Raymarching Regime\nvec2 rotate(vec2 v, float a) {\n  return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat torus(in vec3 p, in vec2 t)\n{\n  vec2 q = abs(vec2(max(abs(p.x), abs(p.z))-t.x, p.y));\n  return max(q.x, q.y)-t.y;\n}\n\n// These are all equally interesting, but I could only pick one :(\nfloat trap(in vec3 p)\n{\n#define var1 abs(max(abs(p.z)-0.1, abs(p.x)-0.1))-0.01\n#define var2 length(max(abs(p.xy) - 0.05, 0.0))\n#define var3 length(p)-0.5\n#define var4 length(max(abs(p) - 0.35, 0.0))\n#define var5 abs(length(p.xz)-0.2)-0.01\n#define var6 abs(min(torus(vec3(p.x, mod(p.y,0.4)-0.2, p.z), vec2(0.1, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005\n#define var7 abs(min(torus(p, vec2(0.3, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005\n#define var8 min(length(p.xz), min(length(p.yz), length(p.xy))) - 0.05\n  return var2;\n  //return  abs(max(abs(p.z)-0.1, abs(p.x)-0.1))-0.01;\n\n}\n\nfloat fractTime = flowTime*0.15;\n\nfloat map(vec3 p)\n{\n  float cutout = dot(abs(p.yz)-(syn_BPMSin2*0.1),vec2(0.5))-0.035;\n\n  vec3 z = abs(1.0-mod(p,2.0));\n\n  float d = 999.0;\n  float s = 1.0;\n  for (float i = 0.0; i < 3.0; i++) {\n    z.xz = rotate(z.xz, radians(i*10.0+flowTime));\n    z.zy = rotate(z.yz, radians((i+1.0)*20.0+flowTime*1.1234));\n    z = abs(1.0-mod(z+i/3.0,2.0));\n\n    z = z*2.0 - 0.3;\n    s *= 0.5;\n    d = min(d, trap(z) * s);\n  }\n  return min(max(d, -cutout), 1.0);\n}\n\nvec3 hsv(float h, float s, float v) {\n  return mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nconst int MAX_ITER = 10;\n\nvec3 intersect(in vec3 rayOrigin, in vec3 rayDir)\n{\n  float total_dist = 0.0;\n  vec3 p = rayOrigin;\n  float d = 1.0;\n  float iter = 0.0;\n  float mind = 0.1;\n  float maxDist = 1.0;\n\n  for (int i = 0; i < MAX_ITER; i++)\n  {\n    if ((d < 0.01)||(total_dist>maxDist)) break;\n\n    d = map(p);\n    p += d*vec3(rayDir.x, rotate(rayDir.yz, (p.z*2.0)));\n//    mind = min(mind, d);\n    mind = d;\n\n    total_dist += d;\n    iter++;\n  }\n\n  vec3 color = vec3(0.0);\n  if (d < 0.01) {\n    float x = (iter/float(MAX_ITER));\n    float y = (d/0.001)/(float(MAX_ITER));\n    float z = (0.01-d)/0.01/float(MAX_ITER);\n    float q = z*20.0-y+x;\n    color = vec3(q)*2;\n  } else {\n    color = vec3(0.0); // Background\n  }\n  return color;\n}\n\nvec3 genFract()\n{\n  vec3 upDirection = vec3(0, -1, 0);\n  vec3 cameraDir = vec3(1,0,0);\n  vec3 cameraOrigin = vec3(bassTime*2.0, 0, 0);\n\n  vec3 u = normalize(cross(upDirection, cameraOrigin));\n  vec3 v = normalize(cross(cameraDir, u));\n  vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;\n  if ((symmetry > 0.5)&&(symmetry < 1.5)){\n    screenPos.x *= resolution.x / resolution.y;\n    screenPos = rotate(screenPos, (sin(flowTime*0.02)+cos(flowTime*0.01))*2*PI);\n    screenPos.x /= resolution.x / resolution.y;\n\n    screenPos = kaleidoscope(screenPos, 3);\n\n  } else if ((symmetry > 1.5)&&(symmetry < 2.5)){\n    screenPos.x *= resolution.x / resolution.y;\n    screenPos = rotate(screenPos, (sin(flowTime*0.02)+cos(flowTime*0.01))*2*PI);\n    screenPos.x /= resolution.x / resolution.y;\n\n    screenPos = kaleidoscope(screenPos, 4);\n\n  }\n  else {\n    screenPos.x *= resolution.x / resolution.y;\n//    screenPos = rotate(screenPos, (sin(flowTime*0.08)+cos(flowTime*0.08))*2*PI);\n  }\n  vec3 rayDir = normalize(u * screenPos.x + v * screenPos.y + cameraDir*(1.0-length(screenPos)*0.5));\n\n  return vec3(intersect(cameraOrigin, rayDir));\n}\n\nvec2 posBL;\nvec2 posCent;\nvec2 perturbedPos;\nvec2 kaliPos;\nvec2 mirrorPos;\nfloat bri = 1.0;\nvec3 fractOutput = vec3(0.0);\nfloat colNoise = 0.0;\nfloat briNoise = 0.0;\nvec3 col = vec3(1.0);\n\nfloat fractOffset=0.08;\n\nvec3 _grad3(vec3 col1, vec3 col2, vec3 col3, float mixVal){\n    mixVal *= 2.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    return mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n}\n\nvec4 renderMain(void)\n{\n  posBL = getNormPosBotLeft();\n  posCent = getNormPos();\n  posBL.x *= resolution.x/resolution.y;\n\n  if ((symmetry > 0.5)&&(symmetry < 1.5)){\n    posBL = kaleidoscope(posCent,3);\n    posCent = kaleidoscope(posCent*2.0,3);\n  } else if ((symmetry > 1.5)&&(symmetry < 2.5)){\n    posBL = kaleidoscope(posCent,6);\n    posCent = kaleidoscope(posCent*2.0,4);\n  }\n\n  float fluidTime = mix(script_time, roil_time, auto_fluid);\n\n  posBL = posBL + lissajousWalk(fluidTime*0.2+2.5, 10.0, 0.8, 2.0, 2.0);\n  perturbedPos = sinPuke(posBL, fluidTime, 5);\n  mirrorPos = getMirrorPos(posCent, 1);\n  mirrorPos *= vec2(1.0,-1.0);\n\n  if (mode > 1.5){\n    fractOutput = genFract();\n    bri = (fractOutput.x);\n  } else if (mode > 0.5){\n    bri = triGen(mirrorPos-vec2(0.0,5.0),-fract(syn_BPMTwitcher)*pow(syn_BPMConfidence,3.0)*0.9);\n  } else {\n    vec3 kaliHolder = kaliset(vec3(perturbedPos-1.0, 1+fractMotion), 8, fractOffset);\n    if (symmetry == 0.0){\n      bri = 1.0-kaliHolder.x+(kaliHolder.y-growerIn*2.0);\n    } else{ \n      bri = kaliHolder.x-(kaliHolder.y-growerIn*3.0);\n    }\n  }\n\n  perturbedPos.y *= resolution.x/resolution.y;\n  float c = fireNoise(perturbedPos*10.0, 0.5, 0.5);\n\n  for (int i=0; i<10; i++){\n    colNoise += cos(c*pow(2.0,i-0.0)*0.5+0.5)/10.0;\n    briNoise += cos(c*pow(2.0,i-4.0))/9.0;\n  }\n\n  float cpPulseTime = fract(0.6+bri*0.5);\n  float cpPulse = smoothstep(0.0,0.3,cpPulseTime)-smoothstep(0.3,0.6,cpPulseTime);\n  float highLightAmt = ((1.0-highlight)-syn_HighHits*auto_highlight);\n  float colorPhase = cpPulse*highLightAmt;\n\n  if (contours < 0.5){\n    colorPhase = syn_HighHits*auto_highlight+smoothstep(0.0,1.0,highlight);\n  }\n\n  if (_exists(syn_UserImage)&&(media_invert>0.5)){\n    colorPhase = mix(colorPhase, 1.0-colorPhase, _loadUserImageAsMask().r);\n  }\n\n  if(color_scheme < 1.0){\n    col = spectral_color(colNoise+(1.0-colorPhase*1.2))*briNoise*bri;\n  }\n  else if (color_scheme < 2.0){\n    col = spectral_color(0.9-colorPhase*0.85-pow(_fbm(vec3(perturbedPos,TIME*0.1)),3.0))*briNoise*bri;\n  }\n  else if (color_scheme < 3.0){\n    float gVal = 1.0;\n    if (briNoise < 1.0){\n      colNoise = smoothstep(0.0,0.5,colNoise)*0.4;\n    }\n    if (bri > 0.2){\n      gVal = 0.0;\n    }\n    col = hsv(colNoise,briNoise*2.0,bri);\n    col = vec3(clamp(col.x,0.0,1.0),clamp(col.y,0.0,1.0),clamp(col.z,0.0,1.0));\n    col *= vec3(sin(perturbedPos.x*2.3)*(0.6+0.3*syn_BassLevel)-pow(col.z,2.0), \n      0.0, \n      pow(col.z,6)*colorPhase*1.0+0.6*sin(perturbedPos.x+perturbedPos.y+1.0)*colorPhase)*1.1;\n    col.r = clamp(col.r, 0.0, 1.0);\n    col.g = (col.b*0.4+0.3*pow(col.r,2.0))*syn_BassLevel;\n  } \n  else {\n    col = spectral_color(colNoise+(1.0-colorPhase*1.2))*briNoise*bri;\n    float saveBlack = smoothstep(0.0, 0.9, length(col));\n    float hue, sat, val;\n    hue = colNoise+sin(perturbedPos.y*1.0+colorPhase);\n    sat = (cos(perturbedPos.y*PI)*0.2+0.8);\n    val = bri*0.5;\n    col = hsv(hue*0.5,sat,val);\n    col.r -= colNoise;\n    col.g -= briNoise;\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    // col = pow(col, vec3(2.0));\n    float logistic = 1/(1+exp(-2*(-6+12*colorPhase)));\n//    col = mix(vec3(0.8)-col, col,logistic);\n    col = mix(col, vec3(0.8)-col, logistic);\n\n    float amtWhiteDec = smoothstep(0.7, 1.3, length(col));\n    col = mix(col, vec3(0.0), saveBlack*(1.0-highLightAmt));\n\n  }\n\n  if (_exists(syn_UserImage)){\n    vec3 texCol = _loadUserImage(vec2(colNoise*0.1+briNoise*0.01)).rgb;\n    col = _grad3(col, col + texCol, texCol, media_color);\n  }\n\n  col *= vuFadeToBlack;\n\n\n\n  vec4 colorOut = vec4(col, 0.0);\n\n  return colorOut;\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":["dark","media","colorful","groovy","fluid","rainbow"],"TITLE":"Chroma Cascade","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Adds more small swirling turbulence to the simulation when on.","MAX":1,"MIN":0,"NAME":"turbulence","TYPE":"toggle","UI_GROUP":"creative"},{"DEFAULT":0,"DESCRIPTION":"Makes the simulation less like paint, more like overdriven plasma.","MAX":-0.5,"MIN":0,"NAME":"plasma","TYPE":"toggle","UI_GROUP":"creative"},{"DEFAULT":0,"DESCRIPTION":"If you want smaller strokes, more consistent texture, less big swatches of colors, turn this off.","MAX":0,"MIN":1,"NAME":"broad_strokes","TYPE":"toggle","UI_GROUP":"creative"},{"DEFAULT":0,"DESCRIPTION":"Causes the color palette to smoothly cycle in time.","MAX":1,"MIN":0,"NAME":"color_phasing","TYPE":"toggle","UI_GROUP":"creative"},{"DEFAULT":1,"DESCRIPTION":"Lifts certain parts of the simulation on press, causing vertical streaks.","MAX":1,"MIN":0,"NAME":"lift","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"movement"},{"DEFAULT":1,"DESCRIPTION":"Swirls the entire simulation about the center on press.","MAX":1,"MIN":0,"NAME":"swirl","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"movement"},{"DEFAULT":0.0500000007450581,"DESCRIPTION":"How heavily or subtly do you want the underlying UserImage or Video to be mixed in? Turn up to snap an image into focus, turn down to have it fade into colors.","MAX":0.300000011920929,"MIN":0,"NAME":"img_mix","TYPE":"slider","UI_GROUP":"general"},{"DEFAULT":0,"DESCRIPTION":"Turn ON if you do not get any FPS lag and like the tilt-shift blur effect. Turn OFF to preserve FPS.","MAX":1,"MIN":0,"NAME":"blur_on_fps","TYPE":"toggle","UI_GROUP":"general"},{"DEFAULT":1,"DESCRIPTION":"Keep ON to have the simulation automatically swirl and push based on the music. Turn OFF to manually control with manual push.","MAX":1,"MIN":0,"NAME":"auto_push","TYPE":"toggle","UI_GROUP":"push"},{"DEFAULT":0,"DESCRIPTION":"auto push MUST BE SET TO OFF. Manually push the simulation forward and backward with this slider.","MAX":1,"MIN":-1,"NAME":"manual_push","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"push"},{"DEFAULT":0,"DESCRIPTION":"'Dive In' to the simulation. Best used by choosing a value and letting it sit, resulting in strange feedback fractals. Turn off your user image for a pure, clean look. Recommended to turn plasma ON.","MAX":2,"MIN":0,"NAME":"dive_in","TYPE":"slider","UI_GROUP":"dive"}],"CREDIT":"Victor S.","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\churning.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"direction","VALUES":[0.100000001490116,0.349999994039536,0.600000023841858,0.850000023841858,1.29999995231628]},{"UNIFORM":"colRegSel","VALUES":[0,0.100000001490116,0.200000002980232]}],"HEIGHT":1080,"ID":"Churning","IMAGES":null,"IMAGE_PATH":"churning.synScene\\Churning.png","JSON_CODE":"{\n \"CREDIT\": \"Victor S.\",\n \"TITLE\": \"Churning\",\n \"IMAGE_PATH\": \"Churning.png\",\n \"HARD_TRANSITIONS\": [\n {\n \"UNIFORM\": \"direction\",\n \"VALUES\":[0.1, 0.35, 0.6, 0.85, 1.3]\n },{\n \"UNIFORM\": \"colRegSel\",\n \"VALUES\":[0.0, 0.1, 0.2]\n }\n ],\n \"PASSES\": [{\"TARGET\": \"firstFB\"}, {\"TARGET\": \"secondFB\"}, {\"TARGET\": \"vertBlur\"}, {\"TARGET\": \"horBlur\"} ],\n \"CONTROLS\": [ \n\t\t{\"NAME\": \"turbulence\", \"DEFAULT\": 0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n        \"UI_GROUP\":\"creative\",\"DESCRIPTION\": \"Adds more small swirling turbulence to the simulation when on.\"}, \n        {\"NAME\": \"plasma\", \"DEFAULT\": 0.0, \"MIN\":0.0, \"MAX\":-0.5, \"TYPE\": \"toggle\",\n        \"UI_GROUP\":\"creative\",\"DESCRIPTION\": \"Makes the simulation less like paint, more like overdriven plasma.\"},\n        {\"NAME\": \"broad_strokes\", \"DEFAULT\": 0.0, \"MAX\":0.0, \"MIN\":1.0, \"TYPE\": \"toggle\",\n        \"UI_GROUP\":\"creative\",\"DESCRIPTION\": \"If you want smaller strokes, more consistent texture, less big swatches of colors, turn this off.\"},\n \t\t{\"NAME\": \"color_phasing\", \"DEFAULT\": 0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n        \"UI_GROUP\":\"creative\",\"DESCRIPTION\": \"Causes the color palette to smoothly cycle in time.\"},\n{\n    \"NAME\": \"lift\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\": 0.1,\n    \"DESCRIPTION\": \"Lifts certain parts of the simulation on press, causing vertical streaks.\",\n    \"UI_GROUP\":\"movement\"\n  },{\n    \"NAME\": \"swirl\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\": 0.1,\n    \"DESCRIPTION\": \"Swirls the entire simulation about the center on press.\",\n    \"UI_GROUP\":\"movement\"\n  },\n\t{\"NAME\": \"img_mix\", \"DEFAULT\": 0.05, \"MIN\":0.0, \"MAX\":0.3, \"TYPE\": \"slider\", \"UI_GROUP\": \"general\",\n    \"DESCRIPTION\": \"How heavily or subtly do you want the underlying UserImage or Video to be mixed in? Turn up to snap an image into focus, turn down to have it fade into colors.\"}, \n    {\"NAME\": \"blur_on_fps\", \"DEFAULT\": 0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n    \"UI_GROUP\":\"general\",\"DESCRIPTION\": \"Turn ON if you do not get any FPS lag and like the tilt-shift blur effect. Turn OFF to preserve FPS.\"},\n    {\"NAME\": \"auto_push\", \"DEFAULT\": 1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n    \"UI_GROUP\":\"push\",\"DESCRIPTION\": \"Keep ON to have the simulation automatically swirl and push based on the music. Turn OFF to manually control with manual push.\"},\n    {\"NAME\": \"manual_push\", \"DEFAULT\": 0.0, \"MIN\":-1.0, \"MAX\":1.0, \"TYPE\": \"slider smooth\", \"PARAMS\": 0.05,\n    \"UI_GROUP\":\"push\",\"DESCRIPTION\": \"auto push MUST BE SET TO OFF. Manually push the simulation forward and backward with this slider.\"},\n    {\"NAME\": \"dive_in\", \"DEFAULT\": 0.0, \"MIN\":0.0, \"MAX\":2.0,\n    \"UI_GROUP\":\"dive\",\"DESCRIPTION\": \"'Dive In' to the simulation. Best used by choosing a value and letting it sit, resulting in strange feedback fractals. Turn off your user image for a pure, clean look. Recommended to turn plasma ON.\"}\n    ]\n }\n\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstFB","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondFB","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"vertBlur","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"horBlur","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"float vuTimeUncorrected = syn_Time;\nfloat vuFadeToBlack = syn_FadeInOut;\nfloat highHits = syn_HighHits;\nfloat highAccum = syn_HighLevel;\nfloat bassAccum = syn_BassLevel;\nfloat bassHits = syn_BassHits;\nfloat switchOnBeat = syn_ToggleOnBeat;\nfloat randomizerBeat = syn_RandomOnBeat;\n\nfloat vuTime = vuTimeUncorrected*60000;\nfloat time = vuTime;\nfloat beatTime = syn_BeatTime*60000;\n\nvec2 resolution = RENDERSIZE;\n\n// const float PI = 3.141592;\n\nvec4 sigmoid(vec4 x){\n  return x/(1.+abs(x));\n}\n\nvoid firstPass( out vec4 fragColor, in vec2 fragCoord )\n{\n  // float t0 = cos(.1*time);\n  // float t1 = cos(.17*time);\n  // float t2 = cos(.117*time);\n  // float t3 = cos(.1717*time);\n  // float t4 = cos(.11717*time);\n\n  vec2 dirOfPush = normalize(vec2(sin(direction*2*PI+syn_BPMTri2), cos(direction*2*PI+randomizerBeat)));\n\n  if (auto_push<0.5){\n    dirOfPush = vec2(1.0,1.0)*manual_push;\n  }\n\n  vec2 tAll = (syn_Level*syn_Level)*2.0*dirOfPush*(0.8+syn_HighHits*0.8);\n\n  if (lift > 0.05){\n    dirOfPush = vec2(-1.0,0.0);\n    tAll = lift*10.0*dirOfPush;\n  }\n\n  if (swirl > 0.05){\n    dirOfPush = normalize(_uvc);\n    tAll = swirl*40.0*dirOfPush;\n  }\n\n\n  vec2 t0 = _rotate(tAll, time);\n  vec2 t1 = _rotate(tAll, -time);\n  vec2 t2 = _rotate(tAll, PI/2);\n  vec2 t3 = _rotate(tAll, -PI/2);\n  vec2 t4 = -tAll;\n\n  vec2 wp = 4.0/resolution.xy;\n  float wg =  -5.0;\n\n  vec2 uv = fragCoord.xy / resolution.xy;\n  uv += _rotate(vec2(1.0,0.0),length(_uvc))*pow(dive_in,2.0);\n\n  vec4 c = -1.+2.*texture(firstFB, uv);\n  c = -1.+2.*texture(firstFB, uv + t0*wp*c.rg);\n  c = -1.+2.*texture(firstFB, uv - t1*wp*c.ba);\n  c = -1.+2.*texture(firstFB, uv + t2*wp*c.ar);\n  c = -1.+2.*texture(firstFB, uv - t3*wp*c.gb);\n\n  vec4 lp = -1.+2.*texture(secondFB, uv);\n\n  // lp *= equalizer3;\n\n  // uv = uv*(1.0+fract(length(_uvc)*equalizer3));\n\n  vec4 rates = vec4(1.,.11,.0111,.001111);\n\n  vec4 phi = rates*time;\n  phi = vec4(highHits);\n\n  // vec4 g = vec4(dot(uv,vec2(1.,0.)+wg*c.rb), dot(uv, vec2(.3,0.8)+wg*c.ga), dot(uv,vec2(.7,.7)+wg* c.bg), dot(uv, vec2(0.,1.)+wg*c.ar));\n  // g = sin(phi+2.*PI*g + wg*c.gbar);\n  vec4 g = vec4(\n                dot(fract(uv-c.rg*broad_strokes), vec2(1.,1.)),\n                dot(fract(uv+c.ba*broad_strokes), vec2(-2.,0.)),\n                dot(fract(uv+c.gr*broad_strokes), vec2(0.,2.)),\n                dot(fract(uv+c.ab*broad_strokes), vec2(1.,-1.))\n                );\n  g = sin(2.0*PI*g + wg*c.gbar + phi);\n\n  g = sigmoid(2.*g.rgba-g.gbar);\n  g *= vec4(1., .57, .27, .77)*(1.0+syn_HighHits);\n\n\n  vec4 c_new = .5*c + g + .25*sigmoid(1.*(c-lp));\n  c_new = c_new.gbar;\n\n  vec4 c_diff = c_new - c;\n  c_diff = .04*mix(c_diff, c_diff.gbra - c_diff.brga, .3*length(t4)+.4);\n\n  c_diff += (plasma+.05)*normalize(c_new-dot(c_new, vec4(.25)));\n\n  float presence;\n  if (syn_HighPresence>syn_BassPresence){\n    presence = syn_HighPresence;\n  } else if (syn_HighPresence<syn_BassPresence){\n    presence = -syn_BassPresence;\n  }\n\n  // if (s2 > 0.5){\n  //   c_new = (1.0-s3)+(s3)*clamp(c+c_diff,-1.0, 1.0);\n  // } else {\n    c_new = .5+.5*clamp(c+c_diff*(clamp(presence,-1.0,1.0)+0.05),-1.,1.);\n  // }\n\n  // c_new = .5+.5*clamp(c+c_diff*(clamp(presence,-1.0,1.0)+0.05),-1.,1.);\n\n  if (turbulence > 0.5){\n    c_new = c_new - c_diff;\n  }\n\n  if (_exists(syn_UserImage)){\n    vec4 image = _loadUserImage();\n    c_new = mix(image,c_new,1.0-img_mix);\n  }\n\n  // c_new *= vec4(equalizer1, equalizer2, equalizer3, 1.0);\n\n  fragColor = c_new;\n}\n\n\n//Second\nvoid secondPass( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / resolution.xy;\n  vec2 d = 1./resolution.xy;\n  vec4 c = .2*(texture(firstFB, uv)\n               + texture(secondFB, uv+d*vec2(1.,0.))\n               + texture(secondFB, uv+d*vec2(-1.,0.))\n               + texture(secondFB, uv+d*vec2(0.,-1.))\n               + texture(secondFB, uv+d*vec2(0.,1.))\n               );\n  fragColor = c;\n}\n\n\n\n\n//Third\nvec3 sigmoid(vec3 x){\n  return x/(1.+abs(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / resolution.xy;\n  vec4 s = texture(firstFB, uv)*2.-1.;\n  vec4 s2 = texture(secondFB, uv)*2.-1.;\n  s = mix(s2, s, highHits);\n  vec3 c = .5+.5*sigmoid(2.*(s.rgb - .25*s.bar));\n  c = c + .05 + .15*normalize(c-dot(c,vec3(.3333)));\n  // fragColor = vec4(c.rgb*vec3(1.0,1.0,0.5+highAccum*_fbm(_uvc-vuTime)),1.);\n  // if (colRegSel == 0.0){\n\n  // }\n\n  float mixer = fract(syn_Time*0.2);\n  float reg;\n  float timer = modf(mod(syn_Time*0.2,3.0), reg);\n\n  vec2 changer = vec2(1.0-mixer, mixer);\n  vec3 v = vec3(0.0);\n  if (reg == 0.0){\n    v = vec3(changer, 0.0);\n  }\n  if (reg == 1.0){\n    v = vec3(0.0, changer);\n  }\n  if (reg == 2.0){\n    v = vec3(changer.y, 0.0, changer.x);\n  }\n\n  if (color_phasing > 0.5){\n    c = vec3(c.r*v.r + c.g*v.g + c.b*v.b, c.g*v.r + c.b*v.g + c.r*v.b, c.b*v.r + c.r*v.g + c.g*v.b);\n  }\n\n  if (colRegSel == 0.1){\n    c = c.bgr-c.rrr+vec3(0.0,0.0,c.g*0.2);\n    c *= 1.5;\n    c *= vec3(1.0, 1.0, 1.0+syn_HighHits*0.5);\n  }\n  else if (colRegSel == 0.2){\n    c = (c.gbr+c.brb)*0.5;\n    c= pow(c,vec3(3.0));\n    c *= vec3(1.0, 1.0+syn_HighHits*0.5, 1.0+syn_HighHits)*1.2;\n  }\n\n  fragColor = vec4(c,1.);\n}\n\nfloat SCurve (float x) {\n        x = x * 2.0 - 1.0;\n        return -x * abs(x) * 0.5 + x + 0.5;\n\n        // return dot(vec3(-x, 2.0, 1.0 ),vec3(abs(x), x, 1.0)) * 0.5; // possibly faster version\n\n}\n\nvec4 BlurV (sampler2D source, vec2 size, vec2 uv, float radius) {\n\n    if (radius >= 1.0)\n    {\n        vec4 A = vec4(0.0);\n        vec4 C = vec4(0.0);\n\n        float height = 1.0 / size.y;\n\n        float divisor = 0.0;\n        float weight = 0.0;\n\n        float radiusMultiplier = 1.0 / radius;\n\n        for (float y = -radius; y <= radius; y++)\n        {\n            A = texture(source, uv + vec2(0.0, y * height));\n\n                weight = SCurve(1.0 - (abs(y) * radiusMultiplier));\n\n                C += A * weight;\n\n            divisor += weight;\n        }\n\n        return vec4(C.r / divisor, C.g / divisor, C.b / divisor, 1.0);\n    }\n\n    return texture(source, uv);\n}\n\nvec4 BlurH (sampler2D source, vec2 size, vec2 uv, float radius) {\n\n    if (radius >= 1.0)\n    {\n        vec4 A = vec4(0.0);\n        vec4 C = vec4(0.0);\n\n        float width = 1.0 / size.x;\n\n        float divisor = 0.0;\n        float weight = 0.0;\n\n        float radiusMultiplier = 1.0 / radius;\n\n        // Hardcoded for radius 20 (normally we input the radius\n        // in there), needs to be literal here\n\n        for (float x = -radius; x <= radius; x++)\n        {\n            A = texture(source, uv + vec2(x * width, 0.0));\n\n                weight = SCurve(1.0 - (abs(x) * radiusMultiplier));\n\n                C += A * weight;\n\n            divisor += weight;\n        }\n\n        return vec4(C.r / divisor, C.g / divisor, C.b / divisor, 1.0);\n    }\n\n    return texture(source, uv);\n}\n\nfloat hZone = (1 - abs(mod(syn_BassTime*0.05, (2)) - 1))-0.5;\nfloat tiltShiftZone = (1.0-smoothstep(0.0+hZone, 0.5+hZone, _uv.y))+(smoothstep(0.5+hZone, 1.0+hZone, _uv.y));\n\nvec4 vertBlurPass(){\n    return BlurV(vertBlur, RENDERSIZE, _uv, tiltShiftZone*20.0*blur_on_fps);\n}\n\nvec4 horBlurPass(){\n    return BlurH(horBlur, RENDERSIZE, _uv, tiltShiftZone*20.0*blur_on_fps);\n}\n\n\nvec4 renderMain () {\n  vec4 fragColor = vec4(0.0);\n  float blurTime = (1.0+0.5*sin(syn_Time*0.1)+0.5*sin(syn_Time*0.0177))*0.5;\n  if (PASSINDEX == 0.0){\n    firstPass(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 1.0){\n    secondPass(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 2.0){\n    mainImage(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }   \n  else if (PASSINDEX == 3.0){\n    return vertBlurPass();\n  }\n  else if (PASSINDEX == 4.0){\n    return horBlurPass()-tiltShiftZone*0.05;\n  }\n\n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Churning","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"rain","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.200000002980232,"MIN":0,"NAME":"pop","PARAMS":0.0799999982118607,"TYPE":"bang smooth","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.899999976158142,"MIN":0,"NAME":"feedback_on","PARAMS":0.0799999982118607,"TYPE":"toggle smooth","UI_GROUP":"feedback"},{"DEFAULT":0.0500000007450581,"DESCRIPTION":"","MAX":0.100000001490116,"MIN":0,"NAME":"feedback_warp","PARAMS":0.0799999982118607,"TYPE":"slider smooth","UI_GROUP":"feedback"},{"DEFAULT":0.800000011920929,"DESCRIPTION":"","MAX":1.5,"MIN":0,"NAME":"speed_","TYPE":"slider","UI_GROUP":"time"},{"DEFAULT":1,"DESCRIPTION":"","MAX":-1,"MIN":1,"NAME":"reverse","TYPE":"toggle","UI_GROUP":"time"}],"CREDIT":"Keijiro Takahashi","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\circles5.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Circles5","IMAGES":null,"IMAGE_PATH":"circles5.synScene\\circles5.png","JSON_CODE":"{\n \"CREDIT\": \"Keijiro Takahashi\",\n \"TITLE\": \"Circles5\",\n \"IMAGE_PATH\": \"circles5.png\",\n \"IMAGES\": [],\n \"PASSES\": [{\"TARGET\":\"firstBuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"rain\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"effects\"\n  },{\n    \"NAME\": \"pop\",\n    \"MAX\" : 0.2,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.08,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"effects\"\n  },{\n    \"NAME\": \"feedback_on\",\n    \"MAX\" : 0.9,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.08,\n    \"TYPE\": \"toggle smooth\",\n    \"UI_GROUP\": \"feedback\"\n  },{\n    \"NAME\": \"feedback_warp\",\n    \"MAX\" : 0.1,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.05,\n    \"PARAMS\": 0.08,\n    \"TYPE\": \"slider smooth\",\n    \"UI_GROUP\": \"feedback\"\n  },{\n    \"NAME\": \"speed_\",\n    \"MAX\" : 1.5,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.8,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"time\"\n  },{\n    \"NAME\": \"reverse\",\n    \"MAX\" : -1.0,\n    \"MIN\" : 1.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"time\"\n  }]\n }","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0}],"SCRIPT_CODE":"function Timer () {\n  this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function(rate, val, dt) {\n  this.time = this.time+rate*dt*val;\n}\n\nvar timevar = new Timer();\nvar bassTimeVar = new Timer();\n\nvar t = 0;\n\nfunction update(dt) {\n\n  timevar.updateTime(inputs.speed_*inputs.reverse, 1.0, dt);\n  uniforms.script_time = timevar.time;\n\n  bassTimeVar.updateTime(0.5+inputs.syn_BassPresence*0.5, 0.05+inputs.syn_BassLevel*3.0, dt);\n  uniforms.bassTime_scr = bassTimeVar.time;\n\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"float circles(vec2 coord)\n{\n    float reso = 5.0;\n    float width = RENDERSIZE.x / reso;\n\n    vec2 center = floor(coord / width + 0.5) * width;\n    float dist = distance(coord, center);\n\n    float time = TIME * 0.9;\n    float phase = dot(center, vec2(1.647346, 7.323874));\n    float radius = width* (0.3 + sin(bassTime_scr*1.3 + phase) * 0.16);\n\n    return dist - radius;\n}\n\nfloat line(vec2 coord, float seed)\n{\n    vec2 dir = vec2(-1.0, 1.0);\n    float bound = dot(RENDERSIZE.xy, abs(dir));\n\n    float speed = fract(seed * 4785.9433) * 0.3 + 0.3;\n    float time = fract(script_time * speed )*1.1;\n\n    float phase = TIME * (fract(seed * 438.454) * 3.3 + 3.3);\n    float width = bound * 0.02 * (sin(phase) + 1.0);\n\n    float dist = dot(coord, dir) + (time - 0.5) * bound;\n    return abs(dist) - width;\n}\n\nvec4 renderMain()\n{\n    if (PASSINDEX == 0.0){\n        vec2 p = _xy.xy;\n        p = mix(p, p-_uvc*RENDERSIZE.y*2.0, pop);\n        \n        float c = 1e+6;\n        for (int i = 0; i < 4; i++)\n            c = min(c, line(p, 94.3 * float(i)));\n\n        float circ = circles(p);\n        float glow = 1000.0;\n        for (int i = 0; i <4; i++){\n            glow = min(glow, line(p*1.0, 100.0*(1.0-_uvc.x*rain) * float(i)));\n        }\n\n        c = max(c, circles(p));\n        c = clamp(1.0 - abs(1.0 - c), 0.0, 1.0);\n        \n        vec4 finalCol = vec4(c);\n\n        finalCol += clamp(1.0-circ,0.0,1.0)*clamp(1.0-glow,0.0,1.0);\n\n        if (syn_MediaType > 0.5){\n            finalCol = _loadUserImage()*(1.0-clamp(circ, 0.0, 1.0)) + finalCol;\n        }\n\n        finalCol = mix(finalCol, texture(firstBuffer, _uv+normalize(_uvc)*pow(feedback_warp,2.0)), feedback_on);\n\n        return finalCol;\n    } else if (PASSINDEX == 1.0){\n        return texture(firstBuffer, _uv);\n    }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Circles5","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Smoothly switch between normal perspective and Equirectangular coordinates. Best results with this slider at 0% or 100%.","MAX":1,"MIN":0,"NAME":"perspective","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":[0,0],"DESCRIPTION":"Just move the X-axis to spin about your main axis, or move the Y-axis to tilt forwards or backwards.","MAX":[1,1],"MIN":[-1,-1],"NAME":"lookXY","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":2,"DESCRIPTION":"Modify the Menger fractal to give it a more complex look. Find an interesting spot and save it.","MAX":0.200000002980232,"MIN":2,"NAME":"noise","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"structure"},{"DEFAULT":0,"DESCRIPTION":"Change from thick chunks of structure to thin bars and panels.","MAX":0.680000007152557,"MIN":0,"NAME":"thin_structure","PARAMS":0.00999999977648258,"TYPE":"toggle smooth","UI_GROUP":"structure"},{"DEFAULT":0,"DESCRIPTION":"Goes further than 'thin structure' to fully open it up.","MAX":1,"MIN":0,"NAME":"fully_open","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"structure"},{"DEFAULT":-0.349999994039536,"DESCRIPTION":"Rate that you fly into or out of the structure. 50% is no motion, 100% is motion forward, 0% is motion backwards. But it automatically reverses if you change perspective.","MAX":1.5,"MIN":-1.5,"NAME":"rate","TYPE":"slider","UI_GROUP":"reactivity"},{"DEFAULT":0,"DESCRIPTION":"Change the size of the media in comparison with the struture.","MAX":1,"MIN":0,"NAME":"media_scale","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Choose whether you want to add the real colors from the media or multiply the media colors in with the scene's natural colors.","MAX":1,"MIN":0,"NAME":"media_mult_or_add","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"media"}],"CREDIT":"mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\circuit_bending.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Circuit Bending","IMAGES":[{"NAME":"circuits","PATH":"images/circuits.jpg"},{"NAME":"circuits2","PATH":"images/circuits2.jpg"}],"IMAGE_PATH":"circuit_bending.synScene\\circuit_bending.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"test\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"perspective\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"slider smooth\",\n         \"DESCRIPTION\":\"Smoothly switch between normal perspective and Equirectangular coordinates. Best results with this slider at 0% or 100%.\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"lookXY\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"xy smooth\",\n         \"DESCRIPTION\":\"Just move the X-axis to spin about your main axis, or move the Y-axis to tilt forwards or backwards.\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"NAME\" : \"noise\",\n         \"DEFAULT\" : 2,\n         \"DESCRIPTION\" : \"Modify the Menger fractal to give it a more complex look. Find an interesting spot and save it.\",\n         \"MAX\" : 0.2,\n         \"MIN\" : 2.0,\n         \"PARAMS\" : 0.05,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"structure\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.68,\n         \"MIN\" : 0,\n         \"NAME\" : \"thin_structure\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"toggle smooth\",\n         \"DESCRIPTION\":\"Change from thick chunks of structure to thin bars and panels.\",\n         \"UI_GROUP\" : \"structure\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"fully_open\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"toggle smooth\",\n         \"DESCRIPTION\":\"Goes further than 'thin structure' to fully open it up.\",\n         \"UI_GROUP\" : \"structure\"\n      },\n      {\n         \"DEFAULT\" : -0.35,\n         \"DESCRIPTION\" : \"Rate that you fly into or out of the structure. 50% is no motion, 100% is motion forward, 0% is motion backwards. But it automatically reverses if you change perspective.\",\n         \"MAX\" : 1.5,\n         \"MIN\" : -1.5,\n         \"NAME\" : \"rate\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"media_scale\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"slider smooth\",\n         \"DESCRIPTION\":\"Change the size of the media in comparison with the struture.\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"media_mult_or_add\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"slider smooth\",\n         \"DESCRIPTION\":\"Choose whether you want to add the real colors from the media or multiply the media colors in with the scene's natural colors.\",\n         \"UI_GROUP\" : \"media\"\n      }\n   ],\n   \"CREDIT\" : \"mojovideotech\",\n   \"DESCRIPTION\" : \"\",\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"circuits\",\n         \"PATH\" : \"images/circuits.jpg\"\n      },\n      {\n         \"NAME\" : \"circuits2\",\n         \"PATH\" : \"images/circuits2.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"circuit_bending.png\",\n   \"TITLE\" : \"Circuit Bending\"\n}\n","PASSES":null,"SCRIPT_CODE":"// function BPMCounter () {\n//   this.time = 0.0;\n//   this.count = 0.0;\n//   this.timeWithinBeat = 0.0;\n//   this.didIncrement = 0.0;\n// }\n\n// BPMCounter.prototype.updateTime = function(bpm, dt) {\n//   this.didIncrement = 0.0;\n//   var amountToStepThroughBeat = 0.25*bpm*dt/60.0;\n//   this.time = this.time+amountToStepThroughBeat;\n//   if(this.count !== Math.floor(this.time)){\n//     this.count = Math.floor(this.time);\n//     this.didIncrement = 1.0;\n//   }\n//   this.timeWithinBeat = this.time-this.count;\n// }\n\n// function SmoothCounter () {\n//   this.oldCount = 0.0;\n//   this.isGoing = 0.0;\n//   this.currentValue = 0.0;\n// }\n\n// SmoothCounter.prototype.update = function(dt, newCount, speed) {\n//   this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n// }\n\nfunction Timer () {\n  this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function(rate, val, dt) {\n  this.time = this.time+rate*dt*val;\n}\n\n// var bpmcount = new BPMCounter();\n// var downrot = new SmoothCounter();\n// var rightrot = new SmoothCounter();\n\nvar timevar = new Timer();\n\nvar decimator = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  try {\n    timevar.updateTime(inputs.rate, 0.1+inputs.syn_BassLevel+inputs.syn_BassHits+inputs.syn_BassPresence, dt);\n  }  \n  catch (e){\n    print(e);\n  }\n\n  // timevar.updateTime(inputs.rate_in, 0.1+inputs.syn_Level+inputs.syn_HighLevel+inputs.syn_Hits*0.5, dt);\n  uniforms.script_time = timevar.time;\n  // downrot.update(dt, inputs.down_rot, 0.1);\n  // rightrot.update(dt, inputs.right_rot, 0.1);\n\n  // uniforms.down_rot_scr = downrot.currentValue;\n  // uniforms.right_rot_scr = rightrot.currentValue;\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\n","SHADER_CODE":"\n\n////////////////////////////////////////////////////////////\n// Equirec_MengerTunnel  by mojovideotech\n//\n// based on : shadertoy/lsjcWV\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n//Modifications by Meebs\n\n\n#define \ttwpi  \t6.283185307179586  \t// two pi, 2*pi\n#define \tpi   \t3.141592653589793 \t// pi\n\nfloat mid(vec3 p) { p = min(p, p.yzx); return max( max(p.x, p.y), p.z); }\n\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n    vec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\nvec3 colGet(float t){\n    return _palette(_triWave(t, 1.0), vec3(0.340, 0.380-0.2*syn_BassLevel, -0.180), vec3(0.339, 0.040+0.2*syn_BassLevel, 0.670), vec3(0.555, 0.900, 0.315), vec3(0.500, 0.890, 0.000));\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tfloat T = script_time;\n\tvec2 v = (_xy.xy / RENDERSIZE.xy) + RENDERSIZE.y;\n\tv.y -= 0.5;\n\tfloat th =  v.y * pi, ph = v.x * twpi;\n    vec3 sp = vec3( sin(ph) * cos(th), sin(th), cos(ph) * cos(th) );\n    // sp.xy += lookXY;\n    sp = mix(sp, normalize(vec3(_uvc, 1.0)), perspective);\n    sp.yz = _rotate(sp.yz, lookXY.y*PI);\n    sp.xy = _rotate(sp.xy, lookXY.x*PI);\n    vec3 camPos = vec3( pi, pi, T);\n\n    vec3 pos = camPos;\n    vec3 dir = normalize(sp);\n    vec3 signdir = sign(dir);\n    float stepsize = 1.0;\n    float dist = 0.0;\n    vec3 normal;\n    for (int i = 0; i < 20; i++) {\n        vec3 p = mod(pos, twpi * stepsize) - pi * stepsize;\n        p.z = mix(p.z, 0.0, mix(thin_structure, 0.78, fully_open));\n        vec3 num = (stepsize - p * signdir) * step( abs(p), vec3(stepsize) ) / dir * signdir;\n        float len = mid(num);\n        if (len < 0.01) {\n            if (stepsize < 0.05) break;\n            stepsize /= noise;\n            // stepsize += sin(syn_BeatTime)*0.001;\n        } else normal = vec3( equal( vec3(len), num) );\n        pos += dir*len;\n        // pos.xy = _rotate(pos.xy, i*sin(TIME)*0.000);\n        dist += len;\n    }\n\n    vec3 finalCol = vec3(0.0);\n    vec3 lp = camPos;\n    vec3  li = normalize( lp - pos ); // Point light.\n    float spe = pow(max(dot(reflect(-li, normal), -dir), 0.), 8.); // Object specular.\n    float dif = clamp(dot(normal, li), 0.0, 1.0); // Diffuse.\n    finalCol = vec3(0.0);\n\n    finalCol += colGet(dot(pos, normal*10.0)*0.01)*( 1.0 / dist);\n\n    //cyan circuits\n    finalCol.rgb += tpl(circuits2, pos*0.9, normal)*vec3(0.2,0.8,1.0)*syn_HighHits*sin(pos.z+syn_HighTime);\n\n    finalCol.rgb += tpl(circuits, pos*0.2+vec3(0.0, 0.0, -syn_BPMTwitcher*0.05), normal)*vec3(1.0,0.8,0.0)*pow(_fbm(pos+TIME),3.0);\n\n    if (syn_MediaType > 0.5){\n        vec3 mediaCol = tpl(syn_UserImage, pos*media_scale, normal*10.0);\n        finalCol.rgb = mix(finalCol.rgb + finalCol.rgb*mediaCol*1.5, finalCol.rgb + mediaCol, media_mult_or_add);\n    }\n    finalCol = clamp(finalCol, 0.0, 1.0);\n    \n    finalCol += 0.2*pow(mix(0.0, dist, smoothstep(10.0,200.0,dist)),0.5)*(1.0+syn_Presence);\n\n    return vec4(finalCol,1.0); \n} \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Circuit Bending","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Automatically rise above and fall below the cloud layer based on the rise and fall of action in the music.","MAX":1,"MIN":0,"NAME":"auto_height","TYPE":"toggle","UI_GROUP":"height"},{"DEFAULT":0,"DESCRIPTION":"auto height MUST BE SET TO OFF. Manually control the height of the camera in the scene.","MAX":1,"MIN":0,"NAME":"manual_height","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"height"},{"DEFAULT":0,"DESCRIPTION":"Flip entire scene over, turning it from a city to a starry sky, and from a flying over clouds to under water.","MAX":1,"MIN":0,"NAME":"flip_side","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0.5,"DESCRIPTION":"Strafe camera back and forth by turning knob.","MAX":1,"MIN":0,"NAME":"horizontal_motion","PARAMS":0.0500000007450581,"TYPE":"knob smooth","UI_GROUP":"motion"},{"DEFAULT":0.5,"DESCRIPTION":"Change sun height in sky, resulting in deeper red sunset or white light from a high sun position.","MAX":1,"MIN":0,"NAME":"sun_position","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"motion"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"Change how fast you fly through the clouds. Higher is faster, lower is slower.","MAX":1.5,"MIN":0,"NAME":"speed","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"motion"},{"DEFAULT":1,"DESCRIPTION":"Turn OFF to stop the generation of the city/stars and preserve FPS.","MAX":1,"MIN":0,"NAME":"city_fps","PARAMS":0.0500000007450581,"TYPE":"toggle smooth","UI_GROUP":"fps"}],"CREDIT":"nimitz","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\cloudten.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Cloud Ten","IMAGES":[{"NAME":"colornoise","PATH":"./images/colornoise.jpg"}],"IMAGE_PATH":"cloudten.synScene\\cloudten.png","JSON_CODE":"{\n  \"TITLE\": \"Cloud Ten\",\n  \"CREDIT\": \"nimitz\",\n  \"IMAGE_PATH\": \"cloudten.png\",\n  \"IMAGES\": [{\n    \"PATH\": \"./images/colornoise.jpg\",\n    \"NAME\": \"colornoise\"\n  }],\n  \"PASSES\": [{\n    \"TARGET\": \"buffer1\",\n    \"WIDTH\": 640,\n    \"HEIGHT\": 360\n    },{\n    \"TARGET\": \"cityClouds\",\n    \"WIDTH\": 1920,\n    \"HEIGHT\": 1280\n    }],\n  \"CONTROLS\": [\n  {\n    \"NAME\": \"auto_height\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\": 1.0,\n    \"DESCRIPTION\": \"Automatically rise above and fall below the cloud layer based on the rise and fall of action in the music.\",\n    \"UI_GROUP\":\"height\"\n  },{\n    \"NAME\": \"manual_height\",\n    \"TYPE\": \"slider smooth\",\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DEFAULT\": 0.0,\n    \"PARAMS\": 0.05,\n    \"DESCRIPTION\": \"auto height MUST BE SET TO OFF. Manually control the height of the camera in the scene.\",\n    \"UI_GROUP\":\"height\"\n  },{\n    \"NAME\": \"flip_side\",\n    \"TYPE\": \"toggle\",\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DEFAULT\": 0.0,\n    \"DESCRIPTION\": \"Flip entire scene over, turning it from a city to a starry sky, and from a flying over clouds to under water.\",\n    \"UI_GROUP\":\"motion\"\n  },{\n    \"NAME\": \"horizontal_motion\",\n    \"TYPE\": \"knob smooth\",\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DEFAULT\": 0.5,\n    \"PARAMS\": 0.05,\n    \"DESCRIPTION\": \"Strafe camera back and forth by turning knob.\",\n    \"UI_GROUP\":\"motion\"\n  },{\n    \"NAME\": \"sun_position\",\n    \"TYPE\": \"slider smooth\",\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DEFAULT\": 0.5,\n    \"PARAMS\": 0.05,\n    \"UI_GROUP\":\"motion\",\n    \"DESCRIPTION\": \"Change sun height in sky, resulting in deeper red sunset or white light from a high sun position.\"\n  },{\n    \"NAME\": \"speed\",\n    \"TYPE\": \"slider smooth\",\n    \"MIN\": 0.0,\n    \"MAX\": 1.5,\n    \"DEFAULT\": 0.3,\n    \"PARAMS\": 0.05,\n    \"UI_GROUP\":\"motion\",\n    \"DESCRIPTION\": \"Change how fast you fly through the clouds. Higher is faster, lower is slower.\"\n  },{\n    \"NAME\": \"city_fps\",\n    \"TYPE\": \"toggle smooth\",\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DEFAULT\": 1.0,\n    \"PARAMS\": 0.05,\n    \"DESCRIPTION\": \"Turn OFF to stop the generation of the city/stars and preserve FPS.\",\n    \"UI_GROUP\":\"fps\"\n  }]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":360,"TARGET":"buffer1","WIDTH":640},{"FLOAT":true,"HEIGHT":1280,"TARGET":"cityClouds","WIDTH":1920}],"SCRIPT_CODE":"function TimeVar () {\n  this.rate = 0.0;\n  this.time = 0.0;\n}\n\nTimeVar.prototype.updateTime = function(val, dt) {\n  this.time = this.time+val*this.rate*(dt*60);\n}\n\nfunction Accumulator () {\n  this.value = 0.0;\n  this.decay = 0.9;\n}\n\nAccumulator.prototype.update = function(val, dt){\n  this.value += (val - this.value) * (this.decay * dt * 60.0);\n  if (this.value > 1.0){\n    this.value = 1.0;\n  }\n}\n\nvar timevar = new TimeVar();\nvar accumulator = new Accumulator();\n\nvar decimator = 0;\nfunction update(dt) {\n  timevar.rate = inputs.speed;\n  accumulator.update(Math.pow(inputs.syn_Level,2.0), dt);\n  timevar.updateTime(accumulator.value, dt);\n  uniforms.script_time = timevar.time;\n\n  if(decimator%50==0){\n    // console.log(timevar.time);\n  }\n  decimator ++;\n\n}\nfunction transition() {\n}","SHADER_CODE":"//Cloud Ten by nimitz (twitter: @stormoid)\n\n// #define time syn_Time\nfloat time = script_time / 10;\n\nfloat sunPos = sun_position-0.3;\n\n// float depth = mix(-20,2,1.0);\n// float depth = mix(-20,2,0.5+0.5*sin(TIME));\nfloat heightPicker = syn_Presence*auto_height*(1.0-flip_side) + manual_height*(1.0-auto_height) + flip_side*(1.0-syn_Presence)*auto_height;\nfloat depth = mix(-20, 2, smoothstep(0,1,heightPicker));\n\nfloat depthOfCross = -10;\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat noise(float t){return texture(colornoise,vec2(t,.0)/vec2(256,256)).x;}\n\nfloat noise(in vec3 x) //3d noise from iq\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = 2.0*(texture( colornoise, (uv+ 0.5)/256.0, -100.0 ).yx)*1.1;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nfloat path(in float x){ return sin(x*0.01-3.1415)*28.+6.5; }\nfloat map(vec3 p){\n    return p.y*0.07 + (fbm(p*0.3)-0.1) + sin(p.x*0.24 + sin(p.z*.01)*7.)*0.22+0.15 + sin(p.z*0.08)*0.05;\n}\n\nfloat soundClouds(vec3 p){\n    return p.y*0.07 + (fbm(p*0.3+0.1*TIME)-0.1) + sin(p.x*0.24 + cos(p.z*0.05)*7.)*0.22+0.15 + sin(p.z*0.08)*0.05;\n}\n\nfloat marchToFindBkg(in vec3 ro, in vec3 rd)\n{\n    float precis = .3;\n    float h= 1.;\n    float d = 0.;\n    for( int i=0; i<10; i++ )\n    {\n        if( abs(h)<precis || d>70. ) break;\n        d += h;\n        vec3 pos = ro+rd*d;\n        pos.y += .5;\n\t    float res = soundClouds(pos)*7.;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 lgt = vec3(0);\nfloat mapV( vec3 p ){ return clamp(-soundClouds(p), 0., 1.);}\nvec4 marchAboveClouds(in vec3 ro, in vec3 rd, in float t, in vec3 bgc)\n{\n    vec4 rz = vec4( 0.0 );\n    \n    for( int i=0; i<70; i++ )\n    {\n        if(rz.a > 0.99 || t > 200.) break;\n        \n        vec3 pos = ro + t*rd;\n        float den = mapV(pos);\n        \n        vec4 col = vec4(mix( vec3(.8,.75,.85), vec3(.0), den ),den);\n        col.xyz *= mix(bgc*bgc*2.5,  mix(vec3(0.1,0.2,0.55),vec3(.8,.85,.9),sunPos*0.4), clamp( -(den*40.+0.)*pos.y*.03-sunPos*0.5, 0., 1. ) );\n        col.rgb += clamp((1.-den*6.) + pos.y*0.13 +.55, 0., 1.)*0.35*mix(bgc,vec3(1),0.7); //Fringes\n        col += clamp(den*pos.y*.15, -.02, .0); //Depth occlusion\n        col *= smoothstep(0.2+sunPos*0.05,.0,mapV(pos+1.*lgt))*.85+0.15; //Shadows\n        \n        col.a *= .9;\n        col.rgb *= col.a;\n        rz = rz + col*(1.0 - rz.a);\n\n        t += max(.4,(2.-den*30.)*t*0.011);\n    }\n\n    return clamp(rz, 0., 1.);\n}\n\nvec4 marchBelowClouds(in vec3 ro, in vec3 rd, in float t, in vec3 bgc)\n{\n    vec4 rz = vec4( 0.0 );\n    \n    for( int i=0; i<70; i++ )\n    {\n        if(rz.a > 0.99 || t > 200.) break;\n        \n        vec3 pos = ro + t*rd;\n        float den = mapV(pos);\n        \n        vec4 col = vec4(mix( vec3(.8,.75,.85), vec3(.0), den ),den);\n        col.xyz *= mix(bgc*bgc*2.5,  mix(vec3(0.1,0.2,0.55),vec3(.8,.85,.9),sunPos*0.4), clamp( -(den*40.+0.)*pos.y*.03-sunPos*0.5, 0., 1. ) );\n        col.rgb += clamp((1.-den*6.) + pos.y*0.13 +.55, 0., 1.)*0.35*mix(bgc,vec3(1),0.7); //Fringes\n        col += clamp(den*pos.y*.15, -.02, .0); //Depth occlusion\n        col *= smoothstep(0.2+sunPos*0.05,.0,mapV(pos+1.*lgt))*.85+0.15; //Shadows\n        \n        col.a *= .9;\n        col.rgb *= col.a;\n        rz = rz + col*(1.0 - rz.a);\n\n        t += max(.4,(2.-den*30.)*t*0.011);\n    }\n\n    return clamp(rz, 0., 1.);\n}\n\nfloat pent(in vec2 p){\n    vec2 q = abs(p);\n    return max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237)*1.;\n}\n\nvec3 flare(vec2 p, vec2 pos) //Inspired by mu6k's lens flare (https://www.shadertoy.com/view/4sX3Rs)\n{\n\tvec2 q = p-pos;\n    vec2 pds = p*(length(p))*0.75;\n\tfloat a = atan(q.x,q.y);\n\n    float rz = .55*(pow(abs(fract(a*.8+.12)-0.5),3.)*(noise(a*15.)*0.9+.1)*exp2((-dot(q,q)*4.))); //Spokes\n\n    rz += max(1.0/(1.0+32.0*pent(pds+0.8*pos)),.0)*00.2; //Projected ghost (main lens)\n    vec2 p2 = mix(p,pds,-.5); //Reverse distort\n\trz += max(0.01-pow(pent(p2 + 0.4*pos),2.2),.0)*3.0;\n\trz += max(0.01-pow(pent(p2 + 0.2*pos),5.5),.0)*3.0;\n\trz += max(0.01-pow(pent(p2 - 0.1*pos),1.6),.0)*4.0;\n    rz += max(0.01-pow(pent(-(p2 + 1.*pos)),2.5),.0)*5.0;\n    rz += max(0.01-pow(pent(-(p2 - .5*pos)),2.),.0)*4.0;\n    rz += max(0.01-pow(pent(-(p2 + .7*pos)),5.),.0)*3.0;\n\n    return vec3(clamp(rz,0.,1.));\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\n//PATTERNS\n\nvec2 createTronGrid(vec2 fragCoord)\n{\n  fragCoord = fract(fragCoord);\n  float gridSeed = .5;\n  float iterationShade = 0;\n  float backgroundOnOff = 0.0;\n  float fractalZoom;\n  float fragX;\n\n  const int iter = 5;\n  for(int i = 0; i < iter; i ++)\n  {\n    // fractalZoom = 0.5 + (gridSeed - 0.5) * 0.9 * bassHits; //bassShake\n    fractalZoom = 0.5 + (gridSeed - 0.5) * 0.9;\n    fragX = fragCoord.x - fractalZoom;\n    backgroundOnOff += pow(clamp(1.0 - abs(fragX), 0.0, 1.0), 200.0);\n    if(fragX > 0.0) {\n      fragCoord.x = (fragCoord.x - fractalZoom) / (1.0 - fractalZoom);\n      iterationShade += 1.0;\n    }\n    else {\n      gridSeed = fract(gridSeed * 1239.528);\n      fragCoord.x = fragCoord.x / fractalZoom;\n    }\n    fragCoord = fragCoord.yx;\n  }\n  iterationShade /= float(iter);\n  return vec2(backgroundOnOff, iterationShade);\n}\n\nconst int MAGIC_BOX_ITERS = 15;\nconst float MAGIC_BOX_MAGIC = 0.55;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nfloat stars(vec2 posIn)\n{\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n    vec2 uv = posIn;\n\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    result *= 0.03;\n    \n    return result;\n}\n\nvec4 pass0(){\n    vec2 q = _xy.xy / RENDERSIZE.xy;\n\n    float reverseSign = 1.0;\n    bool aboveClouds = true;\n    float rox = PI;\n    vec3 ro = vec3(0.0, depth, time*30);\n\n    if (depth < depthOfCross){ //if we're over or under the clouds\n        aboveClouds = false;\n        reverseSign = -1.0;\n        q = vec2(1.0-q.x, q.y);\n        ro = vec3(ro.x, ro.y, -ro.z);\n    }\n\n    vec2 p = q - 0.5;\n    float asp = RENDERSIZE.x/RENDERSIZE.y;\n    p.x *= asp;\n    float st = sin(syn_Time*0.03-1.3)*0.2;\n\n    ro.x = path(ro.z)+horizontal_motion*100.0; // the x coordinate of ray origin is dependent on z coord of ray origin\n\n    vec3 ta = ro + vec3(0,0,1);\n    vec3 fw = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0)*reverseSign, fw ));\n    vec3 vv = normalize(cross(fw,uu));\n    const float zoom = 0.5;\n    vec3 rd = normalize( p.x*uu + p.y*vv + -zoom*fw );\n\n    rox += smoothstep(0.6,1.2,sin(0.25))*3.5;\n    float roy = sin(syn_Time*0.1)*0.2;\n    mat3 rotation = rot_x(-roy)*rot_y(-rox+st*1.5)*rot_z(st);\n    mat3 inv_rotation = rot_z(-st)*rot_y(rox-st*1.5)*rot_x(roy);\n    rd *= rotation;\n    rd.y -= dot(p,p)*0.06;\n    rd = normalize(rd);\n    vec3 col = vec3(0.);\n\n    lgt = normalize(vec3(-0.3,sunPos+0.1,1.));\n    float rdl = clamp(dot(rd*vec3(1.0,reverseSign,1.0), lgt),0.,1.);\n\n    vec3 hor = mix( vec3(.9,.6,.7)*0.35, vec3(.5,0.05,0.05), rdl );\n    hor = mix(hor, vec3(.5,.8,1),sunPos);\n    col += mix( vec3(.2,.2,.6), hor, exp2(-(1.+ 3.*(1.-rdl))*max(abs(rd.y),0.)) )*.6;\n    col += .8*vec3(1.,.9,.9)*exp2(rdl*650.-650.);\n    col += .3*vec3(1.,1.,0.1)*exp2(rdl*100.-100.);\n    col += .5*vec3(1.,.7,0.)*exp2(rdl*50.-50.);\n    col += .4*vec3(1.,0.,0.05)*exp2(rdl*10.-10.);\n    vec3 bgc = col;\n\n    float rz = marchToFindBkg(ro,rd); //determine if we're in \"cloud zone\" or bkg zone\n\n    if (aboveClouds == true){\n\n        if (rz < 70.)\n        {\n            vec4 res = marchAboveClouds(ro, rd, rz-5., bgc);\n            col = col*(1.0-res.w) + res.xyz;\n        }\n\n        vec3 projected_flare = (-lgt*inv_rotation);\n        col += 1.4*vec3(0.7,0.7,0.4)*max(flare(p,-projected_flare.xy/projected_flare.z*zoom)*projected_flare.z,0.);\n    } \n    else {\n\n        if (rz < 70.)\n        {\n            vec4 res = marchBelowClouds(ro, rd, rz-5., bgc);\n            col = col*(1.0-res.w) + res.xyz;\n        }\n    }\n\n    col = clamp(col, 0., 1.);\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col); //saturation\n    col = pow(col, vec3(0.416667))*1.055 - 0.055; //sRGB\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n\n    return vec4( col, 1.0 );\n}\n\nvec4 pass1(){\n    if (city_fps < 0.01){\n        return texture(buffer1, _uv);\n    }\n\n    vec3 col = texture(buffer1,_uv).rgb;\n    //Perspective projection to get \"ground\" coordinates.\n    vec2 uv = _uv;\n    float perspv = 1.0;\n    float f = 30.;\n    uv-= vec2(0.5, 0.25);\n    uv.y*= RENDERSIZE.y/RENDERSIZE.x;\n    float angle = 0.1*sin(time*0.1);\n    uv = _rotate(uv, angle);\n    uv.y/= RENDERSIZE.y/RENDERSIZE.x;\n    uv*= exp(0.0555*f);\n    float uvy = gl_FragCoord.y/RENDERSIZE.y;\n    perspv = 1.-uvy*1.3;\n    uv/= perspv;\n    uv += vec2(0.5, 0.25);\n    uv += vec2(0.0, time*(0.2));\n\n    float briMod = smoothstep(0.12, 0.48, perspv);\n\n    vec2 tronData = createTronGrid(uv);\n    vec2 space = vec2(syn_HighPresence*0.2,0.0);\n    tronData = mix(tronData, space, flip_side);\n    float cityLights = tronData.x;\n    cityLights += pow(stars(uv),3.0+flip_side*1.0);\n    cityLights = clamp(cityLights, 0.0, 1.0);\n\n    vec3 oCol = mix(vec3(0.8, 0.5, 0.2), vec3(syn_BassPresence*0.3+0.5,syn_BassPresence*0.1+0.5,0.5), flip_side);\n    vec3 bCol = vec3(0.5, 0.5, 0.67)*1.5;\n    float medFBM = _fbm(uv*10.0);\n\n    vec3 finalCol = mix(oCol, bCol, medFBM);\n    finalCol *= cityLights*briMod;\n\n    finalCol = pow(finalCol,vec3(1.5));\n    float anotherFBM = ((pow(_fbm(uv+vec2(0.0,time*2.0)),2.0)*4.0));\n    finalCol *= anotherFBM;\n\n    vec3 mixedCol = col+smoothstep(0.2, 8, clamp(depthOfCross-depth-anotherFBM*2.0,0.2,8.0))*finalCol*(1.0-length(col))*3.0;\n\n    mixedCol = mix(col, mixedCol, city_fps);\n\n    return vec4(mixedCol,1.0);\n}\n\nvec4 pass2(){\n    vec2 pos = _uvc;\n    pos = _rotate(pos, PI*flip_side);\n    pos = (pos*vec2(1.0,RENDERSIZE.x/RENDERSIZE.y)+1.0)*0.5;\n    vec4 col = texture(cityClouds, clamp(pos,0.0,1.0));\n    float underwaterBri = pow(length(col)*0.7,4.0);\n    float bri2 = clamp(1.0-underwaterBri, 0.0, 0.5);\n    if (bri2 < 0.2){\n        bri2 = 0.4;\n        underwaterBri=0.4;\n    }\n    col = mix(col, vec4(0.2,0.5,0.8,1.0)*pow(_uv.y*3.0*underwaterBri*bri2,2.5)*7.0, flip_side*clamp(depth+15, 0, 1));\n    float mask = 1.0;\n    if(_exists(syn_UserImage)){\n        mask = _loadUserImageAsMask().r;\n    }\n    col *= mask;\n\n    return col;\n}\n\nvec4 renderMain () {\n  if (PASSINDEX == 0) {\n    return pass0();\n  } else if (PASSINDEX == 1) {\n    return pass1();\n  } else if (PASSINDEX == 2) {\n    return pass2();\n  }\n\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Cloud Ten","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0.400000005960464,0.579999983310699],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"BackColor_color","TYPE":"color","UI_GROUP":"ungrouped"},{"DEFAULT":[0,0.400000005960464,0.579999983310699],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"CloudColor_color","TYPE":"color","UI_GROUP":"ungrouped"},{"DEFAULT":3.5,"DESCRIPTION":"","MAX":20,"MIN":0.25,"NAME":"CloudSize","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1.29999995231628,"MIN":0,"NAME":"CloudDetail","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"","MAX":1,"MIN":0.00999999977648258,"NAME":"NumLayers","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":20,"MIN":0.25,"NAME":"LayerSpread","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":4,"DESCRIPTION":"","MAX":20,"MIN":0,"NAME":"Blurriness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":18,"DESCRIPTION":"","MAX":20,"MIN":0,"NAME":"Zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":10,"MIN":0,"NAME":"OffsetY","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"Antoine Clappier","DESCRIPTION":"tooon clouds","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\cloud_toonscape_lo-fi.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Cloud Toonscape Lo-Fi","IMAGES":null,"IMAGE_PATH":"cloud_toonscape_lo-fi.synScene\\cloud_toonscape_lo-fi.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0.4,\n\t\t\t\t0.58\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"BackColor_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0.4,\n\t\t\t\t0.58\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"CloudColor_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 3.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 0.25,\n\t\t\t\"NAME\" : \"CloudSize\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1.3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"CloudDetail\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"NumLayers\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 0.25,\n\t\t\t\"NAME\" : \"LayerSpread\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 4,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"Blurriness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 18,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"Zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"OffsetY\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"Antoine Clappier\",\n\t\"DESCRIPTION\" : \"tooon clouds\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"cloud_toonscape_lo-fi.png\",\n\t\"TITLE\" : \"Cloud Toonscape Lo-Fi\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec4 CloudColor = vec4(CloudColor_color, 1.0); \r\nvec4 BackColor = vec4(BackColor_color, 1.0); \r\n\r\n\r\nvec3 iResolution = vec3(RENDERSIZE, 1.);\r\nfloat iGlobalTime = TIME;\r\n\r\n// ----------------------------------------------------------------------------------------\r\n//\t\"Toon Cloud\" by Antoine Clappier - March 2015\r\n//\r\n//\tLicensed under:\r\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\r\n// ----------------------------------------------------------------------------------------\r\n\r\n#define TAU 6.28318530718\r\n\r\n// const vec3 BackColor\t= vec3(0.0, 0.4, 0.58);\r\n// const vec3 CloudColor = vec3(0.18,0.70,0.87);\r\n\r\n\r\nfloat Func(float pX)\r\n{\r\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\r\n}\r\n\r\n\r\nfloat FuncR(float pX)\r\n{\r\n\treturn CloudDetail + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));\r\n}\r\n\r\n\r\nfloat Layer(vec2 pQ, float pT)\r\n{\r\n\tvec2 Qt = CloudSize*pQ;\r\n\tpT *= 1.5;\r\n\tQt.x += pT;\r\n\r\n\tfloat Xi = floor(Qt.x);\r\n\tfloat Xf = Qt.x - Xi -0.5;\r\n\r\n\tvec2 C;\r\n\tfloat Yi;\r\n\tfloat D = 1.0 - step(Qt.y,  Func(Qt.x));\r\n\r\n\t// Disk:\r\n\tYi = Func(Xi + 0.5);\r\n\tC = vec2(Xf, Qt.y - Yi ); \r\n\tD =  min(D, length(C) - FuncR(Xi+ pT/80.0));\r\n\r\n\t// Previous disk:\r\n\tYi = Func(Xi+1.0 + 0.5);\r\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \r\n\tD =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));\r\n\r\n\t// Next Disk:\r\n\tYi = Func(Xi-1.0 + 0.5);\r\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \r\n\tD =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));\r\n\r\n\treturn min(1.0, D);\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// Setup:\r\n\tvec2 UV = (20.-Zoom)*(fragCoord.xy - vec2(iResolution.x, iResolution.y/OffsetY)) / min(iResolution.x, iResolution.y);\t\r\n\t\r\n\t// Render:\r\n\tvec3 Color= vec3(BackColor);\r\n\r\n\tfor(float J=0.0; J<=1.0; J+=0.2)\r\n\t{\r\n\t\t// Cloud Layer: \r\n\t\tfloat Lt =  syn_MidTime/4*(0.5  + 2.0*J)*(1.0 + 0.1*sin(226.0*J)) + 17.0*J;\r\n\t\tvec2 Lp = vec2(0.0, 0.3+LayerSpread*( J - 0.5));\r\n\t\tfloat L = Layer(UV + Lp, Lt);\r\n\r\n\t\t// Blur and color:\r\n\t\tfloat Blur = Blurriness*(0.5*abs(2.0 - 5.0*J))/(11.0 - 5.0*J);\r\n\r\n\t\tfloat V = mix( 0.0, 1.0, 1.0 - smoothstep( 0.0, 0.01 +0.2*Blur, L ) );\r\n\t\tvec3 Lc=  mix( vec3(CloudColor), vec3(1.0), J);\r\n\r\n\t\tColor =mix(Color, Lc,  V);\r\n\t}\r\n\r\n\tfragColor = vec4(Color, 1.0);\r\n}\r\n\r\n\r\n\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n    mainImage(out_FragColor, _xy.xy);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Cloud Toonscape Lo-Fi","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Change from pure white to one of three color palettes, with color palettes changing on transition.","MAX":1,"MIN":0,"NAME":"colored","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Toggle between white on black or black on white.","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Two motion modes for the main shape: ON is a poppy motion that moves on the beat. When set to OFF it creates a slower moving, oscillating mandala.","MAX":1,"MIN":0,"NAME":"motion_style","TYPE":"toggle","UI_GROUP":"rings"},{"DEFAULT":1,"DESCRIPTION":"Changes the radius of individual rings. Thin is an interesting look. Can be set very low for disappearing rings.","MAX":9,"MIN":-5,"NAME":"radius_ring","TYPE":"slider","UI_GROUP":"rings"},{"DEFAULT":0,"DESCRIPTION":"Applies blur to the rings, reducing hard edges. Can be turned way up to 'blow up' the scene.","MAX":3,"MIN":0,"NAME":"blur_amount","TYPE":"slider","UI_GROUP":"rings"},{"DEFAULT":0,"DESCRIPTION":"Control amount of chromatic aberration. The middle is 'none', top and bottom are full aberration amount in opposite directions.","MAX":10,"MIN":-10,"NAME":"aberration","TYPE":"slider","UI_GROUP":"optical"},{"DEFAULT":1,"DESCRIPTION":"Control amount of refraction through triangle surface. High refraction results in pretty colors but can lead to FPS lag. Bottom is none, top is full.","MAX":10,"MIN":0,"NAME":"refraction","TYPE":"slider","UI_GROUP":"optical"},{"DEFAULT":1,"DESCRIPTION":"Send a pulse through the triangle surface, shuffling around refracted light.","MAX":1,"MIN":0,"NAME":"surface_pulse","PARAMS":0.0799999982118607,"TYPE":"bang smooth","UI_GROUP":"tri_surface"},{"DEFAULT":1,"DESCRIPTION":"Fracture the triangle surface, as if it had been shattered by a hit.","MAX":1,"MIN":0,"NAME":"surface_fracture","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"tri_surface"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\compound_iris.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"colorMode","VALUES":[0,1,2]},{"UNIFORM":"refract_angle","VALUES":[0,0.5,1]},{"UNIFORM":"zoomAmt","VALUES":[0,1,0.5]}],"HEIGHT":1080,"ID":"Compound Iris","IMAGES":null,"IMAGE_PATH":"compound_iris.synScene\\compound_iris.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Compound Iris\",\n \"IMAGE_PATH\": \"compound_iris.png\",\n \"HARD_TRANSITIONS\": [\n {\n \"UNIFORM\": \"colorMode\",\n \"VALUES\":[0.0, 1.0, 2.0]\n },{\n \"UNIFORM\": \"refract_angle\",\n \"VALUES\":[0.0, 0.5, 1.0]\n },{\n \"UNIFORM\": \"zoomAmt\",\n \"VALUES\":[0.0, 1.0, 0.5]\n }],\n \"IMAGES\": [],\n \"PASSES\": [ {\"TARGET\": \"firstBuffer\"},{\"TARGET\": \"secondBuffer\", \"FLOAT\": true},{\"TARGET\": \"forHorBlur\", \"WIDTH\": 1600, \"HEIGHT\": 900},{\"TARGET\": \"forVertBlur\", \"WIDTH\": 1600, \"HEIGHT\": 900},{\"TARGET\": \"forLastPass\", \"WIDTH\": 1600, \"HEIGHT\": 900}],\n \"CONTROLS\": [{\n    \"NAME\": \"colored\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Change from pure white to one of three color palettes, with color palettes changing on transition.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"invert\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Toggle between white on black or black on white.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"motion_style\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Two motion modes for the main shape: ON is a poppy motion that moves on the beat. When set to OFF it creates a slower moving, oscillating mandala.\",\n    \"UI_GROUP\":\"rings\"\n  },{\n    \"NAME\": \"radius_ring\",\n    \"MAX\" : 9.0,\n    \"MIN\" : -5.0,\n    \"DEFAULT\":1.0,\n    \"DESCRIPTION\": \"Changes the radius of individual rings. Thin is an interesting look. Can be set very low for disappearing rings.\",\n    \"UI_GROUP\":\"rings\"\n  },{\n    \"NAME\": \"blur_amount\",\n    \"MAX\" : 3.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"DESCRIPTION\": \"Applies blur to the rings, reducing hard edges. Can be turned way up to 'blow up' the scene.\",\n    \"UI_GROUP\":\"rings\"\n  },{\n    \"NAME\": \"aberration\",\n    \"MAX\" : 10.0,\n    \"MIN\" : -10.0,\n    \"DEFAULT\":0.0,\n    \"DESCRIPTION\": \"Control amount of chromatic aberration. The middle is 'none', top and bottom are full aberration amount in opposite directions.\",\n    \"UI_GROUP\":\"optical\"\n  },{\n    \"NAME\": \"refraction\",\n    \"MAX\" : 10.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"DESCRIPTION\": \"Control amount of refraction through triangle surface. High refraction results in pretty colors but can lead to FPS lag. Bottom is none, top is full.\",\n    \"UI_GROUP\":\"optical\"\n  },{\n    \"NAME\": \"surface_pulse\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\": 0.08,\n    \"DESCRIPTION\": \"Send a pulse through the triangle surface, shuffling around refracted light.\",\n    \"UI_GROUP\": \"tri_surface\"\n  },{\n    \"NAME\": \"surface_fracture\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\": 0.1,\n    \"DESCRIPTION\": \"Fracture the triangle surface, as if it had been shattered by a hit.\",\n    \"UI_GROUP\": \"tri_surface\"\n  }]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuffer","WIDTH":0},{"FLOAT":true,"HEIGHT":900,"TARGET":"forHorBlur","WIDTH":1600},{"FLOAT":true,"HEIGHT":900,"TARGET":"forVertBlur","WIDTH":1600},{"FLOAT":true,"HEIGHT":900,"TARGET":"forLastPass","WIDTH":1600}],"SCRIPT_CODE":"","SHADER_CODE":"float time = syn_BPMTwitcher;\nfloat jitter = sin(TIME*80.)*.1*pow((1.-fract(syn_BPMTwitcher)),1.)*syn_BassPresence;\nvec2 mouse = vec2(0.5);\nvec2 resolution = RENDERSIZE;\n\nvec3 filmGrain(vec2 uv, float strength ){       \n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (TIME * 10.0);\n  return  vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n\n}\n\nfloat sdf_smin(float a, float b, float k)\n{\n  float res = exp(-k*a) + exp(-k*b);\n  return -log(max(0.0001,res)) / k;\n}\n\nfloat sdf_circ(vec2 pos, float rad)\n{\n  float r = distance(pos, vec2(0));\n  return r-rad;\n} \n\nfloat sdf_ring(vec2 pos, float rad)\n{\n  float thick = rad*.1*radius_ring;\n  return length( vec2(length(pos)-rad) )-thick;\n}\n\nvec4 genObject() {\n  vec2 pos = gl_FragCoord.xy / resolution - vec2(0.5, 0.5);\n  pos.x *= resolution.x/resolution.y;\n  \n  vec3 color = vec3(0.0);\n  \n  float d = sdf_ring(pos, 0.05+pow(syn_MidPresence,4.0)*0.4);\n\n  float ringTime = mod(floor(syn_BPMTwitcher), 8);\n  if (motion_style < 0.5){\n    ringTime = 8.0;\n    jitter = syn_BassPresence*0.5;\n    time = syn_CurvedTime*0.1;\n  }\n\n  for(int i=0; i<1+ringTime; i++)\n  {\n    float offset = float(i)/8.0*6.28;\n    if (mod(i, 2)==0){\n      offset+=PI;\n    }\n    float size = (0.1 + sin(offset*2.0+time*3.0)*0.05 + jitter*0.8);\n    float next = sdf_ring(pos+vec2(sin(time+offset)*.3, cos(time+offset)*.3), size)*1.0;\n    d = sdf_smin(d, next, 32.0-syn_BPMSin2*20.0);\n    d = clamp(d, -100.0, 100.0);\n  }\n\n    color.r = 1.0;\n    color.g = (1.0+d*10.0)*syn_HighPresence;\n    color.b = 0.25;\n    if (colorMode >= 1.0){\n      color = color.gbr;\n    } else if (colorMode >= 2.0){\n      color = color.brg;\n    }\n\n    color *= smoothstep(0.01+blur_amount*0.1, 0.001, d);\n\n  if (colored < 0.5){\n    color = vec3(length(color));\n  }\n\n  color = mix(color, color-color*filmGrain(_uv*0.5,3.0)*100.0, syn_HighHits*syn_HighPresence);\n\n  return vec4(color, d);\n}\n\n\n//Triangle Pass\n\nfloat rando(float n)\n{\n  return fract(abs(sin(n*55.753)*367.34));   \n}\nfloat rando(vec2 n)\n{\n    return rando(dot(n,vec2(2.46,-1.21)));\n}\nfloat cycle(float n)\n{\n  return cos(fract(n)*2.0*3.141592653)*0.5+0.5;\n}\nfloat genTris(float size, vec2 motion)\n{\n  float a = radians(30+30*refract_angle);\n  float zoom = size-size*zoomAmt*0.5;\n  if (RENDERSIZE.x<1300){\n    zoom *= 0.5;\n  }\n  vec2 c = (_uv*RENDERSIZE + motion );\n  \n  c = ((c+vec2(c.y,0.0)*cos(a))/zoom)+vec2(floor((c.x-c.y*cos(a))/zoom),0.0);\n\n  float n = cycle(rando(floor(c*3.0))*0.2+rando(floor(c*2.0))*0.3+rando(floor(c))*0.5+surface_pulse);\n  c = c*fract(_toPolar(_uvc).y*rando(floor(c*0.5)));\n  float n2 = cycle(rando(floor(c*3.0))*0.2+rando(floor(c*2.0))*0.3+rando(floor(c))*0.5+surface_pulse);\n  n = mix(n, n2, surface_fracture);\n  n = mix(sqrt(n), n*0.5, surface_pulse);\n\n  return n;\n}\n\nvec4 secondPass(){\n  vec4 retCol;\n  if (_exists(syn_UserImage)){\n    retCol = _loadUserImageAsMask();\n  } else {\n    float tris = genTris(400, vec2(sin(TIME*0.011), cos(TIME*0.0093))*3000.0);\n    //tris *= syn_Presence;\n    retCol = vec4(tris);\n  }\n  return retCol;\n}\n\n\n\n\n//Chromatic Aberration\n\nfloat linterp( float t ) {\n  return clamp( 1.0 - abs( 2.0*t - 1.0 ), 0.0, 1.0 );\n}\n\nfloat remap( float t, float a, float b ) {\n  return clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\nvec2 remap( vec2 t, vec2 a, vec2 b ) {\n  return clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\n\nvec3 spectrum_offset_rgb( float t ) {\n  vec3 ret;\n  float lo = step(t,0.5);\n  float hi = 1.0-lo;\n  float w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n  ret = vec3(lo,1.0,hi) * vec3(1.0-w, w, 1.0-w);\n\n    return ret;\n    //return smoothstep( vec3(0.0), vec3(1.0), ret );\n    //return pow( ret, vec3(1.0/2.2) );\n}\n\nconst float gamma = 2.2;\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(gamma) );\n}\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(1.0/gamma));\n}\n\n\nvec3 yCgCo2rgb(vec3 ycc)\n{\n    float R = ycc.x - ycc.y + ycc.z;\n  float G = ycc.x + ycc.y;\n  float B = ycc.x - ycc.y - ycc.z;\n    return vec3(R,G,B);\n}\n\nvec3 spectrum_offset_ycgco( float t )\n{\n  //vec3 ygo = vec3( 1.0, 1.5*t, 0.0 ); //green-pink\n    //vec3 ygo = vec3( 1.0, -1.5*t, 0.0 ); //green-purple\n    vec3 ygo = vec3( 1.0, 0.0, -1.25*t ); //cyan-orange\n    //vec3 ygo = vec3( 1.0, 0.0, 1.5*t ); //brownyello-blue\n    return yCgCo2rgb( ygo );\n}\n\nvec3 yuv2rgb( vec3 yuv )\n{\n    vec3 rgb;\n    rgb.r = yuv.x + yuv.z * 1.13983;\n    rgb.g = yuv.x + dot( vec2(-0.39465, -0.58060), yuv.yz );\n    rgb.b = yuv.x + yuv.y * 2.03211;\n    return rgb;\n}\n\n\n// ====\n\nvec2 distort( vec2 uv, float t, vec2 min_distort, vec2 max_distort )\n{\n    vec2 dist = mix( min_distort, max_distort, t );\n    // return radialdistort( uv, 2.0 * dist );\n    // return barrelDistortion( uv, 1.75 * dist ); //distortion at center\n    // return brownConradyDistortion( uv, 75.0 * dist.x );\n\n    float triPattern = texture(secondBuffer,_uv).r*refraction;\n    // float dxTri = dFdx(triPattern)+dFdy(triPattern);\n\n    return uv+normalize(_uvc)*t*0.002*(1.0+syn_MidPresence)*(1.0+triPattern*3.0)*(1.0+aberration);\n}\n\n// ====\n\nvec3 spectrum_offset_yuv( float t )\n{\n  //vec3 yuv = vec3( 1.0, 3.0*t, 0.0 ); //purple-green\n    //vec3 yuv = vec3( 1.0, 0.0, 2.0*t ); //purple-green\n    vec3 yuv = vec3( 1.0, 0.0, -1.0*t ); //cyan-orange\n    //vec3 yuv = vec3( 1.0, -0.75*t, 0.0 ); //brownyello-blue\n    return yuv2rgb( yuv );\n}\n\nvec3 spectrum_offset( float t )\n{\n    return spectrum_offset_rgb( t );\n    //return srgb2lin( spectrum_offset_rgb( t ) );\n    //return lin2srgb( spectrum_offset_rgb( t ) );\n\n    //return spectrum_offset_ycgco( t );\n    //return spectrum_offset_yuv( t );\n}\n\n// ====\n\nfloat nrand( vec2 n )\n{\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 render( vec2 uv )\n{\n  \n    float triPattern = texture(secondBuffer,_uv).r*refraction;\n\n    return srgb2lin(texture(firstBuffer, uv+(triPattern*0.05-0.025)).rgb );\n}\n\nvec4 chromaticAberration()\n{ \n  vec2 uv = _uv;\n    \n  const float MAX_DIST_PX = 40.0;\n  float max_distort_px = MAX_DIST_PX * (1.0-0.0/RENDERSIZE.x);\n  vec2 max_distort = vec2(max_distort_px) / RENDERSIZE.xy;\n  vec2 min_distort = 0.5 * max_distort;\n\n  //vec2 oversiz = vec2(1.0);\n  vec2 oversiz = distort( vec2(1.0), 1.0, min_distort, max_distort );\n  uv = remap( uv, 1.0-oversiz, oversiz );\n\n  vec3 sumcol = vec3(0.0);\n  vec3 sumw = vec3(0.0);\n  float rnd = nrand( uv + fract(TIME) );\n  const int num_iter = 5;\n\n  for ( int i=0; i<num_iter;++i ) {\n    float t = (float(i)+rnd) / float(num_iter-1);\n    vec3 w = spectrum_offset( t );\n    sumw += w;\n    vec2 uvd = distort(uv, t, min_distort, max_distort); //TODO: move out of loop\n    sumcol += w * render(uvd);\n  }\n\n  sumcol.rgb /= sumw;\n  \n  vec3 outcol = sumcol.rgb;\n  outcol = lin2srgb( outcol );\n  outcol += rnd/255.0;\n\n  // vec3 noise = filmGrain(_uv,20.0);\n  //   outcol += noise*2.0;\n\n  return vec4( outcol, 1.0);\n}\n\n// vec3 render2( vec2 uv )\n// {\n  \n//     // float triPattern = texture(secondBuffer,_uv).r;\n\n//     return srgb2lin(texture(forChromaticAberr, uv).rgb );\n// }\n\n// vec4 chromaticAberration2()\n// { \n//   vec2 uv = _uv;\n    \n//   const float MAX_DIST_PX = 40.0;\n//   float max_distort_px = MAX_DIST_PX * (1.0-0.0/RENDERSIZE.x);\n//   vec2 max_distort = vec2(max_distort_px) / RENDERSIZE.xy;\n//   vec2 min_distort = 0.5 * max_distort;\n\n//   //vec2 oversiz = vec2(1.0);\n//   vec2 oversiz = distort( vec2(1.0), 1.0, min_distort, max_distort );\n//   uv = remap( uv, 1.0-oversiz, oversiz );\n\n//   vec3 sumcol = vec3(0.0);\n//   vec3 sumw = vec3(0.0);\n//   float rnd = nrand( uv + fract(TIME) );\n//   const int num_iter = 5;\n\n//   for ( int i=0; i<num_iter;++i ) {\n//     float t = (float(i)+rnd) / float(num_iter-1);\n//     vec3 w = spectrum_offset( t );\n//     sumw += w;\n//     vec2 uvd = distort(uv, t, min_distort, max_distort); //TODO: move out of loop\n//     sumcol += w * render2(uvd);\n//   }\n\n//   sumcol.rgb /= sumw;\n  \n//   vec3 outcol = sumcol.rgb;\n//   outcol = lin2srgb( outcol );\n//   outcol += rnd/255.0;\n\n//   // vec3 noise = filmGrain(_uv,20.0);\n//   //   outcol += noise*2.0;\n\n//   return vec4( outcol, 1.0);\n// }\n\n\nfloat weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\nvec4 gaussianBlur(bool horizontal, sampler2D image)\n{             \n    vec2 tex_offset = 1.0 / textureSize(image, 0); // gets size of single texel\n    vec3 result = texture(image, _uv).rgb * weight[0]; // current fragment's contribution\n    tex_offset *= filmGrain(_uv,20.0).xy;\n    float triBlur = texture(secondBuffer, _uv).a * weight[0];\n\n    if(horizontal)\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += texture(image, _uv + vec2(tex_offset.x * i * 2, 0.0)).rgb * weight[i];\n            result += texture(image, _uv - vec2(tex_offset.x * i * 2, 0.0)).rgb * weight[i];\n            triBlur += texture(secondBuffer, _uv + vec2(tex_offset.x * i * 2, 0.0)).r * weight[i];\n            triBlur += texture(secondBuffer, _uv - vec2(tex_offset.x * i * 2, 0.0)).r * weight[i];\n        }\n    }\n    else\n    {\n        for(int i = 1; i < 5; ++i)\n        {\n            result += texture(image, _uv + vec2(0.0, tex_offset.y * i * 2)).rgb * weight[i];\n            result += texture(image, _uv - vec2(0.0, tex_offset.y * i * 2)).rgb * weight[i];\n            triBlur += texture(secondBuffer, _uv + vec2(0.0, tex_offset.y * i * 2)).r * weight[i];\n            triBlur += texture(secondBuffer, _uv - vec2(0.0, tex_offset.y * i * 2)).r * weight[i];\n        }\n    }\n    // triBlur = texture(secondBuffer, _uv).a;\n\n    return vec4(result, triBlur);\n}\n\nvec4 lastPass(){\n  vec4 initialImg = texture(firstBuffer, _uv);\n  vec4 distortedImg = texture(forHorBlur, _uv);\n  vec4 blurredImg = texture(forLastPass, _uv);\n\n   \n  // vec3 noise = filmGrain(_uv,50.0);\n  // triPattern.rgb += noise;\n  float lightLines = 0.0;\n  if (!_exists(syn_UserImage)){\n    vec2 lightPos = vec2(sin(syn_Time*0.05), cos(syn_Time*0.05))*0.8;\n    vec2 derivs = vec2(dFdy(-blurredImg.a),dFdy(blurredImg.a));\n    lightLines = length(derivs);\n    // float deriv = dot(vec2(clamp(dFdx(blurredImg.a)+dFdy(blurredImg.a),0.0,1.0),clamp(dFdx(-blurredImg.a)+dFdy(-blurredImg.a),0.0,1.0)),lightPos);\n    lightLines *= 2.0*(0.2+syn_HighPresence);\n    lightLines /= (0.5+distance(_uvc, lightPos)*2.5);\n    lightLines*=(1.0+surface_pulse*5.0);\n  }\n  vec4 finalCol = blurredImg+lightLines*clamp(refraction,0.0,3.0);\n\n\n  if (invert > 0.5){\n    finalCol = 1.0-finalCol;\n  }\n  float fbm = _fbm(_uvc*10.0);\n  finalCol += step(1.0-syn_HighPresence*0.1,fract(texture(secondBuffer, _uv)+syn_BeatTime*0.01))*(1.0-pow(distance(_uvc, vec2(sin(TIME), cos(syn_BassTime))),fbm*fbm));\n  finalCol *= syn_FadeInOut;\n\n  return finalCol;\n}\n\nvec4 renderMain () {\n if (PASSINDEX == 0.0){\n    return genObject();\n  }\n  else if (PASSINDEX == 1.0){\n    return secondPass();\n  } \n  else if (PASSINDEX == 2.0){\n    return chromaticAberration();\n  } \n  else if (PASSINDEX == 3.0){\n    return gaussianBlur(true, forHorBlur);\n  }  \n  else if (PASSINDEX == 4.0){\n    return gaussianBlur(false, forVertBlur);\n  }   \n  else if (PASSINDEX == 5.0){\n    return lastPass();\n  } \n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Compound Iris","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":2,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"num_rings","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":5,"MIN":0.100000001490116,"NAME":"speed","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by joshpbatty","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\conc_circles.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Conc Circles","IMAGES":null,"IMAGE_PATH":"conc_circles.synScene\\conc_circles.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"num_rings\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"speed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by joshpbatty\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"conc_circles.png\",\n\t\"TITLE\" : \"Conc Circles\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n//#define CONSTRAINED_TO_CIRCLE //as opposed to filling the whole screen\r\n#define AA 1.0\r\n#define AA_SAMPS 64\t\r\n\r\n//mmalex's random functions\r\nfloat srand(vec2 a) { return fract(sin(dot(a,vec2(1233.224,1743.335)))); }\r\nvec2 rand(vec2 r) { return fract(3712.65*r+0.61432); }\r\n\r\nfloat easeWithSteps(float t, float steps)\r\n{\r\n\tfloat frac = 1.0 / steps;\t\r\n\tfloat eT = mod(t, frac);\r\n\tfloat x = eT / frac;\r\n\treturn t - eT + frac * x*x*x*(x*(x*6.0 - 15.0) + 10.0); // fancy smoothstep (see wikipeed)\r\n}\r\n\r\nfloat map(float x, float xmin, float xmax, float ymin, float ymax)\r\n{\r\n\t// miss u processing\r\n\treturn clamp(ymin + (x - xmin) / (xmax - xmin) * (ymax - ymin), ymin, ymax);\r\n}\r\n\r\n\r\nfloat colorAtCoord(vec2 coord, float t)\r\n{\r\n\tfloat steps = 1. + mod(floor(t), 7.0); // pattern cycling\r\n\tt = mod(t, 1.0);\r\n\t\r\n\tvec2 uv = coord.xy / RENDERSIZE.xy;\r\n\tvec2 p = uv - vec2(.5,.5);\r\n\tp.y *= RENDERSIZE.y / RENDERSIZE.x;\r\n\t\r\n\tfloat angle = atan(p.y, p.x);\r\n\tangle = mod( angle + PI * 2.0, PI * 2.0);\r\n\t\r\n\tfloat dist = length(p);\r\n\t\r\n\tfloat ring = floor(pow(dist*1.5,.5) * num_rings - t); // tweak!\r\n\tfloat ringFrac = ring / num_rings;\r\n\t\r\n\tfloat ringTime = map(t, ringFrac * .125, 1.0 - ringFrac * .125, 0.0, 1.0);\r\n\tringTime = easeWithSteps(ringTime, steps); // aand tweak!\r\n\t\r\n\tfloat color = 0.0;//vec4 color = vec4(0.0,0.0,0.0,1.0);\r\n\tfloat tAngle =  PI * 2.0 * mod(ringTime * ring*1.0, 1.0);\r\n\t//if ( mod(ring, 2.0) == 0.0) tAngle = PI * 2.0 - tAngle;\r\n\ttAngle *= mod(ring, 2.0)*2.0 - 1.0;\r\n\tfloat si = sin(tAngle);\r\n\tfloat co = cos(tAngle);\r\n\tcolor = step(0., dot(vec2(-si,co),p)); \r\n\t// if ((angle > tAngle && angle < tAngle + PI) || angle < tAngle - PI)\r\n\t// \tcolor = vec4(1.0,1.0,1.0,1.0);\r\n\treturn color;\r\n}\r\n\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\t\t// assume 60fps\r\n\tfloat t = syn_Time/8+syn_BassHits/2 * speed/2;\r\n\tfloat c=0.;\r\n\t\r\n\t// mmalex's AA/blur code.\r\n\tvec2 aa=vec2( srand(_xy.xy), srand(_xy.yx) );\r\n\tt+=1.0/60.0/float(AA_SAMPS)*aa.x;\t\r\n\t\r\n\tfor (int i=0;i<(AA_SAMPS);i++) {\r\n\t\taa=rand(aa);\r\n\t\tc+=colorAtCoord(_xy.xy+aa, t*.05);\r\n\t\tt+=1.0/60.0/float(AA_SAMPS);\r\n\t}\t\r\n\tc=sqrt(c/float(AA_SAMPS));\r\n\tout_FragColor = vec4(c);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Conc Circles","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"by mojovideotech","DESCRIPTION":"Automatically converted from http://glslsandbox.com/e#32770.3","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\continuavariation.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"ContinuaVariation","IMAGES":null,"IMAGE_PATH":"continuavariation.synScene\\continuavariation.png","JSON_CODE":"{\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"Automatically converted from http://glslsandbox.com/e#32770.3\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"continuavariation.png\",\n\t\"TITLE\" : \"ContinuaVariation\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n// ContinuaVariation by mojovideotech\r\n// glslsandbox.com/e#32770.3\r\n\r\n// ======================================\r\n// Corrente Continua - 1k intro (win32)\r\n// Zerothehero of Topopiccione\r\n// 25/jul/2012\r\n//@zerothehero: better formulas, visually improved\r\n// mod by mojovideotech\r\n// ======================================\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nconst float di = 0.5772156649;\r\nconst float dh = 0.69314718;\r\nconst float twpi = 6.2831853;\r\n\t\r\nmat2 rotate2d(float _angle){\r\n    return mat2(cos(_angle),-sin(_angle),\r\n                sin(_angle),cos(_angle));\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tfloat t = syn_Time;\r\n\tfloat tt = syn_Time/4*0.005;\r\n\tvec2 p = ((_xy.xy / RENDERSIZE.xy )-0.5)*27.;\r\n\tp.x *= RENDERSIZE.x/RENDERSIZE.y;\r\n\tfloat a=0.,b=0.,c=0.,d=0.,e=0.;\r\n\tfor (int i=-4; i<4; i++) {\r\n\t\tp = rotate2d(tt*-twpi)*p;\r\n\t\tfloat x = (p.x*di-p.y*dh*0.125);\r\n\t\tfloat y = (p.x*di*0.125+p.y*dh);\r\n\t\tc = (sin(x+t*(float(i))/18.0)+b+y+4.0)*(sin(syn_BassHits * PI)+1.5);\r\n\t\td = (cos(y+t*(float(i))/20.0)+x+a+3.0)*(sin(syn_HighLevel * PI)+1.5);\r\n\t\te = (sin(y+t*(float(i))/17.5)+x-e+1.0);\r\n\t\ta -= .25/(c*c); //color of the blue string\r\n\t\tb += .5/(d*d); //color of the pink string\r\n\t\te += .125;\r\n\t}\r\n\tout_FragColor = vec4(log(-e+a+b-1.)/8.-0.2,log(-e-a-b-1.)/8.-0.2,log(e-a+b-1.)/5.-0.1, 1.0) ;\r\n\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"ContinuaVariation","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"how many cubes","MAX":20,"MIN":1,"NAME":"cluster_number","TYPE":"slider","UI_GROUP":"default"}],"CREDIT":"by mojovideotech","DESCRIPTION":"wip based on glslsandbox.com/e#31945.2","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\cubecluster.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"CubeCluster","IMAGES":null,"IMAGE_PATH":"cubecluster.synScene\\cubecluster.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"how many cubes\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"cluster_number\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"default\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"wip based on glslsandbox.com/e#31945.2\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"cubecluster.png\",\n\t\"TITLE\" : \"CubeCluster\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n///////////////////////////////////////////\r\n// CubeCluster (wip)  by mojovideotech\r\n//\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n//\r\n// based on :\r\n// glslsandbox.com/e#31945.2\r\n///////////////////////////////////////////\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n#define\tphi\t1.618033988749895\r\n\r\n\r\nbool intersects(vec3 ro, vec3 rd, vec3 box_center, float box_size, out float t_intersection)\r\n{\r\n    vec3 t1 = (box_center - vec3(box_size) - ro)/rd;\r\n    vec3 t2 = (box_center + vec3(box_size) - ro)/rd;\r\n    vec3 t_min = min(t1, t2);\r\n    vec3 t_max = max(t1, t2);\r\n    float t_near = max(t_min.x, max(t_min.y, t_min.z));\r\n    float t_far = min(t_max.x, min(t_max.y, t_max.z));\r\n    if (t_near > t_far || t_far < 1.0) return false;\r\n    t_intersection = t_near;\r\n    return true;\r\n}\r\n\r\nmat3 camera(vec3 e, vec3 la) {\r\n    vec3 roll = vec3(0, 1, 0);\r\n    vec3 f = normalize(la - e);\r\n    vec3 r = normalize(cross(roll, f));\r\n    vec3 u = normalize(mix(cross(e, f),cross(f, r),0.75));\r\n    return mat3(r, u, f);\r\n}\r\n\r\nvec4 renderMain() {\r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tconst float INFINITY = 1e3,cluster_size = 5.0, EPSILON = .05;\r\n    float a = rate+syn_BassTime/4, t_intersection = INFINITY, inside = 0.0;\r\n    vec2 uv = (2.5*_xy.xy - RENDERSIZE)/min(RENDERSIZE.x, RENDERSIZE.y);\r\n    vec3 ro = 8.0*vec3(cos(a), sin(0.5*syn_Time/4), -sin(a));\r\n    vec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 2.));\r\n    for (float i = 0.; i < cluster_size; i++) {\r\n        for (float j = 0.; j < cluster_size; j++) {\r\n            for (float k = 0.; k < cluster_size; k++) {\r\n                vec3 p = 2.0*(vec3(i, j, k) - 0.5*vec3(cluster_size-3.0,cluster_size,cluster_size-2.0));\r\n\t\t\t\tfloat l = length(p), s = .1 + .6*pow(.5 + .5*sin(rate*rate*syn_Time/4*phi - j*l),k+0.5), t = 0.;\r\n                if (intersects(ro, rd, p, s, t) && t < t_intersection) {\r\n                    t_intersection = t;\r\n                    vec3 n = ro + rd*t_intersection - p;\r\n                    vec3 normal = smoothstep(vec3(s - EPSILON), vec3(s), n) * sin(clamp(syn_HighHits*5, .75, 7.)/10*PI) + smoothstep(vec3(s - EPSILON), vec3(s), -n);\r\n                    inside = smoothstep(1.05, 1.0, normal.x + normal.y + normal.z)*clamp(syn_BPMSin2,0.75,1.);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    vec4 c;\r\n    if (t_intersection == INFINITY)\r\n        c = mix(vec4(.0, .0, .5, 1.), vec4(0.025, 0., 0., 0.5), 0.25*length(uv));\r\n    else\r\n        c = inside*vec4(1.0, sin(syn_Time/4), 0.0, 1.);\r\n\r\n    out_FragColor = c;\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"CubeCluster","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"mouse","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"Automatically converted from http://glslsandbox.com/e#897.0","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\cubes+spheres.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Cubes+Spheres","IMAGES":null,"IMAGE_PATH":"cubes+spheres.synScene\\cubes+spheres.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"mouse\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"Automatically converted from http://glslsandbox.com/e#897.0\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"cubes+spheres.png\",\n\t\"TITLE\" : \"Cubes+Spheres\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n\r\n// Cubes and Spheres\r\n//\r\n// by @paulofalcao\r\n//\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\nvec2 ObjUnion(\r\n  in vec2 obj0,\r\n  in vec2 obj1)\r\n{\r\n  if (obj0.x<obj1.x)\r\n    return obj0;\r\n  else\r\n    return obj1;\r\n}\r\n\r\nvec2 sim2d(\r\n  in vec2 p,\r\n  in float s)\r\n{\r\n   vec2 ret=p;\r\n   ret=p+s/2.0;\r\n   ret=fract(ret/s)*s-s/2.0;\r\n   return ret;\r\n}\r\n\r\nvec3 stepspace(\r\n  in vec3 p,\r\n  in float s)\r\n{\r\n  return p-mod(p-s/2.0,s);\r\n}\r\n\r\nvec3 phong(\r\n  in vec3 pt,\r\n  in vec3 prp,\r\n  in vec3 normal,\r\n  in vec3 light,\r\n  in vec3 color,\r\n  in float spec,\r\n  in vec3 ambLight)\r\n{\r\n   vec3 lightv=normalize(light-pt);\r\n   float diffuse=dot(normal,lightv);\r\n   vec3 refl=-reflect(lightv,normal);\r\n   vec3 viewv=normalize(prp-pt);\r\n   float specular=pow(max(dot(refl,viewv),0.0),spec);\r\n   return (max(diffuse,0.0)+ambLight)*color+specular;\r\n}\r\n\r\n//Util End\r\n\r\n//Scene Start\r\n\r\nvec2 obj(in vec3 p)\r\n{ \r\n  vec3 fp=stepspace(p,2.0);;\r\n  float d=sin(fp.x*0.3+TIME*4.0)+cos(fp.z*0.3+TIME*2.0);\r\n  p.y=p.y+d;\r\n  p.xz=sim2d(p.xz,2.0);\r\n  float c1=length(max(abs(p)-vec3(0.6,0.6,0.6),0.0))-0.35;\r\n  float c2=length(p)-1.0;\r\n  float cf=sin(TIME)*0.5+0.5;\r\n  return vec2(mix(c1,c2,cf),1.0);\r\n}\r\n\r\nvec3 obj_c(vec3 p){\r\n  vec2 fp=sim2d(p.xz-1.0,4.0);\r\n  if (fp.y>0.0) fp.x=-fp.x;\r\n  if (fp.x>0.0) return vec3(0.0,0.0,0.0);\r\n    else return vec3(1.0,1.0,1.0);   \r\n}\r\n\r\n//Scene End\r\n\r\nfloat raymarching(\r\n  in vec3 prp,\r\n  in vec3 scp,\r\n  in int maxite,\r\n  in float precis,\r\n  in float startf,\r\n  in float maxd,\r\n  out float objid)\r\n{ \r\n  const vec3 e=vec3(0.1,0,0.0);\r\n  vec2 s=vec2(startf,0.0);\r\n  vec3 c,p,n;\r\n  float f=startf;\r\n  for(int i=0;i<256;i++){\r\n    if (abs(s.x)<precis||f>maxd||i>maxite) break;\r\n    f+=s.x;\r\n    p=prp+scp*f;\r\n    s=obj(p);\r\n    objid=s.y;\r\n  }\r\n  if (f>maxd) objid=-1.0;\r\n  return f;\r\n}\r\n\r\nvec3 camera(\r\n  in vec3 prp,\r\n  in vec3 vrp,\r\n  in vec3 vuv,\r\n  in float vpd)\r\n{\r\n  vec2 vPos=-1.0+2.0*_xy.xy/RENDERSIZE.xy;\r\n  vec3 vpn=normalize(vrp-prp);\r\n  vec3 u=normalize(cross(vuv,vpn));\r\n  vec3 v=cross(vpn,u);\r\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*RENDERSIZE.x/RENDERSIZE.y+vPos.y*v;\r\n  return normalize(scrCoord-prp);\r\n}\r\n\r\nvec3 normal(in vec3 p)\r\n{\r\n  //tetrahedron normal\r\n  const float n_er=0.01;\r\n  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;\r\n  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;\r\n  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;\r\n  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;\r\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\r\n}\r\n\r\nvec3 render(\r\n  in vec3 prp,\r\n  in vec3 scp,\r\n  in int maxite,\r\n  in float precis,\r\n  in float startf,\r\n  in float maxd,\r\n  in vec3 background,\r\n  in vec3 light,\r\n  in float spec,\r\n  in vec3 ambLight,\r\n  out vec3 n,\r\n  out vec3 p,\r\n  out float f,\r\n  out float objid)\r\n{ \r\n  objid=-1.0;\r\n  f=raymarching(prp,scp,maxite,precis,startf,maxd,objid);\r\n  if (objid>-0.5){\r\n    p=prp+scp*f;\r\n    vec3 c=obj_c(p);\r\n    n=normal(p);\r\n    vec3 cf=phong(p,prp,n,light,c,spec,ambLight);\r\n    return vec3(cf);\r\n  }\r\n  f=maxd;\r\n  return vec3(background); //background color\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n \r\n  //Camera animation\r\n  vec3 vuv=vec3(0,1,0);\r\n  vec3 vrp=vec3((syn_BassTime/4+syn_BassHits/10)*4.0,0.0,0.0);\r\n  float mx=mouse.x*PI*2.0;\r\n  float my=mouse.y*PI/2.01; \r\n  vec3 prp=vrp+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0; //Trackball style camera pos\r\n  float vpd=1.5;\r\n  vec3 light=prp+vec3(5.0,0,5.0);\r\n  \r\n  vec3 scp=camera(prp,vrp,vuv,vpd);\r\n  vec3 n,p;\r\n  float f,o;\r\n  const float maxe=0.01;\r\n  const float startf=0.1;\r\n  const vec3 backc=vec3(0.0,0.0,0.0);\r\n  const float spec=8.0;\r\n  const vec3 ambi=vec3(0.1,0.1,0.1);\r\n  \r\n  vec3 c1=render(prp,scp,256,maxe,startf,60.0,backc,light,spec,ambi,n,p,f,o);\r\n  c1=c1*max(1.0-f*.015,0.0);\r\n  vec3 c2=backc;\r\n  if (o>0.5){\r\n    scp=reflect(scp,n);\r\n    c2=render(p+scp*0.05,scp,32,maxe,startf,10.0,backc,light,spec,ambi,n,p,f,o);\r\n  }\r\n  c2=c2*max(1.0-f*.1,0.0) * ((clamp(syn_BPMSin,0.5,1.)+clamp(syn_BPMSin2*3.,1.,7.)));\r\n  out_FragColor=vec4(c1.xyz*0.75+c2.xyz*0.25,1.0);\r\n  \r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Cubes+Spheres","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[2,2],"MIN":[-2,-2],"NAME":"center","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"ungrouped"},{"DEFAULT":-3.10999989509583,"DESCRIPTION":"","MAX":3,"MIN":-3.14000010490417,"NAME":"cubesize","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":5.30000019073486,"DESCRIPTION":"","MAX":20,"MIN":3,"NAME":"vanishingpoint","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.150000005960464,"DESCRIPTION":"","MAX":0.899999976158142,"MIN":0.00999999977648258,"NAME":"brightness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.600000023841858,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.469999998807907,"DESCRIPTION":"","MAX":0.800000011920929,"MIN":0.0500000007450581,"NAME":"tint","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-1.73000001907349,"DESCRIPTION":"","MAX":3,"MIN":-6,"NAME":"stretchx","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.59999990463257,"DESCRIPTION":"","MAX":3,"MIN":0.00999999977648258,"NAME":"stretchy","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.83000004291534,"DESCRIPTION":"","MAX":3.5,"MIN":0.949999988079071,"NAME":"stretchz","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.490000009536743,"DESCRIPTION":"","MAX":0.990000009536743,"MIN":0.00999999977648258,"NAME":"overdrive","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.76999998092651,"DESCRIPTION":"","MAX":5,"MIN":0,"NAME":"pov","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"colorreact","TYPE":"toggle","UI_GROUP":"default"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\cubicmatrixmodulatorredux.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"CubicMatrixModulatorRedux","IMAGES":null,"IMAGE_PATH":"cubicmatrixmodulatorredux.synScene\\cubicmatrixmodulatorredux.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t2,\n\t\t\t\t2\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-2,\n\t\t\t\t-2\n\t\t\t],\n\t\t\t\"NAME\" : \"center\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -3.11,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : -3.14,\n\t\t\t\"NAME\" : \"cubesize\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 5.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 3,\n\t\t\t\"NAME\" : \"vanishingpoint\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.15,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.9,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"brightness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.6,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.47,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.8,\n\t\t\t\"MIN\" : 0.05,\n\t\t\t\"NAME\" : \"tint\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -1.73,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : -6,\n\t\t\t\"NAME\" : \"stretchx\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.6,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"stretchy\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.83,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3.5,\n\t\t\t\"MIN\" : 0.95,\n\t\t\t\"NAME\" : \"stretchz\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.49,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.99,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"overdrive\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.77,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"pov\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"colorreact\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"default\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"cubicmatrixmodulatorredux.png\",\n\t\"TITLE\" : \"CubicMatrixModulatorRedux\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\n// CubicMatrixModulatorRedux  by mojovideotech\r\n//\r\n// based on :\r\n// shadertoy/\\XsB3Rm\r\n//\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n////////////////////////////////////////////////////////////\r\n\r\n\r\n#define\t\tqtPI\t0.78539816339745\t// quarter PI, PI/4, 45º\r\n\r\nconst int max_iterations = 150;\r\nconst float stop_threshold = 0.001;\r\nconst float grad_step = 0.01;\r\nconst float clip_far = 300.0;\r\n\r\nfloat dist_field(vec3 p) {\r\n    p = mod(p, 8.0) - 4.0;\r\n    p = abs(p);\r\n    float cube = length(max(p - 0.0667, 0.5));\r\n    float xd = max(p.y-dot(-stretchz,stretchx),p.z);\r\n    float yd = max(p.x-pow(stretchy,-stretchz),p.z);\r\n    float zd = mix(p.x,p.y,stretchz);\r\n    float beams = min(zd*cubesize, max(xd, yd)/mix(stretchz,stretchx,stretchy)) - cos(cubesize);\r\n    \t  beams *= min(zd/sin(cubesize), max(xd, yd)/mod(stretchx,-stretchy)+log2(cubesize));\r\n    \t  beams += min(zd, min(xd, yd)) /-rate;\r\n    return min(beams, cube);\r\n}\r\n\r\nvec3 shading( vec3 v, vec3 eye ) {\r\n\tfloat s = v.x + v.y + v.z;\r\n          s -= eye.x + eye.y * v.z;\r\n\treturn vec3(mod(floor (s * 99.0),0.0+overdrive)-brightness);\r\n}\r\n\r\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\r\n\tfloat depth = start;\r\n\tfor ( int i = 0; i < max_iterations; i++ ) {\r\n\t\tfloat dist = dist_field( origin + dir * depth );\r\n\t\tif ( dist < stop_threshold ) {\r\n\t\t\treturn depth;\r\n\t\t}\r\n\t\tdepth += dist;\r\n\t\tif ( depth >= end) {\r\n\t\t\treturn end;\r\n\t\t}\r\n\t}\r\n\treturn end;\r\n}\r\n\r\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\r\n\tvec2 xy = pos - size * center.xy;\r\n\tfloat cot_half_fov = tan( mod((( 270.0 - fov * 0.25 ) * PI - qtPI), (( 60.0 - fov * 0.5 ) * pos.x)));\t\r\n\tfloat z = size.y * 0.67 * pow(pov,cot_half_fov);\r\n\treturn normalize( vec3( xy, -z ) );\r\n}\r\n\r\nmat3 rotationXY( vec2 angle ) {\r\n\tvec2 c = cos( angle*stretchx );\r\n\tvec2 s = sin( angle*stretchy );\r\n\treturn mat3(\r\n\t\tc.y      ,  0.0, -s.y,\r\n\t\ts.y * s.x,  c.x,  c.y * s.x,\r\n\t\ts.y * c.x, -s.x,  c.y * c.x\r\n\t);\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tvec3 dir = ray_dir( stretchx, RENDERSIZE.xy, _xy.xy);\r\n\tvec3 eye = vec3( 0.0, 0.0, 0.0 );\r\n\tfloat TT = (TIME/4 + syn_BassTime/4) * rate;\r\n\tmat3 rot = rotationXY( vec2(TT * 0.005, TT * 0.0125));\r\n\tdir = rot * dir;\r\n\teye = rot * eye;\r\n    eye.z -=  mod(TT * 4.0, 8.0);\r\n    eye.y = eye.x = 0.0;\r\n\tfloat depth = ray_marching( eye, dir, 1.75, clip_far);\r\n\tif ( depth >= clip_far ) { out_FragColor = vec4(1.0); } \r\n   \telse {\r\n\t\tvec3 pos = eye + dir * depth;\r\n\t\tout_FragColor = vec4( shading( pos*(sin(clamp(syn_HighHits/3,.01,.5)*4*PI)*colorreact), eye ) , 1.0 );\r\n        out_FragColor += depth/clip_far * vanishingpoint;\r\n    }\r\n    out_FragColor = vec4(vec3(tint, 0.1+tint, .20-abs(tint/3.0)) - out_FragColor.zyx, 1.0);\r\n    out_FragColor += vec4(vec3(0.0+brightness, 0., 0.), 1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"CubicMatrixModulatorRedux","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"Mouse X","MAX":1,"MIN":0,"NAME":"mX","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"Mouse Y","MAX":1,"MIN":0,"NAME":"mY","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.670000016689301,"DESCRIPTION":"formuparam","MAX":1,"MIN":0,"NAME":"formuparam","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.119999997317791,"DESCRIPTION":"stepsize","MAX":1,"MIN":0,"NAME":"stepsize","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":9,"DESCRIPTION":"Iterations","MAX":20,"MIN":1,"NAME":"IterationLimit","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":14,"DESCRIPTION":"StepsLimit","MAX":20,"MIN":1,"NAME":"StepsLimit","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":5.71000003814697,"DESCRIPTION":"zoom","MAX":100,"MIN":0,"NAME":"zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.26999998092651,"DESCRIPTION":"tile","MAX":10,"MIN":0,"NAME":"tile","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00999999977648258,"DESCRIPTION":"speed","MAX":1,"MIN":0,"NAME":"speed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"XM","MAX":1,"MIN":-1,"NAME":"XM","PARAMS":0.273999989032745,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"YM","MAX":1,"MIN":-1,"NAME":"YM","PARAMS":0.272000014781952,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"ZM","MAX":1,"MIN":-1,"NAME":"ZM","PARAMS":0.0130000002682209,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.0799999982118607,"DESCRIPTION":"brightness","MAX":1,"MIN":0,"NAME":"brightness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.409999996423721,"DESCRIPTION":"darkmatter","MAX":1,"MIN":0,"NAME":"darkmatter","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.639999985694885,"DESCRIPTION":"distfading","MAX":1,"MIN":0,"NAME":"distfading","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.850000023841858,"DESCRIPTION":"saturation","MAX":1,"MIN":0,"NAME":"saturation","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":5,"MIN":1,"NAME":"sBassX","PARAMS":0.28600001335144,"TYPE":"slider smooth","UI_GROUP":"default"},{"DEFAULT":1,"DESCRIPTION":"","MAX":5,"MIN":1,"NAME":"sBassY","PARAMS":0.24600000679493,"TYPE":"slider smooth","UI_GROUP":"default"}],"CREDIT":"by you","DESCRIPTION":"Your shader description","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\deep_field_(star_nest).synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Deep Field (Star Nest)","IMAGES":null,"IMAGE_PATH":"deep_field_(star_nest).synScene\\deep_field_(star_nest).png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"Mouse X\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mX\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"Mouse Y\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mY\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.67,\n\t\t\t\"DESCRIPTION\" : \"formuparam\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"formuparam\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.12,\n\t\t\t\"DESCRIPTION\" : \"stepsize\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"stepsize\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 9,\n\t\t\t\"DESCRIPTION\" : \"Iterations\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"IterationLimit\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 14,\n\t\t\t\"DESCRIPTION\" : \"StepsLimit\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"StepsLimit\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 5.71,\n\t\t\t\"DESCRIPTION\" : \"zoom\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.27,\n\t\t\t\"DESCRIPTION\" : \"tile\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"tile\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.01,\n\t\t\t\"DESCRIPTION\" : \"speed\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"speed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"XM\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"XM\",\n\t\t\t\"PARAMS\" : 0.274,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"YM\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"YM\",\n\t\t\t\"PARAMS\" : 0.272,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"ZM\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"ZM\",\n\t\t\t\"PARAMS\" : 0.013,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.08,\n\t\t\t\"DESCRIPTION\" : \"brightness\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"brightness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.41,\n\t\t\t\"DESCRIPTION\" : \"darkmatter\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"darkmatter\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.64,\n\t\t\t\"DESCRIPTION\" : \"distfading\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"distfading\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.85,\n\t\t\t\"DESCRIPTION\" : \"saturation\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"saturation\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"sBassX\",\n\t\t\t\"PARAMS\" : 0.286,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"default\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"sBassY\",\n\t\t\t\"PARAMS\" : 0.246,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"default\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by you\",\n\t\"DESCRIPTION\" : \"Your shader description\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"deep_field_(star_nest).png\",\n\t\"TITLE\" : \"Deep Field (Star Nest)\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\nvec3 iResolution = vec3(RENDERSIZE, 1.);\r\nfloat iGlobalTime = syn_Time/4;\r\nvec2 iMouse = vec2(mX*RENDERSIZE.x, mY*RENDERSIZE.y);\r\n\r\n// Based on: \"Star Nest\" by Pablo RomÃ¡n Andrioli\r\n\r\n// This content is under the MIT License.\r\n\r\n#define iterations 20\r\n#define volsteps 20\r\n\r\n//#define formuparam 0.53\r\n//#define stepsize 0.1\r\n\r\n//#define zoom   5.100\r\n//#define tile   0.850\r\n//#define speed  0.010 \r\n\r\n//#define brightness 0.015\r\n//#define darkmatter 0.300\r\n//#define distfading 0.730\r\n//#define saturation 0.850\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//get coords and direction\r\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec3 dir=vec3(uv*zoom,1.);\r\n\tfloat time=iGlobalTime*speed+.25;\r\n\r\n\t//mouse rotation\r\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\r\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\r\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\r\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\r\n\tdir.xz*=rot1;\r\n\tdir.xy*=rot2;\r\n\tvec3 from=vec3(1.,.5,0.5);\r\n\tfrom+=vec3(time*XM*-5.,time*YM*-5.,time*ZM*-5.);\r\n\tfrom.xz*=rot1;\r\n\tfrom.xy*=rot2;\r\n\t\r\n\t//volumetric rendering\r\n\tfloat s=0.1,fade=1.;\r\n\tvec3 v=vec3(0.);\r\n\tfor (int r=0; r<volsteps; r++) {\r\n\t\t\r\n\t\tif (r > int (StepsLimit)) {break;}\r\n\t\t\r\n\t\tvec3 p=from+s*dir*.5;\r\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\tfloat pa,a=pa=0.;\r\n\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\t\r\n\t\t\tif (i > int (IterationLimit)) {break;}\r\n\t\t\t\r\n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\tpa=length(p);\r\n\t\t}\r\n\t\tfloat dm=max(0.,darkmatter*10.-a*a*.001); //dark matter\r\n\t\ta*=a*a; // add contrast\r\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\r\n\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\tv+=fade;\r\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\tfade*=1.0-distfading; // distance fading\r\n\t\ts+=stepsize;\r\n\t}\r\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\tfragColor = vec4(v*.01,1.);\t\r\n\t\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n    mainImage(out_FragColor, _xy.xy);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Deep Field (Star Nest)","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Fly deeper quickly or go slowly backwards.","MAX":1,"MIN":0,"NAME":"fly_in_out","PARAMS":0.150000005960464,"TYPE":"slider traveler","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Constant rotation, spinning the scene.","MAX":1,"MIN":0,"NAME":"rotating","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Add in beams, and control their brightness with beam glow.","MAX":1,"MIN":0,"NAME":"beams_on","PARAMS":0.100000001490116,"TYPE":"toggle smooth","UI_GROUP":"beams"},{"DEFAULT":0,"DESCRIPTION":"A few thin beams, or many undulating beams.","MAX":1,"MIN":0,"NAME":"many_beams","TYPE":"toggle","UI_GROUP":"beams"},{"DEFAULT":0,"DESCRIPTION":"Controls how brightly the beams glow.","MAX":0.5,"MIN":0,"NAME":"beam_glow","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"beams"},{"DEFAULT":0,"DESCRIPTION":"Rhythmic contractions of the cavern lining...","MAX":1,"MIN":0,"NAME":"undulating","TYPE":"toggle","UI_GROUP":"cavern"},{"DEFAULT":0,"DESCRIPTION":"Send one smooth pulse outward from the camera.","MAX":1,"MIN":0,"NAME":"wave_pulse","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"cavern"},{"DEFAULT":0,"DESCRIPTION":"A light that chases down the corridor in time with the music.","MAX":1,"MIN":0,"NAME":"light_chaser","TYPE":"toggle","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"Flash the lights according to the music, instead of constant lights.","MAX":1,"MIN":0,"NAME":"lights_react","TYPE":"toggle","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"Stuff gets colorful! Definitely experiment with walls texture while this is on.","MAX":1,"MIN":0,"NAME":"colorful","TYPE":"toggle","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"Add spiral bumps to the surface of the corridor.","MAX":1,"MIN":0,"NAME":"walls_texture","TYPE":"slider","UI_GROUP":"lighting"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\deeper.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Deeper","IMAGES":null,"IMAGE_PATH":"deeper.synScene\\deeper.png","JSON_CODE":"{\n  \"CREDIT\": \"Meebs\",\n  \"TITLE\": \"Deeper\",\n  \"IMAGE_PATH\": \"deeper.png\",\n\n  \"CONTROLS\": [\n    {\n      \"NAME\" : \"fly_in_out\",\n      \"TYPE\" : \"slider traveler\",\n      \"PARAMS\": 0.15,\n      \"UI_GROUP\": \"camera\",\n      \"DESCRIPTION\":\"Fly deeper quickly or go slowly backwards.\"\n    },{\n      \"NAME\" : \"rotating\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\":0.0,\n      \"UI_GROUP\": \"camera\",\n      \"DESCRIPTION\":\"Constant rotation, spinning the scene.\"\n    },{\n      \"NAME\" : \"beams_on\",\n      \"TYPE\" : \"toggle smooth\",\n      \"PARAMS\": 0.1,\n      \"DEFAULT\" : 0.0,\n      \"UI_GROUP\": \"beams\",\n      \"DESCRIPTION\":\"Add in beams, and control their brightness with beam glow.\"\n    },{\n      \"NAME\" : \"many_beams\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\" : 0.0,\n      \"UI_GROUP\": \"beams\",\n      \"DESCRIPTION\":\"A few thin beams, or many undulating beams.\"\n    },{\n      \"NAME\" : \"beam_glow\",\n      \"TYPE\" : \"slider smooth\",\n      \"PARAMS\": 0.1,\n      \"DEFAULT\" :0.0,\n      \"MIN\" : 0,\n      \"MAX\" : 0.5,\n      \"UI_GROUP\": \"beams\",\n      \"DESCRIPTION\":\"Controls how brightly the beams glow.\"\n    },{\n      \"NAME\" : \"undulating\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\" : 0.0,\n      \"UI_GROUP\": \"cavern\",\n      \"DESCRIPTION\":\"Rhythmic contractions of the cavern lining...\"\n    },{\n      \"NAME\" : \"wave_pulse\",\n      \"TYPE\" : \"bang smooth\",\n      \"PARAMS\": 0.01,\n      \"DEFAULT\" :0.0,\n      \"MIN\" : 0,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"cavern\",\n      \"DESCRIPTION\":\"Send one smooth pulse outward from the camera.\"\n    },{\n      \"NAME\" : \"light_chaser\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\" :0.0,\n      \"MIN\" : 0,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"lighting\",\n      \"DESCRIPTION\":\"A light that chases down the corridor in time with the music.\"\n    },{\n      \"NAME\" : \"lights_react\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\" :0.0,\n      \"MIN\" : 0,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"lighting\",\n      \"DESCRIPTION\":\"Flash the lights according to the music, instead of constant lights.\"\n    },{\n      \"NAME\" : \"colorful\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\":0.0,\n      \"UI_GROUP\": \"lighting\",\n      \"DESCRIPTION\":\"Stuff gets colorful! Definitely experiment with walls texture while this is on.\"\n    },{\n      \"NAME\" : \"walls_texture\",\n      \"TYPE\" : \"slider\",\n      \"DEFAULT\":0.0,\n      \"UI_GROUP\": \"lighting\",\n      \"DESCRIPTION\":\"Add spiral bumps to the surface of the corridor.\"\n    }\n  ],\n  \"PASSES\": [\n    {\"TARGET\":\"backbuffer\", \"WIDTH\":1024, \"HEIGHT\":576}\n  ]\n}","PASSES":[{"FLOAT":true,"HEIGHT":576,"TARGET":"backbuffer","WIDTH":1024}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nfunction CameraPos () {\n  this.x = 0.0;\n  this.y = 0.0;\n  this.z = 0.0;\n}\n\nfunction CameraLook () {\n  this.x = 0.0;\n  this.y = 0.0;\n  this.z = 0.0;\n}\n\n\nvar bpmcount = new BPMCounter();\nvar cPos = new CameraPos();\nvar cLook = new CameraLook();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar bpmTime = 0;\nvar bassT = 0.0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM/4.0;\n  bpmcount.updateTime(bpm, dt);\n\n  uniforms.script_time = bpmcount.time;\n\n\n  // if (bpmcount.didIncrement == 1.0){\n  //   tAtLast0 = bpmTime;\n  // }\n  // bpmTime = tAtLast0;\n  // bpmTime += (1. - Math.exp(-bpmcount.timeWithinBeat*3.))*inputs.amount_to_step;\n  // uniforms.script_time = bpmTime;\n\n  bassT = bassT + Math.pow(inputs.syn_BassLevel*0.5,2.0);\n  uniforms.script_bass_time = bassT;\n\n  // cPos.x = cPos.x + (-0.5+Math.random(inputs.syn_BeatTime)*inputs.syn_OnBeat);\n  uniforms.camera_pos = cPos;\n  uniforms.camera_look = cLook;\n\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"#define MAX_ITER 70\n\nfloat cameraZ = fly_in_out + script_bass_time*1.0;\n\nfloat lengthRep = 1500;\n\nvec3 palette( in float t)\n{\nvec3 a = vec3(0.600, 0.500, 0.500);\nvec3 b = vec3(1.000, 0.500, 0.500);\nvec3 c = vec3(0.500, 0.690, 0.750);\nvec3 d = vec3(0.500, 0.500, 0.500);\n  \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 filter_() {\n  vec2 delta = 1. / RENDERSIZE;\n  \n  vec3 val = texture(backbuffer, _uv).xyz;\n\n\n  vec3 l = texture(backbuffer, _uv + vec2(0., delta.y)).xyz;\n  vec3 r = texture(backbuffer, _uv - vec2(0., delta.y)).xyz;\n  vec3 u = texture(backbuffer, _uv + vec2(delta.x, 0.)).xyz;\n  vec3 d = texture(backbuffer, _uv - vec2(delta.x, 0.)).xyz;\n\n  vec3 n = vec3(_rand(_uvc+fract(TIME))) - 0.5;\n  \n  vec3 bloom = max(val, max(max(l, r), max( u, d)));\n  bloom = bloom  + l + r + u + d;\n  bloom /= 5.; // orlando;\n  return bloom + n/9.;\n\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y+s*p.z, -s*p.y+c*p.z);\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    \n    return q;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat hex(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z-h.y, max((q.x*0.866025+q.y*0.5),q.y) - h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nvec2 polar(vec2 c) {\n  return vec2(atan(c.y, c.x), length(c));\n}\nvec2 cart(vec2 p) {\n  return p.y * vec2(cos(p.x), sin(p.x));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}  \n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 DE(vec3 pos) {\n  float dist = 10000.0;\n  float obj = 0.0;\n\n  vec3 staticPos = vec3(pos.xy, pos.z-cameraZ);\n\n  pos.y -= 10.0*_pulse(staticPos.z*0.1, (1.0-wave_pulse)*10.0, 4.0)*sqrt(wave_pulse);\n\n  //Corridor\n  vec3 corridorPos = pos;\n  corridorPos.xy = _rotate(corridorPos.xy, corridorPos.z*2*PI/30.0);\n  float corridor = 15.0 - abs(corridorPos.y);\n\n  if (undulating > 0.5){\n    corridor -= (0.5+0.4*sin(pos.z*0.05+script_time*PI))*10.0;\n  }\n\n  dist = min(corridor, dist);\n\n  // //COLUMNS!\n  vec3 columnPos = pos;\n\n  float columns = 1000.0;\n  vec3 columnPos2 = pos;\n\n  if (many_beams>0.5){\n    columnPos = rotateZ(pos, 0.1);\n    columnPos.y += cubicPulse(30.0+20.0*sin(syn_BassTime*0.25), 10.0, staticPos.z)*4.0*syn_BassLevel;\n    columnPos = opRep(columnPos, vec3(2.5-syn_HighPresence*1.0,10.0,20.0));\n    columnPos = rotateZ(columnPos, columnPos.z*0.1);\n    columns = sdTriPrism(columnPos, vec2(0.1+0.4*syn_HighHits, 100.0));\n  } else {\n    columnPos2 = rotateZ(columnPos2, 0.1);\n    columnPos2 = opRep(columnPos2, vec3(5.0,20.0,20.0));\n    columns = sdTriPrism(columnPos2+vec3(0.0,0.0,sin(pos.z*0.1)*10.0), vec2(0.0, 100.0));\n    // columns = mix(1000, columns, columns_on);\n\n  }\n    // dist = smin(dist, columns, 5.0);\n  // } else {\n  //   columns = mix(1000, columns, columns_on);\n    // columns = mix(1.0, columns, columns_on);\n    dist = mix(smin(dist, columns, 1.5+syn_Presence*3.5), dist, 1.0-beams_on);\n\n\n\n  // }\n\n  ////Sphere\n  // vec3 sphereLightPos = staticPos + vec3(sin(TIME),cos(TIME),-5.0);\n\n  // float sphereLight = sdSphere(sphereLightPos, 0.5+syn_HighHits);\n  // dist = smin(dist, sphereLight, 3.0);\n\n\n  //CUTS!\n  //spherePos = opRep(spherePos, vec3(1.0,1.0,1.0));\n  //spherePos += vec3(sin(TIME), cos(TIME), 0.0);\n  // float sphere = sdTriPrism(spherePos, vec2(1.0));\n  // dist = min(corridor, sphere);\n\n  obj = clamp(1.0-columns,0.0,1.0);\n  \n  float glow = 1/columns;\n\n  return vec3(dist, obj, glow);\n}\n\nvec4 bumpMapParams1 = vec4(2.0,7.0,0.01,-0.01);\nvec4 bumpMapParams2 = vec4(2.0,3.0,-0.01,0.01);\n\n// float bumpmap(vec2 uv)\n// {\n//     float b1 = bumpMapParams1.x*(1.0 - texture(iChannel0, (uv + iGlobalTime*bumpMapParams1.zw)*bumpMapParams1.y).x);\n//     float b2 = bumpMapParams2.x*(1.0-texture(iChannel0, (uv + iGlobalTime*bumpMapParams2.zw)*bumpMapParams2.x).x);\n//     return b1+b2;\n// }\n\n\nfloat bumpmap(vec2 uv)\n{\n  return sin(uv.x*100.0+uv.y*500.0);\n    // float b1 = bumpMapParams1.x*(1.0 - texture(bump_texture, (uv)*bumpMapParams1.y - vec2(syn_HighTime*0.5,0.0)).x);\n    // float b2 = bumpMapParams2.x*(1.0 - texture(bump_texture, (uv)*bumpMapParams2.x - vec2(syn_HighTime*0.5,0.0)).x);\n    // return b1+b2;\n}\n\nvec3 doBumpMap(vec2 uv, vec3 nor, float bumpfactor)\n{\n   \n    const float eps = 0.001;\n    float ref = bumpmap(uv); \n    \n    vec3 grad = vec3(bumpmap(vec2(uv.x-eps, uv.y))-ref, 0.0, bumpmap(vec2(uv.x, uv.y-eps))-ref); \n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\nvec3 gradient(vec3 p, float t) {\n      vec2 e = vec2(0., t);\n\n      return normalize( \n        vec3(\n          DE(p+e.yxx).x - DE(p-e.yxx).x,\n          DE(p+e.xyx).x - DE(p-e.xyx).x,\n          DE(p+e.xxy).x - DE(p-e.xxy).x\n        )\n      );\n    }\n\nvec3 raycast() {\n  \n  vec3 camera = vec3( 0., 0., cameraZ);\n  camera.z = mod(camera.z, lengthRep);\n\n  vec2 screenPos = -1.0 + 2.0 * _uv;\n  screenPos.x *= RENDERSIZE.x / RENDERSIZE.y;\n  vec2 n = vec2(_rand(_uvc+fract(TIME))) - 0.5;\n  \n  vec3 ray = normalize(vec3( screenPos, 1.0));\n  // ray = rotateX(ray, TIME);\n  ray = rotateX(ray, sin(script_time*PI*0.25)*0.2);\n  ray = rotateY(ray, sin(script_time*PI*0.5)*0.2);\n  ray = rotateZ(ray, syn_BassTime*0.1*rotating);\n\n  // raycasting parameter \n  float t  = 0.;\n  vec3 pos;\n  int iter = 0;\n  bool hit = false;\n  vec3 dist;\n  float glow = 0.0;\n  float minDist = pow(0.6+0.0*5.0,10.0);\n\n  // ray stepping \n  for(int i = 0; i < MAX_ITER; i++) {\n    pos = camera + ray * t;\n    dist = DE(pos);\n    glow += dist.z;\n\n    if (abs(dist.x) < minDist) {\n      hit = true;\n      break;\n    }\n              \n    t += dist.x * 0.5;//step_size\n    iter ++;\n\n  }\n\n  float obj = dist.y;\n  vec3 norm = gradient(pos, 0.001);\n  vec2 uv = _rotate(pos.xy, pos.z*2*PI/30.0);\n\n  vec3 bump = doBumpMap(vec2(uv.x*0.01, pos.z*0.01), norm, 3.0);\n  bump = mix(bump, vec3(0.0), clamp(obj,0.0,1.0))*sin(TIME*0.25);\n  bump = mix(vec3(0.0), bump, walls_texture);\n\n\n\n  vec3 topLightPos = -ray + vec3(0.0,-1.0,4.0);\n  float topLight = clamp(dot(normalize(norm+bump), topLightPos), 0.0, 1.0);\n\n  vec3 botLightPos = -ray + vec3(sin(TIME),cos(TIME),2.0+sin(TIME));\n  float botLight = clamp(dot(normalize(norm+bump), botLightPos), 0.0, 1.0);\n\n  float generalLight = clamp(dot(normalize(norm+bump), -ray), 0.0, 1.0);\n\n    // float generalLight = clamp(dot(normalize(norm+bump), -ray), 0.0, 1.0);\n\n\n  vec3 lp = camera + vec3(0.0,0.0,0.5+0.5*sin(script_time*PI*0.25)*200.0); // Light position - Back from the screen.\n  // vec3 lp = camera; // Light position - Back from the screen.\n\n  vec3 ld = lp - pos;\n  float lDist = max(length(ld), 0.001);\n  ld /= lDist;\n\n  float spec = pow(max(dot(reflect(-ld, normalize(norm+bump)), -ray), 0.), 24.); \n\n  float ambientOcclusion = 1. -  float(iter) / float(MAX_ITER);\n  \n  vec3 color = vec3(0.);\n\n  vec3 lightCol = vec3(0.1,0.0,0.0);\n  // lightCol = cross(lightCol, pos);\n  // lightCol = vec3(1.0);\n\n  if (lights_react > 0.5){\n    topLight *= syn_HighHits;\n    botLight *= syn_BassLevel;\n  }\n\n  vec3 columnsCol = vec3(0.0);\n  vec3 cavernCol = vec3(0.0);\n\n  vec3 surfaceCol = vec3(1.0);\n\n  if (colorful>0.5){\n    surfaceCol = _palette(dot(normalize(norm+bump), -ray), vec3(1.020, 0.520, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.240, 0.750), vec3(0.480, 0.090, 0.870));\n  }\n\n  if (hit){\n    columnsCol += lightCol*botLight;\n    cavernCol += spec*vec3(1.0);\n\n    color = mix(vec3(0.0), columnsCol, clamp(obj,0.0,1.0));\n    color = mix(color, cavernCol, clamp(obj, 1.0, 2.0)-1.0);\n    if (light_chaser>0.5){\n      color += generalLight*vec3(1.0)*_pulse(sin((pos.z-cameraZ)*0.01), fract(script_time/1.0), 0.1);\n    }\n    color += botLight*surfaceCol;\n\n    color += spec*surfaceCol;\n    color *= pow(ambientOcclusion,0.1);\n  }\n\n  float fogAmount = 1.0 - exp( -t*0.005);\n  vec3  fogColor  = vec3(0.3+syn_BassPresence*0.6,0.6,0.7);\n  color = mix(color, fogColor, fogAmount*syn_Presence);\n\n  color += clamp(pow(glow*beam_glow,0.5)*0.1,0.0,1.0);\n\n  color = pow(color, vec3(1.5));\n\n  return color;\n\n\n}\n\nvec4 renderMain() {\n  vec4 out_FragColor = vec4(0.0);\n\n  if (PASSINDEX == 0) {\n    out_FragColor = vec4(raycast(), 1.0);\n  } else if (PASSINDEX == 1) {\n    // out_FragColor = texture(backbuffer, _uv);\n    out_FragColor = vec4(filter_(), 1.0);\n\n    vec4 bCol = vec4(0.4, 0.7, 0.9, 1.0);\n    vec4 oCol = vec4(0.9, 0.8, 0.6, 1.0);\n\n    out_FragColor = mix(out_FragColor, pow(out_FragColor,vec4(2.0))*bCol, clamp(abs(_uvc.y)-0.3, 0.0, 1.0));\n    out_FragColor = mix(out_FragColor, pow(out_FragColor,vec4(2.0))*oCol, clamp(0.7-abs(_uvc.y-0.3)*2.0, 0.0, 1.0));\n\n  }\n\n  return out_FragColor;\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Deeper","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.100000001490116,"DESCRIPTION":"Speed","MAX":1,"MIN":-1,"NAME":"Speed","PARAMS":0.184000000357628,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"rotation one","MAX":1,"MIN":0,"NAME":"GRAT","PARAMS":0.247999995946884,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"Ray tracing amount","MAX":2,"MIN":-0.00100000004749745,"NAME":"W","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"Shine","MAX":0,"MIN":-1,"NAME":"Ty","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"Rotation of Torus","MAX":1,"MIN":0,"NAME":"Rot","PARAMS":0.160999998450279,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":2,"MIN":-1,"NAME":"Rat","PARAMS":0.158000007271767,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"Amount of Toruses","MAX":1.29999995231628,"MIN":0.5,"NAME":"Bat","PARAMS":0.197999998927116,"TYPE":"slider smooth","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\diamondvision.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"DiamondVision","IMAGES":null,"IMAGE_PATH":"diamondvision.synScene\\diamondvision.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.1,\n\t\t\t\"DESCRIPTION\" : \"Speed\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"Speed\",\n\t\t\t\"PARAMS\" : 0.184,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"rotation one\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"GRAT\",\n\t\t\t\"PARAMS\" : 0.248,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Ray tracing amount\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -0.001,\n\t\t\t\"NAME\" : \"W\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Shine\",\n\t\t\t\"MAX\" : 0,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"Ty\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Rotation of Torus\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"Rot\",\n\t\t\t\"PARAMS\" : 0.161,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"Rat\",\n\t\t\t\"PARAMS\" : 0.158,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Amount of Toruses\",\n\t\t\t\"MAX\" : 1.3,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"Bat\",\n\t\t\t\"PARAMS\" : 0.198,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"diamondvision.png\",\n\t\"TITLE\" : \"DiamondVision\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n// DiamondVision  by mojovideotech\r\n//\r\n// based on :\r\n// glslsandbox.com\\/e#46411.0\r\n//\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n////////////////////////////////////////////////////////////////////\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n#define    \tc30    \t0.866025     \t// cos 30\r\n#define    \ttwPI   \t6.2831853       // two PI, 2*PI\r\n#define\t\tPIphi\t2.3999632\t\t// PI*phi\r\n#define \tsqPI \t1.7724538\t\t// square root of PI\r\n#define \tphi   \t1.6180339*GRAT\t// golden ratio\r\n#define \tcucuphi\t1.0549232\t\t// cube root of cube root of phi\r\n#define\t\tePI\t\t0.8652559\t\t// e/PI\r\n#define \ttime2\tTIME/20. + syn_BassTime/4*Speed+55.0\r\n#define     R       1.0\r\n\r\nvec2 rotate(in vec2 r, in float o) { return vec2(cos(o)*r.x*Rot + sin(o)*r.y, -sin(o)*r.x + cos(o)*r.y*Rat)*Bat; }\r\n\r\nfloat torus(in vec3 pos, in vec2 tor) { \r\n\tvec2 qt = abs(vec2(max(abs(pos.x), abs(pos.z))-tor.x, pos.y));\r\n\treturn max(qt.x, qt.y)-tor.y;\r\n}\r\n\r\nfloat trap(in vec3 tp) {\r\n\treturn abs(min(torus(tp, vec2(ePI, 0.125)), max(abs(tp.z)-0.125, abs(tp.x)-0.125)))-0.005;\r\n}\r\n\r\nfloat map(in vec3 pm) {\r\n\tfloat c = dot(abs((pm.yz)),vec2(0.5))-0.05;\r\n\tvec3 m = abs(1.0-mod(pm,2.0));\r\n\tm.yz = rotate(m.yz, sqrt(time2));\r\n\tfloat e = 9999.999, f = 1.0 * W;\r\n\tfor (float i = 0.0; i < 4.0; i++) {\r\n\t\tm.xz = rotate(m.xz, radians(i*0.333+time2));\r\n\t\tm.zy = rotate(m.yz, radians((i+i)*0.667+time2*phi));\r\n\t\tm = abs(1.0-mod(m+i/3.0,2.0));\r\n\t\tm *=abs(sqrt(m)*sqPI);\r\n\t\tf *= 0.5;\r\n\t\te = min(e, trap(m) * f);\r\n\t}\r\n\treturn max(e, -c);\r\n}\r\n\r\nvec3 hsv(in float h, in float s, in float v) {\r\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3.0, 2.0, 1.0) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\r\n}\r\n\r\nvec3 intersect(in vec3 rayOrigin, in vec3 rayDir) {\r\n\tfloat d = 1.0, it = 0.0;\r\n\tvec3 p = rayOrigin, col = vec3(0.0);\r\n\tfloat md = phi+sin(time2*0.5)*0.25;\r\n\tfor (int i = 0; i < 50; i++) {\t\t\r\n\t\tif (d < 0.000999) continue;\r\n\t\td = map(p);\r\n\t\tp += d*rayDir; \r\n\t\tmd = min(md, d);\r\n\t\tit++;\r\n\t}\r\n\tif (d < 0.001) {\r\n\t\tfloat x = (it/49.0);\r\n\t\tfloat y = (d-0.01)/0.01/(49.0);\r\n\t\tfloat z = (0.01-d)/0.01/49.0;\r\n\t\tfloat q = 1.0-x-y*2.+z;\r\n\t\tcol = hsv(q*0.2+0.5*R, 1.0-q*ePI, q+Ty);\r\n\t} \r\n\t\tcol += hsv(d, 1.0, 1.0)*md*28.0;\r\n\treturn col;\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tvec2 ps = -1.0 + 2.0 * _xy.xy / RENDERSIZE.xy;\r\n\tps.x *= RENDERSIZE.x / RENDERSIZE.y;\r\n\tvec3 up = vec3(0, -1, 0);\r\n\tvec3 cd = vec3(1, 0, 0);\r\n\tvec3 co = vec3(time2*0.1, 0, 0);\r\n\tvec3 uw = normalize(cross(up, co));\r\n\tvec3 vw = normalize(cross(cd, uw));\r\n\tvec3 rd = normalize(uw * ps.x + vw * ps.y + cd*(1.0-length(ps)*phi));\r\n\tout_FragColor = vec4(vec3(intersect(co, rd)),1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n ","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"DiamondVision","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":3.14590001106262,"MIN":-3.14590001106262,"NAME":"rX","PARAMS":0.155000001192093,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":3.14590001106262,"MIN":-3.14590001106262,"NAME":"rY","PARAMS":0.144999995827675,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":3.14590001106262,"MIN":-3.14590001106262,"NAME":"rZ","PARAMS":0.142000004649162,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":2.25,"DESCRIPTION":"","MAX":5,"MIN":1,"NAME":"zoom","PARAMS":0.125,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[-1,-1],"NAME":"blend","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":4,"DESCRIPTION":"","MAX":6,"MIN":1,"NAME":"subdivisions","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":12.5,"DESCRIPTION":"","MAX":30,"MIN":0,"NAME":"light","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.5,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.75,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"cycle","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.25,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"roto","PARAMS":0.223000004887581,"TYPE":"slider smooth","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\dimensionmorphingtopography.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"DimensionMorphingTopography","IMAGES":null,"IMAGE_PATH":"dimensionmorphingtopography.synScene\\dimensionmorphingtopography.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3.1459,\n\t\t\t\"MIN\" : -3.1459,\n\t\t\t\"NAME\" : \"rX\",\n\t\t\t\"PARAMS\" : 0.155,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3.1459,\n\t\t\t\"MIN\" : -3.1459,\n\t\t\t\"NAME\" : \"rY\",\n\t\t\t\"PARAMS\" : 0.145,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3.1459,\n\t\t\t\"MIN\" : -3.1459,\n\t\t\t\"NAME\" : \"rZ\",\n\t\t\t\"PARAMS\" : 0.142,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"PARAMS\" : 0.125,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t],\n\t\t\t\"NAME\" : \"blend\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 4,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 6,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"subdivisions\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 12.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 30,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"light\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.75,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"cycle\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"roto\",\n\t\t\t\"PARAMS\" : 0.223,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"dimensionmorphingtopography.png\",\n\t\"TITLE\" : \"DimensionMorphingTopography\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n\r\n////////////////////////////////////////////////////////////\r\n// DimensionMorphingTopography  by mojovideotech\r\n//\r\n// based on :\r\n// shadertoy.com/\\lsBBD1  by bal-khan\r\n//\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n////////////////////////////////////////////////////////////\r\n\r\n\r\nvec3\tlux;\r\nfloat tc = syn_BassTime*cycle;\r\nfloat distanceToL,ii,m;\r\n\r\nfloat sdTorus( vec3 p, vec2 tx ) {\r\n\tvec2 q = vec2(length(p.zy)-tx.x,p.x);\r\n\treturn length(q)-tx.y;\r\n}\r\n\r\nfloat sdHexPrism( vec3 p, vec2 hx ) {\r\n    vec3 q = abs(p);\r\n    return max(q.z-hx.y,max((q.x*0.866025+q.y*0.5),q.y)-hx.x);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b ) { return length(max(abs(p)-b,0.0)); }\r\n\r\nvoid rotate(inout vec2 v, float angle) { v = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y); }\r\n\r\nfloat\tscene(vec3 p) {\r\n    distanceToL = 1e3;\r\n    mat2 ma;\r\n    float r2 = 1e5, k = 1.0;\r\n    ii=0.0;\r\n    m = r2;\r\n    float aa = TIME*rate*0.025;\r\n    p.z+=6.0;\r\n    float tr = TIME*roto;\r\n    rotate(p.zx, rX+cos(tr));\r\n    rotate(p.zy, rY+sin(tr));\r\n    rotate(p.xy, rZ-sin(tr)+tr);\r\n    for(float\ti = -1.0; i < 24.0; ++i) {\r\n        ++ii;\r\n        if (i > floor(subdivisions*3.0)) { break; }\r\n\t\tr2= min(r2, sdHexPrism(p, vec2(0.3,0.3)) );\r\n\t\tdistanceToL = sdHexPrism(p, vec2(0.3, 0.0))*60.0;\r\n\t\taa=aa+0.5/(i+2.0);\r\n        if (mod(i, 3.0) == 0.0) {\r\n            ma = mat2(cos(aa+1.0*ii*0.25),sin(aa+1.0*ii*0.25), -sin(aa+1.0*ii*0.25), cos(aa+1.0*ii*0.25) );\r\n\t        p.xy*=ma;\r\n\t        p.xy = abs(p.xy)-0.125;\r\n\t\t\tp.z -= 0.2;\r\n        }\r\n        else if (mod(i, 3.0) == 1.0) {\r\n            ma = mat2(cos(aa*3.0+1.04+1.0*ii*0.1),sin(aa*3.0+1.04+1.0*ii*0.1), -sin(aa*3.0+1.04+1.0*ii*0.1), cos(aa*3.0+1.04+1.0*ii*0.1) );\r\n\t        p.yz*=ma;\r\n\t        p.zy = abs(p.zy)-0.125;\r\n            p.x -= 0.2;\r\n        }\r\n        else if (mod(i, 3.0) == 2.0) {\r\n            ma = mat2(cos(aa*2.0+2.08+1.0*ii*0.5),sin(aa*2.0+2.08+1.0*ii*0.5), -sin(aa*2.0+2.08+1.0*ii*0.5), cos(aa*2.0+2.08+1.0*ii*0.5) );\r\n            p.zx*=ma;\r\n\t        p.xz = abs(p.xz)-0.125;\r\n\t       \tp.y -= 0.2;\r\n        }\r\n\tm = min(m, log(sdBox(p,vec3(0.0612510))/(k*k) ) );\r\n    k *= 1.125;\r\n    }\r\n    return r2;\r\n}\r\n\r\nvec3 evaluateLight(in vec3 pos) {\r\n    vec3 lightCol = vec3(blend.x,length(blend),blend.y)+sin(tc);\r\n    return vec3(lightCol * 1.0/(distanceToL*distanceToL)/(31.0-light*(sin(syn_BassTime*PI)+.5)))*mix(lightCol+pos,lightCol-pos,sin(tc));\r\n}\r\n\r\nvec2\tmarch(vec3 pos, vec3 dir) {\r\n    vec3 p ;\r\n    vec2 s , dist ;\r\n    for (int i = 0; i < 30; ++i) {\r\n    \tp = pos + dir * dist.y;\r\n        dist.x = scene(p);\r\n        dist.y += dist.x;\r\n        lux += evaluateLight(p);\r\n        if (dist.x < 0.00125 || dist.y > 20.0) { break; }\r\n        s.x++;\r\n    }\r\n    s.y = dist.y;\r\n    return (s);\r\n}\r\n\r\nvec3\tcamera(vec2 uv) {\r\n    float   fov = zoom/floor(subdivisions);\r\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\r\n\tvec3    right = vec3(1.0, 0.0, 0.0);\r\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\r\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n    vec4 o = vec4(0.0,0.0,0.0,1.0);\r\n    vec2 uv  = vec2(_xy.xy - RENDERSIZE.xy/2.0) / RENDERSIZE.y;\r\n\tvec3 dir = camera(uv);\r\n    vec3 pos = vec3(0.0, 0.0, 0.0);\r\n    vec2 inter = (march(pos, dir));\r\n    if (inter.y < 20.0) {\r\n    \to.xyz += vec3( abs(sin(tc*1.0+ii*0.1+m+1.04)-blend.x), abs(sin(tc*1.0+ii*0.1+m+2.09+blend.x)), abs(sin(tc*1.0+ii*0.1+m+3.14+blend.y)))*(1.0-inter.x*0.05);\r\n   \t\to.xyz += lux;\r\n    }\r\n    out_FragColor = vec4(o);\r\n\r\nreturn out_FragColor; \r\n } \r\n\r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"DimensionMorphingTopography","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.699999988079071,"DESCRIPTION":"The most important slider. 50% is zero aberration. 100% is full, 0% is negative full. Be careful very far from 0, your FPS may drop.","MAX":1.20000004768372,"MIN":-1.20000004768372,"NAME":"aberration_amount","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"Media"},{"DEFAULT":0,"DESCRIPTION":"If aberration_amount isn't set to zero, this will switch between negative and positive aberration.","MAX":1,"MIN":0,"NAME":"switch_direction","PARAMS":0.0500000007450581,"TYPE":"toggle smooth","UI_GROUP":"Media"},{"DEFAULT":1,"DESCRIPTION":"Generally, just keep one of these four regime toggles selected at a time.","MAX":1,"MIN":0,"NAME":"clouds","TYPE":"toggle","UI_GROUP":"regimes"},{"DEFAULT":0,"DESCRIPTION":"Generally, just keep one of these four regime toggles selected at a time.","MAX":1,"MIN":0,"NAME":"snakes","TYPE":"toggle","UI_GROUP":"regimes"},{"DEFAULT":1,"DESCRIPTION":"Generally, just keep one of these four regime toggles selected at a time.","MAX":0,"MIN":1,"NAME":"backwards_ripples","TYPE":"toggle","UI_GROUP":"regimes"},{"DEFAULT":0.990000009536743,"DESCRIPTION":"Generally, just keep one of these four regime toggles selected at a time.","MAX":1,"MIN":0.990000009536743,"NAME":"smooth_glass","TYPE":"toggle","UI_GROUP":"regimes"},{"DEFAULT":0,"DESCRIPTION":"If you get lost, go back to 'clouds' and click this button to restart the simulation.","MAX":1,"MIN":0,"NAME":"reset_sim","TYPE":"bang","UI_GROUP":"regimes"},{"DEFAULT":0,"DESCRIPTION":"Modifies the flow of the scene so that every time a drum hits, it will bounce backward.","MAX":1,"MIN":0,"NAME":"drum_flow","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0,"DESCRIPTION":"With media selected, this will use your media as a flow source on audio hits.","MAX":1,"MIN":0,"NAME":"media_hits","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0,"DESCRIPTION":"Set this to automatically have audio-reactive extra distortion, or use the slider to manually control.","MAX":1,"MIN":0,"NAME":"auto_distortion","TYPE":"toggle","UI_GROUP":"extra_distortion"},{"DEFAULT":0,"DESCRIPTION":"Add an extra level of distortion to the scene, or just use the auto toggle to have the distortion on drum hits.","MAX":1,"MIN":0,"NAME":"distortion","TYPE":"slider","UI_GROUP":"extra_distortion"},{"DEFAULT":[0,0],"DESCRIPTION":"XY Position of the brush.","MAX":[1,1],"MIN":[0,0],"NAME":"xyPaint1","PARAMS":0.100000001490116,"TYPE":"xy smooth","UI_GROUP":"brush1"},{"DEFAULT":0,"DESCRIPTION":"When the simulation is looking a little dead, paint some new flow into it by toggling this brush on.","MAX":1,"MIN":0,"NAME":"paint1_on","TYPE":"toggle","UI_GROUP":"brush1"},{"DEFAULT":0,"DESCRIPTION":"A different, smoother style of painting that will leave streaks instead of forming ripples.","MAX":1,"MIN":0,"NAME":"paint2_on","TYPE":"toggle","UI_GROUP":"brush2"},{"DEFAULT":[0,0],"DESCRIPTION":"XY Position of the brush.","MAX":[1,1],"MIN":[-1,-1],"NAME":"xyPaint2","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"brush2"}],"CREDIT":"cornusammonis","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\dispersion.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Dispersion","IMAGES":null,"IMAGE_PATH":"dispersion.synScene\\dispersion.png","JSON_CODE":"{\n  \"TITLE\": \"Dispersion\",\n  \"CREDIT\": \"cornusammonis\",\n  \"IMAGE_PATH\": \"dispersion.png\",\n  \"HEIGHT\":720,\n  \"WIDTH\":1280,\n  \"PASSES\": [{\n    \"TARGET\": \"BuffA\",\n    \"WIDTH\": 1024,\n    \"HEIGHT\": 576,\n    \"FLOAT\": true\n  },{\n    \"TARGET\": \"BuffB\",\n    \"WIDTH\": 1024,\n    \"HEIGHT\": 576,\n    \"FLOAT\": true\n  }\n  ],\n  \"CONTROLS\": [{\n         \"DEFAULT\" : 0.00,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.2,\n         \"MIN\" : -1.2,\n         \"NAME\" : \"aberration_amount\",\n         \"TYPE\" : \"slider smooth\",\n         \"DEFAULT\":0.7,\n         \"PARAMS\":0.2,\n         \"DESCRIPTION\":\"The most important slider. 50% is zero aberration. 100% is full, 0% is negative full. Be careful very far from 0, your FPS may drop.\",\n         \"UI_GROUP\" : \"Media\"\n      },{\n         \"DEFAULT\" : 0.00,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"switch_direction\",\n         \"TYPE\" : \"toggle smooth\",\n         \"DESCRIPTION\":\"If aberration_amount isn't set to zero, this will switch between negative and positive aberration.\",\n         \"DEFAULT\":0.0,\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"Media\"\n      },{\n    \"NAME\": \"clouds\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\":1.0,\n    \"DESCRIPTION\":\"Generally, just keep one of these four regime toggles selected at a time.\",\n    \"UI_GROUP\":\"regimes\"\n  },{\n    \"NAME\": \"snakes\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\":0.0,\n    \"DESCRIPTION\":\"Generally, just keep one of these four regime toggles selected at a time.\",\n    \"UI_GROUP\":\"regimes\"\n  },\n  {\"NAME\": \"backwards_ripples\", \"DEFAULT\": 1.0, \"MAX\":0.0,\"MIN\":1.0, \"UI_GROUP\":\"regimes\", \"TYPE\":\"toggle\",  \n     \"DESCRIPTION\":\"Generally, just keep one of these four regime toggles selected at a time.\"},  \n  {\"NAME\": \"smooth_glass\", \"DEFAULT\": 0.99, \"MIN\":0.99, \"MAX\":1.0, \"UI_GROUP\":\"regimes\", \"TYPE\":\"toggle\",   \n     \"DESCRIPTION\":\"Generally, just keep one of these four regime toggles selected at a time.\"}, \n  {\n    \"NAME\": \"reset_sim\",\n    \"TYPE\":\"bang\",\n    \"DESCRIPTION\":\"If you get lost, go back to 'clouds' and click this button to restart the simulation.\", \n    \"UI_GROUP\":\"regimes\"\n  },\n  {\"NAME\": \"drum_flow\", \"DEFAULT\": 0.0, \"MAX\":1.0, \"MIN\":0.0, \"UI_GROUP\":\"reactivity\", \"TYPE\":\"toggle\",\n      \"DESCRIPTION\":\"Modifies the flow of the scene so that every time a drum hits, it will bounce backward.\"},\n  {\n    \"NAME\": \"media_hits\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\":0.0,\n    \"UI_GROUP\":\"reactivity\",\n    \"DESCRIPTION\":\"With media selected, this will use your media as a flow source on audio hits.\"\n  },{\n    \"NAME\": \"auto_distortion\",\n    \"TYPE\": \"toggle\",\n    \"MIN\":0.0,\n    \"DEFAULT\":0.0,\n    \"DESCRIPTION\":\"Set this to automatically have audio-reactive extra distortion, or use the slider to manually control.\",\n    \"UI_GROUP\":\"extra_distortion\"\n  },{\n    \"NAME\": \"distortion\",\n    \"TYPE\": \"slider\",\n    \"MIN\":0.0,\n    \"DEFAULT\":0.0,\n    \"DESCRIPTION\":\"Add an extra level of distortion to the scene, or just use the auto toggle to have the distortion on drum hits.\",\n    \"UI_GROUP\":\"extra_distortion\"\n  },{\n    \"NAME\": \"xyPaint1\",\n    \"TYPE\": \"xy smooth\",\n    \"PARAMS\": 0.1,\n    \"DESCRIPTION\":\"XY Position of the brush.\",\n    \"UI_GROUP\":\"brush1\"\n  },{\n    \"NAME\": \"paint1_on\",\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\":\"When the simulation is looking a little dead, paint some new flow into it by toggling this brush on.\",\n    \"UI_GROUP\":\"brush1\"\n  },{\n    \"DEFAULT\" : 0,\n    \"DESCRIPTION\" : \"\",\n    \"MAX\" : 1,\n    \"MIN\" : 0,\n    \"NAME\" : \"paint2_on\",\n    \"DESCRIPTION\":\"A different, smoother style of painting that will leave streaks instead of forming ripples.\",\n    \"TYPE\" : \"toggle\",\n    \"UI_GROUP\" : \"brush2\"\n  },{\n    \"DEFAULT\" : 0,\n    \"DESCRIPTION\" : \"\",\n    \"MAX\" : 1,\n    \"MIN\" : -1,\n    \"NAME\" : \"xyPaint2\",\n    \"TYPE\" : \"xy smooth\",\n    \"DESCRIPTION\":\"XY Position of the brush.\",\n    \"PARAMS\":0.05,\n    \"UI_GROUP\" : \"brush2\"\n  }\n\n\n\n]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":576,"TARGET":"BuffA","WIDTH":1024},{"FLOAT":true,"HEIGHT":576,"TARGET":"BuffB","WIDTH":1024}],"SCRIPT_CODE":"","SHADER_CODE":"vec3 iMouse = vec3(xyPaint1*RENDERSIZE, paint1_on);\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\nfloat ADVECT_DIST = mix(2.0, 2.0-syn_HighHits*10.0, drum_flow);\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return reset_sim > 0.5;\n}\n\nvec2 normz(vec2 x) {\n    return x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(BuffB, fract(aUv));\n    vec4 u_n =  texture(BuffB, fract(aUv+n));\n    vec4 u_e =  texture(BuffB, fract(aUv+e));\n    vec4 u_s =  texture(BuffB, fract(aUv+s));\n    vec4 u_w =  texture(BuffB, fract(aUv+w));\n    vec4 u_nw = texture(BuffB, fract(aUv+nw));\n    vec4 u_sw = texture(BuffB, fract(aUv+sw));\n    vec4 u_ne = texture(BuffB, fract(aUv+ne));\n    vec4 u_se = texture(BuffB, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\nvec4 advect2(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(BuffA, fract(aUv));\n    vec4 uv_n =  texture(BuffA, fract(aUv+n));\n    vec4 uv_e =  texture(BuffA, fract(aUv+e));\n    vec4 uv_s =  texture(BuffA, fract(aUv+s));\n    vec4 uv_w =  texture(BuffA, fract(aUv+w));\n    vec4 uv_nw = texture(BuffA, fract(aUv+nw));\n    vec4 uv_sw = texture(BuffA, fract(aUv+sw));\n    vec4 uv_ne = texture(BuffA, fract(aUv+ne));\n    vec4 uv_se = texture(BuffA, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvec4 firstPass()\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 vUv = _xy.xy / RENDERSIZE.xy;\n    vec2 texel = 1. / RENDERSIZE.xy;\n    \n    if (paint2_on > 0.5) {\n        vec2 d = _uvc-xyPaint2*vec2(1.0,9.0/16.0);\n        vec2 m = 2.0 * normz(d) * exp(-length(d) / 0.03);\n        vUv += m;\n        // div += pow(length(m)*3.0,2.0);\n    }\n\n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(BuffB, fract(vUv));\n    vec4 u_n =  texture(BuffB, fract(vUv+texel*n));\n    vec4 u_e =  texture(BuffB, fract(vUv+texel*e));\n    vec4 u_s =  texture(BuffB, fract(vUv+texel*s));\n    vec4 u_w =  texture(BuffB, fract(vUv+texel*w));\n    vec4 u_nw = texture(BuffB, fract(vUv+texel*nw));\n    vec4 u_sw = texture(BuffB, fract(vUv+texel*sw));\n    vec4 u_ne = texture(BuffB, fract(vUv+texel*ne));\n    vec4 u_se = texture(BuffB, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n        vec2 d = _xy.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.1 * m * normz(d);\n    }\n\n    // if (syn_OnBeat > 0.9) {\n    //     float m = lum;\n    //     du += 0.2 * m ;\n    // }\n    \n    vec2 init = vec2(_rand(_uv+TIME),_rand(-_uv-TIME));\n    // initialize with noise\n    if(FRAMECOUNT < 10 || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        vec4 img = _loadUserImage();\n        float lum = dot(img.rgb, vec3(1.0))/3.0;\n\n        du = length(du) > 1.0 ? normz(du) : du;\n        du -= _uvc*pow(_pulse(lum, 0.85, 0.15)*syn_HighHits,5.0)*media_hits*3.0;\n        du += _uvc*pow(_pulse(lum, 0.85, 0.15)*syn_BassLevel,5.0)*media_hits*3.0;\n        fragColor = vec4(du, dv);\n    }\n    \n    return fragColor;\n}\n\n\n\nvec4 secondPass()\n{\n    vec4 fragColor = vec4(0.0);\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    float cs = -3.0*clouds + 0.5*snakes;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    float pwr = backwards_ripples;  // power when deriving rotation angle from curl\n    float amp = 1.0;  // self-amplification\n    float upd = smooth_glass;  // update smoothing\n    float sq2 = 1.0;  // diagonal weight\n    \n    vec2 vUv = _xy.xy / RENDERSIZE.xy;\n    vec2 texel = 1. / RENDERSIZE.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(BuffA, fract(vUv));\n    vec4 uv_n =  texture(BuffA, fract(vUv+n));\n    vec4 uv_e =  texture(BuffA, fract(vUv+e));\n    vec4 uv_s =  texture(BuffA, fract(vUv+s));\n    vec4 uv_w =  texture(BuffA, fract(vUv+w));\n    vec4 uv_nw = texture(BuffA, fract(vUv+nw));\n    vec4 uv_sw = texture(BuffA, fract(vUv+sw));\n    vec4 uv_ne = texture(BuffA, fract(vUv+ne));\n    vec4 uv_se = texture(BuffA, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect2(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    return fragColor;\n    \n}\n\n\n\n// displacement amount\nfloat DISP_SCALE = (-1.0+2.0*switch_direction)*sign(aberration_amount)*pow(aberration_amount,2.0);\n\n// chromatic dispersion samples\n#define SAMPLES 34\n\n// contrast\n#define SIGMOID_CONTRAST 8.0\n\n// channels to use for displacement, either xy or zw\n\nvec3 contrast(vec3 x) {\n    return 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\n/*\n    This function supplies a weight vector for each color channel.\n    It's analogous to (but not a physically accurate model of)\n    the response curves for each of the 3 cone types in the human eye.\n    The three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n    integrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n    return vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        if (syn_MediaType>0.5){\n            col += sw * texture(syn_UserImage, uv + dispNorm * disp * wl).xyz;\n        } else {\n            vec2 pos = fract(uv*4.0*vec2(RENDERSIZE.x/RENDERSIZE.y, 1.0)*vec2(0.145,2.0) + (dispNorm * disp * wl)*10.0*(0.05+syn_Presence) + vec2(0.0, syn_Time*0.1));\n            pos *= 1.0-syn_HighHits*0.5;\n            float stepper = 0.1;\n            col += sw*vec3((1.0-step(stepper, pos.x+0.05)*step(stepper+0.1, pos.y+0.05)),(1.0-step(stepper, pos.x+0.05)*step(stepper+0.1, pos.y+0.05)),(1.0-step(stepper, pos.x+0.05)*step(stepper+0.1, pos.y+0.05)));\n        }\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvec4 renderPass(){\n    vec4 fragColor = vec4(0.0);\n    vec2 texel = 1. / RENDERSIZE.xy;\n    vec2 uv = _uv;\n\n    // uv = arbMirror(uv);\n    // return vec4(fract(uv.x*10.0),fract(uv.y*10.0), 0.0, 1.0);\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec4 dF = texture(BuffA, uv);\n    vec4 d_nF = texture(BuffA, fract(uv+n));\n    vec4 d_eF = texture(BuffA, fract(uv+e));\n    vec4 d_sF = texture(BuffA, fract(uv+s));\n    vec4 d_wF = texture(BuffA, fract(uv+w)); \n\n    vec2 d   = mix(dF.xy, _rotate(dF.xy, dot(dF.zw, vec2(1.0))*50.0), distortion+syn_HighLevel*auto_distortion);\n    vec2 d_n = mix(d_nF.xy, _rotate(d_nF.xy, dot(d_nF.zw, vec2(1.0))*50.0), distortion+syn_HighLevel*auto_distortion);\n    vec2 d_e = mix(d_eF.xy, _rotate(d_eF.xy, dot(d_eF.zw, vec2(1.0))*50.0), distortion+syn_HighLevel*auto_distortion);\n    vec2 d_s = mix(d_sF.xy, _rotate(d_sF.xy, dot(d_sF.zw, vec2(1.0))*50.0), distortion+syn_HighLevel*auto_distortion);\n    vec2 d_w = mix(d_wF.xy, _rotate(d_wF.xy, dot(d_wF.zw, vec2(1.0))*50.0), distortion+syn_HighLevel*auto_distortion); \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n    if ((syn_MediaType > 1.5)&&(syn_MediaType < 2.5)){\n        uv.y = 1.0-uv.y;\n    }\n\n    vec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n    return fragColor;\n\n}\n\nvec4 renderMain(){\n    if (PASSINDEX == 0.0){\n        return firstPass();\n    } else if (PASSINDEX == 1.0){\n        return secondPass();\n    } else if (PASSINDEX == 2.0){\n        return renderPass();\n    } \n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Dispersion","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Audio reactive pulses. Turn OFF for constant motion.","MAX":1,"MIN":0,"NAME":"pulsing_fire","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0,"DESCRIPTION":"Zoom in on bass hits, creating a feeling of moving forwards.","MAX":1,"MIN":0,"NAME":"bass_travel","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":1,"DESCRIPTION":"This lets you use the media color only, instead of mixing with the fire.","MAX":0,"MIN":1,"NAME":"media_color_only","TYPE":"slider","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"When ON, multiplies the media and fire color, otherwise it is additive.","MAX":1,"MIN":0,"NAME":"multiply_color","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"Affects how distorted the media is.","MAX":1,"MIN":0,"NAME":"media_refract","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"4 color palettes to choose from on one slider.","MAX":3,"MIN":0,"NAME":"color_palette","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Creates a smooth glassy surface. Tipping point is around 70%.","MAX":0,"MIN":1,"NAME":"glassy_surface","TYPE":"slider","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Pulses vertical scan lines out from the center.","MAX":1,"MIN":0,"NAME":"scan_lines","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Spawns a slow moving ring of fire moving out from the center.","MAX":1,"MIN":0,"NAME":"ring_of_fire","PARAMS":0.00249999994412065,"TYPE":"bang smooth","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Pulse of darkness across the screen, with fire returning shortly afer.","MAX":1,"MIN":0,"NAME":"darken","PARAMS":0.5,"TYPE":"bang smooth","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Creates quick burst effects in each cell of the fire.","MAX":1,"MIN":0,"NAME":"fireworks","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Only used to reset the simulation if it entirely dies.","MAX":1,"MIN":0,"NAME":"reset_sim","TYPE":"bang","UI_GROUP":"reset"}],"CREDIT":"cornusammonis","DESCRIPTION":"A flaming dynamical system. Click to interact, press spacebar to reset.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\dynamical_flame.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Dynamical Flame","IMAGES":[{"NAME":"image16","PATH":"images/16.png"}],"IMAGE_PATH":"dynamical_flame.synScene\\dynamical_flame.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n   {\n      \"NAME\":\"pulsing_fire\",\n      \"DESCRIPTION\":\"Audio reactive pulses. Turn OFF for constant motion.\",\n      \"TYPE\":\"toggle\",\n      \"DEFAULT\":1.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"UI_GROUP\":\"reactivity\"\n   },{\n      \"NAME\":\"bass_travel\",\n      \"DESCRIPTION\":\"Zoom in on bass hits, creating a feeling of moving forwards.\",\n      \"TYPE\":\"toggle\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"UI_GROUP\":\"reactivity\"\n   },{\n      \"NAME\":\"media_color_only\",\n      \"DESCRIPTION\":\"This lets you use the media color only, instead of mixing with the fire.\",\n      \"TYPE\":\"slider\",\n      \"DEFAULT\":1.0,\n      \"MAX\":0.0,\n      \"MIN\":1.0,\n      \"UI_GROUP\":\"media\"\n   },{\n      \"NAME\":\"multiply_color\",\n      \"DESCRIPTION\":\"When ON, multiplies the media and fire color, otherwise it is additive.\",\n      \"TYPE\":\"toggle\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"UI_GROUP\":\"media\"\n   },{\n      \"NAME\":\"media_refract\",\n      \"DESCRIPTION\":\"Affects how distorted the media is.\",\n      \"TYPE\":\"slider smooth\",\n      \"DEFAULT\":0.4,\n      \"PARAMS\":0.1,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"UI_GROUP\":\"media\"\n   },{\n      \"NAME\":\"color_palette\",\n      \"DESCRIPTION\":\"4 color palettes to choose from on one slider.\",\n      \"TYPE\":\"slider\",\n      \"DEFAULT\":0.0,\n      \"MAX\":3.0,\n      \"MIN\":0.0,\n      \"UI_GROUP\":\"color\"\n   },{\n      \"NAME\":\"glassy_surface\",\n      \"DESCRIPTION\":\"Creates a smooth glassy surface. Tipping point is around 70%.\",\n      \"TYPE\":\"slider\",\n      \"DEFAULT\":1.0,\n      \"MAX\":0.0,\n      \"MIN\":1.0,\n      \"UI_GROUP\":\"action\"\n   },{\n      \"NAME\":\"scan_lines\",\n      \"DESCRIPTION\":\"Pulses vertical scan lines out from the center.\",\n      \"TYPE\":\"bang smooth\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"PARAMS\":0.05,\n      \"UI_GROUP\":\"action\"\n   },{\n      \"NAME\":\"ring_of_fire\",\n      \"DESCRIPTION\":\"Spawns a slow moving ring of fire moving out from the center.\",\n      \"TYPE\":\"bang smooth\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"PARAMS\":0.0025,\n      \"UI_GROUP\":\"action\"\n   },{\n      \"NAME\":\"darken\",\n      \"DESCRIPTION\":\"Pulse of darkness across the screen, with fire returning shortly afer.\",\n      \"TYPE\":\"bang smooth\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"PARAMS\":0.5,\n      \"UI_GROUP\":\"action\"\n   },{\n      \"NAME\":\"fireworks\",\n      \"DESCRIPTION\":\"Creates quick burst effects in each cell of the fire.\",\n      \"TYPE\":\"bang smooth\",\n      \"DEFAULT\":0.0,\n      \"MAX\":1.0,\n      \"MIN\":0.0,\n      \"PARAMS\":0.1,\n      \"UI_GROUP\":\"action\"\n   },{\n      \"NAME\":\"reset_sim\",\n      \"DESCRIPTION\":\"Only used to reset the simulation if it entirely dies.\",\n      \"TYPE\":\"bang\",\n      \"UI_GROUP\":\"reset\"\n   }\n\n   ],\n   \"CREDIT\" : \"cornusammonis\",\n   \"DESCRIPTION\" : \"A flaming dynamical system. Click to interact, press spacebar to reset.\",\n   \"HARD_TRANSITIONS\" : null,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image16\",\n         \"PATH\" : \"images/16.png\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"dynamical_flame.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 720,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 1280\n      },{\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 720,\n         \"TARGET\" : \"BuffA2\",\n         \"WIDTH\" : 1280\n      }\n   ],\n   \"SMOOTH_TRANSITIONS\" : null,\n   \"TITLE\" : \"Dynamical Flame\"\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"BuffA","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"BuffA2","WIDTH":1280}],"SCRIPT_CODE":"","SHADER_CODE":"vec4 iMouse = vec4(720, 720, 0.0, 0.0); \n\n\n\t\t\t//******** BuffA2 Code Begins ********\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 24.0\n#define W1 0.3\n#define TIMESTEP 0.2\nfloat ADVECT_DIST = mix(0.2, syn_BassLevel*0.4-syn_HighHits*0.25, pulsing_fire)*(0.9+syn_Presence*0.2);\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return ((reset_sim>0.5)||(TIME<0.1));\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(BuffA2, fract(aUv));\n    vec4 u_n =  texture(BuffA2, fract(aUv+n));\n    vec4 u_e =  texture(BuffA2, fract(aUv+e));\n    vec4 u_s =  texture(BuffA2, fract(aUv+s));\n    vec4 u_w =  texture(BuffA2, fract(aUv+w));\n    vec4 u_nw = texture(BuffA2, fract(aUv+nw));\n    vec4 u_sw = texture(BuffA2, fract(aUv+sw));\n    vec4 u_ne = texture(BuffA2, fract(aUv+ne));\n    vec4 u_se = texture(BuffA2, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    const float xd = sqrt(3.0) / 2.0;\n    const float xi = 1.0 - xd;\n    return 0.5 * ((x + x_v) * xi + (x_h + x_d) * xd);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    const float xd = sqrt(3.0) / 2.0;\n    const float xi = 1.0 - xd;\n    return 0.5 * ((x + x_h) * xi + (x_v + x_d) * xd);\n}\n\nvec2 rotateCenter(vec2 uvIn, float amount){\n  uvIn.y += (RENDERSIZE.x-RENDERSIZE.y)/RENDERSIZE.x;\n  uvIn*=vec2(1.0, RENDERSIZE.y/RENDERSIZE.x);\n  _uv2uvc(uvIn);\n  uvIn = _rotate(uvIn, amount);\n  _uvc2uv(uvIn);\n  uvIn/=vec2(1.0, RENDERSIZE.y/RENDERSIZE.x);\n  uvIn.y -= (RENDERSIZE.x-RENDERSIZE.y)/RENDERSIZE.x;\n  return uvIn;\n}\n// vec4 col = mix(img, img*extra_bright+texture(fxApplied, rotateCenter(_uv, fb_rotate*PI)-sign(fb_motion)*fb_motion*fb_motion*0.1+(_uvc)*fb_zoom*fb_zoom*sign(fb_zoom)*0.05), feedback_mix);\n\n\nvec4 renderPassA() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    vec2 vUv = fragCoord.xy / RENDERSIZE.xy;\n    vec2 texel = 1. / RENDERSIZE.xy;\n    vUv = vUv - _uvc*0.005*syn_BassLevel*syn_BassLevel*bass_travel;\n    float dist = glassy_surface*glassy_surface;\n\n    vec2 n  = vec2(0.0, 1.0)*dist;\n    vec2 ne = vec2(1.0, 1.0)*dist;\n    vec2 e  = vec2(1.0, 0.0)*dist;\n    vec2 se = vec2(1.0, -1.0)*dist;\n    vec2 s  = vec2(0.0, -1.0)*dist;\n    vec2 sw = vec2(-1.0, -1.0)*dist;\n    vec2 w  = vec2(-1.0, 0.0)*dist;\n    vec2 nw = vec2(-1.0, 1.0)*dist;\n\n    vec4 u =    texture(BuffA2, fract(vUv));\n    vec4 u_n =  texture(BuffA2, fract(vUv+texel*n));\n    vec4 u_e =  texture(BuffA2, fract(vUv+texel*e));\n    vec4 u_s =  texture(BuffA2, fract(vUv+texel*s));\n    vec4 u_w =  texture(BuffA2, fract(vUv+texel*w));\n    vec4 u_nw = texture(BuffA2, fract(vUv+texel*nw));\n    vec4 u_sw = texture(BuffA2, fract(vUv+texel*sw));\n    vec4 u_ne = texture(BuffA2, fract(vUv+texel*ne));\n    vec4 u_se = texture(BuffA2, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = sqrt(3.0) / 2.0;\n    const float hx = vy;\n    const float hy = vx;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    vec2 d_nne = diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy);\n    vec2 d_ene = diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy);\n    vec2 d_ese = diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy);\n    vec2 d_sse = diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy);\n    vec2 d_ssw = diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy);\n    vec2 d_wsw = diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy);\n    vec2 d_wnw = diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy);\n    vec2 d_nnw = diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy);\n    \n    float di_nne = nl(distance(d_nne, u.xy));\n    float di_ene = nl(distance(d_ene, u.xy));\n    float di_ese = nl(distance(d_ese, u.xy));\n    float di_sse = nl(distance(d_sse, u.xy));    \n    float di_ssw = nl(distance(d_ssw, u.xy));\n    float di_wsw = nl(distance(d_wsw, u.xy));\n    float di_wnw = nl(distance(d_wnw, u.xy));\n    float di_nnw = nl(distance(d_nnw, u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = d_nne - u.xy;\n    vec2 xy_ene = d_ene - u.xy;\n    vec2 xy_ese = d_ese - u.xy;\n    vec2 xy_sse = d_sse - u.xy;\n    vec2 xy_ssw = d_ssw - u.xy;\n    vec2 xy_wsw = d_wsw - u.xy;\n    vec2 xy_wnw = d_wnw - u.xy;\n    vec2 xy_nnw = d_nnw - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec2 du = u_blur.xy;\n    vec2 dv = u_blur.zw;\n    \n    for (int i = 0; i < 5; i++ ) {\n        vec4 auv = advect(du, vUv, texel);        \n        dv = auv.zw + 1.0 * ma;\n        du = auv.xy + 0.4 * dv;\n    }\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = 2.0 * exp(-length(d) / 100.0);\n        du.xy += m * normz(d);\n    }\n    \n    vec3 init = texture(image16, vUv).xyz;\n    // initialize with noise\n    if((length(u) <= 0.001 && init != vec3(0.0)) || reset()) {\n        fragColor = vec4(-0.5 + init.xy, 0.0, 0.0);\n    } else {\n        fragColor = vec4(du, dv);\n    }\n\n    if (length(dv)<5.0){\n        fragColor.zw = mix(fragColor.zw, fragColor.xy, darken);\n    }\n\n    if (length(du)>10.0){\n        fragColor.xy = mix(fragColor.xy, fragColor.xy*4.0, fireworks);\n    }\n    if (length(dv)<1.0){\n        fragColor.xy = mix(fragColor.xy, -fragColor.xy*1.0, fireworks);\n    }\n\n    fragColor = mix(fragColor, vec4(1.0,1.0,1.0,1.0), _pulse(length(_uvc), -0.1+(1.0-ring_of_fire)*2.0, 0.01+length(du)*0.01));\n    fragColor = mix(fragColor, vec4(0.0,0.0,_uvc), _pulse(-0.1+abs(_uvc.x)+length(dv)*0.01, (1.0-scan_lines)*1.0, 0.01+length(du)*0.01));\n\n\n\treturn fragColor; \n } \n\n\n// Visualization of the system in Buffer A\n\n// uncomment to just render the normals\n//#define NORMAL\n\n// displacement\nfloat DISP = (2.0*(1.0-glassy_surface*0.5)*media_refract*(0.5+pow(length(_uvc), 2.0)*0.5))*0.015;\n\n// contrast\n#define SIGMOID_CONTRAST 8.0\n\n// mip level\n#define MIP 1.0\n\nvec4 contrast(vec4 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec4 renderMainImage(){\n    vec4 fragColor = vec4(0.0);\n    vec2 texel = 1. / RENDERSIZE.xy;\n    vec2 uv = _xy.xy / RENDERSIZE.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(BuffA2, uv).xy;\n    vec2 d_n = texture(BuffA2, fract(uv+n)).xy;\n    vec2 d_e = texture(BuffA2, fract(uv+e)).xy;\n    vec2 d_s = texture(BuffA2, fract(uv+s)).xy;\n    vec2 d_w = texture(BuffA2, fract(uv+w)).xy;    \n\n    uv = _correctImageCoords(textureSize(syn_UserImage, 0));\n    uv = _invertYAxisVideo(uv);\n\n    vec3 i   = texture(syn_UserImage, fract(uv + DISP * d  ), MIP).xyz;\n    vec3 i_n = texture(syn_UserImage, fract(uv + DISP * d_n), MIP).xyz;\n    vec3 i_e = texture(syn_UserImage, fract(uv + DISP * d_e), MIP).xyz;\n    vec3 i_s = texture(syn_UserImage, fract(uv + DISP * d_s), MIP).xyz;\n    vec3 i_w = texture(syn_UserImage, fract(uv + DISP * d_w), MIP).xyz;\n\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n    float dd = exp(-0.02 * length(abs(d_n-d_s) + abs(d_e-d_w)));\n    vec3 ib = 0.4 * i + 0.15 * (i_n+i_e+i_s+i_w);\n    ib = _contrast(_invertImage(vec4(ib, 1.0)), _Media_Contrast).rgb;\n    vec3 nr = normalize(vec3(db.x,db.y,sqrt(clamp(1.0-length(db.xy),0.0,1.0))));\n    //vec3 l = normalize(vec3(cos(TIME), sin(TIME), 0.1)); \n    //vec3 sh = pow(vec3(clamp(dot(nr,l),0.0,1.0)), vec3(1.0));\n    float shl = 1.0 * exp(-0.13 * length(db.xy)) * dd;\n    vec3 col1P = 2.0*(1.0-smoothstep(0.9, 1.0, dd))*_palette(clamp(smoothstep(0.9, 1.0, dd), 0.0, 1.0), vec3(1.025, 0.361, 0.703), vec3(0.900, 0.506, 0.724), vec3(0.720, 1.005, 0.075), vec3(1.000, 0.950, 0.590));\n\n    vec3 col1 = mix(vec3(1.3, 0.0, 0.0), col1P, 0.5*syn_BassLevel);\n    vec3 col2 = vec3(0.9, 0.7, 0.3);\n\n    // *** Color Regime 1 ***\n    float colMixer = color_palette;\n    float cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n    \n    vec3 col2P = _palette(clamp(-nr.y*0.4, 0.0, 1.0), vec3(0.540, 0.440, 1.424), vec3(0.410, 0.480, 1.000), vec3(0.810, 0.525, 0.207), vec3(0.210, 0.480, 0.399));\n    col1 = mix(col1, col2P.gbr*2.0, cm);\n    col2 = mix(col2, col1P.grg, cm);\n    // return vec4(col2P,1.0);\n\n    // *** Color Regime 2 ***\n    colMixer = colMixer-1.0;\n    cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n    col1P = (1.0-smoothstep(0.5, 0.5+0.2, dd*dd))*vec3(1.0)*5.0*(0.2+syn_HighHits);\n    col1 = mix(col1, col1P, cm);\n    col2P = (1.0-smoothstep(0.0, 0.1, 1.0-dd*dd))*vec3(0.4,0.0,0.3)*20.0*pow(syn_Presence, 1.6);\n    col2 = mix(col2, col2P, cm);\n\n    // *** Color Regime 3 ***\n    colMixer = colMixer-1.0;\n    cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n    col1P = 2.0*(1.0-smoothstep(0.9, 1.0, dd))*_palette(clamp(smoothstep(0.9, 1.0, dd), 0.0, 1.0), vec3(1.025, 0.361, 0.703), vec3(0.900, 0.506, 0.724), vec3(0.720, 1.005, 0.075), vec3(1.000, 0.950, 0.590));\n\n    col1 = mix(col1, col1P, cm);\n    col2P = _palette(clamp(1.0-dd*_uv.y*length(_uvc)-0.2, 0.0, 1.0), vec3(0.380, 0.420, 0.940), vec3(0.730, 0.740, 0.500), vec3(0.570, 0.223, 0.360), vec3(0.382, 0.670, 0.433));\n    col2 = mix(col2, col2P, cm);\n\n    vec3 m = shl * mix(col1, col2, shl);\n\n    if (syn_MediaType<0.5){\n    \t// vec3 d = texture(BuffA2, uv).xyz;\n     //    d.xy *= vec2(sin(syn_Time*0.01+syn_BPMSin2),cos(syn_Time*0.01+syn_BPMSin2));\n   \t\t// vec3 nr = 0.3 + 0.5 * normalize(vec3(d.x+d.y*0.5,d.y*0.5+d.z,d.z));\n     //    nr = contrast(vec4(nr, 1.0)).rgb;\n\n     //    if (syn_MediaType>0.5){\n     //        nr *= _loadUserImage(db*0.001*syn_BassPresence*4.0).rgb;\n     //    }\n\n    \tfragColor = contrast(vec4(m, 1.0));\n    } else {\n        fragColor = mix(vec4(ib, 1.0), contrast(vec4(mix(0.7*ib + m, ib*m, multiply_color),1.0)), media_color_only);\n        // if (multiply_color>0.5){\n        //     fragColor = contrast(vec4(ib*m,1.0));\n        // }\n    }\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderPassA();\n\t}\n    if(PASSINDEX == 1){\n        return texture(BuffA, _uv);\n    }\n\tif(PASSINDEX == 2){\n\t\tvec4 fireCol = renderMainImage();\n        // vec3 hsv = _rgb2hsv(fireCol.rgb);\n\n        // hsv = _hsv2rgb(hsv);\n        return fireCol;\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Dynamical Flame","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Mirror the scene across an axis for a symmetrical look.","MAX":1,"MIN":0,"NAME":"mirror_on","TYPE":"toggle","UI_GROUP":"mirror"},{"DEFAULT":0,"DESCRIPTION":"mirror on MUST BE SET TO ON. Change the mirror location on every press to get different kinds of symmetry.","MAX":1,"MIN":0,"NAME":"mirror_change","TYPE":"bang counter","UI_GROUP":"mirror"},{"DEFAULT":1,"DESCRIPTION":"Refract the scene through one of two surfaces. 1/3 up selects an 'X' surface. 2/3 up selects a diamond surface. All the way down for None. Both move on the beat.","MAX":2,"MIN":0,"NAME":"refract_type","TYPE":"slider","UI_GROUP":"refractor"},{"DEFAULT":0,"DESCRIPTION":"Turn on an RGB Split effect that splits more when the bass hits.","MAX":1,"MIN":0,"NAME":"RGB_Split","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":1,"DESCRIPTION":"Intensity of the atmosphere's glow. ","MAX":2,"MIN":0,"NAME":"intns_atmos","TYPE":"slider","UI_GROUP":"effects"},{"DEFAULT":1,"DESCRIPTION":"Intensity of the planet's glow.","MAX":2,"MIN":0,"NAME":"intns_planet","TYPE":"slider","UI_GROUP":"effects"},{"DEFAULT":1,"DESCRIPTION":"Choose between your two selected colors or a full spectrum color scheme.","MAX":1,"MIN":0,"NAME":"color_scheme","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":[0.785000026226044,0.259999990463257,0],"DESCRIPTION":"color scheme MUST BE SET TO ON. Color of planet surface.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"color_low","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":[0.699999988079071,0.600000023841858,0.100000001490116],"DESCRIPTION":"color scheme MUST BE SET TO ON. Color of atmosphere.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"color_high","TYPE":"color","UI_GROUP":"color"}],"CREDIT":"Meebs ft. WAHa_06x36","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\exoplanet.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"EXOplanet","IMAGES":null,"IMAGE_PATH":"exoplanet.synScene\\exoplanet.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs ft. WAHa_06x36\",\n \"DESCRIPTION\": \"\",\n \"TITLE\": \"EXOplanet\",\n \"IMAGE_PATH\": \"exoplanet.jpg\",\n \"HARD_TRANSITIONS\":[\n ],\n \"PASSES\": [ {\"TARGET\":\"sunTexIn\", \"WIDTH\":3000, \"HEIGHT\":1500, \"FLOAT\": true},\n              {\"TARGET\":\"forMirroring\", \"FLOAT\":false, \"WIDTH\":1280, \"HEIGHT\":720},\n              {\"TARGET\":\"forRGBSplit\", \"FLOAT\":false}\n ],\n \"CONTROLS\":[\n  {\n    \"NAME\": \"mirror_on\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DESCRIPTION\": \"Mirror the scene across an axis for a symmetrical look.\",\n    \"UI_GROUP\":\"mirror\"\n  },{\n    \"NAME\": \"mirror_change\",\n    \"TYPE\": \"bang counter\",\n    \"DESCRIPTION\": \"mirror on MUST BE SET TO ON. Change the mirror location on every press to get different kinds of symmetry.\",\n    \"UI_GROUP\":\"mirror\"\n  },{ \n    \"NAME\": \"refract_type\",\n    \"TYPE\": \"slider\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.0,\n    \"MAX\": 2.0,\n    \"DESCRIPTION\": \"Refract the scene through one of two surfaces. 1/3 up selects an 'X' surface. 2/3 up selects a diamond surface. All the way down for None. Both move on the beat.\",\n    \"UI_GROUP\":\"refractor\"\n  },{\n    \"NAME\": \"RGB_Split\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DESCRIPTION\": \"Turn on an RGB Split effect that splits more when the bass hits.\",\n    \"UI_GROUP\":\"effects\"\n  },{\n    \"NAME\": \"intns_atmos\",\n    \"TYPE\": \"slider\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.0,\n    \"MAX\": 2.0,\n    \"UI_GROUP\": \"effects\",\n    \"DESCRIPTION\": \"Intensity of the atmosphere's glow. \"\n  },{\n    \"NAME\": \"intns_planet\",\n    \"TYPE\": \"slider\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.0,\n    \"MAX\": 2.0,\n    \"UI_GROUP\": \"effects\",\n    \"DESCRIPTION\": \"Intensity of the planet's glow.\"\n  },{\n    \"NAME\": \"color_scheme\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.0,\n    \"MAX\": 1.0,\n    \"DESCRIPTION\": \"Choose between your two selected colors or a full spectrum color scheme.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"color_low\",\n    \"TYPE\": \"color\",\n    \"DEF_COLOR\": [0.785,0.26,0.0],\n    \"DESCRIPTION\": \"color scheme MUST BE SET TO ON. Color of planet surface.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"color_high\",\n    \"TYPE\": \"color\",\n    \"DEF_COLOR\": [0.7,0.6,0.1],\n    \"DESCRIPTION\": \"color scheme MUST BE SET TO ON. Color of atmosphere.\",\n    \"UI_GROUP\":\"color\"\n  }]\n}\n\n","PASSES":[{"FLOAT":true,"HEIGHT":1500,"TARGET":"sunTexIn","WIDTH":3000},{"FLOAT":false,"HEIGHT":720,"TARGET":"forMirroring","WIDTH":1280},{"FLOAT":false,"HEIGHT":0,"TARGET":"forRGBSplit","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"float rippleTimeIn = syn_BPMSin4;\nfloat colorPhase = syn_HighHits;\nfloat bassTimeInUncorrected = syn_BassTime;\nfloat highsTimeInUncorrected = syn_HighTime;\nfloat vuTimeInUncorrected = syn_Time;\nfloat rgbZoomAmt = syn_BassExpoCurve;\nfloat vuFadeToBlack = syn_FadeInOut;\nfloat bassHits = syn_BassHits;\n\nfloat mirrorOptionsArray[7] = float[7](0.100, 0.010, 0.001, 0.110, 0.101, 0.011, 0.111);\nfloat mirrorOptionsSelector = floor(mod(mirror_change, 7.0));\n\nvec2 resolution = RENDERSIZE; // the rendering resolution (in pixels)\nfloat time = TIME;\nuniform vec2 mousePos = vec2(0.5,0.5);\nfloat bassTimeIn = bassTimeInUncorrected*6 + time;\nfloat highsTimeIn = highsTimeInUncorrected*6 + time;\nfloat vuTimeIn = vuTimeInUncorrected*6 + time;\nfloat beatTime = syn_BPMTwitcher*2.5;\n\nfloat timeIn = time/5.0;\n\n// ***** for Mirror Pass *****/\nvec2 getMirrorPos(vec2 pos, float mirrorOptions){\n  //decoding a 3 decimal float into a bvec3. Hacky, but it makes keeps our uniforms only floats.\n  bvec3 mirrorOptionsBVec = bvec3(false);\n  float hundreds = floor(mirrorOptions/100.0);\n  mirrorOptions -= hundreds*100;\n  float tens = floor(mirrorOptions/10.0);\n  mirrorOptions -= tens*10;\n  float ones = mirrorOptions;\n\n  if (hundreds==1.0) mirrorOptionsBVec.r = true;\n  if (tens==1.0) mirrorOptionsBVec.g = true;\n  if (ones==1.0) mirrorOptionsBVec.b = true;\n  bool vertIfTrue = mirrorOptionsBVec.r;\n  bool greaterHalfIfTrue = mirrorOptionsBVec.g;\n  bool invertIfTrue = mirrorOptionsBVec.b;\n\n  float mirrorVar;\n  vec2 mirrorPos = pos;\n  if (vertIfTrue){\n    mirrorVar = pos.x;\n  } else {\n    mirrorVar = pos.y;\n  }\n  if (invertIfTrue){\n    mirrorVar = abs(0.5-mirrorVar);\n  }\n  if (greaterHalfIfTrue){\n    if (mirrorVar < 0.5){\n      mirrorVar = (0.5-mirrorVar)+0.5;\n    }\n  } else {\n    if (mirrorVar > 0.5){\n      mirrorVar = 0.5+(0.5-mirrorVar);\n    }\n  }\n  if (vertIfTrue){\n    mirrorPos.x = mirrorVar;\n  } else {\n    mirrorPos.y = mirrorVar;\n  }\n  return mirrorPos;\n}\n\n// * FIRST PASS ------------------------------------------------------------------------------------------------------------------ */\n\nvec2 getNormPosBotLeft() {\n  return vec2(gl_FragCoord.xy/resolution.xy);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 spectralColor(float l){ // RGB <0,1> <- lambda l <400,700> [nm]\n  l=l*300+400;\n  float r=0.0,g=0.0,b=0.0;\n  if ((l>=400.0)&&(l<410.0))      { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n  else if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n  else if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n  else if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n  else if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n  if ((l>=415.0)&&(l<475.0))      { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n  else if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n  else if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n  if ((l>=400.0)&&(l<475.0))      { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n  else if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n  return vec3(r,g,b);\n}\n\nfloat fireNoise(vec2 pos, float persistence, float scale, float time)\n{\n  float v = 0.0;\n  float p = 1.0;\n  int octaves = 10;\n  for (int i=octaves-1; i>=0; --i)\n  {\n    v += (sin(pos.x)+cos(pos.y))*p;\n    pos += sin(pos.yx+vec2(time, 0.6));\n    p *= persistence;\n    pos /= scale;\n  }\n  return v;\n}\n\n\n// * PASS SPLIT ------------------------------------------------------------------------------------------------------------------ */\n\n\nfloat e = 0.02;\nfloat radOfBackground = 40;\nfloat radOrbIn;\nfloat radOfInnerSphere;\nfloat radMoon;\nfloat radMoonOrbitInput;\nfloat radMoonOrbit;\nfloat glowAmt = 2.0+colorPhase*4.0;\nfloat bassTime = bassTimeIn/50.0;\n\nvec2 getNDCAspectCorrected() {\n  vec2 pos = vec2(-1+2*(gl_FragCoord.x/resolution.x),-1+2*(gl_FragCoord.y/resolution.y));\n  float aspectRatio = resolution.y/resolution.x;\n  pos.y *= aspectRatio;\n  return pos;\n}\n\nvec3 rotate(vec3 vector){\n  return vector;\n}\n\nvec3 offset(vec3 pos, vec3 amount) {\n  return pos - amount;\n}\n\nfloat distSphere(vec3 pos, float radius, vec3 origin) {\n  vec3 posOffset = offset(pos, origin);\n  return length(posOffset) - radius;\n}\n\nfloat invertedSphere( vec3 pos, float radius, vec3 origin) {\n  vec3 posOffset = offset(pos, origin);\n  return radius - length(posOffset);\n}\n\nfloat distOrb(vec3 pos) {\n  return distSphere(pos, radOfInnerSphere, vec3(0.0));\n}\n\nfloat distMoon(vec3 pos, vec3 originMoon){\n  return distSphere(pos, radMoon, originMoon);\n}\n\nvec2 distUnion(vec3 pos, float r, vec3 originMoon){\n  vec2 distData;\n  float distO, distBkg, moonDist;\n  distO = distOrb(pos);\n  moonDist = min(distMoon(pos, originMoon), distMoon(pos, -originMoon));\n  distBkg = invertedSphere(pos, r, vec3(0.0));\n  float objIndex;\n  if (min(distO, moonDist)<distBkg){\n    objIndex = 1.0; //moon or orb at 1.0\n  }\n  else {\n    objIndex = 2.0;\n  }\n  if (objIndex < 2.0){\n    distData.r = _smin(moonDist,distO, 2.0);\n    objIndex = clamp(1.0-0.1*abs(distO-moonDist),0.0,1.0);\n  }\n  else if (objIndex == 2.0){\n    distData.r = distBkg;\n  }\n  distData.g = objIndex;\n  return distData;\n}\n\n#define PHI pow(gl_FragCoord.x,(1.00001/sqrt(1.0)))\n\nfloat hash(float x)\n{\n  return pow(mod(mod(x, PHI)*x, 1.),mod(x,log2(PHI)));\n}\nfloat bash(float x)\n{\n  x = cos(x)*(time/PHI);\n  return pow(mod(mod(x, PHI)*x, 0.5),mod(x,log(PHI)));\n}\nfloat cash(float x)\n{\n  x = step(cos(x),sin(x));\n  return pow(mod(mod(x, PHI)*x, 1.),mod(x,log2(PHI)*x));\n}\nfloat stash(float x)\n{\n  x = smoothstep(sin(x),sin(x+0.1),(x));\n  return pow(mod(mod(x, PHI), -1.),mod(PHI,fract(exp(x))));\n}\n\nmat2 rot(float angle){\n  return mat2(cos(angle),-sin(angle),\n              sin(angle),-cos(angle));\n}\n\nvec3 weirdTex(vec3 pos) {\n\n  float c1 = fract(hash(pos.x+bash(pos.y)));\n  float c2 = fract(hash(pos.x+stash(pos.y)));\n  float c3 = fract(hash(pos.x+cash(pos.y)));\n\n  vec3 cc = vec3(smoothstep(c1,c2,c3));\n\n  //\t     col.xy *= rot(time/PHI);\n  //\t     col.xz *= rot(time/col.y);\n  //\t     col.yz *= rot(time/col.x);\n\n  return vec3(cc);\n\n}\n\nvec2 getMirrorPosSimple(vec2 pos, int horVert) {\n  vec2 newPos = pos;\n  if (horVert == 0){\n    newPos.x = abs(newPos.x);\n  }\n  if (horVert == 1){\n    newPos.y = abs(newPos.y);\n  }\n  return newPos;\n}\n\nfloat triGen(vec2 pos, float grower){\n  pos.x *= (resolution.x / resolution.y);\n  pos *= vec2(3.0,2.0)*2.0;\n  pos += vec2(0.0,0.2);\n  pos.x = abs(pos.x);\n  pos.y += abs(pos.x);\n  \n  //        float r = triRand(sin(pos.y), grower);\n  float retVal;\n  if (refract_type < 0.5){\n    retVal = 0;\n  } else if (refract_type < 1.5){\n    retVal = tan(pos.y+beatTime*0.5);\n  } else if (refract_type < 2.5){\n    retVal = atan(pos.y*1000.0*(1.0-0.2*cos(beatTime))-pos.x*1000.0*(1.0-0.2*sin(beatTime)))*5.0;\n  }\n\n  if (_exists(syn_UserImage)){\n    retVal = length(_uvc+vec2(sin(TIME*0.5),cos(TIME*0.567)))*_loadUserImageAsMask().r*3.0;\n  }\n  \n  return retVal;\n}\n\nvec4 loadMask(sampler2D imageName, vec2 imageSize) {\n  float wr = RENDERSIZE.x/imageSize.x;\n  float hr = RENDERSIZE.y/imageSize.y;\n  float ratio = min(wr, hr);\n  vec2 uv = _uv;\n  \n  uv.y *= hr/ratio;\n  uv.x *= wr/ratio;\n  \n  uv.x += -wr/ratio/2 + 0.5;\n  uv.y += -hr/ratio/2 + 0.5;\n  \n  if (uv.x < 0.0 || uv.y < 0.0 || uv.y > 1.0 || uv.x > 1.0) {\n    return vec4(0.0);\n  }\n  \n  vec4 colorOut = texture(imageName, uv);\n  colorOut *= colorOut.a;\n  \n  if (max(max(colorOut.r,colorOut.g),colorOut.b) >= 0.25){\n    colorOut = vec4(1.0);\n  } else {\n    colorOut = vec4(0.0);\n  }\n  \n  return colorOut;\n}\n\nvec4 renderMain(void){\n  radOrbIn = _scale(syn_Intensity, 0.0, 9.0);\n  radOfInnerSphere = 2.0+radOrbIn+colorPhase*0.3;\n  radMoon = 1.0+radOrbIn/2.0;\n  radMoonOrbitInput = _scale(syn_BassLevel, 1.0, 4.0);\n  radMoonOrbit = pow(radMoonOrbitInput/3.0,2.0)*3.5+radOrbIn*radMoonOrbitInput/4.0;\n  glowAmt = 2.0+colorPhase*4.0;\n  bassTime = bassTimeIn/50.0;\n\n  if (PASSINDEX == 0){\n    vec3 col;\n    vec2 pos = getNormPosBotLeft();\n\n    float rippleAmt = 0.1*smoothstep(0.0, 0.5, abs(pos.y - rippleTimeIn*1.0));\n    pos.y += rippleAmt;\n\n    //Create fireNoise pattern in two floats\n    float colNoise = 0.0;\n    float briNoise = 0.0;\n    float c = fireNoise(pos*10.0, 0.5, 0.5, highsTimeIn/6.0);\n    for (int i=0; i<10; i++){\n      colNoise += cos(c*pow(2.0,i-0.0)*0.5+0.5)/10.0;\n      briNoise += cos(c*pow(2,i-4.0))/9.0;\n    }\n    //Create pattern in color\n    col = spectralColor(colNoise*0.3+0.87)*(2.0*pow(briNoise,1.3));\n\n    //Final color shifting\n    col = rgb2hsv(col);\n    col.x = fract(col.x+timeIn*0.05+0.2*sin(pos.y*2.8)+0.8*col.b+colorPhase*0.4);\n    col = hsv2rgb(col);\n\n    return vec4(col, 1.0);\n  }\n\n  else if (PASSINDEX == 1){\n    vec3 col;\n    //Moon Motion\n    float orbitTime = bassTime*0.9;\n    float sM = orbitTime; //Radial motion\n    float orbitHemisphere = floor(mod(orbitTime,2.0)); //Says which half of orbit its in. Important to get phi smooth.\n    float tM = PI*mix(fract(orbitTime),-1+fract(orbitTime),orbitHemisphere); //Updown angle from 0 to PI\n    vec3 surfaceOfSphereMoon = vec3(cos(sM) * sin(tM), cos(tM), sin(sM) * sin(tM));\n    vec3 originMoon = radMoonOrbit*surfaceOfSphereMoon;\n\n    //Camera moves around surface of sphere at r = 25 always looking towards center\n    float rad = 30;\n    float camTime = vuTimeIn/200.0+0.01;\n    float camOrbitHemisphere = floor(mod(camTime,2.0));\n    float s = PI*mix(camTime*0.2,0.2*camTime+1.0,camOrbitHemisphere);\n    float t = PI*mix(fract(camTime),1.0-fract(camTime),camOrbitHemisphere);\n    vec3 surfaceOfSphere = vec3(cos(s) * sin(t), cos(t), sin(s) * sin(t));\n    vec3 camOrigin = rad*surfaceOfSphere;\n    vec3 camLookAt = vec3(0.0);\n\n    //Camera Setup\n    vec3 camUpVector = mix(vec3(0.0,1.0,0.0),vec3(0.0,-1.0,0.0),camOrbitHemisphere);\n    vec3 vpn = normalize(camLookAt-camOrigin);\n    vec3 u = normalize(cross(camUpVector,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (camOrigin+vpn);\n    vec2 vPos = getNDCAspectCorrected()*vec2(1.15,1.0);\n    vec3 scrCoord = vcv+vPos.x*u*0.8+vPos.y*v*0.8;\n    vec3 rayPath = normalize(scrCoord-camOrigin);\n\n    //Raymarching\n    const float maxd = 100.0; //Max Depth\n    float dist = 10.0; //greater than 0.01\n    float depth=0.0;\n\n    vec3 rayPos;\n    vec2 objData;\n    vec3 colGlow = vec3(0.0);\n    float glowDist;\n    vec2 planetCoords = vec2(1.0,1.0);\n\n    //Raymarching loop\n    for(int i=0; i<20; i++){\n      if ((abs(dist) < 0.001)|| (depth > maxd)) {\n        break;\n      }\n\n      //Find rayPos where contact with object occurs\n      rayPos = camOrigin+rayPath*depth;\n      vec3 normalToSurface = normalize(rayPos);\n      planetCoords.x = 0.5 - atan(normalToSurface.z, normalToSurface.x) / (2*PI);\n      planetCoords.y = 0.5 - asin(-normalToSurface.y) / PI;\n      planetCoords *= vec2(0.63,1.0); //Vec2(0.63,1.0) is a magic number to make it seamless.\n      vec4 sunTexData = texture(sunTexIn, planetCoords);\n\n      objData = distUnion(rayPos, radOfBackground, originMoon);\n      dist = objData.r;\n      depth += dist;\n\n      //at every step along the way, if you are close to the surface of the sun, color yourself\n      if (mod(i,2)==0){\n        glowDist = distOrb(rayPos)+_rand(planetCoords)*2.0;\n        if ((glowDist < 4.0)){\n          vec3 colFixed = pow(sunTexData.rgb,vec3(3.5));\n          if (color_scheme>0.5){\n            colFixed = mix(vec3(0.0), color_high, (0.01+length(colFixed)*0.5)*glowDist);\n          }\n          vec3 tempColGlow = 0.9*(1/(glowDist*0.2+0.5))*colFixed;\n          colGlow += tempColGlow*glowAmt;\n        }\n      }\n    }\n    colGlow *= intns_atmos;\n\n    //Post stepping coloring\n    if (depth < maxd){\n      if (objData.g < 2.0){\n        //Color Sun and Moon the same, but check if the blob is very detached by using origin moon. Then make it darker.\n        col = texture(sunTexIn, planetCoords).rgb*mix(0.2, 1.0, clamp(1.0+radOfInnerSphere-length(rayPos),0.0,1.0))*2.0;\n        if (color_scheme>0.5){\n          col = mix(vec3(0.0), color_low, pow(length(col),2.0)*2.0);\n        }\n      }\n      else {\n        col = vec3((abs(rayPos.z))/400.0)*weirdTex(rayPos/1000.0);\n      }\n      col *= intns_planet;\n    }\n    else {\n      col = vec3(0.0);\n    }\n    col += colGlow;\n    //Final color mixing\n    col.g *= 0.8;\n     return vec4(col,1.0);\n\n  }\n  else if (PASSINDEX == 2){\n    vec2 posBL = getNormPosBotLeft();\n    vec2 mirrorPos;\n    if (mirror_on > 0.5){\n      mirrorPos = getMirrorPos(posBL, mirrorOptionsArray[int(mirrorOptionsSelector)]*1000.0);\n    } else {\n      mirrorPos = posBL;\n    }\n     return texture(forMirroring, mirrorPos);\n  }\n  else if (PASSINDEX == 3){\n    vec3 col;\n    vec2 posBL = getNormPosBotLeft();\n    vec2 posTri = getNDCAspectCorrected();\n    posTri = getMirrorPosSimple(posTri, 1);\n    posTri *= vec2(0.5,-1.0);\n    float tri = triGen(posTri, rgbZoomAmt*0.5);\n    posBL = posBL + posBL*tri*0.01;\n    if (RGB_Split > 0.5){\n      vec2 modifiedCenter = vec2(cos(time), sin(time))*0.5;\n      vec2 rPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmt*0.31*sin(time*0.23)))+modifiedCenter;\n      vec2 gPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmt*0.398*sin(time*0.2)))+modifiedCenter;\n      vec2 bPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmt*0.33*sin(time*0.3)))+modifiedCenter;\n\n      rPos = abs(rPos);\n      if (rPos.x >= 0.9999){\n        rPos.x = 0.9999-rPos.x;\n      }\n      if (rPos.y >= 0.9999){\n        rPos.y = 0.9999-rPos.y;\n      }\n\n      gPos = abs(gPos);\n      if (gPos.x >= 0.9999){\n        gPos.x = 0.9999-gPos.x;\n      }\n      if (rPos.y >= 0.9999){\n        gPos.y = 0.9999-gPos.y;\n      }\n\n      bPos = abs(bPos);\n      if (bPos.x >= 0.9999){\n        bPos.x = 0.9999-bPos.x;\n      }\n      if (rPos.y >= 0.9999){\n        bPos.y = 0.9999-bPos.y;\n      }\n\n      col.r = texture(forRGBSplit, rPos).r;\n      col.g = texture(forRGBSplit, gPos).g;\n      col.b = texture(forRGBSplit, bPos).b;\n    }\n    else {\n      col = texture(forRGBSplit, posBL).rgb;\n    }\n\n    col *= vuFadeToBlack;\n\n    return vec4(col,1.0);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"EXOplanet","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Smoothly switch between 3D and 2D perspective using Equirectangular projection.","MAX":1,"MIN":0,"NAME":"perspective","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":[1,1],"DESCRIPTION":"Just move the X-axis to spin about your main axis, or move the Y-axis to tilt forwards or backwards.","MAX":[2,2],"MIN":[0,0],"NAME":"look_xy","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":0.5,"DESCRIPTION":"Zoom in and out of the input media.","MAX":1,"MIN":0,"NAME":"zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":[0,0],"DESCRIPTION":"Pan input media in any direction.","MAX":[1,1],"MIN":[-1,-1],"NAME":"position","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"media"},{"DEFAULT":[0,0],"DESCRIPTION":"Automatically pan input media in any direction.","MAX":[0.5,0.5],"MIN":[-0.5,-0.5],"NAME":"velocity","PARAMS":0.00249999994412065,"TYPE":"xy traveler","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Mirror input texture when tiling.","MAX":1,"MIN":0,"NAME":"mirror","TYPE":"toggle","UI_GROUP":"media"}],"CREDIT":"Shady Headstash","DESCRIPTION":"Smoothly switch between 3D and 2D perspective using Equirectangular projection.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\equirectangular.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Equirectangular","IMAGES":[{"NAME":"image1","PATH":"images/1.jpg"}],"IMAGE_PATH":"equirectangular.synScene\\equirectangular.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Smoothly switch between 3D and 2D perspective using Equirectangular projection.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"perspective\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Just move the X-axis to spin about your main axis, or move the Y-axis to tilt forwards or backwards.\",\n         \"IS_META\" : false,\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"look_xy\",\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Zoom in and out of the input media.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"zoom\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Pan input media in any direction.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"position\",\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Automatically pan input media in any direction.\",\n         \"IS_META\" : false,\n         \"MAX\" : 0.5,\n         \"MIN\" : -0.5,\n         \"NAME\" : \"velocity\",\n         \"PARAMS\" : 0.0025,\n         \"TYPE\" : \"xy traveler\",\n         \"UI_GROUP\" : \"media\"\n      },\n       {\n           \"DEFAULT\" : 1.0,\n           \"DESCRIPTION\" : \"Mirror input texture when tiling.\",\n           \"IS_META\" : false,\n           \"MAX\" : 1.0,\n           \"MIN\" : 0.0,\n           \"NAME\" : \"mirror\",\n           \"TYPE\" : \"toggle\",\n           \"UI_GROUP\" : \"media\"\n       }\n   ],\n   \"CREDIT\" : \"Shady Headstash\",\n   \"DESCRIPTION\" : \"Smoothly switch between 3D and 2D perspective using Equirectangular projection.\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"equirectangular.png\",\n   \"IMAGES\": [\n       {\n           \"NAME\" : \"image1\",\n           \"PATH\" : \"images/1.jpg\"\n       }\n   ],\n   \"TITLE\" : \"Equirectangular\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"#define \tTWPI  \t6.283185307179586  \t// two pi, 2*pi\n\nvec4 texMirror(sampler2D samplerIn, vec2 uvIn){\n    if (mod(uvIn.x, 2.0) > 1.0){\n        uvIn.x = 1.0-uvIn.x;\n    }\n    if (mod(uvIn.y, 2.0) > 1.0){\n        uvIn.y = 1.0-uvIn.y;\n    }\n    return texture(samplerIn, mod(uvIn, 1.0));\n}\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n    vec2 v = (_uv.xy + RENDERSIZE.y) - 0.5;\n\n    float th = v.y * PI,\n        ph = v.x * TWPI;\n    vec3 sp = vec3( sin(ph) * cos(th), sin(th), cos(ph) * cos(th) );\n    vec3 pos = vec3( PI, 0, 0);\n\n    pos *= ((mix(0.25+(1.0-zoom)*4., 0.25+(1.0-zoom)*2., perspective)) * 0.1);\n    //pos += (zoom * 0.18 * perspective);\n    sp = mix(sp, normalize(vec3(_uvc, 1.0)), 1.0-perspective);\n\n    sp.yz = _rotate(sp.yz, look_xy.y*PI);\n    sp.xy = _rotate(sp.xy, look_xy.x*PI);\n\n    vec2 nUv = vec2(dot(pos, sp.zxy), dot(pos.yzx, sp.zxy));\n    nUv -= 0.5;\n    nUv.x += velocity.x;\n    nUv.y += velocity.y;\n    nUv += (position);\n    nUv.y += mix(0.0, 1.0, mirror);\n\n    if (_exists(syn_UserImage)) {\n        fragColor = _contrast(_invertImage(mirror > 0.0 ? texMirror(syn_UserImage, nUv) : texture(syn_UserImage, mod(nUv, 1.0))),_Media_Contrast);\n    } else {\n        fragColor = texture(image1, mod(nUv * 6.0, 1.0));\n    }\n\n    return fragColor;\n}\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Equirectangular","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"You must pick a video from your media. DOWN applies a motion blur effect to the video, UP uses an edge detector.","MAX":0,"MIN":1,"NAME":"MODE_1_OR_2","TYPE":"toggle","UI_GROUP":"VIDEO"},{"DEFAULT":0,"DESCRIPTION":"Choose from one of 10 color palettes.","MAX":1,"MIN":0,"NAME":"color_palette","TYPE":"bang counter","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Stay in the same color space, but switch the direction of the palette from dark to light.","MAX":1,"MIN":0,"NAME":"invert_regime","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"When on, color palette will slowly oscillate vertically on the screen. ","MAX":1,"MIN":0,"NAME":"color_oscillator","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.5,"DESCRIPTION":"Adjusts the level of motion blur. If in MODE 2 (UP), then it adjusts edge thickness.","MAX":0,"MIN":0.990000009536743,"NAME":"motion_blur","TYPE":"slider","UI_GROUP":"effects"},{"DEFAULT":1,"DESCRIPTION":"Adjusts the contrast of the underlying image or video.","MAX":0,"MIN":3,"NAME":"contrast","TYPE":"slider","UI_GROUP":"effects"},{"DEFAULT":1.10000002384186,"DESCRIPTION":"Only works in MODE 1, changes animation style. Set to bottom for none. Set to middle for diamonds. Set to top for waves.","MAX":2.90000009536743,"MIN":0,"NAME":"animation_style","TYPE":"slider","UI_GROUP":"animation"},{"DEFAULT":0,"DESCRIPTION":"Hit to create an animation pulse.","MAX":1,"MIN":0,"NAME":"manual_animation","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"animation"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\filter_blown.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"direction","VALUES":[-1,1]}],"HEIGHT":1080,"ID":"Filter Blown","IMAGES":null,"IMAGE_PATH":"filter_blown.synScene\\filter_blown.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Filter Blown\",\n \"IMAGE_PATH\": \"filter_blown.png\",\n \"HARD_TRANSITIONS\": [\n {\n \"UNIFORM\": \"direction\",\n \"VALUES\":[-1.0,1.0]\n }],\n \"IMAGES\": [],\n \"PASSES\": [ {\"TARGET\": \"firstBuffer\"}, {\"TARGET\": \"secondBuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"MODE_1_OR_2\",\n    \"MAX\" : 0.0,\n    \"MIN\" : 1.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"You must pick a video from your media. DOWN applies a motion blur effect to the video, UP uses an edge detector.\",\n    \"UI_GROUP\":\"VIDEO\"\n  },{\n    \"NAME\": \"color_palette\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"bang counter\",\n    \"DESCRIPTION\": \"Choose from one of 10 color palettes.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"invert_regime\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Stay in the same color space, but switch the direction of the palette from dark to light.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"color_oscillator\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"When on, color palette will slowly oscillate vertically on the screen. \",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"motion_blur\",\n    \"MIN\" : 0.99,\n    \"MAX\" : 0.00,\n    \"DEFAULT\":0.5,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Adjusts the level of motion blur. If in MODE 2 (UP), then it adjusts edge thickness.\",\n    \"UI_GROUP\":\"effects\"\n  },{\n    \"NAME\": \"contrast\",\n    \"MAX\" : 0.0,\n    \"MIN\" : 3.00,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Adjusts the contrast of the underlying image or video.\",\n    \"UI_GROUP\":\"effects\"\n  },{\n    \"NAME\": \"animation_style\",\n    \"MAX\" : 2.9,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.1,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Only works in MODE 1, changes animation style. Set to bottom for none. Set to middle for diamonds. Set to top for waves.\",\n    \"UI_GROUP\":\"animation\"\n  },{\n    \"NAME\": \"manual_animation\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.2,\n    \"TYPE\": \"bang smooth\",\n    \"DESCRIPTION\": \"Hit to create an animation pulse.\",\n    \"UI_GROUP\":\"animation\"\n  }]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuffer","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"// const float PI = 3.141592;\n\nfloat colRegime = mod(color_palette, 10);\n\nvec4 sigmoid(vec4 x){\n  return x/(1.+abs(x));\n}\n\nfloat sigmoid(float x){\n  return x/(1.+abs(x));\n}\n\nvoid fromCentToUV(out vec2 posIn){\n  posIn *= 0.5;\n  posIn += 0.5;\n}\n\nfloat triWave(float var, float period){\n    float up = (abs(mod(var,period))-period/2)/period;\n    float down = (abs(mod(-var,period))-period/2)/period;\n    if (mod(var, period)<period/2){\n        return up;\n    } else {\n        return down;\n    }\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n  // finalCol *= palette(fract(redAmt + grnAmt + bluAmt), vec3(0.420, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.600, 0.250, 1.200), vec3(0.500, 0.450, 0.500));\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0f;\n    x /= w;\n    return 1.0f - x*x*(3.0f-2.0f*x);\n}\n\n/**\n * Detects edges using the Sobel equation\n * @name syn_pass_edgeDetectSobel\n * @param  {sampler2D} smp texture you wish to detect edges on\n * @returns {float} edges\n */\n\nfloat sobel_intensity(in vec4 color){\n  return sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n}\nfloat sobel_helper(float stepx, float stepy, vec2 center, sampler2D tex){\n  // get samples around pixel\n  float tleft = sobel_intensity(texture(tex,center + vec2(-stepx,stepy)));\n  float left = sobel_intensity(texture(tex,center + vec2(-stepx,0)));\n  float bleft = sobel_intensity(texture(tex,center + vec2(-stepx,-stepy)));\n  float top = sobel_intensity(texture(tex,center + vec2(0,stepy)));\n  float bottom = sobel_intensity(texture(tex,center + vec2(0,-stepy)));\n  float tright = sobel_intensity(texture(tex,center + vec2(stepx,stepy)));\n  float right = sobel_intensity(texture(tex,center + vec2(stepx,0)));\n  float bright = sobel_intensity(texture(tex,center + vec2(stepx,-stepy)));\n\n  float x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n  float y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n  float color = sqrt((x*x) + (y*y))*pow((3.0-contrast)/3.0,2.0);\n  return color;\n}\nfloat pass_edgeDetectSobel(sampler2D tex, vec2 texCoords){\n  float stepSize = (1.0+cubicPulse(0.5, 0.4, abs(_uvc.y)-triWave(syn_BassTime*0.25,2*PI))*(0.2+pow(syn_BPMSin2/syn_BPMConfidence,2.0))*syn_BassLevel*30.0)*(1.0-motion_blur)*2.0;\n  vec2 uv = gl_FragCoord.xy / RENDERSIZE.xy;\n  // vec4 color = texture(tex, uv.xy);\n  return sobel_helper(stepSize/RENDERSIZE.x, cubicPulse(0.5, 0.1+0.25*(1.0-abs(_uvc.y)), abs(_uvc.x)+abs(_uvc.y)-fract(syn_HighTime*0.25)*1.5+0.8)*_rand(_pixelate(_uvc.x*_uvc.y+_rand(sin(_uv.y*0.0001+TIME*0.1)), 400.0))*0.05*(0.2+syn_HighHits)+stepSize/RENDERSIZE.y, texCoords, tex);\n}\n\nvec3 colorPaletteChooser(float colReg, float var){\n  vec3 paletteCol = vec3(0.5);\n  if (colReg < 1.0){\n    paletteCol = palette(var, vec3(0.420, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.600, 0.250, 1.200), vec3(0.500, 0.450, 0.500));\n  } else if (colReg < 2.0){\n    paletteCol = palette(var, vec3(0.500, 0.580, 0.500), vec3(0.190, 0.460, 0.500), vec3(0.760, 0.740, 0.580), vec3(1.000, 0.300, 0.490));\n  } else if (colReg < 3.0){\n    paletteCol = palette(1.0-var,vec3(0.500, 0.940, 0.900), vec3(0.600, 0.640, 0.350), vec3(0.680, 1.020, 0.405), vec3(0.380, 0.440, 0.095));\n  } else if (colReg < 4.0){\n    paletteCol = palette(var,vec3(0.500, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.825, 0.750), vec3(0.500, 0.500, 0.500));\n  } else if (colReg < 5.0){\n    paletteCol = palette(1.0-var,vec3(0.000, 0.580, 0.453), vec3(0.848, 0.703, 0.110), vec3(0.700, 0.175, 0.542), vec3(0.000, 0.182, 0.915));\n  } else if (colReg < 6.0){\n    paletteCol = palette(var,vec3(0.129, 0.359, 0.072), vec3(0.933, 0.561, 0.616), vec3(0.334, 1.013, 0.882), vec3(0.597, 0.050, 0.885));\n  } else if (colReg < 7.0){\n    paletteCol = palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.7191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 8.0){\n    paletteCol = palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.2191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 9.0){\n    paletteCol = palette(var,vec3(0.000, 0.040, 0.073), vec3(0.000, 0.530, 0.420), vec3(0.485, 0.930, 0.931), vec3(0.400, 0.599, 0.520));\n  } else if (colReg < 10.0){\n    paletteCol = palette(1.0-var,vec3(1.040, 0.180, 0.260), vec3(0.053, 0.775, 0.330), vec3(0.142, 0.523, 0.800), vec3(0.242, 0.887, 0.000));\n  }\n  return paletteCol;\n}\n\nbool getAnimationMask(){\n  vec2 shape = vec2(-2.0);\n  if (animation_style < 1.0){\n    return false; //do no modification\n  } else if (animation_style < 2.0){\n    vec2 tempPos = _uvc;\n    return fract((0.001+syn_OnBeat+manual_animation)*10.0*(abs(tempPos.x)*(shape.x) + abs(tempPos.y)*shape.y)) < 0.05*abs(tempPos.y);\n  } else if (animation_style < 3.0){\n    vec2 tempPos = _uvc*(-1+(syn_ToggleOnBeat-(1.0-manual_animation)*0.5)*2.0);\n    return (abs(_uvc.x)*fract(pow(syn_OnBeat+manual_animation,1.5)*20.0*dot((abs(tempPos)+0.5+_rand(_uvc)*0.1)*vec2(shape),abs(tempPos)*vec2(shape))) > 2.0*abs(tempPos.y));\n  }\n}\n\nvec2 offsetTex(){\n  return -_uv+((_uvc*vec2(1.0, RENDERSIZE.x/RENDERSIZE.y))*vec2((1.0+syn_BPMSin4*0.15), (1.0+syn_BPMSin4*0.125))+0.5)*0.5+0.25;\n}\n\nvec4 firstPass() {\n  vec4 oldCol = texture(firstBuffer, _uv);\n  vec4 newCol = vec4(0.0);\n  if (syn_MediaType < 0.5){\n    newCol = vec4(0.0);\n  } else if (syn_MediaType < 1.5){\n    newCol = vec4(_loadUserImage(offsetTex()).rgb, 1.0);\n  } else if (syn_MediaType < 3.5){\n    newCol = vec4(_loadUserImage().rgb, 1.0);\n  }\n\n  if (getAnimationMask()){\n    oldCol = 1.0-oldCol;\n    newCol = 1.0-newCol;\n  }\n\n  // vec4 retCol = oldCol;\n  // if (_rand(_pixelate(_uvc+syn_BeatTime,100.0))>0.5){\n  //   retCol = _loadUserImage();\n  // }\n\n  return vec4(mix(oldCol.rgb, newCol.rgb, motion_blur*motion_blur*motion_blur), oldCol.a);\n  // return retCol;\n}\n\nvec4 secondPass() {\n  vec4 oldCol = texture(firstBuffer, _uv);\n  vec4 newCol = vec4(0.0);\n  if (syn_MediaType < 0.5){\n    newCol = vec4(0.0);\n  } else if (syn_MediaType < 1.5){\n    newCol = vec4(_loadUserImage(offsetTex()).rgb, 1.0);\n  } else if (syn_MediaType < 3.5){\n    newCol = vec4(_loadUserImage().rgb, 1.0);\n  }\n  vec3 maxCol = max(oldCol.rgb, newCol.rgb);\n  vec3 minCol = min(oldCol.rgb, newCol.rgb);\n\n  vec3 colDiff = pow(maxCol-minCol,vec3(contrast));\n  float colPicker = clamp(length(colDiff),0.0,1.0);\n  colPicker = colPicker+color_oscillator*colPicker*sin(_uvc.y+TIME*0.2);\n  if (colPicker > 1) colPicker = 1.0-(colPicker-1);\n\n\n  vec3 paletteCol = vec3(0.0);\n  if (invert_regime > 0.5){\n    colPicker = 1.0-colPicker;\n  }\n  paletteCol = colorPaletteChooser(colRegime, colPicker);\n\n  return vec4(paletteCol, 0.0);\n}\n\nvec4 thirdPass() {\n  vec4 mainImg = texture(secondBuffer, _uv);\n  float edges = pass_edgeDetectSobel(syn_UserImage, _invertYAxisVideo(_correctImageCoords(textureSize(syn_UserImage,0))));\n\n  float colPicker = clamp(edges*0.5,0.0,1.0);\n  colPicker = colPicker+syn_Presence*colPicker*sin(_uvc.y)+color_oscillator*colPicker*sin(_uvc.y+TIME*0.2);\n  colPicker = clamp(colPicker, 0.0, 1.0);\n  if (invert_regime > 0.5){\n    colPicker = 1.0-colPicker;\n  }\n\n  // if (getAnimationMask()){\n  //   colPicker = abs(0.5-colPicker*0.5);\n  // }\n\n  vec3 paletteCol = colorPaletteChooser(colRegime, colPicker);\n  // return vec4(mainImg.a);\n  return MODE_1_OR_2 < 0.5 ? vec4(paletteCol,0.0) : mainImg;\n}\n\nvec4 renderMain () {\n  if (PASSINDEX == 0.0){\n    return firstPass();\n  }\n  else if (PASSINDEX == 1.0){\n    return secondPass();\n  } else if (PASSINDEX == 2.0){\n    return thirdPass();\n  }\n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Filter Blown","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.25,"DESCRIPTION":"Turn down for softer look, up for crisper edges. Default: 50%.","MAX":0,"MIN":0.5,"NAME":"sharpness","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"tunnel"},{"DEFAULT":1,"DESCRIPTION":"Turn up to decrease diameter of tunnel, constricting it, or turn down to make it wider. Default: 50%.","MAX":2,"MIN":0,"NAME":"constriction","TYPE":"slider","UI_GROUP":"tunnel"},{"DEFAULT":1,"DESCRIPTION":"Turn up for noisier tunnel, or all the way down for just the smooth geometric tunnel, no cloud-like noise.","MAX":2,"MIN":0,"NAME":"noise","TYPE":"slider","UI_GROUP":"tunnel"},{"DEFAULT":1,"DESCRIPTION":"Turn up to change it from a tunnel to just two planes. Once it is planes, try playing with the 'twist' slider.","MAX":0.5,"MIN":1,"NAME":"planes_only","TYPE":"slider","UI_GROUP":"tunnel"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Determines how much the bass will make you travel forward. Default: 25%.","MAX":0.800000011920929,"MIN":0,"NAME":"auto_in","TYPE":"slider","UI_GROUP":"speed"},{"DEFAULT":0,"DESCRIPTION":"Additional, constant motion forward or backwards. Turn auto_in all the way down and just use this slider for full manual control.","MAX":1,"MIN":0,"NAME":"const_speed","PARAMS":0.119999997317791,"TYPE":"slider traveler","UI_GROUP":"speed"},{"DEFAULT":1,"DESCRIPTION":"Field of view. Default: 50%.","MAX":2,"MIN":0.0299999993294477,"NAME":"fov","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Add a twist to the tunnel's geometry.","MAX":1,"MIN":-1,"NAME":"twist","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"rotation"},{"DEFAULT":0,"DESCRIPTION":"Add a spin to the camera, forward for clockwise. Default: 50%.","MAX":1,"MIN":0,"NAME":"spin","PARAMS":0.00999999977648258,"TYPE":"slider traveler","UI_GROUP":"rotation"}],"CREDIT":"aiekick","DESCRIPTION":"Fire Tunnel","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\fire_tunnel.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Fire Tunnel","IMAGES":[{"NAME":"image30","PATH":"images/30.png"}],"IMAGE_PATH":"fire_tunnel.synScene\\fire_tunnel.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n   {\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"Turn down for softer look, up for crisper edges. Default: 50%.\",\n         \"MAX\" : 0.0,\n         \"MIN\" : 0.5,\n         \"NAME\" : \"sharpness\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"tunnel\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Turn up to decrease diameter of tunnel, constricting it, or turn down to make it wider. Default: 50%.\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"constriction\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"tunnel\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Turn up for noisier tunnel, or all the way down for just the smooth geometric tunnel, no cloud-like noise.\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"noise\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"tunnel\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Turn up to change it from a tunnel to just two planes. Once it is planes, try playing with the 'twist' slider.\",\n         \"MAX\" : 0.5,\n         \"MIN\" : 1.0,\n         \"NAME\" : \"planes_only\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"tunnel\"\n      },{\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"Determines how much the bass will make you travel forward. Default: 25%.\",\n         \"MAX\" : 0.8,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_in\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"speed\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Additional, constant motion forward or backwards. Turn auto_in all the way down and just use this slider for full manual control.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"const_speed\",\n         \"TYPE\" : \"slider traveler\",\n         \"PARAMS\":0.12,\n         \"UI_GROUP\" : \"speed\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Field of view. Default: 50%.\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.03,\n         \"NAME\" : \"fov\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Add a twist to the tunnel's geometry.\",\n         \"NAME\" : \"twist\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"rotation\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Add a spin to the camera, forward for clockwise. Default: 50%.\",\n         \"NAME\" : \"spin\",\n         \"TYPE\" : \"slider traveler\",\n         \"PARAMS\":0.01,\n         \"UI_GROUP\" : \"rotation\"\n      }\n   ],\n   \"CREDIT\" : \"aiekick\",\n   \"DESCRIPTION\" : \"Fire Tunnel\",\n   \"WIDTH\" : 1920,\n   \"HEIGHT\" : 1080,\n   \"PASSES\":[{\"TARGET\":\"tunnelPass\", \"HEIGHT\":360, \"WIDTH\":640}],\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image30\",\n         \"PATH\" : \"images/30.png\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"fire_tunnel.png\",\n   \"TITLE\" : \"Fire Tunnel\"\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":360,"TARGET":"tunnelPass","WIDTH":640}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nvar bpmcount = new BPMCounter();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar bpmTime = 0;\nvar bassT = 0.0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM/4.0;\n  bpmcount.updateTime(bpm, dt);\n\n  uniforms.script_time = bpmcount.time;\n\n\n  // if (bpmcount.didIncrement == 1.0){\n  //   tAtLast0 = bpmTime;\n  // }\n  // bpmTime = tAtLast0;\n  // bpmTime += (1. - Math.exp(-bpmcount.timeWithinBeat*3.))*inputs.amount_to_step;\n  // uniforms.script_time = bpmTime;\n\n  bassT = bassT + Math.pow(inputs.syn_BassLevel,1.9)*(dt*60)*inputs.auto_in*2.0;\n  uniforms.script_bass_time = bassT;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"vec3 filter_() {\n  vec2 delta = 1. / RENDERSIZE;\n  \n  vec3 val = texture(tunnelPass, _uv).xyz;\n\n\n  vec3 l = texture(tunnelPass, _uv + vec2(0., delta.y)).xyz;\n  vec3 r = texture(tunnelPass, _uv - vec2(0., delta.y)).xyz;\n  vec3 u = texture(tunnelPass, _uv + vec2(delta.x, 0.)).xyz;\n  vec3 d = texture(tunnelPass, _uv - vec2(delta.x, 0.)).xyz;\n\n  vec3 n = vec3(_rand(_uvc+fract(TIME))) - 0.5;\n  \n  vec3 bloom = max(val, max(max(l, r), max( u, d)));\n  bloom = bloom  + l + r + u + d;\n  bloom /= 5.; // orlando;\n  return bloom + n/9.;\n\n}\n\n// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* \n\tvariation more cloudy off Another Cloudy Tunnel 3 : \n\t\thttps://www.shadertoy.com/view/ltBSzV\n\n\tthe cloudy famous tech come from the shader of duke : https://www.shadertoy.com/view/MljXDw\n        Himself a Port of a demo by Las => http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n*/\n\nfloat t;\nfloat cosPath(vec3 p, vec3 dec){return dec.x * cos(p.z * dec.y + dec.z);}\nfloat sinPath(vec3 p, vec3 dec){return dec.x * sin(p.z * dec.y + dec.z);}\n#define Tunnel(p,pos,c,s) p.xy-pos-vec2(cosPath(p, c)*0.5,sinPath(p, s)*0.5)\n\nvec3 getHotColor(float Temp)\n{\n\tvec3 col = vec3(255.);\n\tcol.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n\tif (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod(image30, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.y, rg.x, f.z );\n}\nfloat planesMod = pow(planes_only, 10.0);\nfloat df(vec3 p)\n{\n\tfloat pnNoise = pn(p*.26)*1.98 + pn(p*.26)*.62 + pn(p*1.17)*.39;\n\tfloat path = sinPath(p ,vec3(5.704,0.3828,0.16));\n    float bt = min(p.y, -p.y) + 12.;\n\tfloat df;\n    vec4 vec, var;\n\tfor (float i=0.;i<4.;i++)\n\t{\n\t\tvar = vec4(0.35,2.5,5.8,0) + vec4(0.5,0.06,0,5) * i;\n\t\tvec.xy = Tunnel(p, vec2(path, 0.), var.xyz, var.zxy);\n\t\tdf = var.w - min(length(vec.xy), length(vec.zw));\n\t\tvec.zw = mix(vec.zw, vec.xy, planesMod);\t\n\t}\n\treturn min(df, bt) + pnNoise*noise;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv, float fov)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu, rov));\n    vec3 v = normalize(cross(rov, u));\n    vec3 rd = normalize(rov + fov*u*uv.x + fov*v*uv.y);\n    return rd;\n}\n\nvec4 march(vec4 f, vec3 ro, vec3 rd, float st)\n{\n\tfloat s = 1., h = .25*constriction, td = 0.0, d=1.,dl=0.2, w;\n\tvec3 p = ro;\n\tfor(float i=0.;i<100.0;i++)\n\t{      \n\t\tp.xy = mix(p.xy, _rotate(p.xy, p.z), twist);\n\t\tif(s<0.01||d>50.||td>.95) break;\n        s = df(p) * .09 * i/50.;\n\t\tif (s < h)\n\t\t{\n\t\t\tw = (1.-td) * (h-s) * i/60.;\n\t\t\tf.rgb += texture(syn_UserImage, p.xz*0.01+p.y*0.01).rgb*0.02*(syn_HighPresence+syn_HighHits*2.0)*_pulse(fract(p.y*0.1-TIME), 0.5, 0.5);\n\t\t\tf.rgb += getHotColor(td*i*70.)*mix(w, (0.05-w), syn_BassPresence*(syn_BassLevel+syn_BassHits)*_pulse(fract(p.z*0.1-TIME), 0.5, 0.5));\n\t\t\ttd += w;\n\t\t}\n\t\tdl += 1.01 - exp(-0.001 * log(d));\t\n\t\ttd += 0.01;\n\t\ts = max(s, st);\n\t\td+=s;\n\t\tp = ro+rd*d;\t\n   \t}\n\tf.rgb = mix( f.rgb, vec3(0), 1.0 - exp( -0.002*d*d) )/dl; // fog\n\treturn f;\n}\n\nvec4 renderMainImage() {\n\tvec4 f = vec4(0.0);\n\tvec2 g = _xy;\n\n\t\tt = script_bass_time*0.1+TIME*0.1+const_speed;\n\t\tf = vec4(syn_MidPresence*0.25,0.15,0.32,1);\n\t  vec2 q = g/RENDERSIZE.xy;\n\t  vec3 ro = vec3(cos(t*.3), sin(t*.2),t )*vec3(8.5, 8.5, 5.)*0.4;\n\t\tvec3 rd = cam((2.*g-RENDERSIZE.xy)/RENDERSIZE.y, ro, vec3(0,1,0), ro + vec3(0,0,1), 3.5*fov);\n\n    rd.xy = _rotate(rd.xy, -spin*PI);\n\n\t\tf = march(f, ro, rd, sharpness+0.01);\n\t  f.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 ); // iq vignette\n\n\treturn f; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n\tif (PASSINDEX == 1){\n\t\treturn vec4(filter_(), 1.0);\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Fire Tunnel","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.25,"DESCRIPTION":"fluid-like motion","MAX":1,"MIN":0.0199999995529652,"NAME":"flow","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0.5,"DESCRIPTION":"modulate flow by audio","MAX":1,"MIN":0,"NAME":"pulse","TYPE":"knob","UI_GROUP":"motion"},{"DEFAULT":[1,1],"DESCRIPTION":"damp motion at largest scale","MAX":[2,2],"MIN":[0,0],"NAME":"drift","TYPE":"xy","UI_GROUP":"motion"},{"DEFAULT":0.25,"DESCRIPTION":"smooth out motion in time","MAX":1,"MIN":0,"NAME":"momentum","TYPE":"knob","UI_GROUP":"motion"},{"DEFAULT":1,"DESCRIPTION":"emphasize smaller or large scale motion","MAX":2,"MIN":0,"NAME":"scale_factor","TYPE":"knob","UI_GROUP":"motion"},{"DEFAULT":[0,0],"DESCRIPTION":"cycle colors","MAX":[1,1],"MIN":[0,0],"NAME":"color_rotate","TYPE":"xy","UI_GROUP":"color"},{"DEFAULT":0.5,"DESCRIPTION":"color mutation","MAX":1,"MIN":0,"NAME":"coruscate","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"auto color rotate - x","MAX":1,"MIN":0,"NAME":"flash_x","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"auto color rotate - y","MAX":1,"MIN":0,"NAME":"flash_y","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"change color palette","MAX":1,"MIN":0,"NAME":"chromatic","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"impulse to flow, push, momentum","MAX":1,"MIN":0,"NAME":"zap","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"perform"},{"DEFAULT":0,"DESCRIPTION":"instantaneous circular distortion","MAX":1,"MIN":0,"NAME":"lens","PARAMS":0.00100000004749745,"TYPE":"bang smooth","UI_GROUP":"perform"},{"DEFAULT":0,"DESCRIPTION":"reset to horizontal bars","MAX":1,"MIN":0,"NAME":"bars","TYPE":"bang","UI_GROUP":"perform"}],"CREDIT":"Victor S.","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\fluid_body.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Fluid Body","IMAGES":null,"IMAGE_PATH":"fluid_body.synScene\\fluid_body.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"fluid-like motion\",\n         \"MAX\" : 1,\n         \"MIN\" : 0.02,\n         \"NAME\" : \"flow\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"motion\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"cycle colors\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"color_rotate\",\n         \"TYPE\" : \"xy\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"color mutation\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"coruscate\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"modulate flow by audio\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pulse\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"motion\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"auto color rotate - x\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flash_x\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"auto color rotate - y\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flash_y\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"impulse to flow, push, momentum\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"PARAMS\": 0.2,\n         \"NAME\" : \"zap\",\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"perform\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"change color palette\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"chromatic\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"damp motion at largest scale\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"drift\",\n         \"TYPE\" : \"xy\",\n         \"UI_GROUP\" : \"motion\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"instantaneous circular distortion\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"PARAMS\": 0.001,\n         \"NAME\" : \"lens\",\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"perform\"\n      },\n      {\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"smooth out motion in time\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"momentum\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"motion\"\n      },\n      {\n        \"DEFAULT\" : 1,\n        \"DESCRIPTION\" : \"emphasize smaller or large scale motion\",\n        \"MAX\" : 2,\n        \"MIN\" : 0,\n        \"NAME\" : \"scale_factor\",\n        \"TYPE\" : \"knob\",\n        \"UI_GROUP\" : \"motion\"\n      },\n      {\n        \"DEFAULT\" : 0,\n        \"DESCRIPTION\" : \"reset to horizontal bars\",\n        \"MAX\" : 1,\n        \"MIN\" : 0,\n        \"NAME\" : \"bars\",\n        \"TYPE\" : \"bang\",\n        \"UI_GROUP\" : \"perform\"\n      }\n   ],\n   \"CREDIT\" : \"Victor S.\",\n   \"DESCRIPTION\" : \"\",\n   \"WIDTH\" : 1920,\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"fluid_body.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1024,\n         \"TARGET\" : \"fb0\",\n         \"WIDTH\" : 1792\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1024,\n         \"TARGET\" : \"fb1\",\n         \"WIDTH\" : 1792\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 512,\n         \"TARGET\" : \"flow1\",\n         \"WIDTH\" : 896\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 256,\n         \"TARGET\" : \"flow2\",\n         \"WIDTH\" : 448\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 128,\n         \"TARGET\" : \"flow3\",\n         \"WIDTH\" : 224\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 64,\n         \"TARGET\" : \"flow4\",\n         \"WIDTH\" : 112\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 32,\n         \"TARGET\" : \"flow5\",\n         \"WIDTH\" : 56\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 16,\n         \"TARGET\" : \"flow6\",\n         \"WIDTH\" : 28\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 8,\n         \"TARGET\" : \"flow7\",\n         \"WIDTH\" : 14\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 4,\n         \"TARGET\" : \"flow8\",\n         \"WIDTH\" : 7\n      }\n   ],\n   \"TITLE\" : \"Fluid Body\"\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1024,"TARGET":"fb0","WIDTH":1792},{"FLOAT":true,"HEIGHT":1024,"TARGET":"fb1","WIDTH":1792},{"FLOAT":true,"HEIGHT":512,"TARGET":"flow1","WIDTH":896},{"FLOAT":true,"HEIGHT":256,"TARGET":"flow2","WIDTH":448},{"FLOAT":true,"HEIGHT":128,"TARGET":"flow3","WIDTH":224},{"FLOAT":true,"HEIGHT":64,"TARGET":"flow4","WIDTH":112},{"FLOAT":true,"HEIGHT":32,"TARGET":"flow5","WIDTH":56},{"FLOAT":true,"HEIGHT":16,"TARGET":"flow6","WIDTH":28},{"FLOAT":true,"HEIGHT":8,"TARGET":"flow7","WIDTH":14},{"FLOAT":true,"HEIGHT":4,"TARGET":"flow8","WIDTH":7}],"SCRIPT_CODE":"var framecount = 0;\nvar prev_BPMTri = 0;\n// factors to compute slowed BPMTri LFOs for, as rationals\nvar slow_BPMTri = [\n  // [1, 8],\n  // [1, 4],\n  // [1, 3],\n  // [1, 2], //double speed\n  [1], // should match syn_BPMTri\n  // [3, 2],\n  [2], //half speed (should match syn_BPMTri2)\n  // [3], //third speed etc\n  [4]\n];\nvar phi_BPMTri = Array.apply(null, Array(slow_BPMTri.length)).map(function() { return 0 });\n\nfunction clamp(x, lo, hi) {\n  return Math.max(Math.min(x, hi), lo)\n}\n\nfunction scale(x, lo, hi) {\n  return x * (hi - lo) + lo;\n}\n\nfunction fract(x) {\n  return x - Math.floor(x);\n}\n\nfunction getSpectrum() {\n  var highs = inputs.syn_HighHits;\n  var highmids = inputs.syn_MidHighLevel;\n  var mids = inputs.syn_MidLevel;\n  var bass = inputs.syn_BassHits;\n  return [bass, mids, highmids, highs];\n}\n\nfunction update(dt) {\n  getSpectrum().forEach(function(el, i) {\n    uniforms['spectrum_' + i] = el\n  })\n\n  var BPMTri = (inputs.syn_BPMTri / inputs.syn_BPMConfidence) || 0;\n  var delta_BPMTri = fract(BPMTri - prev_BPMTri);\n  slow_BPMTri.forEach(function(r, i) {\n    var num = r[0];\n    var denom = r[1] || 1;\n    phi_BPMTri[i] = fract(phi_BPMTri[i] + delta_BPMTri * denom / num);\n    uniforms['BPMTri' + num + (denom == 1 ? '' : '_' + denom)] = phi_BPMTri[i];\n  });\n\n  prev_BPMTri = BPMTri;\n\n  framecount++;\n}","SHADER_CODE":"vec4 spectrum = vec4(spectrum_0, spectrum_1, spectrum_2, spectrum_3);\n\nconst float pi = 3.14159265359;\nconst float eps = 1e-15;\n\n/*\nHSLUV-GLSL v4.2\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\n// vec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n//     return (line1y - line2y) / (line2x - line1x);\n// }\n//\n// vec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n//     return sqrt(pointx*pointx + pointy*pointy);\n// }\n//\n// vec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n//     vec3 len = y / (sin(theta) - x * cos(theta));\n//     if (len.r < 0.0) {len.r=1000.0;}\n//     if (len.g < 0.0) {len.g=1000.0;}\n//     if (len.b < 0.0) {len.b=1000.0;}\n//     return len;\n// }\n//\n// float hsluv_maxSafeChromaForL(float L){\n//     mat3 m2 = mat3(\n//          3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n//         -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n//         -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786\n//     );\n//     float sub0 = L + 16.0;\n//     float sub1 = sub0 * sub0 * sub0 * .000000641;\n//     float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n//\n//     vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n//     vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n//     vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n//\n//     vec3 bounds0x = top1 / bottom;\n//     vec3 bounds0y = top2 / bottom;\n//\n//     vec3 bounds1x =              top1 / (bottom+126452.0);\n//     vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n//\n//     vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n//     vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n//\n//     vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n//     vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n//\n//     return  min(lengths0.r,\n//             min(lengths1.r,\n//             min(lengths0.g,\n//             min(lengths1.g,\n//             min(lengths0.b,\n//                 lengths1.b)))));\n// }\n//\n// float hsluv_maxChromaForLH(float L, float H) {\n//\n//     float hrad = radians(H);\n//\n//     mat3 m2 = mat3(\n//          3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,\n//         -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,\n//         -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786\n//     );\n//     float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n//     float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n//\n//     vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n//     vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n//     vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n//\n//     vec3 bound0x = top1 / bottom;\n//     vec3 bound0y = top2 / bottom;\n//\n//     vec3 bound1x =              top1 / (bottom+126452.0);\n//     vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n//\n//     vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n//     vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n//\n//     return  min(lengths0.r,\n//             min(lengths1.r,\n//             min(lengths0.g,\n//             min(lengths1.g,\n//             min(lengths0.b,\n//                 lengths1.b)))));\n// }\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\nvec3 hsluv_fromLinear(vec3 c) {\n    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\n// float hsluv_yToL(float Y){\n//     return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n// }\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    const mat3 m = mat3(\n        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,\n       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,\n        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );\n\n    return hsluv_fromLinear(tuple*m);\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    const mat3 m = mat3(\n        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,\n        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,\n        0.019330818715591851, 0.11919477979462599, 0.95053215224966058\n    );\n    return hsluv_toLinear(tuple) * m;\n}\n//\n// vec3 xyzToLuv(vec3 tuple){\n//     float X = tuple.x;\n//     float Y = tuple.y;\n//     float Z = tuple.z;\n//\n//     float L = hsluv_yToL(Y);\n//\n//     float div = 1./dot(tuple,vec3(1,15,3));\n//\n//     return vec3(\n//         1.,\n//         (52. * (X*div) - 2.57179),\n//         (117.* (Y*div) - 6.08816)\n//     ) * L;\n// }\n\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float U = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float V = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 2.25 * U * Y / V;\n    float Z = (3./V - 5.)*Y - (X/3.);\n\n    return vec3(X, Y, Z);\n}\n\n// vec3 luvToLch(vec3 tuple) {\n//     float L = tuple.x;\n//     float U = tuple.y;\n//     float V = tuple.z;\n//\n//     float C = length(tuple.yz);\n//     float H = degrees(atan(V,U));\n//     if (H < 0.0) {\n//         H = 360.0 + H;\n//     }\n//\n//     return vec3(L, C, H);\n// }\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\n// vec3 hsluvToLch(vec3 tuple) {\n//     tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;\n//     return tuple.bgr;\n// }\n//\n// vec3 lchToHsluv(vec3 tuple) {\n//     tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;\n//     return tuple.bgr;\n// }\n//\n// vec3 hpluvToLch(vec3 tuple) {\n//     tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;\n//     return tuple.bgr;\n// }\n//\n// vec3 lchToHpluv(vec3 tuple) {\n//     tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;\n//     return tuple.bgr;\n// }\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n\n}\n\n// vec3 rgbToLch(vec3 tuple) {\n//     return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n// }\n//\n// vec3 hsluvToRgb(vec3 tuple) {\n//     return lchToRgb(hsluvToLch(tuple));\n// }\n//\n// vec3 rgbToHsluv(vec3 tuple) {\n//     return lchToHsluv(rgbToLch(tuple));\n// }\n//\n// vec3 hpluvToRgb(vec3 tuple) {\n//     return lchToRgb(hpluvToLch(tuple));\n// }\n//\n// vec3 rgbToHpluv(vec3 tuple) {\n//     return lchToHpluv(rgbToLch(tuple));\n// }\n//\n// vec3 luvToRgb(vec3 tuple){\n//     return xyzToRgb(luvToXyz(tuple));\n// }\n\n// allow vec4's\nvec4   xyzToRgb(vec4 c) {return vec4(   xyzToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4   rgbToXyz(vec4 c) {return vec4(   rgbToXyz( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4   xyzToLuv(vec4 c) {return vec4(   xyzToLuv( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   luvToXyz(vec4 c) {return vec4(   luvToXyz( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4   luvToLch(vec4 c) {return vec4(   luvToLch( vec3(c.x,c.y,c.z) ), c.a);}\nvec4   lchToLuv(vec4 c) {return vec4(   lchToLuv( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 hsluvToLch(vec4 c) {return vec4( hsluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 lchToHsluv(vec4 c) {return vec4( lchToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 hpluvToLch(vec4 c) {return vec4( hpluvToLch( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 lchToHpluv(vec4 c) {return vec4( lchToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4   lchToRgb(vec4 c) {return vec4(   lchToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4   rgbToLch(vec4 c) {return vec4(   rgbToLch( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 hsluvToRgb(vec4 c) {return vec4( hsluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 rgbToHsluv(vec4 c) {return vec4( rgbToHsluv( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 hpluvToRgb(vec4 c) {return vec4( hpluvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4 rgbToHpluv(vec4 c) {return vec4( rgbToHpluv( vec3(c.x,c.y,c.z) ), c.a);}\n// vec4   luvToRgb(vec4 c) {return vec4(   luvToRgb( vec3(c.x,c.y,c.z) ), c.a);}\n// allow 3 floats\nvec3   xyzToRgb(float x, float y, float z) {return   xyzToRgb( vec3(x,y,z) );}\n// vec3   rgbToXyz(float x, float y, float z) {return   rgbToXyz( vec3(x,y,z) );}\n// vec3   xyzToLuv(float x, float y, float z) {return   xyzToLuv( vec3(x,y,z) );}\nvec3   luvToXyz(float x, float y, float z) {return   luvToXyz( vec3(x,y,z) );}\n// vec3   luvToLch(float x, float y, float z) {return   luvToLch( vec3(x,y,z) );}\nvec3   lchToLuv(float x, float y, float z) {return   lchToLuv( vec3(x,y,z) );}\n// vec3 hsluvToLch(float x, float y, float z) {return hsluvToLch( vec3(x,y,z) );}\n// vec3 lchToHsluv(float x, float y, float z) {return lchToHsluv( vec3(x,y,z) );}\n// vec3 hpluvToLch(float x, float y, float z) {return hpluvToLch( vec3(x,y,z) );}\n// vec3 lchToHpluv(float x, float y, float z) {return lchToHpluv( vec3(x,y,z) );}\n// vec3   lchToRgb(float x, float y, float z) {return   lchToRgb( vec3(x,y,z) );}\n// vec3   rgbToLch(float x, float y, float z) {return   rgbToLch( vec3(x,y,z) );}\n// vec3 hsluvToRgb(float x, float y, float z) {return hsluvToRgb( vec3(x,y,z) );}\n// vec3 rgbToHsluv(float x, float y, float z) {return rgbToHsluv( vec3(x,y,z) );}\n// vec3 hpluvToRgb(float x, float y, float z) {return hpluvToRgb( vec3(x,y,z) );}\n// vec3 rgbToHpluv(float x, float y, float z) {return rgbToHpluv( vec3(x,y,z) );}\n// vec3   luvToRgb(float x, float y, float z) {return   luvToRgb( vec3(x,y,z) );}\n// allow 4 floats\nvec4   xyzToRgb(float x, float y, float z, float a) {return   xyzToRgb( vec4(x,y,z,a) );}\n// vec4   rgbToXyz(float x, float y, float z, float a) {return   rgbToXyz( vec4(x,y,z,a) );}\n// vec4   xyzToLuv(float x, float y, float z, float a) {return   xyzToLuv( vec4(x,y,z,a) );}\nvec4   luvToXyz(float x, float y, float z, float a) {return   luvToXyz( vec4(x,y,z,a) );}\n// vec4   luvToLch(float x, float y, float z, float a) {return   luvToLch( vec4(x,y,z,a) );}\nvec4   lchToLuv(float x, float y, float z, float a) {return   lchToLuv( vec4(x,y,z,a) );}\n// vec4 hsluvToLch(float x, float y, float z, float a) {return hsluvToLch( vec4(x,y,z,a) );}\n// vec4 lchToHsluv(float x, float y, float z, float a) {return lchToHsluv( vec4(x,y,z,a) );}\n// vec4 hpluvToLch(float x, float y, float z, float a) {return hpluvToLch( vec4(x,y,z,a) );}\n// vec4 lchToHpluv(float x, float y, float z, float a) {return lchToHpluv( vec4(x,y,z,a) );}\n// vec4   lchToRgb(float x, float y, float z, float a) {return   lchToRgb( vec4(x,y,z,a) );}\n// vec4   rgbToLch(float x, float y, float z, float a) {return   rgbToLch( vec4(x,y,z,a) );}\n// vec4 hsluvToRgb(float x, float y, float z, float a) {return hsluvToRgb( vec4(x,y,z,a) );}\n// vec4 rgbToHslul(float x, float y, float z, float a) {return rgbToHsluv( vec4(x,y,z,a) );}\n// vec4 hpluvToRgb(float x, float y, float z, float a) {return hpluvToRgb( vec4(x,y,z,a) );}\n// vec4 rgbToHpluv(float x, float y, float z, float a) {return rgbToHpluv( vec4(x,y,z,a) );}\n// vec4   luvToRgb(float x, float y, float z, float a) {return   luvToRgb( vec4(x,y,z,a) );}\n\n/*\nEND HSLUV-GLSL\n*/\n\nfloat pulse_ = zap + pulse\n  * abs(length(sqrt(spectrum.xxyz*spectrum.xyzw)*vec4(1.5,1,.5,.25))-.1);\nfloat zap_ = zap;\n\nvec4 circleDiff(vec4 a, vec4 b){\n  return fract(a-b+.5)-.5;\n}\nvec4 circleDist(vec4 a, vec4 b){\n  return abs(circleDiff(a, b));\n}\n\nvec4 initialCondition(){\n  // return .5+.5*cos(2*pi*(vec4(0, 0.75, 0.5, 0.25)+dot(_uvc, _uvc)));\n  vec4 s = vec4(\n    _noise(FRAMECOUNT), _noise(2*FRAMECOUNT),\n    _noise(3*FRAMECOUNT), _noise(4*FRAMECOUNT));\n  return .5+.5*cos(2*pi*(_uv.y+s));\n}\n\nvec4 media_features(){\n  vec3 media = rgbToXyz(_loadUserImage().rgb);\n  vec3 dx = dFdx(media);\n  vec3 sgn = sign(dx);\n  dx *= sgn;\n  vec3 dy = dFdy(media)*sgn;\n  return vec4(\n    dot(vec3(1), dx),\n    dot(vec3(1), dy),\n    (media.xz - vec2(.31, .35))*sqrt(media.z)\n    );\n}\n\nvec2 flowRule(vec4 s){\n  vec2 r = (\n    12*sin(2*pi*(2*s.b+vec2(0, .25)))\n    + 6*cos(2*pi*(3*s.a+vec2(0, .25)))\n    - 4*sin(2*pi*(5*s.g+vec2(0, .25)))\n    - 3*cos(2*pi*(7*s.r+vec2(0, .25)))\n    )/25;\n\n  r*=pow(2, -2*dot(_uvc, _uvc));\n  return r;\n}\n\nvec4 lerp4(in vec4 v00, in vec4 v01, in vec4 v10, in vec4 v11, in vec2 m){\n  return mix(mix(v00, v01, m.y), mix(v10, v11, m.y), m.x);\n}\n\n//assume premultiplied by 2pi for efficiency\nvec4 circleLerp(in vec4 v00, in vec4 v01, in vec4 v10, in vec4 v11, in vec2 m){\n  return fract(atan(\n    lerp4(sin(v00), sin(v01), sin(v10), sin(v11), m),\n    lerp4(cos(v00), cos(v01), cos(v10), cos(v11), m)\n    )/pi/2);\n}\n\nvec4 circleTexture(in sampler2D state, in vec2 p){\n  ivec2 ts = textureSize(state, 0);\n  vec2 xy = ts*(p+1)-0.5;\n  ivec2 ixy = ivec2(xy);\n  vec2 m = fract(xy);\n  return circleLerp(\n    2*pi*texelFetch(state, ixy%ts, 0),\n    2*pi*texelFetch(state, (ixy+ivec2(0,1))%ts, 0),\n    2*pi*texelFetch(state, (ixy+ivec2(1,0))%ts, 0),\n    2*pi*texelFetch(state, (ixy+ivec2(1,1))%ts, 0),\n    m);\n}\n\nmat4 texel4(in sampler2D state, in vec2 xy){\n  ivec2 ixy = ivec2(xy);\n  ivec2 ts = textureSize(state, 0);\n  return mat4(\n    texelFetch(state, ixy%ts, 0),\n    texelFetch(state, (ixy+ivec2(0,1))%ts, 0),\n    texelFetch(state, (ixy+ivec2(1,0))%ts, 0),\n    texelFetch(state, (ixy+ivec2(1,1))%ts, 0));\n}\n\nmat4 initFlow(sampler2D state, ivec2 p){\n  mat4 c = texel4(state, p);\n  vec4 m = media_features();\n  return mat4(\n    vec4(flowRule(c[0])+m.zw, m.xy),\n    vec4(flowRule(c[1])+m.zw, m.xy),\n    vec4(flowRule(c[2])+m.zw, m.xy),\n    vec4(flowRule(c[3])+m.zw, m.xy)\n    );\n}\n\nvec4 stepFlow(in sampler2D state, in sampler2D fine, bool init){\n  float momentum_ = momentum\n    * pow(2, -4*pulse_)\n    * float(lens<=1.0)*max(1-zap_, 0);\n\n  mat4 corners;\n  vec4 r_fine;\n\n  if(init)\n    corners = initFlow(fine, ivec2(_xy)*2);\n  else\n    corners = texel4(fine, ivec2(_xy)*2);\n\n  vec4 w = exp(vec4(\n    length(corners[0].zw),\n    length(corners[1].zw),\n    length(corners[2].zw),\n    length(corners[3].zw)\n    ));\n  w /= dot(vec4(1), w);\n  r_fine.zw =\n    w[0]*corners[0].zw + w[1]*corners[1].zw\n    + w[2]*corners[2].zw + w[3]*corners[3].zw;\n  r_fine.zw /= sqrt(length(r_fine.zw)) + 1e-5;\n\n  r_fine.xy = (\n    corners[0].xy\n    + corners[1].xy\n    + corners[2].xy\n    + corners[3].xy)/4;\n\n  r_fine.xy = r_fine.xy - dot(r_fine.xy, r_fine.zw)*r_fine.zw;\n\n  vec4 r = mix(\n    texelFetch(state, ivec2(_xy), 0), r_fine, 1-momentum_);\n  return r;\n}\n\nvec4 aggregate(sampler2D fb){\n  vec2 p = _uv;\n\n  vec2 d[8];\n  d[0] = texture(flow1, p).xy;\n  d[1] = texture(flow2, p).xy;\n  d[2] = texture(flow3, p).xy;\n  d[3] = texture(flow4, p).xy;\n  d[4] = texture(flow5, p).xy;\n  d[5] = texture(flow6, p).xy;\n  d[6] = texture(flow7, p).xy;\n  d[7] = texture(flow8, p).xy;\n\n  // vec4 w = pow(vec4(2), spectrum.wzyx*vec4(4+1-dot(_uvc, _uvc),3,2,1)-.5);\n  vec4 w = pow(vec4(2), spectrum.wzyx*vec4(4,3,2,1)-.5);\n  vec2 ws[8] = vec2[8](\n    vec2(w.x), vec2(w.x+w.y)/2, vec2(w.y), vec2(w.y+w.z)/2,\n    vec2(w.z), vec2(w.z+w.w)/2, vec2(w.w), drift);\n\n  //convert the displacements computed for each layer of flow\n  //to displacements at each scale\n  vec2 disp = vec2(0);\n  float scale = 1;\n  float sf_ = pow(2, scale_factor);\n  float z = 0;\n\n  for (int i=0; i<8; i++){\n    vec2 d2 = d[i];\n    if(i<7)\n      d2 -= d[i+1];\n\n    d2 /= length(d2) + 1e-1;\n    d2 *= scale;\n\n    disp += d2*ws[i];\n    scale *= sf_;\n    z += scale;\n  }\n\n  disp *= 128*flow*pow(2, 3*pulse_);\n  disp /= z*RENDERSIZE;\n\n  p += disp;\n\n  if(lens==1.0){\n    vec2 ts = textureSize(fb, 0);\n    vec2 ar = mix(ts.xx, ts.yy, step(ts.x, ts.y))/ts.yx;\n    p = _uv - .5;\n    p *= ar;\n    float lp = length(p);\n    p *= lp < .5 ? 2-1/(lp+1e-5) : (1-lp)/(lp+1e-5);\n    p /= ar;\n    p += .5;\n  }\n\n  vec4 c0 = circleTexture(fb, p);\n\n  // distance to other channels minus distance to antipodes\n  vec4 ac0 = fract(.5+c0);\n  vec4 dir = (0\n    + circleDist(c0, c0.gbar)\n    + circleDist(c0, c0.barg)\n    + circleDist(c0, c0.argb)\n    - circleDist(c0, ac0.gbar)\n    - circleDist(c0, ac0.barg)\n    - circleDist(c0, ac0.argb)\n    )/3.;\n\n  float hipulse_ = pulse*abs(length(spectrum*vec4(.25, .5, 1, 1.5))-.1);\n  vec4 coruscate_ =\n    max(pow(zap_, 3), pow(coruscate, 4-2*hipulse_))\n    * vec4(.25,1,.5,.125);\n  if (syn_MediaType == 0)\n    coruscate_ *= exp(-dot(_uvc, _uvc));\n  else\n    coruscate_ *= 0.5;\n\n  // vec4 media = getMediaDelta();\n  // coruscate_ *= exp(dot(vec3(1.), abs(media.rgb))-1.);\n\n  dir *= min(vec4(1), coruscate_*0.5/length(dir));//pow(coruscate, 4)/2.;\n  dir *= mix(sin(2*pi*(c0.a+BPMTri2))*2+1, 1, zap_);\n  return fract(c0+dir);\n}\n\nfloat mirror(float x){\n  return abs(fract((x+1)/2)*2-1);\n}\n\nvec4 getColor(vec4 c0){//, vec4 slope){\n  vec4 media = _loadUserImage();//texture(media_hist, _uv);\n  float media_lum = rgbToXyz(media.rgb).y;//0.5*pow(dot(vec3(1./3), media.rgb), 2);\n  float chromatic_ = chromatic;//*  media_lum;\n\n  float lfo = BPMTri2;\n  float lfo2 = BPMTri4;\n  vec3 rot_ =\n    pow(vec3(color_rotate.x ), vec3(3,2,1))\n    + flash_x*lfo2;\n  c0.xyz = fract(c0.xyz+rot_);\n\n  float x = //mirror(color_rotate.y+ flash_y*lfo + media_lum + c0.x+_uv.y*.05);//\n    fract(c0.x+_uv.y*.05);\n  x = x<=.5 ? (1-sqrt(1-x*x*4))/2 : (sqrt(1-(1-x)*(1-x)*4)+1)/2;\n  // x = mirror(x-.5);\n  float y = sin(2*pi*(c0.y+_uv.y*.1));\n  float h = fract(x+color_rotate.y + flash_y*lfo + media_lum);//bias hue toward half of spectrum and away from other half\n  float l = mix(sin(2*pi*(h-chromatic_/4)), y, chromatic_); //align midtones with most in/frequent hues\n  float c =  1 - 2*l*l; //align high chroma with midtones\n\n  vec3 lch = vec3(\n    .5+.5*l,\n    .5+.5*c,\n    fract(h-chromatic_/4)\n    // mirror(h*2-chromatic_/3)/2\n    );\n\n  vec3 r = lchToRgb(vec3(\n    85*lch.x,\n    95*lch.y,\n    360*lch.z\n    ).xyz);\n  r = clamp(r, 0, 1);\n\n  return vec4(r, c0.a+.5);\n}\n\nvec4 colorAntialias(in sampler2D state){\n  // return texture(state, _uv);\n  vec4 r = vec4(0);\n  vec2 xy = _uv*textureSize(state, 0)-.5;\n  vec2 m = fract(xy);\n  mat4 cf = texel4(state, xy);\n  // //multiple calls to circleTexture very expensive --\n  // // instead split the difference b/t interpolation and msaa\n  vec4 m4 = sqrt(vec4((1-m.x)*(1-m.y), (1-m.x)*m.y, m.x*(1-m.y), m.x*m.y));\n  for (int i=0; i<4; i++){\n    r += m4[i]*getColor(cf[i]);\n  }\n  r/=dot(vec4(1), m4);\n  return r;\n}\n\nvec4 postMain(in sampler2D state){\n  return texture(state, _uv);\n}\n\nvec4 renderMain () {\n  if (FRAMECOUNT<=2){\n    return initialCondition();\n  }\n  if (PASSINDEX == 0.0){\n    vec4 r = aggregate(fb1);\n    if(bars > 0){\n      // return initialCondition();\n      return mix(r, initialCondition(), 0.5);\n    }\n    return r;\n  }\n  else if (PASSINDEX == 1.0){\n    return texelFetch(fb0, ivec2(_xy), 0);\n  }\n  else if (PASSINDEX == 2.0){\n    return stepFlow(flow1, fb1, true);\n  }\n  else if (PASSINDEX == 3.0){\n    return stepFlow(flow2, flow1, false);\n  }\n  else if (PASSINDEX == 4.0){\n    return stepFlow(flow3, flow2, false);\n  }\n  else if (PASSINDEX == 5.0){\n    return stepFlow(flow4, flow3, false);\n  }\n  else if (PASSINDEX == 6.0){\n    return stepFlow(flow5, flow4, false);\n  }\n  else if (PASSINDEX == 7.0){\n    return stepFlow(flow6, flow5, false);\n  }\n  else if (PASSINDEX == 8.0){\n    return stepFlow(flow7, flow6, false);\n  }\n  else if (PASSINDEX == 9.0){\n    return stepFlow(flow8, flow7, false);\n  }\n  else if (PASSINDEX == 10.0){\n    return colorAntialias(fb0);\n  }\n\n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Fluid Body","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"adds basic feedback to the scene","MAX":1,"MIN":0,"NAME":"feedback","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"distortion"},{"DEFAULT":0,"DESCRIPTION":"Distorts the fractal and adds a vignette","MAX":1,"MIN":0,"NAME":"barrel_distortion","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"distortion"},{"DEFAULT":0.970000028610229,"DESCRIPTION":"This adds more variation to the fractal color. Turning it up all the way will create a lot of 'rings'","MAX":0.999899983406067,"MIN":0.899999976158142,"NAME":"detail","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"fractal"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Create a softer or harder edge with the fractal coloration","MAX":0,"MIN":1,"NAME":"fractal_softness","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"fractal"},{"DEFAULT":1,"DESCRIPTION":"Add manual rotation to the fractal. This is helpful if you want to control the intensity of the rotation","MAX":1,"MIN":0,"NAME":"auto_rotate","TYPE":"toggle","UI_GROUP":"rotate"},{"DEFAULT":0,"DESCRIPTION":"Add manual rotation to the fractal. This is helpful if you want to control the intensity of the rotation","MAX":1,"MIN":-1,"NAME":"rotate","PARAMS":0.00100000004749745,"TYPE":"knob traveler","UI_GROUP":"rotate"},{"DEFAULT":1.5,"DESCRIPTION":"Zoom in on the fractal","MAX":3,"MIN":0.5,"NAME":"zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":[0,0],"DESCRIPTION":"Move the position of the fractal","MAX":[1,1],"MIN":[-1,-1],"NAME":"camera_position","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Choose from one of 3 color palettes.","MAX":1,"MIN":0,"NAME":"color_regime","TYPE":"slider","UI_GROUP":"colorize"},{"DEFAULT":1,"DESCRIPTION":"Flip the color scheme","MAX":1,"MIN":0,"NAME":"colorModifier","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"colorize"},{"DEFAULT":0,"DESCRIPTION":"pulses color to the beat.","MAX":1,"MIN":0,"NAME":"color_beat_pulse","PARAMS":0.00999999977648258,"TYPE":"toggle smooth","UI_GROUP":"colorize"}],"CREDIT":"mojovideotech","DESCRIPTION":"FractilianFoundation","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\fractilian_foundation.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Fractilian Foundation","IMAGES":null,"IMAGE_PATH":"fractilian_foundation.synScene\\fractilian_foundation.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n     {\n        \"DEFAULT\" : 0.0,\n        \"DESCRIPTION\" : \"adds basic feedback to the scene\",\n        \"MAX\" : 1.0,\n        \"MIN\" : 0.0,\n        \"NAME\" : \"feedback\",\n        \"PARAMS\" : 0.05,\n        \"TYPE\" : \"slider smooth\",\n        \"UI_GROUP\" : \"distortion\"\n     },\n     {\n        \"DEFAULT\" : 0.0,\n        \"DESCRIPTION\" : \"Distorts the fractal and adds a vignette\",\n        \"MAX\" : 1.0,\n        \"MIN\" : 0.0,\n        \"NAME\" : \"barrel_distortion\",\n        \"PARAMS\" : 0.01,\n        \"TYPE\" : \"slider smooth\",\n        \"UI_GROUP\" : \"distortion\"\n     },\n      {\n         \"DEFAULT\" : 0.97,\n         \"DESCRIPTION\" : \"This adds more variation to the fractal color. Turning it up all the way will create a lot of 'rings'\",\n         \"MAX\" : 0.9999,\n         \"MIN\" : 0.9000,\n         \"NAME\" : \"detail\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"fractal\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"Create a softer or harder edge with the fractal coloration\",\n         \"MAX\" : 0.0,\n         \"MIN\" : 1.0,\n         \"NAME\" : \"fractal_softness\",\n         \"PARAMS\" : 0.05,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"fractal\"\n      },\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Add manual rotation to the fractal. This is helpful if you want to control the intensity of the rotation\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"auto_rotate\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"rotate\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Add manual rotation to the fractal. This is helpful if you want to control the intensity of the rotation\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"rotate\",\n         \"PARAMS\" : 0.001,\n         \"TYPE\" : \"knob traveler\",\n         \"UI_GROUP\" : \"rotate\"\n      },\n      {\n         \"DEFAULT\" : 1.5,\n         \"DESCRIPTION\" : \"Zoom in on the fractal\",\n         \"MAX\" : 3,\n         \"MIN\" : 0.5,\n         \"NAME\" : \"zoom\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Move the position of the fractal\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"camera_position\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Choose from one of 3 color palettes.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"color_regime\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"colorize\"\n      },\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Flip the color scheme\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"colorModifier\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"colorize\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"pulses color to the beat.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"color_beat_pulse\",\n         \"TYPE\" : \"toggle smooth\",\n         \"UI_GROUP\" : \"colorize\"\n      }\n   ],\n   \"PASSES\" : [\n      {\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 1920\n      }\n    ],\n   \"CREDIT\" : \"mojovideotech\",\n   \"DESCRIPTION\" : \"FractilianFoundation\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"fractilian_foundation.png\",\n   \"TITLE\" : \"Fractilian Foundation\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"BuffA","WIDTH":1920}],"SCRIPT_CODE":"","SHADER_CODE":"///////////////////////////////////////////\n// FractilianFoundation  by mojovideotech\n// orgin of the Fractilian series of ISFs\n//\n// based on :\n//\n// Fractals: MRS\n// by Nikos Papadopoulos, 4rknova / 2015\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n///////////////////////////////////////////\n\nvec3 _grad3(vec3 col1, vec3 col2, vec3 col3, float mixVal){\n    mixVal *= 2.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    return mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n}\n\nvec3 colorPaletteChooser(float colReg, float var){\n  vec3 paletteCol = vec3(0.5);\n  vec3 color1 = clamp(_palette(var, vec3(0.500, 0.531, 0.177), vec3(0.500, 0.500, 0.531), vec3(0.535, 0.688, 0.612), vec3(0.500, 0.500, 0.669)), 0.0, 1.0);\n  vec3 color2 = clamp(_palette(var, vec3(-0.038, -0.146, -0.131), vec3(0.838, 0.531, 0.392), vec3(0.962, 1.000, 1.281), vec3(0.354, 0.262, 0.915)), 0.0, 1.0);\n  vec3 color3 = clamp(_palette(var,vec3(-0.346, -0.423, -0.269), vec3(0.877, 0.862, 1.000), vec3(1.054, 1.085, 0.15), vec3(0.238, 0.432, 0.908)), 0.0, 1.0);\n\n  paletteCol = _grad3(color1, color2, color3, colReg);\n  // paletteCol = mix(paletteCol, color4, max(0, colReg - 2));\n\n  return paletteCol;\n}\n\nvec2 barrelDistortion(vec2 coord, float amt) {\n\n\tvec2 cc = coord - 0.5;\n\tfloat dist = dot(cc, cc);\n\t//return coord + cc * (dist*dist)  * amt;\n\treturn coord + cc * dist * amt;\n}\n\nvec4 applyVignette(vec4 fragColor)\n{\n    // vec2 position = (_xy / u_resolution) - vec2(0.5);\n    vec2 position = _uvc;\n    float dist = length(position);\n\n\n    float radius = 1.35 - 0.4*barrel_distortion;\n    float softness = 0.4;\n    float vignette = smoothstep(radius, radius - softness, dist);\n\n    fragColor.rgb = fragColor.rgb - max(0, 0.75 - vignette);\n\n    return fragColor;\n}\n\nvec4 applyBarrelDistortion(vec4 fragColor) {\n\n\t//vec2 uv=(gl_FragCoord.xy/iResolution.xy);\n\n\t// vec2 uv=modifier * zoom*_uvc;\n  // vec2 uv = (_xy/RENDERSIZE.xy*.5)+.25;\n  vec2 uv = _uv;\n\t//uv.y +=.1;\n\tvec4 a1=texture(BuffA, barrelDistortion(uv,0.0));\n\tvec4 a2=texture(BuffA, barrelDistortion(uv,barrel_distortion*0.6));\n\tvec4 a3=texture(BuffA, barrelDistortion(uv,barrel_distortion*0.9));\n\tvec4 a4=texture(BuffA, barrelDistortion(uv,barrel_distortion*1.2));\n\n\t// vec4 a5=texture2D(BuffA, barrelDistortion(uv,0.8));\n\t// vec4 a6=texture2D(BuffA, barrelDistortion(uv,1.0));\n\t// vec4 a7=texture2D(BuffA, barrelDistortion(uv,1.2));\n\t// vec4 a8=texture2D(BuffA, barrelDistortion(uv,1.4));\n\n\t// vec4 a9=texture2D(BuffA, barrelDistortion(uv,1.6));\n\t// vec4 a10=texture2D(BuffA, barrelDistortion(uv,1.8));\n\t// vec4 a11=texture2D(BuffA, barrelDistortion(uv,2.0));\n\t// vec4 a12=texture2D(BuffA, barrelDistortion(uv,2.2));\n\n\t// vec4 tx=(a1+a2+a3+a4+a5+a6+a7+a8+a9+a10+a11+a12)/12.;\n\tvec4 tx=(a1+a2+a3+a4)/4.;\n\tfragColor = vec4(tx.rgb, 1. );\n\n  return fragColor;\n}\n\nvec4 renderPassA() {\n\n\tvec4 colOut = vec4(0.0);\n  vec2 uv =  zoom*(_uvc+0.5);\n  uv += camera_position.xy;\n  // vec2 uv = vec2(modifier * zoom * _xy - RENDERSIZE.xy/2.) / RENDERSIZE.x;\n  // vec2 uv = (modifier * zoom*_uvc);\n\n  float t = auto_rotate*syn_Time*.00325+auto_rotate*syn_BassTime*0.005+40.+rotate;\n  float k = cos(t+syn_Presence*.00125);\n  float l = sin(t);\n  float s = 1.25;\n\n  vec3 imageBase = vec3(0.);\n\n  //load user image\n\n  if (_exists(syn_UserImage)){\n      vec4 image = _loadUserImage();\n      imageBase = image.rgb;\n  }\n\n  for(int i=0; i<60; ++i)\n  {\n      uv  = abs(uv) - s;\n      // uv = _rotate(uv, 0.5+);\n      uv *= mat2(k,-l,l,k);\n      s  *= detail;\n      // uv *= ;\n      // s *= exp(i);\n  }\n\n\n  float x = .92*cos(0.325*(237.*fractal_softness*length(uv)));\n  float x2 = .92*sin(0.325*(237.*fractal_softness*length(uv)));\n\n  vec4 last = texture(BuffA, _uv);\n\n  float pulse = _pulse(x, syn_BPMSin4, 0.6);\n  float secondPulse = _pulse(x2, abs(sin(syn_BassTime*.75)*0.5), 0.1+syn_ToggleOnBeat*0.9);\n\n  colOut = vec4(colorPaletteChooser(color_regime, colorModifier - x), 1.0);\n  //color tweaking + pulse\n  colOut.rgb = _rgb2hsv(colOut.rgb);\n  // out_FragColor.b -= 0.2;\n  colOut.g -= 0.96*color_beat_pulse;\n  colOut.g += secondPulse*0.8*color_beat_pulse;\n  colOut.g += pulse*0.8*color_beat_pulse;\n  colOut.g = clamp(colOut.g, 0.0, 1.0);\n\n  colOut.b -= 0.7*color_beat_pulse;\n  colOut.b += secondPulse*0.7*color_beat_pulse;\n  colOut.b += pulse*0.7*color_beat_pulse;\n  colOut.b = clamp(colOut.b, 0.0, 1.0);\n  // out_FragColor.b = _contrast(out_FragColor.b, 1.1);\n  colOut.rgb = _hsv2rgb(colOut.rgb);\n  colOut = _gamma(colOut, 0.8);\n  colOut = clamp(mix(colOut, last, 0.99*pow(feedback, 0.1)),0.0,1.0);\n  return colOut;\n}\n\n\nvec4 renderMainImage(){\n vec4 fragColor = texture(BuffA, _uv);\n // fragColor.xy = _rotate(fragColor.xy, 0.003);\n fragColor = applyBarrelDistortion(fragColor);\n fragColor = applyVignette(fragColor);\n // fragColor *= 1.;\n return fragColor;\n}\n\nvec4 renderMain(){\n if(PASSINDEX == 0){\n\t\treturn renderPassA();\n\t}\n\tif(PASSINDEX == 1){\n\t\treturn renderMainImage();\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Fractilian Foundation","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[-1,-1],"NAME":"center","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":3,"MIN":0.5,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.150000005960464,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.349999994039536,"DESCRIPTION":"","MAX":0.5,"MIN":0.00999999977648258,"NAME":"fine","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":32,"DESCRIPTION":"","MAX":100,"MIN":12,"NAME":"loops","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-0.25,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"r1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.275000005960464,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"r2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":5,"MIN":0.100000001490116,"NAME":"brightness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.75,"DESCRIPTION":"","MAX":0.990000009536743,"MIN":0.00999999977648258,"NAME":"bleed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":0.990000009536743,"MIN":0.00999999977648258,"NAME":"edge","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":[0.600000023841858,0.400000005960464,0.899999976158142],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"color_color","TYPE":"color","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"flipH_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"flipV_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"mirrorH_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"mirrorV_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"blend_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"invert_bool","TYPE":"toggle","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\fractilianparaboliccircleinversion.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"FractilianParabolicCircleInversion","IMAGES":null,"IMAGE_PATH":"fractilianparaboliccircleinversion.synScene\\fractilianparaboliccircleinversion.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t],\n\t\t\t\"NAME\" : \"center\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.15,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.35,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"fine\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 32,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 12,\n\t\t\t\"NAME\" : \"loops\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -0.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"r1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.275,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"r2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"brightness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.75,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.99,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"bleed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.99,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"edge\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.6,\n\t\t\t\t0.4,\n\t\t\t\t0.9\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"color_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"flipH_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"flipV_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mirrorH_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mirrorV_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"blend_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"invert_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"fractilianparaboliccircleinversion.png\",\n\t\"TITLE\" : \"FractilianParabolicCircleInversion\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec4 color = vec4(color_color, 1.0); \nbool invert = (invert_bool > 0.5); \nbool blend = (blend_bool > 0.5); \nbool mirrorV = (mirrorV_bool > 0.5); \nbool mirrorH = (mirrorH_bool > 0.5); \nbool flipV = (flipV_bool > 0.5); \nbool flipH = (flipH_bool > 0.5); \n\n\n\n\n////////////////////////////////////////////////////////////\n// FractilianParabolicCircleInversion  by mojovideotech\n//\n// based on :\n// Fractal Soup  by @P_Malin\n// shadertoy.com/\\lsB3zR\n//\n// License: \n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n\nvec2 CircleInversion(vec2 vPos, vec2 vOrigin, float fRadius) {\t\n\tvec2 vOP = vPos - vOrigin;\n\treturn vOrigin - vOP * fRadius * fRadius / dot(vOP, vOP);\n}\n\nfloat Parabola( float x, float n ) { return pow( 4.0*x*(1.0-x), n ); }\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 pos = _xy.xy/RENDERSIZE.xy;\n\tif (mirrorV) { if (pos.y < 0.5) pos.y = 1.0-pos.y; }\n\tif (mirrorH) { if (pos.x < 0.5) pos.x = 1.0-pos.x; }\n\tpos.x *= RENDERSIZE.x / RENDERSIZE.y;\n\tif (flipH) { pos.x = 1.0 - pos.x; }\n\tif (flipV) { pos.y = 1.0 - pos.y; }\n\tfloat T = TIME * rate + fine;\n\tfloat TT = T * 0.05;\n\tfloat drift = mix(pos.x+sin(TT),sin(pos.x)*cos(pos.x-TT),sin(pos.y-TT));\n\tvec2 spin = vec2( sin(T*r1), -sin(T*r2))+center;\n\tfloat l = 0.0, b = 0.0, m = 10000.0;\n\tvec2 p = pos.xy;\t\n\tfor(int i=0; i<100; i++) {\n\t\tp.x = abs(p.x);\n\t\tp = p * scale + spin;\n\t\tp = CircleInversion(p, vec2(0.5, 0.5), 1.0);\n\t\tl = length(p);\n\t\tm = min(l, m);\n\t\tm += Parabola(m, drift);\n\t\tb += 1.0;\n\t\tif (b>loops) break; \n}\n\t\n\tvec3 col = color.rgb * l * l * brightness;\n\tcol = mix(col,pow(col,vec3(m)),1.0-edge);\n\tcol = mix(col,col*fract(m*col+m),bleed);\n\tif (blend) { col = 1.0 - exp(-col); }\n\tif (invert) { out_FragColor = vec4(1.0-col,1.0); }\n\telse\n\tout_FragColor = vec4(col,1.0);\n\nreturn out_FragColor; \n } \n\n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"FractilianParabolicCircleInversion","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"RGB or CMYK for glitch colors","MAX":1,"MIN":0,"NAME":"rgb_vs_cmyk","TYPE":"toggle","UI_GROUP":"glitch"},{"DEFAULT":1,"DESCRIPTION":"Audio-reactive glitch flashes","MAX":1,"MIN":0,"NAME":"glitch_flashes","TYPE":"knob","UI_GROUP":"glitch"},{"DEFAULT":0,"DESCRIPTION":"Constant glitch effect (non-reactive)","MAX":1,"MIN":0,"NAME":"glitch_constant","TYPE":"slider","UI_GROUP":"glitch"},{"DEFAULT":0.850000023841858,"DESCRIPTION":"How far the glitch extends outward","MAX":2,"MIN":0,"NAME":"glitch_scale","TYPE":"slider","UI_GROUP":"glitch"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"Audio-reactive fuzz flashes","MAX":1,"MIN":0,"NAME":"fuzz_flashes","TYPE":"knob","UI_GROUP":"fuzz"},{"DEFAULT":0,"DESCRIPTION":"Constant fuzz effect (non-reactive)","MAX":1,"MIN":0,"NAME":"fuzz_constant","TYPE":"slider","UI_GROUP":"fuzz"},{"DEFAULT":1,"DESCRIPTION":"How far the fuzz extends outward","MAX":2,"MIN":0,"NAME":"fuzz_scale","TYPE":"slider","UI_GROUP":"fuzz"},{"DEFAULT":0,"DESCRIPTION":"Amount of feedback","MAX":1,"MIN":0,"NAME":"feedback_amt","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"feedback_scale","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"feedback_style","PARAMS":0.5,"TYPE":"toggle smooth","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Shake the screen","MAX":1,"MIN":0,"NAME":"anger_shake","PARAMS":0.25,"TYPE":"bang smooth","UI_GROUP":"fx"},{"DEFAULT":0,"DESCRIPTION":"Send a ripple outward","MAX":1,"MIN":0,"NAME":"ripple_snap","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"fx"},{"DEFAULT":0,"DESCRIPTION":"Switches from main pattern to simple lines to save FPS on older computers","MAX":1,"MIN":0,"NAME":"save_fps","TYPE":"toggle","UI_GROUP":"pattern"},{"DEFAULT":0,"DESCRIPTION":"Switches to a subtractive pattern instead of additive","MAX":1,"MIN":0,"NAME":"mix_type","TYPE":"toggle","UI_GROUP":"pattern"},{"DEFAULT":0,"DESCRIPTION":"Multiplies the pattern into the media","MAX":1,"MIN":0,"NAME":"pattern_media_multiply","TYPE":"toggle","UI_GROUP":"pattern"},{"DEFAULT":0,"DESCRIPTION":"Makes the pattern jump on the beat for when you need maximum tactical glitch","MAX":1,"MIN":0,"NAME":"beat_jump","TYPE":"toggle","UI_GROUP":"pattern"},{"DEFAULT":0,"DESCRIPTION":"Mixes the media into the pattern","MAX":1,"MIN":0,"NAME":"media_glitch","TYPE":"toggle","UI_GROUP":"media_glitch"},{"DEFAULT":0,"DESCRIPTION":"Makes all the other effects only happen towards the edges of the screen","MAX":1,"MIN":0,"NAME":"vignette","TYPE":"slider","UI_GROUP":"vignette"},{"DEFAULT":0,"DESCRIPTION":"Inverts the vignette so all effects only happen towards the center","MAX":1,"MIN":0,"NAME":"vignette_invert","TYPE":"toggle","UI_GROUP":"vignette"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\fuzzy_signal.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Fuzzy Signal","IMAGES":null,"IMAGE_PATH":"fuzzy_signal.synScene\\fuzzy_signal.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"RGB or CMYK for glitch colors\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"rgb_vs_cmyk\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"glitch\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Audio-reactive glitch flashes\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"glitch_flashes\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"glitch\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Constant glitch effect (non-reactive)\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"glitch_constant\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"glitch\"\n      },\n      {\n         \"DEFAULT\" : 0.85,\n         \"DESCRIPTION\" : \"How far the glitch extends outward\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"glitch_scale\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"glitch\"\n      },\n      {\n         \"DEFAULT\" : 0.3,\n         \"DESCRIPTION\" : \"Audio-reactive fuzz flashes\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"fuzz_flashes\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"fuzz\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Constant fuzz effect (non-reactive)\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"fuzz_constant\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"fuzz\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"How far the fuzz extends outward\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"fuzz_scale\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"fuzz\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Amount of feedback\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"feedback_amt\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"feedback\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"feedback_scale\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"feedback\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"feedback_style\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.5,\n         \"UI_GROUP\" : \"feedback\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Shake the screen\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"anger_shake\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.25,\n         \"UI_GROUP\" : \"fx\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Send a ripple outward\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"ripple_snap\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"fx\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Switches from main pattern to simple lines to save FPS on older computers\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"save_fps\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"pattern\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Switches to a subtractive pattern instead of additive\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"mix_type\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"pattern\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Multiplies the pattern into the media\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pattern_media_multiply\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"pattern\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Makes the pattern jump on the beat for when you need maximum tactical glitch\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"beat_jump\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"pattern\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Mixes the media into the pattern\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_glitch\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"media_glitch\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Makes all the other effects only happen towards the edges of the screen\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"vignette\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"vignette\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Inverts the vignette so all effects only happen towards the center\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"vignette_invert\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"vignette\"\n      }\n   ],\n   \"CREDIT\" : \"Meebs\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"fuzzy_signal.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"TARGET\" : \"feedback\"\n      }\n   ],\n   \"TITLE\" : \"Fuzzy Signal\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"feedback","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"vec2 glitchPos;\n\nfloat rand(vec2 uv, float t) {\n    return fract(sin(dot(uv, vec2(1225.6548, 321.8942))) * 4251.4865 + t);\n}\nvec2 trueUV = _uv;\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat lum(vec3 colIn){\n  return dot(colIn, vec3(1.0))/3.0;\n}\n\nvec3 diamondsPattern(vec2 uvIn) {\n\tvec2 p = -0.5+uvIn;\n\tp = _rotate(p, PI/2.0);\n\tif (save_fps>0.5){\n\t\treturn vec3(sin(cos(p.x+p.y+syn_BassTime*0.1)*10.0+p.x*100.0), sin(p.y*100.0+cos(p.x*10.0+syn_BassTime)), sin(p.x*sin(TIME)*10.0+p.y*100.0));\n\t}\n\tfloat f=0., f2=0., r = 0.0, r2 = 0.0;\n  float timeVar = syn_BeatTime*beat_jump+TIME*0.05+syn_BPMTwitcher*0.05;\n\tconst float I = 30.;\n\tvec2 p2 = vec2(-p);\n\tfor(float i=1.; i<=I; i++) {\n\t\tif(abs(p.x)+abs(p.y)<1.+syn_Presence*0.25) {\n\t\t  r = cos(timeVar+.3*i)/2.;\n\t\t  p += atan(i*rand(vec2(i), syn_BeatTime*beat_jump))*0.1;\n\t\t\tif(p.x<2.*r) {\n\t\t\t\tp.x -= r-.5;\n\t\t\t\tp /= r+.5;\n\t\t\t} else {\n\t\t\t\tp.x -= r+.5;\n\t\t\t\tp /= r-.5;\n\t\t\t}\n\t\t  f = i/I;\n\t\t}\n\t\tif(abs(p2.x)+abs(p2.y)<1.+syn_Presence*0.25) {\n\t\t  r2 = cos(timeVar+.3*i)/2.;\n\t\t  p2 += atan(i*rand(vec2(i), syn_BeatTime*beat_jump))*0.1;\n\t\t\tif(p2.x<2.*r2) {\n\t\t\t\tp2.x -= r2-.5;\n\t\t\t\tp2 /= r2+.5;\n\t\t\t} else {\n\t\t\t\tp2.x -= r2+.5;\n\t\t\t\tp2 /= r2-.5;\n\t\t\t}\n\t\t  f2 = i/I;\n\t\t}\n\t}\n\tfloat colSpot = 1.0-floor(mod(f*13.3, 4.0));\n\tfloat colSpot2 = 1.0-floor(mod(f2*13.3, 4.0));\n\n\tcolSpot = clamp(colSpot, 0.0, 1.0);\n\tcolSpot2 = clamp(colSpot2, 0.0, 1.0);\n\n\tvec3 colOut = vec3(mix(colSpot+colSpot2, colSpot-colSpot2, mix_type));\n  // vec3 colOut = _hsv2rgb(vec3(mix(0.7, 0.0, step(0.5, f)), colSpot, mod(f*17.7,2.0)-1.0));\n  // colOut = clamp(colOut, 0.0, 1.0);\n  // colOut = pow(colOut, vec3(2.0));\n\treturn colOut;\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n\tx += anger_shake*glitchPos*RENDERSIZE;\n  x += RENDERSIZE*_uvc*_pulse(length(_uvc)*length(_uvc), 0.5-pow(ripple_snap,0.5), 0.5*sqrt(ripple_snap))*0.2;\n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n      vec2 g = vec2( float(i),float(j) );\n\t\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\t\tvec2 r = g - f + o.xy;\n\t\t\tfloat d = dot(r,r);\n\t\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\t\tva += o.z*ww;\n\t\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nvec3 _grad3(vec3 col1, vec3 col2, vec3 col3, float mixVal){\n    mixVal *= 2.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    return mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n}\n\n\nvec3 loadUserImageMirrored(vec2 offset){\n  vec2 uv = _correctImageCoords(textureSize(syn_UserImage, 0));\n  uv = _invertYAxisVideo(uv);\n  \n  uv += anger_shake*glitchPos;\n  uv += _uvc*_pulse(length(_uvc)*length(_uvc), 0.95-pow(ripple_snap,0.5)*1.5, 0.5*sqrt(ripple_snap))*0.2;\n  uv += offset;\n  \n  vec3 colOut = vec3(0.0);\n\n\tif (syn_MediaType > 0.5){\n\t\tvec3 pat = diamondsPattern(uv*vec2(RENDERSIZE.x/RENDERSIZE.y, 1.0)-vec2(0.25*RENDERSIZE.x/RENDERSIZE.y, 0.0));\n\t\tif (media_glitch > 0.5){\n\t\t\tuv = uv*pat.rg;\n\t\t}\n\t\tif (mod(uv.x, 2.0) > 1.0){\n    \tuv.x = 1.0-uv.x;\n  \t}\n  \tif (mod(uv.y, 2.0) > 1.0){\n    \tuv.y = 1.0-uv.y;\n  \t}\n\t\tcolOut = texture(syn_UserImage, uv).rgb;\n\t\tcolOut = _contrast(_invertImage(vec4(colOut, 0.0)), _Media_Contrast).rgb;\n\t\tcolOut = mix(colOut, colOut*pat, pattern_media_multiply);\n\t} else {\n\t  colOut = diamondsPattern(uv);\n\t}\n\n  return colOut;\n}\n\nvec3 loadImageMirrored(sampler2D sampIn, vec2 offset){\n\tvec2 uv = _uv;  \n  uv += offset;\n  uv += anger_shake*glitchPos;\n  uv += _uvc*_pulse(length(_uvc)*length(_uvc), 0.95-pow(ripple_snap,0.5)*1.5, 0.5*sqrt(ripple_snap))*0.2;\n\tif (mod(uv.x, 2.0) > 1.0){\n    uv.x = 1.0-uv.x;\n  }\n  if (mod(uv.y, 2.0) > 1.0){\n    uv.y = 1.0-uv.y;\n  }\n  \n  return texture(sampIn, uv).rgb;\n}\n\nvec4 renderMain(void)\n{\n\tglitchPos = 0.1*vec2(_statelessContinuousChaotic(TIME*100.0), _statelessContinuousChaotic(TIME*77.0));\n\n\tif (PASSINDEX == 0.0){\n\t  vec3 color = vec3(0.0);\n\t  float scale = 250.0;  \n\t  vec2 vigUv = _uv;\n\t  vec2 uv = _uv;\n\t  //Create Vignette Var\n\t  vigUv *=  1.0 - vigUv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret !\n\t  float vig = vigUv.x*vigUv.y * 15.0; // multiply with sth for intensity\n\t  vig = pow(vig, 0.6+vignette_invert*0.8); // change pow for modifying the extend of the  vignette\n\t  vig = mix(0.0, mix(vig, 1.0-vig, vignette_invert), vignette);\n\t  //Create voronoise\n\t  float voronoise = iqnoise(_uvc*scale*0.1+syn_BeatTime*10.0, 1.0, 0.4);\n\t  voronoise *= (1.0-vig);\n\n\t  //Create pixely noise\n\t  float voronoise3 = iqnoise(_uvc*scale*0.01+syn_BeatTime*10.0, 1.0, 0.1);\n\t  vec2 largePixels = _pixelate(_uvc, floor(20.0*(1.0+voronoise3)));\n\t  vec2 largerPixels = _pixelate(_uvc, 100.0);\n\t \tfloat voronoise2 = iqnoise(_rotate(_uvc, syn_BeatTime*10.0)*scale*0.1+syn_BeatTime*10.0+17.7, 1.0, 0.1);\n\t \t// return vec4(voronoise2);\n\t  uv = mix(voronoise2*uv, largePixels, step(0.5,rand(largerPixels, TIME*100.0)));\n\t  float smallNoise = rand(uv, TIME);\n\t  vec2 offset = (smallNoise - 0.5) * 2.0 * vec2(1.0);\n\t  // return vec4(abs(offset), 0.0, 0.0);\n\t  vec2 totOff = vec2(1.0,-1.0)*_uvc*2.0*offset*voronoise2;\n\t  totOff *= (syn_HighHits+glitch_constant);\n\n\t  // **** GLITCH ****\n\t  color = loadUserImageMirrored(vec2(0.0)).rgb;\n\t  float lumAtOrig = lum(color);\n\t  vec3 noiseC = loadUserImageMirrored(totOff*glitch_scale*0.05).rgb;\n\t  totOff = _rotate(totOff, PI*0.5);\n\t \tvec3 noiseM = loadUserImageMirrored(totOff*glitch_scale*0.05).rgb;\n\t \ttotOff = _rotate(totOff, PI*0.5);\n\t  vec3 noiseY = loadUserImageMirrored(totOff*glitch_scale*0.05).rgb;\n\t  vec3 noise = noiseC*mix(vec3(1.0,0.0,0.0), vec3(0.0,1.0,1.0), rgb_vs_cmyk)+noiseM*mix(vec3(0.0,1.0,0.0), vec3(1.0,0.0,1.0), rgb_vs_cmyk)+noiseY*mix(vec3(0.0,0.0,1.0), vec3(1.0,1.0,0.0), rgb_vs_cmyk);\n\t  noise *= 2.0-rgb_vs_cmyk;\n\n\t  color = mix(color, max(color, noise), (glitch_flashes*sqrt(syn_HighHits)+glitch_constant)*(1.0-vig));\n\n\n\n\t  // **** FEEDBACK ****\n\t  float pixelateRoto = floor(voronoise2*16);\n\t  vec2 feedbackOffset = _rotate(vec2(1.0,0.0), pixelateRoto*PI*0.25);\n\t  float feedbackNoise = iqnoise(_uvc*scale*0.1+vec2(syn_BeatTime), 1.0, 0.4);\n\t  feedbackOffset *= feedback_scale*feedback_scale*feedback_scale*0.1;\n\t  vec3 last = loadImageMirrored(feedback, feedbackOffset).rgb;\n\t  float mixAmt = (1.0-vig);\n\t  mixAmt = clamp(mixAmt*feedback_amt, 0.0, 1.0);\n\t  color = mix(color, mix(last, max(color, last), feedback_style), mixAmt);\n\n\n\t  // **** FUZZ ****\n\t  vec2 fuzzyOffset = vec2(-0.5+_rand(_uv+TIME*0.743), -0.5+_rand(_uv+TIME*0.543))*0.1;\n\t  vec3 fuzzyImg = loadUserImageMirrored(fuzzyOffset*fuzz_scale*mix(1.0, syn_BassLevel, fuzz_flashes));\n\t  vec3 fuzzyImg2 = loadUserImageMirrored(-fuzzyOffset*fuzz_scale*mix(1.0, syn_BassLevel, fuzz_flashes));\n\t  fuzzyImg = fuzzyImg+fuzzyImg2;\n\t  float fuzzer = lum(fuzzyImg);\n\t  fuzzer *= fuzzer;\n\t  vec3 warmCol = _grad3(vec3(1.0,0.3,0.0), vec3(1.0,0.6,0.0), vec3(1.0,0.8,0.3), fuzzyImg.r*0.75+fuzzyImg2.g*0.75);\n\t  color += fuzz_flashes*warmCol*fuzzer*syn_BassLevel*(1.0-vig)+fuzz_constant*warmCol*fuzzer*(1.0-vig);\n\n\n\t  color = clamp(color, -1.0, 2.0);\n\t  return vec4(color, 1.0);\n\t} else if (PASSINDEX == 1.0){\n\t\treturn texture(feedback, _uv);\n\t}\n\n}\n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Fuzzy Signal","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Turn ON to cause the scene to flash on high percussive hits.","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Turn ON to force the scene to monochrome, which also effects the visual feedback. Try with a UserImage (and try inverting the image).","MAX":1,"MIN":0,"NAME":"monochrome","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Turn ON to add in extra colors to any of the color palettes. Results in more saturated, noisy colors.","MAX":1,"MIN":0,"NAME":"extra_cols","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":500,"DESCRIPTION":"Default is none. Increase this slider for a pixelation effect.","MAX":4,"MIN":500,"NAME":"pixelation","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":1,"DESCRIPTION":"Turn up to increase the 'overload' feedback moments. Turn down to turn off overloaded feedback entirely.","MAX":3,"MIN":0.5,"NAME":"feedback","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":1,"DESCRIPTION":"Turn ON to automatically have large blocky pixels change on beat.","MAX":1,"MIN":0,"NAME":"auto_blocks","TYPE":"toggle","UI_GROUP":"background"},{"DEFAULT":0,"DESCRIPTION":"Manually force blocks to change on press.","MAX":1,"MIN":0,"NAME":"fresh_blocks","TYPE":"bang counter","UI_GROUP":"background"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\gpu_melter.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"bkgColSel","VALUES":[0,0.100000001490116,0.200000002980232,0.300000011920929]},{"UNIFORM":"faceZoom","VALUES":[0.200000002980232,0.100000001490116,1]}],"HEIGHT":1080,"ID":"GPU_Melter","IMAGES":null,"IMAGE_PATH":"gpu_melter.synScene\\gpu_melter.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"GPU_Melter\",\n \"IMAGE_PATH\": \"gpu_melter.jpg\",\n \"HARD_TRANSITIONS\": [{\n   \"UNIFORM\": \"bkgColSel\",\n   \"VALUES\":[0.0, 0.1, 0.2, 0.3]\n  },{\n   \"UNIFORM\": \"faceZoom\",\n   \"VALUES\":[0.2, 0.1, 1.0]\n  }],\n \"CONTROLS\": [{\n    \"NAME\": \"flashing\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON to cause the scene to flash on high percussive hits.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"monochrome\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON to force the scene to monochrome, which also effects the visual feedback. Try with a UserImage (and try inverting the image).\",\n    \"UI_GROUP\":\"color\"\n  },{\n   \"NAME\": \"extra_cols\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON to add in extra colors to any of the color palettes. Results in more saturated, noisy colors.\",\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"pixelation\",\n    \"MAX\" : 4.0,\n    \"MIN\" : 500.0,\n    \"DEFAULT\":500.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Default is none. Increase this slider for a pixelation effect.\",\n    \"UI_GROUP\":\"feedback\"\n  },{\n    \"NAME\": \"feedback\",\n    \"MAX\" : 3.0,\n    \"MIN\" : 0.5,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Turn up to increase the 'overload' feedback moments. Turn down to turn off overloaded feedback entirely.\",\n    \"UI_GROUP\":\"feedback\"\n  },{\n    \"NAME\": \"auto_blocks\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON to automatically have large blocky pixels change on beat.\",\n    \"UI_GROUP\":\"background\"\n  },{\n    \"NAME\": \"fresh_blocks\",\n    \"TYPE\": \"bang counter\",\n    \"DESCRIPTION\": \"Manually force blocks to change on press.\",\n    \"UI_GROUP\":\"background\"\n  }],\n \"PASSES\": [ {\"TARGET\": \"face\", \"FLOAT\":false}, {\"TARGET\": \"forBlur\", \"FLOAT\":true} ]\n }\n","PASSES":[{"FLOAT":false,"HEIGHT":0,"TARGET":"face","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"forBlur","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"vec2 resolution = RENDERSIZE; // the rendering resolution (in pixels)\nfloat time = TIME;\nfloat faceTime = 500+500*sin(syn_Time*0.08*0.5/8.0+syn_BassLevel*0.1) + 100.0;\nfloat rgbZoomAmt = pow(syn_HighHits,4.0)*1.2;\n\n// Created by inigo quilez - iq/2013 : https://www.shadertoy.com/view/lsl3RH\n// See here for a tutorial on how to make this: http://www.iquilezles.org/www/articles/warp/warp.htm\n\nconst mat2 m = mat2( 0.10,  0.9, -0.60,  0.60 );\n\nfloat noise( in vec2 x )\n{\n  return sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n  float f = 0.0;\n  f += 0.5000*noise( p ); p = m*p*2.02;\n  f += 0.2500*noise( p ); p = m*p*2.02;\n  f += 0.1250*noise( p ); p = m*p*2.01;\n  f += 0.0625*noise( p );\n  return f/0.03275;\n}\n\nfloat fbm6( vec2 p )\n{\n  float f = 0.0;\n  f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n  f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n  f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n  f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n  f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n  f += 0.015625*(0.5+0.5*noise( p ));\n  return f/sin(10.596871);\n}\n\nfloat func( vec2 q, out vec4 ron )\n{\n  float ql = length( q );\n  q.x += 0.1*sin(0.0527*faceTime+ql*4.1);\n  q.y += 0.1*sin(0.0523*faceTime+ql*4.3);\n  q = 0.5 * sin(q/2.0);\n\n  vec2 o = vec2(0.0);\n  o.x = 0.5 + 0.1*fbm4( vec2(2.0*q          )  );\n  o.y = 0.5 + 0.1*fbm4( vec2(2.0*q+vec2(5.2))  );\n\n  float ol = length( o );\n  o.x += 0.2*sin(0.0512*faceTime+ol)/ol;\n  o.y += 0.2*sin(0.0514*faceTime+ol)/ol;\n\n  vec2 n;\n  n.x = fbm6( vec2(1.0*o+vec2(9.2))  );\n  n.y = fbm6( vec2(1.0*o+vec2(5.7))  );\n\n  vec2 p = mix(q, n, syn_MidPresence);\n\n  float f = 0.5 + 0.5*fbm4( p );\n\n  f = mix( f, f*sin(faceTime/8.0)/4.0, f*abs(n.x) );\n\n  float g = 0.5 + 0.5*sin(sin(500.0*f)*p.x)*sin(sin(500.0*f)*p.y);\n  f *= 1.0-0.5*pow( g, 64.0 );\n\n  ron = vec4( o, n );\n\n  return f + sin(f * faceTime/50.0);\n}\n\nvec3 doMagic(vec2 p)\n{\n  vec2 q = p*-4.6;\n\n  vec4 on = vec4(0.0);\n  float f = func(q, on);\n\n  vec3 col = vec3(0.0);\n  col = mix( vec3(0.3,0.6,0.4), vec3(0.3,0.5,0.05), f );\n  col = mix( col, vec3(0.5,0.5,0.5), dot(on.zw,on.zw) );\n  col = mix( col, vec3(0.2,0.3,0.3), 0.5*on.y*on.y );\n  col = mix( col, vec3(0.3,0.2,0.4), 2.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n  col = clamp( col*f*1.3, 0.1, 0.7 );\n\n  vec3 nor = normalize( vec3( sin(f/faceTime) * resolution.x, 6.0, sin(f/faceTime) * resolution.y ) );\n\n  vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n  float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n  vec3 bdrf;\n  bdrf  = vec3(1.10,1.40,1.95)*(nor.y*0.5+0.5);\n  bdrf += vec3(0.15,0.10,0.05)*dif;\n  col *= 1.3*bdrf;\n  col = 1.0-col;\n  return 1.2*col*col;\n}\n\nvec3 fuckedFace(vec2 posIn) {\n  vec2 q = posIn;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= resolution.x/resolution.y;\n\n  return vec3(doMagic(p));\n}\n\n\n//HashBasher\n#define PHI pow(gl_FragCoord.y,(1.00001/sqrt(1.0)))\n\n// float hashBasherTime = mod(syn_Level*0.08*2.0,100)+400;\n\nfloat hash(float x)\n{\n  return pow(mod(mod(x, PHI)*x, 1.),mod(x,log2(PHI)));\n}\nfloat bash(float x, float hashBasherTime)\n{\n  x = cos(x)*(hashBasherTime/PHI);\n  return pow(mod(mod(x, PHI)*x, 0.5),mod(x,log(PHI)));\n}\nfloat cash(float x, float hashBasherTime)\n{\n  x = step(cos(x),sin(x));\n  return pow(mod(mod(x, PHI)*x, 1.),mod(x,log2(PHI)*x)*hashBasherTime);\n}\nfloat stash(float x, float hashBasherTime)\n{\n  x = smoothstep(sin(x),sin(x+0.1),(x*hashBasherTime));\n  return pow(mod(mod(x, PHI)*hashBasherTime, -1.),mod(PHI,fract(exp(x))));\n}\n\nfloat hashBasher(vec2 pixelPos, float timeIn) {\n\n  float c1 = fract(hash(pixelPos.x+bash(pixelPos.y, timeIn)));\n  float c2 = fract(hash(pixelPos.x+stash(pixelPos.y, timeIn)));\n  float c3 = fract(hash(pixelPos.x+cash(pixelPos.y, timeIn)));\n\n  float cc = smoothstep(c1,c2,c3);\n\n  return cc;\n}\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    vec2 posBL = _uv;\n\n    vec2 posModder = vec2(1.0)-mix(vec2(0.00,-0.02),vec2(0.00,0.02),abs(posBL.y-syn_OnBeat));\n    posBL *= posModder;\n    posBL *= faceZoom;\n    vec3 faceCol = fuckedFace(posBL);\n\n    faceCol -= clamp(texture(face, _uv-vec2(0.0,0.001)).rgb*1.0,0.0,1.0);\n\n    return vec4(faceCol, 1.0);\n  }\n  else if (PASSINDEX == 1.0){\n    vec2 posBL = _uv;\n    posBL.x *= resolution.x/resolution.y;\n    posBL *= vec2(1.2, 1.0);\n\n    float timeSmall = mod(syn_Time*0.08*1.0,100)+400;\n    vec2 pixelPos = _xy.yx*vec2(1.0, 0.2-syn_BassPresence*0.1+timeSmall)+vec2(0,100);\n    float hashySmall = hashBasher(pixelPos, -timeSmall);\n\n    pixelPos = _xy.yx/100.0-vec2(mod(-syn_Time*0.08*3.0,40.0)*10.0,0.0)-1.35;\n    float hashyMed = hashBasher(pixelPos, timeSmall);\n\n    float bigBeatTime = syn_BeatTime*auto_blocks + fresh_blocks;\n\n    float timeBig = mod(bigBeatTime*0.1*6,100)+10;\n    pixelPos = _xy.yx/2000.0+floor(posBL.y*10.0+bigBeatTime*10.0)/10.0-10.0;\n    float hashyBig = hashBasher(pixelPos, timeBig);\n\n\n    vec3 bkgCol;\n    vec3 eyeCol;\n\n    if (bkgColSel == 0.0){\n      bkgCol = vec3(0.0, step(hashyMed, 0.5)*0.8, 1.0)*hashyBig;\n      eyeCol = vec3(-hashySmall, step(hashyMed, 0.5)*0.5, 0.8)*hashyMed;\n    }\n    else if (bkgColSel == 0.1){\n      bkgCol = vec3(0.0, hashyBig, hashyBig)*0.7;\n      eyeCol = vec3(hashyBig,-hashySmall,0.2)*(0.5+hashySmall);\n    }\n    else if (bkgColSel == 0.2){\n      bkgCol = (vec3(0.0, 0.7, 0.7)*hashyBig+vec3(0.2, 0.2, 0.2)*hashyMed)*hashySmall;\n      eyeCol = vec3(hashyMed)*vec3(0.3,hashyBig,0.64);\n    }\n    else if (bkgColSel == 0.3){\n      bkgCol = (vec3(0.2, 0.7, 0.1)*hashyBig+vec3(0.0, 0.0, 0.6)*hashyMed)*hashySmall;\n      eyeCol = vec3(hashyMed, 0.0, hashyBig);\n    }\n\n    if (monochrome > 0.5){\n      // bkgCol = vec3(hashySmall*hashyBig);\n      bkgCol = vec3(0.5);\n      eyeCol = vec3(hashySmall);\n    }\n    if (flashing > 0.5){\n      bkgCol *= (0.4+syn_HighHits*0.7);\n      eyeCol *= (0.5+syn_BassLevel*0.5);\n    }\n\n\n    //Face Part\n\n    posBL = vec2(_pixelate(_uv.x, pixelation*RENDERSIZE.x/RENDERSIZE.y),_pixelate(_uv.y, pixelation));\n    if (pixelation >= 490.0){\n      posBL = _uv;\n    }\n    vec3 faceCol = texture(face, posBL).rgb;\n    float faceArea = clamp(length(faceCol),0.0,1.0);\n\n    float mouth = 1.0-faceArea;\n    faceCol = faceCol.rbg*0.2;\n    faceCol *= vec3(5.0,1.0,1.0);\n    vec3 faceColoring = bkgCol*(0.4+mouth)+pow(faceCol, vec3(2.0))*0.5;\n\n    bkgCol = pow(bkgCol, vec3(1.2-1.0*(syn_HighHits)))*syn_FadeInOut;\n    vec4 col = vec4(mix(bkgCol, faceColoring, faceArea),1.0);\n\n    float eyeMixer = 1.0-step(length(faceCol),0.2);\n    if (extra_cols == 1.0){\n      eyeMixer = 3.0-eyeMixer;\n    }\n    col.rgb = mix(eyeCol*(1.0-faceArea), col.rgb, eyeMixer);\n\n    vec3 tempCol1 = texture(forBlur, _uv+vec2(0.0,-0.01)).rgb;\n    if (flashing > 0.5){\n      col.rgb -= tempCol1*syn_HighHits*length(faceCol);\n    } else {\n      col.rgb += tempCol1*clamp(syn_HighPresence,0.0,0.8)*0.9;\n    }\n\n    col.a = length(faceCol*3);\n    col.a += pow(texture(forBlur, _uv).a,3.0)*(syn_BassLevel-1.0);\n    col.a *= feedback;\n    float drips;\n    if (_exists(syn_UserImage)){    \n      drips = 1.0-_loadUserImageAsMask().r;\n    } else {\n      drips = (1.0-step(length(faceCol),0.2));\n    }\n    vec4 tempCol = texture(forBlur, _uv+vec2(0.0,-0.0001))*syn_BassLevel/drips;\n    if (col.a > 2.0){\n      col = tempCol;\n      if (col.r < -90){\n        col = -col;\n      }\n      col = clamp(col, -100.0, 10.0);\n    }\n    col.rgb += bkgCol;\n    if ((drips < 0.1)&&(length(col.rgb)<2.0)){\n      col.rgb = vec3(0.0);\n    }\n\n    return vec4(col);\n  } else if (PASSINDEX == 2.0){\n    vec2 e = vec2(0.0025,0.0025)*5.0*(1.0-syn_HighPresence-syn_HighHits)*_uvc.y;\n    vec4 blurCol;\n\n    vec2 pixelPos = _uv;\n    if (blurCol.a > 2.0){\n      pixelPos+=vec2(0.0,-0.1);\n    }\n    blurCol = texture(forBlur, pixelPos);\n    // vec4 alphaFeedback = texture(forBlur, _uv+vec2(0.0,-0.1))*syn_BassLevel;\n\n    // if (blurCol.a > 2.0){\n    //   blurCol = alphaFeedback;\n    // }\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(1.0,0.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(0.0,1.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(1.0,1.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(-1.0,0.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(0.0,-1.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(-1.0,-1.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(-1.0,1.0)).rgb;\n    blurCol.rgb += texture(forBlur, pixelPos+e*vec2(1.0,-1.0)).rgb;\n\n    blurCol.rgb = blurCol.rgb/9.0;\n\n    return vec4(blurCol);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"GPU_Melter","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"OFF for quick splitting cells or ON for slow moving worms.","MAX":1,"MIN":0,"NAME":"regime_toggle","TYPE":"toggle","UI_GROUP":"regime"},{"DEFAULT":0,"DESCRIPTION":"Concentric circles feed or poison the simulation.","MAX":1,"MIN":0,"NAME":"cycling_rings","TYPE":"toggle","UI_GROUP":"regime"},{"DEFAULT":1,"DESCRIPTION":"Extra pulsing and shimmering with the music. Turn off to let it naturally progress.","MAX":1,"MIN":0,"NAME":"audio_reactivity","TYPE":"slider","UI_GROUP":"regime"},{"DEFAULT":0,"DESCRIPTION":"Removes the blur effect.","MAX":1,"MIN":0,"NAME":"no_blur","TYPE":"toggle","UI_GROUP":"colorize"},{"DEFAULT":0,"DESCRIPTION":"Choose from one of 7 color palettes.","MAX":6.5,"MIN":0,"NAME":"color_regime","TYPE":"slider","UI_GROUP":"colorize"},{"DEFAULT":0,"DESCRIPTION":"Mix to greyscale for a more minimal look.","MAX":1,"MIN":0,"NAME":"greyscale","TYPE":"slider","UI_GROUP":"colorize"},{"DEFAULT":1.29999995231628,"DESCRIPTION":"Lower for a lot of smaller cells. Higher for fewer, big cells.","MAX":2,"MIN":0.200000002980232,"NAME":"scale","TYPE":"slider","UI_GROUP":"parameters"},{"DEFAULT":1,"DESCRIPTION":"Affects how fast it naturally travels.","MAX":3,"MIN":0.800000011920929,"NAME":"flow_resistance","TYPE":"slider","UI_GROUP":"parameters"},{"DEFAULT":1,"DESCRIPTION":"Affects how eagerly it occupies empty space.","MAX":3,"MIN":0.800000011920929,"NAME":"space_filling","TYPE":"slider","UI_GROUP":"parameters"},{"DEFAULT":1.5,"DESCRIPTION":"Contrast of the feeding media.","MAX":4,"MIN":0.5,"NAME":"contrast","TYPE":"slider","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Lower bound for the birth parameter.","MAX":2,"MIN":0.800000011920929,"NAME":"birth_lower","TYPE":"slider","UI_GROUP":"advanced"},{"DEFAULT":1,"DESCRIPTION":"Higher bound for the birth parameter (more important).","MAX":2,"MIN":0.800000011920929,"NAME":"birth_upper","TYPE":"slider","UI_GROUP":"advanced"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"Lower bound for the survival parameter.","MAX":3,"MIN":0.200000002980232,"NAME":"survival_lower","TYPE":"slider","UI_GROUP":"advanced"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"Higher bound for the survival parameter. (Turn this up if you're getting frequent black outs).","MAX":3,"MIN":0.200000002980232,"NAME":"survival_upper","TYPE":"slider","UI_GROUP":"advanced"},{"DEFAULT":1,"DESCRIPTION":"Timestep. Turn this up for faster, glitchier action.","MAX":3,"MIN":0.800000011920929,"NAME":"timestep","TYPE":"slider","UI_GROUP":"advanced"},{"DEFAULT":[0,0],"DESCRIPTION":"This applies a flow direction to the simulation. This interacts in complex ways with the other parameters. Try to search for different stable flow regimes.","MAX":[1,1],"MIN":[0,0],"NAME":"xy_flow","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"advanced"},{"DEFAULT":0,"DESCRIPTION":"If the simulation dies, return to default parameters and press this button.","MAX":1,"MIN":0,"NAME":"reset_sim","TYPE":"bang","UI_GROUP":"utility"}],"CREDIT":"cornusammonis","DESCRIPTION":"A variant of Stephan Rafler's SmoothLife that uses a separable Gaussian kernel to compute inner and outer fullness. The improvement in performance over full 2D convolution makes it possible to use a much larger kernel in realtime, without using FFT.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\gaussian_smoothlife.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Gaussian SmoothLife","IMAGES":[{"NAME":"image47","PATH":"images/47.jpg"}],"IMAGE_PATH":"gaussian_smoothlife.synScene\\gaussian_smoothlife.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"OFF for quick splitting cells or ON for slow moving worms.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"regime_toggle\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"regime\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Concentric circles feed or poison the simulation.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"cycling_rings\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"regime\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Extra pulsing and shimmering with the music. Turn off to let it naturally progress.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"audio_reactivity\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"regime\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Removes the blur effect.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"no_blur\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"colorize\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Choose from one of 7 color palettes.\",\n         \"MAX\" : 6.5,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"color_regime\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"colorize\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Mix to greyscale for a more minimal look.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"greyscale\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"colorize\"\n      },{\n         \"DEFAULT\" : 1.3,\n         \"DESCRIPTION\" : \"Lower for a lot of smaller cells. Higher for fewer, big cells.\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.2,\n         \"NAME\" : \"scale\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"parameters\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Affects how fast it naturally travels.\",\n         \"MAX\" : 3.0,\n         \"MIN\" : 0.8,\n         \"NAME\" : \"flow_resistance\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"parameters\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Affects how eagerly it occupies empty space.\",\n         \"MAX\" : 3.0,\n         \"MIN\" : 0.8,\n         \"NAME\" : \"space_filling\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"parameters\"\n      },{\n         \"DEFAULT\" : 1.5,\n         \"DESCRIPTION\" : \"Contrast of the feeding media.\",\n         \"MAX\" : 4.0,\n         \"MIN\" : 0.5,\n         \"NAME\" : \"contrast\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Lower bound for the birth parameter.\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.8,\n         \"NAME\" : \"birth_lower\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"advanced\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Higher bound for the birth parameter (more important).\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.8,\n         \"NAME\" : \"birth_upper\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"advanced\"\n      },{\n         \"DEFAULT\" : 0.7,\n         \"DESCRIPTION\" : \"Lower bound for the survival parameter.\",\n         \"MAX\" : 3.0,\n         \"MIN\" : 0.2,\n         \"NAME\" : \"survival_lower\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"advanced\"\n      },{\n         \"DEFAULT\" : 0.7,\n         \"DESCRIPTION\" : \"Higher bound for the survival parameter. (Turn this up if you're getting frequent black outs).\",\n         \"MAX\" : 3.0,\n         \"MIN\" : 0.2,\n         \"NAME\" : \"survival_upper\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"advanced\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Timestep. Turn this up for faster, glitchier action.\",\n         \"MAX\" : 3.0,\n         \"MIN\" : 0.8,\n         \"NAME\" : \"timestep\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"advanced\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"This applies a flow direction to the simulation. This interacts in complex ways with the other parameters. Try to search for different stable flow regimes.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"xy_flow\",\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"advanced\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"If the simulation dies, return to default parameters and press this button.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"reset_sim\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"utility\"\n      }\n   ],\n   \"CREDIT\" : \"cornusammonis\",\n   \"DESCRIPTION\" : \"A variant of Stephan Rafler's SmoothLife that uses a separable Gaussian kernel to compute inner and outer fullness. The improvement in performance over full 2D convolution makes it possible to use a much larger kernel in realtime, without using FFT.\",\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image47\",\n         \"PATH\" : \"images/47.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"gaussian_smoothlife.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 720,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 1280\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 720,\n         \"TARGET\" : \"BuffB\",\n         \"WIDTH\" : 1280\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 720,\n         \"TARGET\" : \"BuffC\",\n         \"WIDTH\" : 1280\n      }\n   ],\n   \"TITLE\" : \"Gaussian SmoothLife\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"BuffA","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"BuffB","WIDTH":1280},{"FLOAT":true,"HEIGHT":720,"TARGET":"BuffC","WIDTH":1280}],"SCRIPT_CODE":"","SHADER_CODE":"vec3 colorPaletteChooser(float colReg, float var){\n  vec3 paletteCol = vec3(0.5);\n  if (colReg < 1.0){\n    paletteCol = _palette(var, vec3(0.500, 0.500, 0.520), vec3(0.500, 0.500, 0.500), vec3(0.780, 0.765, 0.750), vec3(0.360, 0.570, 0.680));\n  } else if (colReg < 2.0){\n    paletteCol = _palette(var, vec3(1.025, 0.361, 0.703), vec3(0.900, 0.506, 0.724), vec3(0.720, 1.005, 0.075), vec3(1.000, 0.950, 0.590));\n  } else if (colReg < 3.0){\n    paletteCol = _palette(1.0-var,vec3(0.540, -0.500, 0.340), vec3(0.630, 0.816, 0.680), vec3(1.410, 0.855, 0.570), vec3(0.370, 0.620, 0.630));\n  } else if (colReg < 4.0){\n    paletteCol = _palette(var,vec3(0.500, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.825, 0.750), vec3(0.500, 0.500, 0.500));\n  } else if (colReg < 5.0){\n    paletteCol = _palette(1.0-var,vec3(0.000, 0.580, 0.453), vec3(0.848, 0.703, 0.110), vec3(0.700, 0.175, 0.542), vec3(0.000, 0.182, 0.915));\n  } else if (colReg < 6.0){\n    paletteCol = _palette(var,vec3(0.411, -0.070, 0.500), vec3(0.350, 0.880, 0.471), vec3(1.398, 1.363, 0.678), vec3(0.652, 0.250, 0.809)).gbr;\n  } else if (colReg < 7.0){\n    paletteCol = _palette(1.0-var,vec3(1.040, 0.180, 0.260), vec3(0.053, 0.775, 0.330), vec3(0.142, 0.523, 0.800), vec3(0.242, 0.887, 0.000));\n  }\n  return paletteCol;\n}\n\n\t\t\t//******** BuffA Code Begins ********\n\nfloat sHighHits = syn_HighHits*audio_reactivity;\nfloat sBassHits = syn_BassHits*audio_reactivity;\n\n// ---------------------------------------------\nfloat or = 9.0*scale*scale;         // outer gaussian std dev\nfloat ir = 3.0*scale*scale;          // inner gaussian std dev\nfloat b1 = 0.19*birth_lower-        0.18*regime_toggle  ;                // birth1\nfloat b2 = 0.222*birth_upper+       0.15*regime_toggle*(1.0-sBassHits*2.5) + sHighHits*0.03;// birth2\nfloat s1 = 0.267*survival_lower-                (1.0-sBassHits);                // survival1\nfloat s2 = 0.445*survival_upper+    regime_toggle*0.2+  sBassHits*0.2;                  // survival2\nfloat dt = (0.2*timestep+sHighHits*0.3);          // timestep\nfloat alpha_n = 0.017*flow_resistance;   // sigmoid width for outer fullness\nfloat alpha_m = 0.112*space_filling;   // sigmoid width for inner fullness\n// ---------------------------------------------\n// float or = 18.0; \n// float ir = 6.0; \n// float b1 = 0.2; \n// float b2 = 0.215; \n// float s1 = 0.25; \n// float s2 = 0.5; \n// float dt = 0.2; \n// float alpha_n = 0.02; \n// float alpha_m = 0.11;\n\nbool reset() {\n    return ((FRAMECOUNT < 2)||(reset_sim>0.5));\n}\n\n// the logistic function is used as a smooth step function\nfloat sigma1(float x,float a,float alpha) \n{ \n    return 1.0 / ( 1.0 + exp( -(x-a)*4.0/alpha ) );\n}\n\nfloat sigma2(float x,float a,float b,float alpha)\n{\n    return sigma1(x,a,alpha) \n        * ( 1.0-sigma1(x,b,alpha) );\n}\n\nfloat sigma_m(float x,float y,float m,float alpha)\n{\n    return x * ( 1.0-sigma1(m,0.5,alpha) ) \n        + y * sigma1(m,0.5,alpha);\n}\n\n// the transition function\n// (n = outer fullness, m = inner fullness)\nfloat s(float n,float m)\n{\n    return sigma2( n, sigma_m(b1,s1,m,alpha_m), \n        sigma_m(b2,s2,m,alpha_m), alpha_n );\n}\n\n#define T(d) texture(BuffA, fract(uv+d)).x\n\nvec4 renderPassA() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    vec2 tx = 1.0 / RENDERSIZE.xy;\n    vec2 uv = fragCoord.xy * tx;\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    \n    \n\t// We can optionally add a laplacian to the update rule\n\t// to decrease the appearance of aliasing, but we also\n\t// introduce subtle anisotropy by doing so.\n        // vec4 t = vec4(tx, -tx.y, 0.0);\n        // float u =    T( t.ww); float u_n =  T( t.wy); float u_e =  T( t.xw);\n        // float u_s =  T( t.wz); float u_w =  T(-t.xw); float u_nw = T(-t.xz);\n        // float u_sw = T(-t.xy); float u_ne = T( t.xy); float u_se = T( t.xz);\n        // float lapl  = _K0*u + _K1*(u_n + u_e + u_w + u_s) + _K2*(u_nw + u_sw + u_ne + u_se);\n       \n\n    vec4 current = texture(BuffA, uv);\n    vec2 fullness = texture(BuffC, uv).xy;\n    \n    float delta =  2.0 * s( fullness.x, fullness.y ) - 1.0;\n    float new = clamp( current.x + dt * delta, 0.0, 1.0 );\n    \n    // if(paint_on > 0.0) {\n    //     // from chronos' SmoothLife shader https://www.shadertoy.com/view/XtdSDn\n    //     float dst = length(fragCoord.xy - paint_xy*RENDERSIZE);\n    //     if(dst <= or) {\n    //     \tnew = step((ir+1.5), dst) * (1.0 - step(or, dst));\n    //     }\n    // }\n    \n    vec4 init = texture(image47, uv*1.4);\n    if(FRAMECOUNT < 10 || reset() || (init != vec4(0) && current.w == 0.0)) {\n    \tfragColor = vec4(2.0*init.xyz,1.0);    \n    } else {\n    \tfragColor = vec4(new, fullness, current.w);\n    }\n\n    fragColor -= cycling_rings*fragColor*sin(length(_uvc)*10.0+TIME*2.0)*0.1;\n\n    float lum = dot(_loadUserImage().rgb,vec3(1.0))/3.0;\n    fragColor.r = max(fragColor.r, pow(lum,contrast*contrast));\n\treturn fragColor; \n } \n\n\n\t\t\t//******** BuffB Code Begins ********\n\n#define SQRT_2_PI 2.50662827463\n\n// ---------------------------------------------\n// const float or2 = 18.0;         // outer gaussian std dev\n// const float ir2 = 6.0;          // inner gaussian std dev\nconst int   oc = 50;           // sample cutoff\n// ---------------------------------------------\n\n\nvec2 gaussian1(float i, vec2 a, vec2 d) {\n     return a * exp( -(i*i) / d );\n}\n\nvec2 gaussian1d1(sampler2D sam, vec2 sigma, vec2 uv, vec2 tx) {\n    vec2 a = vec2(1.0 / (sigma * SQRT_2_PI));\n    vec2 d = vec2(2.0 * sigma * sigma);\n    vec2 acc = vec2(0.0);\n    vec2 sum = vec2(0.0);\n    \n    // centermost term\n    acc += a * texture(sam, uv).x;\n    sum += a;\n\n    // sum up remaining terms symmetrically\n    for (int i = 1; i <= oc; i++) {\n        float fi = float(i);\n        vec2 g = gaussian1(fi, a, d);\n        vec2 posL = fract(uv - tx * fi);\n        vec2 posR = fract(uv + tx * fi);\n        acc += g * (texture(sam, posL).x + texture(sam, posR).x);\n        sum += 2.0 * g;\n    }\n\n    return acc / sum;\n}\n\nvec4 renderPassB() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    vec2 tx = 1.0 / RENDERSIZE.xy;\n    vec2 uv = fragCoord.xy * tx;\n        uv += xy_flow*1;\n\n    tx = (mod(float(FRAMECOUNT),2.0) < 1.0) ? vec2(tx.x,0) : vec2(0,tx.y);\n    vec2 x_pass = gaussian1d1(BuffA, vec2(or, ir), uv, tx);\n    fragColor = vec4(x_pass,0,0);\n\treturn fragColor; \n } \n\n\n\t\t\t//******** BuffC Code Begins ********\n\n#define SQRT_2_PI 2.50662827463\n\n// ---------------------------------------------\n// const float or3 = 18.0;         // outer gaussian std dev\n// const float ir3 = 6.0;          // inner gaussian std dev\n// ---------------------------------------------\n\n\nvec2 gaussian(float i, vec2 a, vec2 d) {\n     return a * exp( -(i*i) / d );\n}\n\nvec2 gaussian1d(sampler2D sam, vec2 sigma, vec2 uv, vec2 tx) {\n    vec2 a = vec2(1.0 / (sigma * SQRT_2_PI));\n    vec2 d = vec2(2.0 * sigma * sigma);\n    vec2 acc = vec2(0.0);\n    vec2 sum = vec2(0.0);\n    \n    // centermost term\n    acc += a * texture(sam, uv).x;\n    sum += a;\n\n    // sum up remaining terms symmetrically\n    for (int i = 1; i <= oc; i++) {\n        float fi = float(i);\n        vec2 g = gaussian(fi, a, d);\n        vec2 posL = fract(uv - tx * fi);\n        vec2 posR = fract(uv + tx * fi);\n        acc += g * (texture(sam, posL).xy + texture(sam, posR).xy);\n        sum += 2.0 * g;\n    }\n\n    return acc / sum;\n}\n\nvec4 renderPassC() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    vec2 tx = 1.0 / RENDERSIZE.xy;\n    vec2 uv = fragCoord.xy * tx;\n            uv += xy_flow*1;\n\n    tx = (mod(float(FRAMECOUNT),2.0) < 1.0) ? vec2(0,tx.y) : vec2(tx.x,0);\n    vec2 y_pass = gaussian1d(BuffB, vec2(or, ir), uv, tx);\n    fragColor = vec4(y_pass,0,0);\n\treturn fragColor; \n } \n\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n\tvec2 uv = fragCoord.xy / RENDERSIZE.xy;\n\tvec4 col = texture(BuffA, uv);\n    \n    float semiBlur = col.b;\n    float blur = col.g;\n    float hard = col.r;\n\n    float colSel = mix(mix(blur, semiBlur, syn_Presence*audio_reactivity), hard, syn_HighHits*audio_reactivity);\n    colSel = mix(colSel, (col.b+col.g+col.r)*(0.33+syn_BassLevel*0.3), max(no_blur, 1.0-audio_reactivity));\n    // vec3 palCol = vec3(0.0,0.0,blur)*syn_BassLevel+colSel*_palette(colSel, vec3(1.439, -0.012, 0.314), vec3(0.746, 0.702, 0.276), vec3(0.680, 0.321, 1.190), vec3(0.407, 0.661, 0.759));\n    vec3 palCol = vec3(0.0,0.0,blur)*syn_BassLevel+colSel*colorPaletteChooser(color_regime, colSel);\n\n    vec3 normCol = col.x*vec3(1.0) + col.y*vec3(1,0.5,0) + col.z*vec3(0,0.5,1);\n    fragColor = vec4(mix(palCol, normCol, greyscale), 1.0);\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderPassA();\n\t}\n\tif(PASSINDEX == 1){\n\t\treturn renderPassB();\n\t}\n\tif(PASSINDEX == 2){\n\t\treturn renderPassC();\n\t}\n\tif(PASSINDEX == 3){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Gaussian SmoothLife","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Click to pull the simulation backwards a bit, or click many times to completely black it out and let it pour forward at the right moment.","MAX":1,"MIN":0,"NAME":"shock_back","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"shock"},{"DEFAULT":0,"DESCRIPTION":"Push the simulation forward, dulling it out a bit in the process.","MAX":1,"MIN":0,"NAME":"shock_forward","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"shock"},{"DEFAULT":1,"DESCRIPTION":"Choose whether the image should be a hard boundary in the simulation (ON) or have a subtle effect (OFF).","MAX":1,"MIN":0,"NAME":"image_block","TYPE":"toggle","UI_GROUP":"general"},{"DEFAULT":0,"DESCRIPTION":"ON Allows dark parts of the simulation to be filled in with inverted colors rather than just black.","MAX":1,"MIN":0,"NAME":"color_inv","TYPE":"toggle","UI_GROUP":"general"},{"DEFAULT":1,"DESCRIPTION":"Let the stirrer move around the screen constantly, or turn off to take manual control.","MAX":1,"MIN":0,"NAME":"auto_position","TYPE":"toggle","UI_GROUP":"position"},{"DEFAULT":[0,0],"DESCRIPTION":"auto position MUST BE SET TO OFF. Manually set the position of the 'stirrer'.","MAX":[0.800000011920929,0.800000011920929],"MIN":[-0.800000011920929,-0.800000011920929],"NAME":"manual_position","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"position"},{"DEFAULT":1,"DESCRIPTION":"Choose whether impulses should happen automatically (ON) or only on your manual command.","MAX":1,"MIN":0,"NAME":"auto_impulse","TYPE":"toggle","UI_GROUP":"impulse"},{"DEFAULT":0,"DESCRIPTION":"Manually cause the stirrer to receive an impulse. Depends on 'motion mode', 'manual position' and 'impulse power'.","MAX":1,"MIN":0,"NAME":"manual_impulse","PARAMS":0.0949999988079071,"TYPE":"bang smooth","UI_GROUP":"impulse"},{"DEFAULT":1,"DESCRIPTION":"Choose how powerful the automatic and manual impulses are.","MAX":2,"MIN":0,"NAME":"impulse_power","TYPE":"slider","UI_GROUP":"impulse"},{"DEFAULT":0,"DESCRIPTION":"Choose whether the stirrer creates vortices on high hits (OFF) or pushes the fluid up on bass hits (ON).","MAX":1,"MIN":0,"NAME":"motion_mode","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Cause the simulation to slowly move inwards or outwards based on the position of the slider. Centered is zero. Careful when maxing out upward, if there is no User Image feeding it, you could kill the simulation and you'd have to restart the scene.","MAX":5,"MIN":-5,"NAME":"in_out","TYPE":"slider","UI_GROUP":"motion"}],"CREDIT":"Felix Woitzel","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\glassier.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Glassier","IMAGES":null,"IMAGE_PATH":"glassier.synScene\\Glassier.png","JSON_CODE":"{\n \"CREDIT\": \"Felix Woitzel\",\n \"TITLE\": \"Glassier\",\n \"IMAGE_PATH\": \"Glassier.jpg\",\n\"IMAGES\": [],\n \"SMOOTH_TRANSITIONS\":[{\n \"UNIFORMS\":[\"cReg4\", \"cReg0\", \"cReg2\", \"cReg3\", \"cReg1\"],\n \"DURATION\": 5\n }],\n\n \"PASSES\": [\n {\"TARGET\":\"buffA\", \"WIDTH\":1600, \"HEIGHT\":900, \"FLOAT\": true},\n {\"TARGET\":\"buffB\", \"WIDTH\":1600, \"HEIGHT\":900, \"FLOAT\": true},\n {\"TARGET\":\"buffC\", \"WIDTH\":1600, \"HEIGHT\":900, \"FLOAT\": true} ],\n\n\"CONTROLS\":[\n  {\"NAME\": \"shock_back\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\":\"bang smooth\", \"PARAMS\": 0.01,\n  \"UI_GROUP\":\"shock\",\"DESCRIPTION\": \"Click to pull the simulation backwards a bit, or click many times to completely black it out and let it pour forward at the right moment.\"},\n  {\"NAME\": \"shock_forward\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\":\"bang smooth\", \"PARAMS\": 0.2,\n  \"UI_GROUP\":\"shock\",\"DESCRIPTION\": \"Push the simulation forward, dulling it out a bit in the process.\"},\n  {\"NAME\": \"image_block\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\":\"general\",\"DESCRIPTION\": \"Choose whether the image should be a hard boundary in the simulation (ON) or have a subtle effect (OFF).\"},\n\t{\"NAME\": \"color_inv\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\":\"toggle\",\n  \"UI_GROUP\":\"general\",\"DESCRIPTION\": \"ON Allows dark parts of the simulation to be filled in with inverted colors rather than just black.\"},\n  {\"NAME\": \"auto_position\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\":\"toggle\",\n  \"UI_GROUP\":\"position\",\"DESCRIPTION\": \"Let the stirrer move around the screen constantly, or turn off to take manual control.\"},\n  {\"NAME\": \"manual_position\", \"DEFAULT\":0.0, \"MIN\":-0.8, \"MAX\":0.8, \"TYPE\":\"xy smooth\", \"PARAMS\": 0.05,\n  \"UI_GROUP\":\"position\",\"DESCRIPTION\": \"auto position MUST BE SET TO OFF. Manually set the position of the 'stirrer'.\"},\n  {\"NAME\": \"auto_impulse\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\":\"toggle\",\n  \"UI_GROUP\":\"impulse\",\"DESCRIPTION\": \"Choose whether impulses should happen automatically (ON) or only on your manual command.\"},\n  {\"NAME\": \"manual_impulse\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\":\"bang smooth\", \"PARAMS\": 0.095,\n  \"UI_GROUP\":\"impulse\",\"DESCRIPTION\": \"Manually cause the stirrer to receive an impulse. Depends on 'motion mode', 'manual position' and 'impulse power'.\"},\n  {\"NAME\": \"impulse_power\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":2.0, \"TYPE\":\"slider\",\n  \"UI_GROUP\":\"impulse\",\"DESCRIPTION\": \"Choose how powerful the automatic and manual impulses are.\"},\n  {\"NAME\": \"motion_mode\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\",\n  \"UI_GROUP\":\"motion\",\"DESCRIPTION\": \"Choose whether the stirrer creates vortices on high hits (OFF) or pushes the fluid up on bass hits (ON).\"},\n  {\"NAME\": \"in_out\", \"DEFAULT\":0.0, \"MIN\":-5.0, \"MAX\":5.0, \"TYPE\":\"slider\",\n  \"UI_GROUP\":\"motion\",\"DESCRIPTION\": \"Cause the simulation to slowly move inwards or outwards based on the position of the slider. Centered is zero. Careful when maxing out upward, if there is no User Image feeding it, you could kill the simulation and you'd have to restart the scene.\"}\n]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":900,"TARGET":"buffA","WIDTH":1600},{"FLOAT":true,"HEIGHT":900,"TARGET":"buffB","WIDTH":1600},{"FLOAT":true,"HEIGHT":900,"TARGET":"buffC","WIDTH":1600}],"SCRIPT_CODE":"","SHADER_CODE":"float bassHits = syn_BassHits;\nfloat highHits = syn_HighHits;\nfloat vuTimeUncorrected = syn_Time;\nfloat bassTimeUncorrected = syn_BassTime;\nfloat randomizerBeat = syn_RandomOnBeat;\nfloat beatTimeUncorrected = syn_BeatTime;\nfloat onBeat = syn_OnBeat;\nfloat switchOnBeat = syn_ToggleOnBeat;\nfloat highsAccum = syn_HighLevel;\nfloat bassAccum = syn_BassLevel;\nfloat vuFadeToBlack = syn_FadeInOut;\n\nvec3 iResolution = vec3(RENDERSIZE.x, RENDERSIZE.y, 0.0);\nfloat iGlobalTime = TIME*1.0;\nint iFrame = int(TIME*60.0);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\nfloat vuTime = vuTimeUncorrected*6*0.01;\nfloat bassTime = vuTimeUncorrected*6*0.01;\nfloat beatTime = beatTimeUncorrected*6;\n// vec2 lightPos = vec2(resolution.x*(0.5+0.5*sin(vuTime*2*PI*0.5)),resolution.y*(0.5+0.5*cos(vuTime*2*PI*0.67)));\n\n// vec4 dataPass(){\n//   vec4 oldTimeData = texelFetch(pass0, ivec2(0,0), 0);\n//   if (TIME <= 0.1){\n//       return vec4(0.0);\n//   }\n//   float newMidiInputX = x_position;\n//   float oldX = oldTimeData.r;\n//   float newX = oldX-(oldX-newMidiInputX)*0.1;\n\n//   float newMidiInputY = y_position;\n//   float oldY = oldTimeData.g;\n//   float newY = oldY-(oldY-newMidiInputY)*0.1;\n\n//   vec4 retData = vec4(newX, newY, abs(newMidiInputX-oldX)+abs(newMidiInputY-oldY), 0.0);\n//   return retData;\n// }\n\n// ****************** PASS 0 ***********************\n// main reaction-diffusion loop\n\n// actually the diffusion is realized as a separated two-pass Gaussian blur kernel and is stored in buffer C\n\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n  return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nfloat sigmoid(float x) {\n  return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n  return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpf1lter(vec2 uv, vec2 pos, float size, float ramp)\n{\n  return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n  vec2 pos_correct = 0.5 + (pos - 0.5);\n  vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n  float f1lter = warpf1lter(uv, pos_correct, size, ramp);\n  return mix(uv, rot_uv, f1lter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel, out float touched){\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n  float ramp = 5.;\n\n  float d = 0.2;\n\n  float l = length(vel);\n  vec2 p1 = pos;\n  vec2 p2 = pos;\n\n  if(l > 0.){\n    vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n    p1 = pos - normal * d / 2.;\n    p2 = pos + normal * d / 2.;\n  }\n\n  float w = l / d * 2.;\n\n  // two overlapping rotations that would annihilate when they were not displaced.\n  vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n  vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n\n  touched = abs(pow(distance((circle1+circle2)/2.0, uv),2.0)*1000);\n  return (circle1 + circle2) / 2.;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 pixelSize = 1. / iResolution.xy;\n\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n  vec2 flowVec = normalize(vec2(sin(PI*2*iGlobalTime), cos(PI*2*iGlobalTime)));\n\n  vec2 brushPosition = manual_position;\n  if (auto_position >= 0.5){\n    brushPosition = vec2((sin(syn_Time*2*PI*0.025)),(cos(syn_HighTime*2*PI*0.1)));\n  }\n  flowVec = brushPosition;\n\n\n  float decay = 0.95;\n\n  float touchOld = texture(buffA, _uv).g*decay;\n  float touchNew;\n\n  float twitcher = (syn_HighHits*auto_impulse+manual_impulse*0.7)*impulse_power;\n\n\n  if (motion_mode < 0.5){\n    uv = vortex_pair_warp(uv, (flowVec+1.0)*0.5, normalize(flowVec)*(twitcher)*0.025, touchNew);\n  }\n\n  vec4 blur1 = texture(buffC, uv);\n\n  vec4 noise = vec4(_noise(_uv*1000.0),_noise(_uv*1000.0),_noise(_uv*1000.0),_noise(_uv*1000.0));\n\n  // get the gradients from the blurred image\n  vec2 d = pixelSize*4.;\n  vec4 dx = (texture(buffC, fract(uv + vec2(1,0)*d)) - texture(buffC, fract(uv - vec2(1,0)*d))) * 0.5;\n  vec4 dy = (texture(buffC, fract(uv + vec2(0,1)*d)) - texture(buffC, fract(uv - vec2(0,1)*d))) * 0.5;\n  // if (flowing == 1.0){\n  //   dy.x += distance(uv*aspect, vec2(0.5,0.0));\n  // }\n\n  vec3 logoCol = vec3(0.0);\n  if (_exists(syn_UserImage)){\n    logoCol = _loadUserImageAsMask().rgb;\n  }\n\n  float distFunc = 0.0;\n  vec2 flowOut;\n  if (motion_mode >= 0.5){\n    twitcher = (pow(syn_BassLevel,2.0)*0.75*auto_impulse+manual_impulse)*impulse_power;\n    vec2 posCent = _uvc-brushPosition*0.5*vec2(RENDERSIZE.x/RENDERSIZE.y,1.0);\n    float mask = smoothstep(twitcher*0.5,twitcher*0.5+0.5,length(posCent));\n    distFunc = 1.0-mask;\n    flowOut = normalize(posCent)*0.6*distFunc*(-0.25+twitcher)*3.0;\n    touchNew += pow(distFunc,10.0)*twitcher*0.2;\n    dx.x -= flowOut.x;\n    dy.x -= flowOut.y;\n  }\n\n  dx.x -= normalize(_uvc).x*0.1*clamp(in_out, -30.0, 10.0);\n  dy.x -= normalize(_uvc).y*0.1*clamp(in_out, -30.0, 10.0);\n\n  if (image_block < 0.5){\n    distFunc = distFunc-length(logoCol)*10.5;\n  }\n\n  // if (invertLogo >= 0.5){\n  //   distFunc = 1.0-logoCol;\n  // }\n\n  vec2 uv_red = uv + vec2(dx.x, dy.x)*pixelSize*8.0*(1.0+shock_forward*8.0); // add some diffusive expansion\n\n  uv_red = mix(uv_red, uv - vec2(dx.x, dy.x)*pixelSize*8.0, pow(shock_back,2.0)); // add some diffusive expansion\n\n\n  float new_red = texture(buffA, fract(uv_red)).x + (noise.x*0.5) * 0.0025 - 0.002; // stochastic dec\n  new_red -= (texture(buffC, fract(uv_red + (noise.xy-0.5)*pixelSize)).x -\n              texture(buffA, fract(uv_red + (noise.xy-0.5)*pixelSize))).x * 0.047  ; // reaction-diffusion\n\n  // float cReg4 = 1.0;\n  // if (cReg4 > 0.01){\n    new_red -= texture(buffC, _uv).r*0.001*syn_BassPresence;\n  // }\n\n  if (distFunc>0.999){\n    new_red = new_red+bassAccum*0.01;\n  }\n\n  // touchNew = 0.0;\n  if(FRAMECOUNT<=10){\n    fragColor = noise;\n  }\n  else{\n    fragColor.r = clamp(new_red, 0., 1.);\n    fragColor.g = touchOld+touchNew;\n  }\n\n  if ((image_block<0.5)&&(length(logoCol)*1.5>1.0)){\n    fragColor.r -= 0.009;\n  }\n\n  if (image_block>=0.5){\n    if (logoCol.r>0.5){\n      fragColor.r = 1.0*syn_BassLevel;\n    }\n  }\n\n\n\n  //    fragColor = noise; // need a restart?\n}\n\n// *************** PASS 1 *****************\n// horizontal Gaussian blur pass\n\nvoid horizontalBlur(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pixelSize = 1./ iResolution.xy;\n  vec2 uv = fragCoord.xy * pixelSize;\n\n  float h = pixelSize.x;\n  vec4 sum = vec4(0.0);\n  sum += texture(buffA, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n  sum += texture(buffA, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n  sum += texture(buffA, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n  sum += texture(buffA, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n  sum += texture(buffA, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n  sum += texture(buffA, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n  sum += texture(buffA, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n  sum += texture(buffA, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n  sum += texture(buffA, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n  fragColor.xyz = sum.xyz/0.98; // normalize\n  fragColor.a = 1.;\n}\n\n\n\n// *************** PASS 2 *****************\n// vertical Gaussian blur pass\nvoid verticalBlur(out vec4 fragColor, in vec2 fragCoord){\n  vec2 pixelSize = 1./ iResolution.xy;\n  vec2 uv = fragCoord.xy * pixelSize;\n\n  float v = pixelSize.y;\n  vec4 sum = vec4(0.0);\n  sum += texture(buffB, fract(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n  sum += texture(buffB, fract(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n\n  fragColor.xyz = sum.xyz/0.98; // normalize\n  fragColor.a = 1.;\n}\n\n\n// *************** PASS 4 *****************\nvoid mainImage4( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 pixelSize = 1. / iResolution.xy;\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n  vec4 noise = vec4(_noise(_uv*1000.0),_noise(_uv*1000.0),_noise(_uv*1000.0),_noise(_uv*1000.0));\n\n  vec2 lightSize=vec2(4.0);\n  // lightSize /= pow(highsAccum,5.0)*2.0;\n\n  // get the gradients from the blurred image\n  vec2 d = pixelSize*2.0;\n  vec4 dx = (texture(buffC, uv + vec2(1,0)*d) - texture(buffC, uv - vec2(1,0)*d))*0.5;\n  vec4 dy = (texture(buffC, uv + vec2(0,1)*d) - texture(buffC, uv - vec2(0,1)*d))*0.5;\n\n  // // add the pixel gradients\n  d = pixelSize;\n  dx += texture(buffA, uv + vec2(1,0)*d) - texture(buffA, uv - vec2(1,0)*d);\n  dy += texture(buffA, uv + vec2(0,1)*d) - texture(buffA, uv - vec2(0,1)*d);\n\n  vec2 displacement = vec2(dx.x,dy.x)*lightSize; // using only the red gradient as displacement vector\n  // float light = pow(max(1.-distance(0.5+(uv-0.5)*aspect*lightSize + displacement*5.0,vec2(0.5)),0.),2.);\n  float light1 = 2.-distance(0.5+(uv-vec2(0.5,1.0))*aspect*lightSize + displacement*5.0,vec2(0.5,1.5));\n  light1 = max(light1,0.0);\n\n  float light2 = 2.-distance(0.5+(uv-vec2(0.5,-1.0))*aspect*lightSize + displacement*5.0,vec2(0.5,1.5));\n  light2 = max(light2,0.0);\n\n  vec3 baseCol = vec3(0.0);\n  vec3 newSpawnCol = vec3(0.0,-1.0,-1.0);\n  vec3 topLightCol = vec3(0.5,0.6,0.7)*2.5;\n  vec3 botLightCol = vec3(0.5,0.6,0.7)*2.5;\n  vec3 motionCol = vec3(-1.1,0.2,0.2)*4.0;\n\n  // float cReg0= 1.0;\n  // float cReg1= 0.0;\n  // float cReg2= 0.0;\n  // float cReg3= 0.0;\n  // float cReg4= 0.0;\n\n\n  // *** Color Regime 1 ***\n  baseCol = mix(baseCol, vec3(0.45,0.75,1.0), cReg1);\n  newSpawnCol = mix(newSpawnCol, vec3(0.45,0.9,1.0), cReg1);\n  topLightCol = mix(topLightCol, vec3(0.25,0.55,1.0), cReg1);\n  botLightCol = mix(botLightCol, vec3(0.25,0.55,1.0), cReg1);\n  motionCol = mix(motionCol, vec3(0.6,0.6,0.08)*3.0, cReg1);\n  // motionCol = mix(motionCol, vec3(0.3,0.4,0.22), cReg1);\n\n  // *** Color Regime 2 ***\n  baseCol = mix(baseCol, vec3(1.2,0.7,0.8)*3.0, cReg2);\n  newSpawnCol = mix(newSpawnCol, vec3(1.0,0.7,0.8)*2.0, cReg2);\n  topLightCol = mix(topLightCol, vec3(1.0,1.0,1.0), cReg2);\n  botLightCol = mix(botLightCol, vec3(1.0,1.0,1.0), cReg2);\n  motionCol = mix(motionCol, vec3(1.0,0.95,0.00)*3.0, cReg2);\n\n  // *** Color Regime 3 ***\n  baseCol = mix(baseCol, vec3(0.5,0.5,0.5), cReg3);\n  newSpawnCol = mix(newSpawnCol, vec3(0.8,0.5,0.1), cReg3);\n  topLightCol = mix(topLightCol, vec3(1.0,0.0,0.0), cReg3);\n  botLightCol = mix(botLightCol, vec3(1.0,0.4,0.1), cReg3);\n  motionCol = mix(motionCol, vec3(0.2,0.2,0.3)*2.0, cReg3);\n\n  // *** Color Regime 4 ***\n  baseCol = mix(baseCol, vec3(1.0,0.0,1.0), cReg4);\n  newSpawnCol = mix(newSpawnCol, vec3(0.2,0.0,0.8), cReg4);\n  topLightCol = mix(topLightCol, vec3(0.3,0.7,1.0)*2.0, cReg4);\n  botLightCol = mix(botLightCol, vec3(0.9,0.8,0.2)*2.0, cReg4);\n  motionCol = mix(motionCol, vec3(1.0,0.77,0.0)*1.0, cReg4);\n\n  baseCol *= 0.5+bassAccum*0.5;\n\n  // recolor the red channel\n  vec3 surface = vec3(texture(buffA,uv+vec2(dx.x,dy.x)*pixelSize*10.0).r);\n  vec3 edges = vec3(pow(texture(buffA,uv+vec2(dx.x,dy.x)).r,10.0));\n\n  vec3 lightCol = topLightCol*light1 + botLightCol*light2;\n  lightCol *= 0.5+highsAccum;\n\n  // and add the light map\n  vec3 finalColor = surface*baseCol + lightCol;\n\n  float darkener = (1.-texture(buffA,uv+vec2(dx.x,dy.x)*pixelSize*lightSize.x).x);\n  finalColor -= darkener;\n\n  float newSpawn = clamp(texture(buffA, _uv).r,0.0,1.0);\n  finalColor = mix(finalColor, edges*newSpawnCol, newSpawn);\n\n  float recentlyTouched = texture(buffA, _uv).g;\n  finalColor = mix(finalColor, motionCol*sqrt(edges)*2.0, recentlyTouched*0.4);\n\n  if (color_inv>0.5){\n    finalColor = pow(finalColor, vec3(1.000001));\n  }\n\n  fragColor = vec4(finalColor, 1.0);\n}\n\n\n\nvec2 getNormPos() {\n  return vec2(-1+2*(gl_FragCoord.x/resolution.x),-1+2*(gl_FragCoord.y/resolution.y));\n}\nvec2 getNormPosBotLeft() {\n  return vec2(gl_FragCoord.xy/resolution.xy);\n}\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    //buffA\n    vec4 fragColor;\n    mainImage0(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 1.0){\n    //buffB\n    vec4 fragColor;\n    horizontalBlur(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 2.0){\n    //buffC\n    vec4 fragColor;\n    verticalBlur(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 3.0){\n    //Image\n    vec4 fragColor;\n    mainImage4(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":5,"UNIFORMS":["cReg4","cReg0","cReg2","cReg3","cReg1"]}],"TAGS":[],"TITLE":"Glassier","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"When ON the center white object or User Image will appear. When OFF, only the background.","MAX":1,"MIN":0,"NAME":"white_on","TYPE":"toggle","UI_GROUP":"white"},{"DEFAULT":0,"DESCRIPTION":"When on, scanning white lines will trace across the scene.","MAX":1,"MIN":0,"NAME":"linesOn","TYPE":"toggle","UI_GROUP":"white"},{"DEFAULT":0,"DESCRIPTION":"white or lines MUST BE SET TO ON. Invert the scene, so background is white and colors only allowed in the center object.","MAX":1,"MIN":0,"NAME":"invert_white","TYPE":"toggle","UI_GROUP":"white"},{"DEFAULT":0.170000001788139,"DESCRIPTION":"How much to separate the colors while applying the RGB split effect. ","MAX":1,"MIN":0,"NAME":"rgb_split","TYPE":"slider","UI_GROUP":"rgb"},{"DEFAULT":0,"DESCRIPTION":"Rotate to change the direction of the slicing effect. Vertical is default.","MAX":0.5,"MIN":-0.5,"NAME":"rotate_slice","TYPE":"knob","UI_GROUP":"slice"},{"DEFAULT":0,"DESCRIPTION":"Increase or decrease the intensity of the drip effect. Bottom is entirely off, top is full.","MAX":7,"MIN":-1,"NAME":"drip_rate","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"slice"},{"DEFAULT":1,"DESCRIPTION":"If ON, every time an intense percussive hit occurs, the background will jump to a new spot. Turn OFF to manually jump instead.","MAX":1,"MIN":0,"NAME":"auto_jumps","TYPE":"toggle","UI_GROUP":"jump"},{"DEFAULT":0,"DESCRIPTION":"auto jumps MUST BE OFF. On press, a new background is chosen and the drip effect restarts.","MAX":1,"MIN":0,"NAME":"jump","TYPE":"bang","UI_GROUP":"jump"}],"CREDIT":"Meebs ft. XOR","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\glitch.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"sizeTri","VALUES":[90,30,200]},{"UNIFORM":"rgbSplitStyle","VALUES":[2,1,0]}],"HEIGHT":1080,"ID":"Glitch","IMAGES":[{"NAME":"myImage","PATH":"images/city.jpg"},{"NAME":"anotherImage","PATH":"images/nightclubLights.jpg"},{"NAME":"badlands","PATH":"images/fire.jpg"},{"NAME":"goop","PATH":"images/goop.jpg"}],"IMAGE_PATH":"glitch.synScene\\glitch.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs ft. XOR\",\n \"TITLE\": \"Glitch\",\n \"IMAGE_PATH\": \"glitch.png\",\n \"HARD_TRANSITIONS\": [\n    {\"UNIFORM\": \"sizeTri\", \"VALUES\":[90.0, 30.0, 200.0]},\n    {\"UNIFORM\": \"rgbSplitStyle\", \"VALUES\":[2.0, 1.0, 0.0]}\n    ],\n \"SMOOTH_TRANSITIONS\":[\n    {\"UNIFORMS\":[\"c0\", \"c1\", \"c2\", \"c3\"], \"DURATION\": 10}\n    ],\n \"IMAGES\": [\n    {\"PATH\": \"images/city.jpg\", \"NAME\": \"myImage\"},\n    {\"PATH\": \"images/nightclubLights.jpg\", \"NAME\": \"anotherImage\"},\n    {\"PATH\": \"images/fire.jpg\", \"NAME\": \"badlands\"},\n    {\"PATH\": \"images/goop.jpg\", \"NAME\": \"goop\"}\n    ],\n  \"CONTROLS\": [{\n            \"NAME\": \"white_on\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":1.00,\n            \"TYPE\": \"toggle\",\n            \"DESCRIPTION\": \"When ON the center white object or User Image will appear. When OFF, only the background.\",\n            \"UI_GROUP\":\"white\"\n        },{\n            \"NAME\": \"linesOn\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.00,\n            \"TYPE\": \"toggle\",\n            \"DESCRIPTION\": \"When on, scanning white lines will trace across the scene.\",\n            \"UI_GROUP\":\"white\"\n        },{\n            \"NAME\": \"invert_white\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.00,\n            \"TYPE\": \"toggle\",\n            \"DESCRIPTION\": \"white or lines MUST BE SET TO ON. Invert the scene, so background is white and colors only allowed in the center object.\",\n            \"UI_GROUP\":\"white\"\n        },{\n            \"NAME\": \"rgb_split\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.17,\n            \"TYPE\": \"slider\",\n            \"DESCRIPTION\": \"How much to separate the colors while applying the RGB split effect. \",\n            \"UI_GROUP\":\"rgb\"\n        },{\n            \"NAME\": \"rotate_slice\",\n            \"MIN\" : -0.5,\n            \"MAX\" : 0.5,\n            \"DEFAULT\":0.0,\n            \"TYPE\": \"knob\",\n            \"DESCRIPTION\": \"Rotate to change the direction of the slicing effect. Vertical is default.\",\n            \"UI_GROUP\":\"slice\"\n        },{\n            \"NAME\": \"drip_rate\",\n            \"MIN\" : -1.0,\n            \"MAX\" : 7.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\": \"slider smooth\",\n            \"PARAMS\": 0.05,\n            \"DESCRIPTION\": \"Increase or decrease the intensity of the drip effect. Bottom is entirely off, top is full.\",\n            \"UI_GROUP\":\"slice\"\n        },{\n            \"NAME\": \"auto_jumps\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":1.00,\n            \"TYPE\": \"toggle\",\n            \"DESCRIPTION\": \"If ON, every time an intense percussive hit occurs, the background will jump to a new spot. Turn OFF to manually jump instead.\",\n            \"UI_GROUP\":\"jump\"\n        },{\n            \"NAME\": \"jump\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.00,\n            \"TYPE\": \"bang\",\n            \"DESCRIPTION\": \"auto jumps MUST BE OFF. On press, a new background is chosen and the drip effect restarts.\",\n            \"UI_GROUP\":\"jump\"\n        }],\n \"PASSES\": [{\"TARGET\":\"pass0\", \"WIDTH\":2, \"HEIGHT\":1, \"FLOAT\": true},\n            {\"TARGET\":\"forDripping\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true},\n            {\"TARGET\":\"dripBuffer\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true},\n            {\"TARGET\":\"forRGBSplit\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true}]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":1,"TARGET":"pass0","WIDTH":2},{"FLOAT":true,"HEIGHT":1080,"TARGET":"forDripping","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"dripBuffer","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"forRGBSplit","WIDTH":1920}],"SCRIPT_CODE":"","SHADER_CODE":"\nfloat triggerNewImg(){\n  float trigger = 0.0;\n  if(auto_jumps>0.5){\n    if (syn_OnBeat > 0.9){\n      trigger = 1.0;\n    }\n  } else {\n    if(jump>0.5){\n      trigger = 1.0;\n    }\n  }\n  return trigger;\n}\n\nvec4 dataPass(){\n    vec4 oldTimeData = texelFetch(pass0, ivec2(0,0), 0);\n    if (FRAMECOUNT <= 5){\n        oldTimeData = vec4(0.0);\n    }\n    float timeSinceReset = oldTimeData.r;\n    timeSinceReset += 1.0/60.0;\n    if (triggerNewImg() == 1.0){\n      timeSinceReset = 0.0;\n    }\n\n    float incrementOnReset = oldTimeData.g;\n    if (triggerNewImg() == 1.0){\n      incrementOnReset += 1.0;\n    }\n    // oldTimeData += pow(vec4(syn_BassLevel, syn_MidLevel, syn_MidHighLevel, syn_HighLevel),vec4(2.0))*0.1;\n    return vec4(timeSinceReset, incrementOnReset, 0.0, 0.0);\n}\n\nfloat rando(float n)\n{\n  return fract(abs(sin(n*55.753)*367.34));   \n}\nfloat rando(vec2 n)\n{\n    return rando(dot(n,vec2(2.46,-1.21)));\n}\nfloat cycle(float n)\n{\n  return cos(fract(n)*2.0*3.141592653)*0.5+0.5;\n}\nvec4 genTris(float size, vec2 motion)\n{\n  float a = radians(60.0);\n  float zoom = size;\n  vec2 c = (_uv*RENDERSIZE + motion * vec2(sin(a),1.0));\n  \n  c = ((c+vec2(c.y,0.0)*cos(a))/zoom)+vec2(floor((c.x-c.y*cos(a))/zoom),0.0);\n  \n  float n = cycle(rando(floor(c*4.0))*0.2+rando(floor(c*2.0))*0.3+rando(floor(c))*0.5+TIME*0.125);\n  \n  float briTris = 0.1*exp(0.03*(pow(n,-1.)));\n\n  vec4 finalCol = vec4(0.0, n*(1.0-syn_BassPresence), pow(n, 2.0), 1.0)+vec4(0.6,0.3,0.0,0.0)*pow(briTris,2.0-syn_HighPresence*1.5);\n\n\n  return clamp(finalCol,0.0,1.0);\n}\n\nvec3 hash3( vec2 p ) //By iq !\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n           dot(p,vec2(269.5,183.3)), \n           dot(p,vec2(419.2,371.9)) );\n  return fract(sin(q)*43758.5453);\n}\nvec4 whiteLines(vec2 posIn)\n{\n  float l=sqrt(RENDERSIZE.x*RENDERSIZE.x+RENDERSIZE.y*RENDERSIZE.y);\n  float eps=0.13;\n  vec2 uv = _xy/RENDERSIZE;\n  uv *= vec2(1.0,0.1);\n  uv += vec2(1.0,0.5);\n  uv.x *= 3.1415*0.5;\n  uv.y *= 2.0;\n  uv.y -= 1.0;\n  uv.y *= RENDERSIZE.y;\n  vec3 color = vec3(0.0,0.0,0.0);\n  float passes = 20.0;\n  \n  for  (float i=0.0; i<passes; i++) {\n      vec3 rd=hash3(vec2(1.45*i/passes,2.0*i/passes)*26.351);\n      float rd_l=0.1-rd.x;\n      float rd_p=3.1415*(rd.y);\n      float rd_speed=2.0+2.0*rd.z;\n      float fy=l*rd_l*cos(uv.x+rd_speed*syn_Time*0.0001+rd_p*i*syn_BassTime*0.1);\n      vec3 col = texture(forDripping, _uv).rgb;\n      if (mod(i, 2)==0){\n        col = vec3(1.0);\n      }\n      if (uv.y >= fy - eps && uv.y <= fy + eps) {\n          color += col*vec3(0.6 - 0.12*abs(uv.y - fy)/eps);\n      }\n  }\n      \n  return vec4(clamp(color.xyz*1.5,0.0,1.0),1.0);\n}\n\nvec4 dripGlitch() {\n  vec4 timeData = texelFetch(pass0, ivec2(0,0), 0);\n  float timeSinceReset = timeData.r;\n  float incrementOnReset = timeData.g;\n\n  float timeModderX, timeModderY, slicerAngleCor;\n\n\n  timeModderY = smoothstep(0.0,0.25,timeSinceReset)-smoothstep(0.35, 1.0,timeSinceReset);\n  timeModderY = pow(timeModderY, 1.5);\n  timeModderY *= 0.0025+drip_rate*0.0025;\n\n  timeModderX = smoothstep(0.2,2.0,timeSinceReset)-smoothstep(2.0, 3.0,timeSinceReset);\n  // timeModderX += timeSinceReset*0.1;\n  timeModderX = pow(timeModderX, 1.5);\n  timeModderX *= 0.0005+drip_rate*0.0005;\n      \n  slicerAngleCor = rotate_slice;\n\n\n  vec2 rotPos = _rotate(_uv, slicerAngleCor*PI);\n  // vec2 rotPos = _uv;\n\n\n  vec4 refreshImg = texture(forDripping, _uv);\n\n  float columns = _pixelate(rotPos.x, 100.0);\n  columns = (-0.5+_rand(columns+incrementOnReset))*2.0;\n\n  float rows = _pixelate(rotPos.y, 500.0);\n  rows = (-0.5+_rand(rows+incrementOnReset))*2.0;\n\n  vec2 posModder = vec2(rows*timeModderX,columns*timeModderY);\n\n  vec2 constantX = vec2(rows*0.0005*clamp(timeSinceReset-2.0, 0.0, 1.0) ,0.0)*syn_FadeInOut;\n\n  vec2 drippedPos = _rotate(_uv, slicerAngleCor*PI)+(posModder)*(0.2+syn_Presence*1.5)+constantX;\n\n  drippedPos = _rotate(drippedPos, -slicerAngleCor*PI);\n\n  vec4 oldDripImg = texture(dripBuffer, _uv);\n  vec4 newDripImg = texture(dripBuffer, drippedPos);\n\n  if (length(oldDripImg)>length(newDripImg)){\n    newDripImg = oldDripImg;\n  }\n    vec4 tritex = clamp(pow(1.0-texture(forDripping, _uv),vec4(3.0))*10.0,0.0,1.0);\n    vec4 logoImg = vec4(step(max(abs(_uvc.x*_pixelate(_fbm(TIME*10.0+_uv.y*100.0), 10.0)), abs(_uvc.y*_pixelate(_fbm(TIME*10.0+_uv.x*100.0), 10.0))),0.05));\n    if(_exists(syn_UserImage)){\n      logoImg = _loadUserImageAsMask();\n    }\n\n  if (triggerNewImg()==1.0){\n    newDripImg = refreshImg;\n    vec2 posModded = _uv*0.8+normalize(clamp(_uvc,0.1,1.0))*sin(TIME*0.1)*0.5+0.5*vec2(sin(TIME*0.25),cos(TIME*0.33));\n    vec4 picture = texture(anotherImage, posModded);\n    if (mod(incrementOnReset,2.0)==0.0){\n      picture = texture(badlands, posModded);\n    }\n    if (mod(incrementOnReset,3.0)==0.0){\n      picture = texture(myImage, posModded);\n    }\n    if (mod(incrementOnReset,4.0)==0.0){\n      picture = texture(goop, posModded);\n    }\n    picture = vec4(_pixelate(picture.r,10.0),_pixelate(picture.g,10.0),_pixelate(picture.b,10.0),_pixelate(picture.a,10.0));\n\n    newDripImg = min(newDripImg,pow(picture,vec4(3.0)));\n    newDripImg += pow(newDripImg, vec4(0.5)).rgba*0.2;\n\n\n    if (linesOn >= 0.5) {\n      vec4 lines = whiteLines(_uv);\n      newDripImg = max(newDripImg, lines*newDripImg);\n      if (invert_white>0.5){\n        lines = 0.9-lines;\n        newDripImg = min(newDripImg, lines*newDripImg);\n        newDripImg += tritex*syn_HighHits*pow(lines,vec4(10.0))*2.0;\n      }else {\n        newDripImg = max(newDripImg, lines*newDripImg);\n        newDripImg += tritex*syn_HighHits*pow(lines,vec4(5.0))*20.0;\n      }\n    } \n\n    if (invert_white >= 0.5){\n      logoImg = 0.9-logoImg;\n\n    }\n    if (white_on >= 0.5){\n      newDripImg = max(newDripImg*1.3, logoImg*0.9);\n      newDripImg += vec4(newDripImg.r*c0*0.4,newDripImg.g*c1*0.4,newDripImg.b*c2,c3)*0.5;\n    }\n  }\n\n  if (linesOn >= 0.5) {\n    vec4 lines = whiteLines(_uv);\n    newDripImg = max(newDripImg, lines*newDripImg);\n    newDripImg += tritex*syn_HighHits*pow(lines,vec4(5.0))*20.0;\n  } \n\n\n  return newDripImg;\n}\n\nvec4 displayDrippedBuffer() {\n  vec4 backbuffer = texture(dripBuffer, _uv);\n  return backbuffer;\n}\n\n\nfloat rgbZoomAmt = pow((syn_BassLevel+syn_BassHits)*0.8+syn_BPMTri*0.3+syn_Hits*0.3,2.0)*pow(rgb_split,2.0);\nfloat time = TIME;\nvec4 renderMain(void)\n{\n\tif (PASSINDEX == 0.0){\n\t\treturn dataPass();\n\t} else if (PASSINDEX == 1.0){\n    return genTris(sizeTri, vec2(sin(TIME)*96.0*3.0, cos(TIME)*96.0)*3.0);\n\t} else if (PASSINDEX == 2.0){\n    return dripGlitch();\n  } else if (PASSINDEX == 3.0){\n    return displayDrippedBuffer();\n  } else if (PASSINDEX == 4.0){\n    vec3 col;\n    vec2 posBL = _uv;\n    // vec2 posTri = getNDCAspectCorrected();\n    // posTri = getMirrorPosSimple(posTri, 1);\n    // posTri *= vec2(0.5,-1.0);\n    // float tri = triGen(posTri, rgbZoomAmt*0.5);\n    float rgbZoomAmtMod = rgbZoomAmt;\n    vec2 modifiedCenter = vec2(cos(time), sin(time))*0.5;\n    if (rgbSplitStyle > 0.5){\n      rgbZoomAmtMod *= _noise(_pixelate(_uv.y,50.0)*100.0);\n    } else if (rgbSplitStyle > 1.5){\n      rgbZoomAmtMod *= -1+mod(_xy.x,3.0);\n    } else {\n      rgbZoomAmtMod *= step(0.5,_noise(_pixelate(_uvc+syn_BeatTime,100.0)*100.0));\n      modifiedCenter = pow(_uvc,vec2(3.0));\n    }\n    vec2 rPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmtMod*0.31*sin(time*0.23)))+modifiedCenter;\n    vec2 gPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmtMod*0.398*sin(time*0.2)))+modifiedCenter;\n    vec2 bPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmtMod*0.33*sin(time*0.3)))+modifiedCenter;\n\n    rPos = abs(rPos);\n    if (rPos.x >= 0.9999){\n      rPos.x = 0.9999-rPos.x;\n    }\n    if (rPos.y >= 0.9999){\n      rPos.y = 0.9999-rPos.y;\n    }\n\n    gPos = abs(gPos);\n    if (gPos.x >= 0.9999){\n      gPos.x = 0.9999-gPos.x;\n    }\n    if (rPos.y >= 0.9999){\n      gPos.y = 0.9999-gPos.y;\n    }\n\n    bPos = abs(bPos);\n    if (bPos.x >= 0.9999){\n      bPos.x = 0.9999-bPos.x;\n    }\n    if (rPos.y >= 0.9999){\n      bPos.y = 0.9999-bPos.y;\n    }\n\n    col.r = texture(forRGBSplit, rPos).r;\n    col.g = texture(forRGBSplit, gPos).g;\n    col.b = texture(forRGBSplit, bPos).b;\n\n    col *= syn_FadeInOut;\n\n    return vec4(col,1.0);\n  }\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":10,"UNIFORMS":["c0","c1","c2","c3"]}],"TAGS":[],"TITLE":"Glitch","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"fade_to_color","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"lighting"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"shading","PARAMS":0.25,"TYPE":"toggle smooth","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"fog","TYPE":"toggle","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"","MAX":-5,"MIN":0,"NAME":"fuzz","PARAMS":0.125,"TYPE":"toggle smooth","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"autofuzz","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"electrify","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"scratch","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"bump_up","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"beat"},{"DEFAULT":1,"DESCRIPTION":"","MAX":0,"MIN":2,"NAME":"size","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"object"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"simplify","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"object"}],"CREDIT":"Nimitz","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\glob.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Glob","IMAGES":null,"IMAGE_PATH":"glob.synScene\\glob.png","JSON_CODE":"{\n  \"CREDIT\": \"Nimitz\",\n  \"TITLE\": \"Glob\",\n  \"IMAGE_PATH\": \"glob.png\",\n  \"SMOOTH_TRANSITIONS\":[\n    {\"UNIFORMS\":[\"c0\",\"c1\",\"c2\",\"c3\"]},\n    {\"UNIFORMS\":[\"b0\",\"b1\",\"b2\",\"b3\"]}\n  ],\n  \"CONTROLS\":[\n  {\"UI_GROUP\":\"lighting\",\"NAME\": \"fade_to_color\", \"DEFAULT\":1.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"slider smooth\", \"PARAMS\": 0.05},\n  {\"UI_GROUP\":\"lighting\",\"NAME\": \"shading\", \"DEFAULT\":1.0, \"MIN\":-1.0, \"MAX\":1.0, \"TYPE\": \"toggle smooth\", \"PARAMS\": 0.25, \"VALUES\": [0.0, 1.0, -1.0], \"LABELS\": [\"flat\", \"back\", \"front\"]},\n  {\"UI_GROUP\":\"lighting\",\"NAME\": \"fog\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\"},\n  {\"UI_GROUP\":\"effects\",\"NAME\": \"fuzz\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":-5.0, \"TYPE\": \"toggle smooth\", \"PARAMS\": 0.125},\n  {\"UI_GROUP\":\"effects\",\"NAME\": \"autofuzz\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\"},\n  {\"UI_GROUP\":\"effects\",\"NAME\": \"electrify\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\"},\n  {\"NAME\": \"scratch\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"toggle\", \"UI_GROUP\": \"effects\"},\n  {\"UI_GROUP\":\"beat\",\"NAME\": \"bump_up\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"bang smooth\", \"PARAMS\": 0.2},\n  {\"UI_GROUP\":\"object\",\"NAME\": \"size\", \"DEFAULT\":1.0, \"MIN\":2.0, \"MAX\":0.0, \"TYPE\": \"slider smooth\", \"PARAMS\": 0.01},\n  {\"UI_GROUP\":\"object\",\"NAME\": \"simplify\", \"DEFAULT\":0.0, \"MIN\":0.0, \"MAX\":1.0, \"TYPE\": \"slider smooth\", \"PARAMS\": 0.1}\n\n]\n}\n","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"float t;\nfloat highcolor;\nfloat lowcolor;\nfloat fade;\nfloat edibleHelper;\n\nmat2 m(float a){\n  float c=cos(a), s=sin(a);\n  return mat2(c,-s,s,c);\n}\n\nfloat map(vec3 p){\n    p.xz*= m(t*0.4);\n    p.xy*= m(t*0.3);\n    vec3 q = p*2.0+t*1.;\n    q = mix(q, p*0.1+t*1., simplify);\n    float map1 = length(p+vec3(sin(t*0.7)))*log(length(p*pow(size,3.0))+1.) + sin(q.x+sin(q.z+sin(q.y)))*0.5 - 1.;\n    float map2 = map1 + length(q)*0.0005 + sin(q.z*q.y)*fract(syn_BPMTwitcher)*0.1*scratch;\n    return map2;\n}\n\nvec3 color1() {\n  vec3 C = vec3(0.1,0.3,.4);\n  C = mix(C, vec3(0.1,0.3,0.4), c1);\n  C = mix(C, vec3(0.4,0.2,0.2), c2);\n  C = mix(C, vec3(0.05,0.3,0.15), c3);\n  return C;\n}\n\nvec3 color2() {\n  vec3 C = vec3(5, 2.5, 3);\n  C = mix(C, vec3(5,4,2),   b1);\n  C = mix(C, vec3(3,5,2.5), b2);\n  C = mix(C, vec3(1,2.5,6), b3);\n  return C;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mainImage(vec2 p){\n  vec3 cl = vec3(0);\n  float d = fade;\n  float iters = 3.0+syn_HighHits*5.0;\n  if (autofuzz <= 0.5){\n    iters = 7+fuzz;\n  }\n  if (_exists(syn_UserImage)){\n    float tempo = _loadUserImageAsMask().r;\n    iters -= (iters/2)*tempo*0.5;\n  }\n  for(int i=0; i<=iters; i++)\t{\n\t\tvec3 p = vec3(0,0,5) + normalize(vec3(p, -1.))*d;\n    vec3 posMod = vec3(fade_to_color, fade_to_color, 1.0+(1.0-fade_to_color)*0.75);\n    float rz = map(p*vec3(1.0-bump_up,1.0+bump_up,1.0)*posMod);\n\t\tfloat f =  clamp((rz - map(p+.1*shading))*0.5, -.1, 1. );\n    vec3 l = (color1()*lowcolor) + color2()*(f + highcolor);\n    if (fog >= 0.5){\n      cl = cl + hsv2rgb(vec3(f+edibleHelper, 0.5+0.5*sin(rz*2.0)-edibleHelper, f))*1.0;\n    } else{\n      cl = cl*l + (1.-smoothstep(0., 2.5, rz))*.7*l;\n    }\n\t\td += min(rz, 1.);\n\t}\n  return cl;\n}\n\n\nvec4 renderMain() {\n  t = mod((syn_CurvedTime*0.7+syn_Time*0.3),500.0);\n  highcolor = syn_HighHits * 0.1;\n  lowcolor = _scale(syn_BassHits, 1.2, 0.7);\n  fade     = _scale(syn_FadeInOut, 10, 2.5);\n  edibleHelper = (fog-0.5)*2.0;\n\n  vec2 p = _uvc;\n  p = _rotate(p, TIME/10);\n  // p *= (1.0-bump_up);\n\n\n  vec3 col = mainImage(p)*2/3;\n  if (electrify >= 0.5){\n    p = _rotate(p,length(col)*PI);\n  } else {\n    p = _rotate(p,1.0);\n    p /= 5;\n  }\n  col += mainImage(p)/3;\n\n  return vec4(col, 1.0);\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":0.5,"UNIFORMS":["c0","c1","c2","c3"]},{"DURATION":0.5,"UNIFORMS":["b0","b1","b2","b3"]}],"TAGS":[],"TITLE":"Glob","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Splits the hexagons into triangles, diamonds, and trapezoids.","MAX":1,"MIN":0,"NAME":"alt_geometry","TYPE":"toggle","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Creates a flat plane of shapes instead of a sphere.","MAX":1,"MIN":0,"NAME":"flat_plane","TYPE":"toggle","UI_GROUP":"geometry"},{"DEFAULT":0.5,"DESCRIPTION":"Sets how much the bumps extend from the surface.","MAX":1,"MIN":0,"NAME":"size_bumps","TYPE":"slider","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"Number of hexagons fit onto the surface. Higher for more, smaller hexagons.","MAX":3,"MIN":0,"NAME":"num_hexes","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":4.69999980926514,"DESCRIPTION":"Elevation of the camera.","MAX":10,"MIN":3,"NAME":"elevation","TYPE":"slider","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"When on, the bumps will bounce more often, on any bass instead of the beat.","MAX":0,"MIN":1,"NAME":"bass_bump","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0,"DESCRIPTION":"Lets see some moves.","MAX":1,"MIN":0,"NAME":"DISCO","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":1,"DESCRIPTION":"When DISCO is on, this sets the background flashing with hexagons as well.","MAX":1,"MIN":0,"NAME":"disco_bkg","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"More dramatic, high contrast lighting.","MAX":1,"MIN":0,"NAME":"intense_lighting","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"lighting"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Turns off the background coloration. Can be good when you're using media.","MAX":1,"MIN":0,"NAME":"bkg_off","TYPE":"toggle","UI_GROUP":"lighting"},{"DEFAULT":[1,1,1],"DESCRIPTION":"The default, rainbow color scheme gets multiplied by this color. Set it off white to limit the color palette.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"mult_col","TYPE":"color","UI_GROUP":"lighting"}],"CREDIT":"aiekick","DESCRIPTION":"based on pattern from 104 shader https://www.shadertoy.com/view/ltlSW4  displaced on ball\nyou can comment line 4 il you want unlimited dispalce from 0 to 1.\nMouse Axis X =&gt; Grow Up/Down // Mouse Axis Y =&gt; Density from 0 to 100.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\hexoplanet.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"grouping_size","VALUES":[1,0.200000002980232,0.5,1.5,2]}],"HEIGHT":1080,"ID":"HEXOplanet","IMAGES":[{"NAME":"skyTex","PATH":"images/skytex.jpg"}],"IMAGE_PATH":"hexoplanet.synScene\\hexoplanet.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Splits the hexagons into triangles, diamonds, and trapezoids.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"alt_geometry\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"geometry\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Creates a flat plane of shapes instead of a sphere.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flat_plane\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Sets how much the bumps extend from the surface.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"size_bumps\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Number of hexagons fit onto the surface. Higher for more, smaller hexagons.\",\n         \"MAX\" : 3,\n         \"MIN\" : 0,\n         \"NAME\" : \"num_hexes\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 4.7,\n         \"DESCRIPTION\" : \"Elevation of the camera.\",\n         \"MAX\" : 10,\n         \"MIN\" : 3,\n         \"NAME\" : \"elevation\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"When on, the bumps will bounce more often, on any bass instead of the beat.\",\n         \"MAX\" : 0,\n         \"MIN\" : 1,\n         \"NAME\" : \"bass_bump\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Lets see some moves.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"DISCO\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"When DISCO is on, this sets the background flashing with hexagons as well.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"disco_bkg\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"More dramatic, high contrast lighting.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"intense_lighting\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"lighting\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"Turns off the background coloration. Can be good when you're using media.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"bkg_off\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"lighting\"\n      },\n      {\n         \"DEFAULT\" : 0.20000000298023224,\n         \"DEF_COLOR\" : [ 1, 1, 1 ],\n         \"DESCRIPTION\" : \"The default, rainbow color scheme gets multiplied by this color. Set it off white to limit the color palette.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"mult_col\",\n         \"TYPE\" : \"color\",\n         \"UI_GROUP\" : \"lighting\"\n      }\n   ],\n   \"CREDIT\" : \"aiekick\",\n   \"DESCRIPTION\" : \"based on pattern from 104 shader https://www.shadertoy.com/view/ltlSW4  displaced on ball\\nyou can comment line 4 il you want unlimited dispalce from 0 to 1.\\nMouse Axis X =&gt; Grow Up/Down // Mouse Axis Y =&gt; Density from 0 to 100.\",\n   \"HARD_TRANSITIONS\" : [\n      {\n         \"UNIFORM\" : \"grouping_size\",\n         \"VALUES\" : [ 1, 0.20000000298023224, 0.5, 1.5, 2 ]\n      }\n   ],\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"skyTex\",\n         \"PATH\" : \"images/skytex.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"hexoplanet.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 576,\n         \"TARGET\" : \"tunnelPass\",\n         \"WIDTH\" : 1024\n      }\n   ],\n   \"TITLE\" : \"HEXOplanet\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":576,"TARGET":"tunnelPass","WIDTH":1024}],"SCRIPT_CODE":"","SHADER_CODE":"// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// #define limited_displace\n\nfloat dstepf = 0.0;\n\nconst vec2 RMPrec = vec2(0.2, 0.05); \nconst vec3 DPrec = vec3(1e-3, 12., 1e-8); \n\nvec2 Params; // x => ratio, y => Density\n\nfloat bassBump = (clamp(syn_BassLevel, 0.25, 1.0)-0.25)*1.5;\nfloat bumpAction = mix(bassBump*bassBump, syn_ToggleOnBeat, bass_bump);\nvec4 map(vec3 p)\n{\n\t// pattern based on 104 shader https://www.shadertoy.com/view/ltlSW4 \n    vec4 col = vec4(p,1);\n    vec2 i = col.xz*Params.y;\n    i=i/col.y+syn_Time*0.2;\n    i-=col.xy=ceil(i+=i.x*=.577);\n    if (alt_geometry>0.5){\n        col.xz+=step(1.,col.z=mod(col.x+col.y,3.))-step(2.,col.z)*step(i,i.yx)*mod(syn_BeatTime, 8.0)*0.5;\n        col.y=0.;\n    } else {\n        col.xy+=step(1.,col.z=mod(col.x+col.y,3.))-step(2.,col.z)*step(i,i.yx);\n        col.z=0.;\n    }\n    col=.5+.5*sin(col*grouping_size);\n\n    dstepf += 0.005;\n\n    // float disp;\n    \n    // #ifdef limited_displace\n    // \tdisp = dot(col.rgb,vec3(Params.x));\n    // #else\n    // \tdisp = dot(col,vec4(Params.x));\n    // #endif               \n                \n    float disp = col.r*col.g*(1.0+alt_geometry*1.0);\n    float space = flat_plane<0.5 ? length(p):p.y;\n    float dist = space - 3.5 - smoothstep(0., 1., disp*bumpAction)*size_bumps;\n    col = mix(col, 1.0-col.brra, alt_geometry);\n    return vec4(dist, col.rgb*mult_col);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    p*=0.5;\n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );\n    if (syn_MediaType < 0.5){\n        p = (texture(t, p.yz+0.5)*n.x + texture(t, p.zx+0.5)*n.y + texture(t, p.xy+0.5)*n.z).xyz;\n    } else {\n        p *= 1.0;\n        p = (texture(syn_UserImage, p.yz+0.5)*n.x + texture(syn_UserImage, p.zx+0.5)*n.y + texture(syn_UserImage, p.xy+0.5)*n.z).xyz;\n        p *= 2.0;\n    }\n    return p*p;\n}\n\nvec4 renderMainImage() {\n\tvec4 f = vec4(0.0);\n\tvec2 g = _xy;\n\n    vec2 si = RENDERSIZE.xy;\n   \tfloat t = TIME;\n    Params.x = 0.75;\n    Params.y = 10.;\n    Params = vec2(0.75, num_hexes*num_hexes*20.0);\n    f = vec4(0.);\n    float ca = t*.2; // angle z\n    float ce = elevation; // elevation\n    float cd = 0.5; // distance to origin axis\n    vec3 cu=vec3(0,1,0);//Change camere up vector here\n    vec3 cv=vec3(0,0,0); //Change camere view here\n    float refl_i = .6; // reflexion intensity\n    float refr_a = 1.2; // refraction angle\n    float refr_i = .8; // refraction intensity\n    float bii = 0.6; // bright init intensity\n    vec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); //\n    vec3 rd = cam(uv, ro, cu, cv);\n    float b = bii;\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    float s = DPrec.y;\n    float rmd = sign(map(p).x);\n    for(int i=0;i<1000;i++)\n    {      \n\t\tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n       \tif (sign(s) != rmd) break;\n        d.y = d.x;\n        d.x += s * 0.3/1.3;\n        p = ro+rd*d.x;\n   \t}\n\n    float countIter = 0.;\n    if (sign(s) == rmd)\n    {\n    \tp = ro+rd*d.x;\n        rmd = map(p).x;\n        for (int i = 0; i < 20; i++)\n        {\n        \tcountIter += 10.;\n            d.z = (d.x + d.y)*.5;\n            p = ro+rd*d.z;\n            s = map(p).x*RMPrec.y;\n            d.x += abs(s);\n            if (abs(s) < DPrec.z)break;\n            (d.x*rmd < 0. )? (d.x = d.z ): (d.y = d.z);\n       \t}\n        d.x = (d.x+d.y) * .5;\n   \t}\n\n    f += pow(b,15.);\n    \n    float hit = 0.0;\n    if (d.x<DPrec.y)\n    {\n        hit = 1.0;\n    \tfloat nPrec = 10./countIter;\n        vec3 n = nor(p, nPrec);\n        vec3 ray = reflect(rd, n);\n        f.rgb += tpl(skyTex, ray*1.0, n) * refl_i; \n        ray = refract(rd, n, refr_a);\n        f.rgb += tpl(skyTex, rd*1.0, n) * refr_i; \n        f.rgb = mix(f.rgb, map(p).yzw,0.65-syn_BassLevel*syn_BassLevel*0.25);                \n   \t}\n    else\n    {\n        f = mix(vec4(tpl(skyTex, rd*0.75, -rd*0.01), 1.0)*0.3, vec4(0.2), bkg_off);\n    }\n\n    f *= mix(dstepf, dstepf*dstepf*dstepf*0.1, sqrt(intense_lighting));\n    vec3 hexCol = map(p).gba;\n\n    vec3 hsvCol = _rgb2hsv(hexCol);\n    float surf = smoothstep(2.0, 5.0, d.z);\n    surf = mix(hit, hit+smoothstep(2.0, 5.0, d.z), disco_bkg);\n    surf *= _pulse(hsvCol.r, 0.5+0.5*sin(syn_BeatTime), 0.2)*(syn_Hits*syn_Hits)*2.0;\n\n    vec4 colOut = vec4(surf*hexCol, 1.0);\n\n    f += colOut*DISCO;\n\treturn f; \n } \n\nvec3 filter_() {\n  vec2 delta = 1. / RENDERSIZE;\n  \n  vec3 val = texture(tunnelPass, _uv).xyz;\n\n\n  vec3 l = texture(tunnelPass, _uv + vec2(0., delta.y)).xyz;\n  vec3 r = texture(tunnelPass, _uv - vec2(0., delta.y)).xyz;\n  vec3 u = texture(tunnelPass, _uv + vec2(delta.x, 0.)).xyz;\n  vec3 d = texture(tunnelPass, _uv - vec2(delta.x, 0.)).xyz;\n  \n  vec3 bloom = max(val, max(max(l, r), max( u, d)));\n  bloom = bloom  + l + r + u + d;\n  bloom /= 5.; // orlando;\n  return bloom;\n\n}\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t} else if (PASSINDEX == 1){\n        return vec4(filter_(), 1.0);\n    }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"HEXOplanet","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"split_position","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"MKGartner","DESCRIPTION":"Init walkthrough from the docs","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\helloworld.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"HelloWorld","IMAGES":null,"IMAGE_PATH":"helloworld.synScene\\helloworld.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"split_position\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"MKGartner\",\n\t\"DESCRIPTION\" : \"Init walkthrough from the docs\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"helloworld.png\",\n\t\"TITLE\" : \"HelloWorld\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec3 splitScreen(vec3 screen1, vec3 screen2, float split_value){\r\n    if (_uv.y > split_value){\r\n        return screen1;\r\n    } else {\r\n        return screen2;\r\n    }\r\n}\r\n\r\nfloat drawCircle(vec2 circlePosition, float circleSize){\r\n    if (distance(_uvc, circlePosition)<circleSize){\r\n        return 1.0;\r\n    }\r\n    return 0.0;\r\n}\r\n\r\nvec4 renderMain(void)\r\n{\r\n    vec3 whiteBackground = vec3(1.0,1.0,1.0);\r\n    vec3 cyanBackground = vec3(0.0,1.0,1.0);\r\n    vec3 background = splitScreen(whiteBackground, cyanBackground, split_position);\r\n\r\n    float insideCircle = drawCircle(vec2(0.0), clamp(syn_BassHits-.25, 0.25, .5));\r\n    vec3 finalColor = background*(1.0-insideCircle);\r\n\r\n    vec3 circleColor = vec3(1.0,0.75,0.1);\r\n    finalColor += circleColor*insideCircle;\r\n\r\n    return vec4(finalColor, 1.0);\r\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"HelloWorld","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":3.14000010490417,"DESCRIPTION":"","MAX":6.28000020980835,"MIN":0,"NAME":"spin","PARAMS":0.109999999403954,"TYPE":"knob smooth","UI_GROUP":"twist"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1.5,"MIN":-1.5,"NAME":"squiggle","PARAMS":0.109999999403954,"TYPE":"knob smooth","UI_GROUP":"twist"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":3,"MIN":0.00999999977648258,"NAME":"separation","PARAMS":0.109999999403954,"TYPE":"slider smooth","UI_GROUP":"space"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[5,5],"MIN":[0,0],"NAME":"xy_mod","PARAMS":0.109999999403954,"TYPE":"xy smooth","UI_GROUP":"space"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"fly_in_out","PARAMS":0.0799999982118607,"TYPE":"slider traveler","UI_GROUP":"space"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"","MAX":1.39999997615814,"MIN":0.00999999977648258,"NAME":"size","PARAMS":0.150000005960464,"TYPE":"slider smooth","UI_GROUP":"hexagons"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"size_hole","PARAMS":0.150000005960464,"TYPE":"slider smooth","UI_GROUP":"hexagons"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"","MAX":1,"MIN":0.00100000004749745,"NAME":"depth","PARAMS":0.109999999403954,"TYPE":"slider smooth","UI_GROUP":"hexagons"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"greyscale","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"lighting","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"color"}],"CREDIT":"sheltron","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\hex_array.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Hex Array","IMAGES":null,"IMAGE_PATH":"hex_array.synScene\\hex_array.png","JSON_CODE":"{\n  \"CREDIT\": \"sheltron\",\n  \"TITLE\": \"Hex Array\",\n  \"IMAGE_PATH\": \"hex_array.png\",\n  \"CONTROLS\": [\n    {\n      \"NAME\" : \"spin\",\n      \"TYPE\" : \"knob smooth\",\n      \"PARAMS\": 0.11,\n      \"DEFAULT\" :3.14,\n      \"MIN\" : 0,\n      \"MAX\" : 6.28,\n      \"UI_GROUP\": \"twist\"\n    },\n    {\n      \"NAME\" : \"squiggle\",\n      \"TYPE\" : \"knob smooth\",\n      \"PARAMS\": 0.11,\n      \"DEFAULT\" : 0.5,\n      \"MIN\" : -1.5,\n      \"MAX\" : 1.5,\n      \"UI_GROUP\": \"twist\"\n    },\n    {\n      \"NAME\" : \"separation\",\n      \"TYPE\" : \"slider smooth\",\n      \"PARAMS\": 0.11,\n      \"DEFAULT\" : 0.5,\n      \"MIN\" : 0.01,\n      \"MAX\" : 3,\n      \"UI_GROUP\": \"space\"\n    },\n    {\n      \"NAME\" : \"xy_mod\",\n      \"TYPE\" : \"xy smooth\",\n      \"PARAMS\": 0.11,\n      \"DEFAULT\" : 0.5,\n      \"MIN\" : 0.0,\n      \"MAX\" : 5,\n      \"UI_GROUP\": \"space\"\n    },\n    {\n      \"NAME\" : \"fly_in_out\",\n      \"TYPE\" : \"slider traveler\",\n      \"PARAMS\": 0.08,\n      \"UI_GROUP\": \"space\"\n    },\n    {\n      \"NAME\" : \"size\",\n      \"TYPE\" : \"slider smooth\",\n      \"PARAMS\": 0.15,\n      \"DEFAULT\" : 0.4,\n      \"MIN\" : 0.01,\n      \"MAX\" : 1.4,\n      \"UI_GROUP\": \"hexagons\"\n    },\n    {\n      \"NAME\" : \"size_hole\",\n      \"TYPE\" : \"slider smooth\",\n      \"PARAMS\": 0.15,\n      \"DEFAULT\" : 0.5,\n      \"MIN\" : 0,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"hexagons\"\n    },\n    {\n      \"NAME\" : \"depth\",\n      \"TYPE\" : \"slider smooth\",\n      \"PARAMS\": 0.11,\n      \"DEFAULT\" : 0.1,\n      \"MIN\" : 0.001,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"hexagons\"\n    },{\n      \"NAME\" : \"greyscale\",\n      \"TYPE\" : \"toggle\",\n      \"DEFAULT\" : 0,\n      \"MIN\" : 0,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"color\"\n    },{\n      \"NAME\" : \"lighting\",\n      \"TYPE\" : \"slider smooth\",\n      \"PARAMS\": 0.4,\n      \"DEFAULT\" :0.7,\n      \"MIN\" : 0,\n      \"MAX\" : 1,\n      \"UI_GROUP\": \"color\"\n    }\n\n  ],\n  \"PASSES\": [\n    {\"TARGET\":\"backbuffer\", \"WIDTH\":1200, \"HEIGHT\":720}\n  ]\n}","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"backbuffer","WIDTH":1200}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nvar bpmcount = new BPMCounter();\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM/4.0;\n  bpmcount.updateTime(bpm, dt);\n\n  if (bpmcount.didIncrement == 1.0){\n    tAtLast0 = t;\n  }\n  t = tAtLast0;\n  t += (1. - Math.exp(-bpmcount.timeWithinBeat*3.));\n  uniforms.script_time = t;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"#define MAX_ITER 40\n\nfloat termThres = 10.0;\n\nvec3 filter_() {\n  vec2 delta = 1. / RENDERSIZE;\n  \n  vec3 val = texture(backbuffer, _uv).xyz;\n\n\n  vec3 l = texture(backbuffer, _uv + vec2(0., delta.y)).xyz;\n  vec3 r = texture(backbuffer, _uv - vec2(0., delta.y)).xyz;\n  vec3 u = texture(backbuffer, _uv + vec2(delta.x, 0.)).xyz;\n  vec3 d = texture(backbuffer, _uv - vec2(delta.x, 0.)).xyz;\n\n  vec3 n = vec3(_rand(_uvc+TIME)) - 0.5;\n  \n  vec3 bloom = max(val, max(max(l, r), max( u, d)));\n  // bloom = bloom  + l + r + u + d;\n  // bloom /= 5.; // orlando;\n  return bloom + n/9.;\n\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    \n    return q;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat hex(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z-h.y, max((q.x*0.866025+q.y*0.5),q.y) - h.x);\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nvec2 polar(vec2 c) {\n  return vec2(atan(c.y, c.x), length(c));\n}\nvec2 cart(vec2 p) {\n  return p.y * vec2(cos(p.x), sin(p.x));\n}\n\n\n\nvec2 DE(vec3 pos) {\n\n  pos = pos * rotationMatrix(normalize(vec3(0., 0., 1.)), spin + TIME/10. + squiggle * sin(pos.z));\n  \n  // pos -= vec3(0., sin(TIME), cos(TIME));\n  pos = opRep(pos, vec3(xy_mod.x+separation, xy_mod.y+separation,separation));\n  \n\n  pos.xy = polar(pos.xy);\n  pos.x += 5.;\n  pos.xy = cart(pos.xy);\n\n  float a = hex(pos, vec2(size * separation,  depth/2.));\n  float b = hex(pos, vec2(size_hole * size * separation, depth));\n\n   // b = sdTriPrism(pos - vec3(-1., 0., 0.), vec2(0.6, 1.));\n  // float c = sdTriPrism(pos - vec3(0., 0., 0.), vec2(0.6, 1.));\n\n  float d =  max(a,-b);\n\n  return vec2(pos.z, d);\n}\n\nvec3 gradient(vec3 p, float t) {\n      vec2 e = vec2(0., t);\n\n      return normalize( \n        vec3(\n          DE(p+e.yxx).y - DE(p-e.yxx).y,\n          DE(p+e.xyx).y - DE(p-e.xyx).y,\n          DE(p+e.xxy).y - DE(p-e.xxy).y\n        )\n      );\n    }\n\nvec3 palette( in float t)\n{\nvec3 a = vec3(0.600, 0.500, 0.500);\nvec3 b = vec3(1.000, 0.500, 0.500);\nvec3 c = vec3(0.500, 0.690, 0.750);\nvec3 d = vec3(0.500, 0.500, 0.500);\n  \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 raycast() {\n  \n  vec3 camera = vec3( 0., 0., script_time*(0.5+(separation*1.1-0.5)) + fly_in_out);\n  vec2 screenPos = -1.0 + 2.0 * _uv;\n  screenPos.x *= RENDERSIZE.x / RENDERSIZE.y;\n  vec2 n = vec2(_rand(_uvc+TIME)) - 0.5;\n  \n  // screenPos += n/100.;\n  vec3 ray = normalize(vec3( screenPos, 1.0));\n  float thresh = exp(-termThres);\n\n  \n  // raycasting parameter \n  float t  = 0.;\n  vec3 point;\n  int iter = 0;\n  bool hit = false;\n  vec2 dist;\n  // ray stepping \n  for(int i = 0; i < MAX_ITER; i++) {\n    point = camera + ray * t;\n     dist = DE(point);\n\n    thresh = exp(-termThres) * exp(t/4.);\n  \n    if (abs(dist.y) < thresh ) {\n      hit = true;\n      break;\n    }\n              \n    t += dist.y * lighting;\n    iter ++;\n\n  }\n          \n  float shade = dot(gradient(point, 0.01 ), -ray);\n  float ao = 1. -  float(iter) / float(MAX_ITER);\n  \n  vec3 color = vec3(0.);\n  \n  if ( hit ){\n    if (greyscale > 0.5){\n      color = vec3(1.0);\n    } else {\n      color = _palette(_triWave(point.z/5.,3), vec3(1.445, 1.107, 0.460), vec3(0.760, 1.000, 0.470), vec3(0.870, 0.341, 0.894), vec3(0.440, 0.404, 0.916));\n    }\n  }\n\n  color *= sqrt(ao)*(0.5+shade*0.5);\n  vec3 mediaCol = vec3(0.0);\n  if (syn_MediaType > 0.5){\n    if (dot(color, vec3(1.0))<0.1){\n      color = _loadUserImage().rgb*(0.5+shade*1.7)*(length(vec2(0.5))-length(_uvc));\n    }   \n  }\n\n  return color;\n\n\n}\n\nvec4 renderMain() {\n  vec4 out_FragColor = vec4(0.0);\n\n  if (PASSINDEX == 0) {\n    out_FragColor = vec4(raycast(), 1.0);\n  } else if (PASSINDEX == 1) {\n    // out_FragColor = texture(backbuffer, _uv);\n    out_FragColor = vec4(filter_(), 1.0);\n  }\n\n  return out_FragColor;\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Hex Array","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"Use this scene with media!","MAX":1,"MIN":0,"NAME":"media_scale","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"USE MEDIA"},{"DEFAULT":[3.14000010490417,3.14000010490417],"DESCRIPTION":"Look around in the tunnel.","MAX":[6.28000020980835,6.28000020980835],"MIN":[0,0],"NAME":"cam_Look","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"tunnel"},{"DEFAULT":0.600000023841858,"DESCRIPTION":"Radius of the tunnel. Too big and you may get noisy.","MAX":0.899999976158142,"MIN":0.100000001490116,"NAME":"radius","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"tunnel"},{"DEFAULT":0,"DESCRIPTION":"Add a simple smooth ripple distortion to the scene.","MAX":1,"MIN":0,"NAME":"ripples","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"tunnel"},{"DEFAULT":1,"DESCRIPTION":"Add a simple smooth ripple distortion to the scene.","MAX":1,"MIN":0,"NAME":"Red","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Add a simple smooth ripple distortion to the scene.","MAX":1,"MIN":0,"NAME":"Green","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Add a simple smooth ripple distortion to the scene.","MAX":1,"MIN":0,"NAME":"Blue","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"color"}],"CREDIT":"sheltron","DESCRIPTION":"raymarch hex tunnel day3","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\hextunnel.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"HexTunnel","IMAGES":[{"NAME":"image30","PATH":"images/30.png"}],"IMAGE_PATH":"hextunnel.synScene\\hextunnel.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Use this scene with media!\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_scale\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"USE MEDIA\"\n      },\n      {\n         \"DEFAULT\" : 3.14,\n         \"DESCRIPTION\" : \"Look around in the tunnel.\",\n         \"MAX\" : 6.28,\n         \"MIN\" : 0,\n         \"NAME\" : \"cam_Look\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"tunnel\"\n      },\n      {\n         \"DEFAULT\" : 0.6,\n         \"DESCRIPTION\" : \"Radius of the tunnel. Too big and you may get noisy.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.1,\n         \"NAME\" : \"radius\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"tunnel\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Add a simple smooth ripple distortion to the scene.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"ripples\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"tunnel\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Add a simple smooth ripple distortion to the scene.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"Red\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Add a simple smooth ripple distortion to the scene.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"Green\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Add a simple smooth ripple distortion to the scene.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"Blue\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      }\n   ],\n   \"CREDIT\" : \"sheltron\",\n   \"DESCRIPTION\" : \"raymarch hex tunnel day3\",\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image30\",\n         \"PATH\" : \"images/30.png\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"hextunnel.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 1920\n      }\n   ],\n   \"TITLE\" : \"HexTunnel\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"BuffA","WIDTH":1920}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\n\nvar bpmcount = new BPMCounter();\n\nvar decimator = 0;\nvar bassT = 0.0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM/4.0;\n  bpmcount.updateTime(bpm, dt);\n\n  uniforms.script_time = bpmcount.time;\n\n  bassT = bassT + Math.pow(inputs.syn_BassLevel*0.5,2.0)*(dt*60);\n  uniforms.script_bass_time = bassT;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"float camZ = 0.5 * TIME + sin(script_time);\n\t\t\t//******** BuffA Code Begins ********\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*(0.866025*(2.0-syn_Presence))+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat map(vec3 p)\n{\n   // p.x += (texture(iChannel0, 0.01 * p.zz + TIME * 100.0).r - 0.5) * 0.2;\n    vec3 q = p;\n    vec3 staticPos = q-vec3(0.0,0.0,camZ);\n\n    // p.y -= 1.5*_pulse(staticPos.z, (1.0-undulate)*10.0, 4.0)*sqrt(undulate);\n\n\n    vec3 c = vec3(0.1);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), 1.0 * sin(q.z) + 2.0 * sin( TIME*0.2+syn_BassTime*0.2 + q.z));\n    \n    float rad = 0.7 + 0.4 * sin(q.z) + 0.5+0.5*sin(TIME*0.5);\n    float rad2 = rad * radius; //0.8 + 0.8 * cos(q.z );\n    float outer = sdHexPrism(p, vec2(rad, 0.01+0.02*syn_Presence));\n    float inner = sdHexPrism(p, vec2(rad2, 0.6));\n    \n    float ring =  opS(inner, outer);\n    \n    // vec3 p_s = p; \n    // p_s = p_s * rotationMatrix(vec3(0.0, 0.0, 1.0), 3.1415 * 0.333 );\n    // float bars = sdBox(p_s, vec3(2.0, sin(q.z * 10.0)* 0.5 + 0.5, 0.1)); \n    \n    float result = ring; //opS(bars, ring);\n    \n    return result;\n}\n\n\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n  vec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n  return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n           e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// See http://iquilezles.org/www/articles/palettes/palettes.htm for more information\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z += camZ;\n    // ro.x += sin(TIME * 0.2) * 0.1;\n\n    rd = rd * rotationMatrix(vec3(0.0, 1.0, 0.0), 0.2 * sin(TIME * 0.2 + 3.14));\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.1,1.0,1.0), // fog color\n                           vec3(0.0)*0.7, // light color\n                           pow(sunAmount,8.0) );\n    return mix(rgb, rgb, fogAmount);\n}\n\n\nvec4 renderPassA() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n\n    vec2 _p = (-RENDERSIZE.xy + 2.0*fragCoord.xy) / RENDERSIZE.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    ray.xz = _rotate(ray.xz, cam_Look.x);\n    ray.yz = _rotate(ray.yz, -cam_Look.y);\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n\n\n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 80; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d * 0.5 ;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0-iter/80.0);\n    if(hit){\n        col = pow(vec3(0.1), vec3(3.0));\n    }\n\n    col = applyFog(col, depth, ray, vec3(0, 0, 1));\n    vec3 norm = nr(p);\n    vec3 lum = pow(tpl(syn_UserImage, p*media_scale+0.5, norm*10.0)*vec3(0.0, Red, Green),vec3(1.0));\n    col.rgb += lum;\n\n    fragColor = vec4(col, p.z);\n\n\treturn fragColor; \n } \n\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\n    vec2 uv = _uv;\n    uv.x += ripples*sin(uv.y * 50.0) / 80.0;\n    vec4 buff = texture(BuffA, clamp(uv,0.0,1.0));\n    float depth = buff.a;\n\n    // vec4 noise  = texture(image30, uv + TIME * 100.0).rrrr - 0.5;\n\t// vec4 noise0 = texture(image30, 0.01 * uv + TIME * 0.001).rrrr - 0.5;\n    vec2 delta = vec2(uv - 0.5) * 0.1; // * noise0.r * 10.0 ;\n    vec4 col;\n    \n    col.rgb = buff.gbr;\n    col.rg -= texture(BuffA, clamp(uv + delta*0.5*sin(depth*0.1+syn_HighTime*0.2),0.0,1.0)).g;\n    col.gb -= texture(BuffA, clamp(uv - delta*0.5*sin(depth*0.1+syn_HighTime*0.2),0.0,1.0)).b;\n    col.a = 1.0;\n    \n    fragColor = pow(col, vec4(0.3, 0.5, 0.3+(1.0-Blue)*5.0, 0.5)).rgba;\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderPassA();\n\t}\n\tif(PASSINDEX == 1){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"HexTunnel","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"center","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[2,2],"DESCRIPTION":"","MAX":[10,10],"MIN":[0.5,0.5],"NAME":"shape","PARAMS":0.0839999988675117,"TYPE":"xy smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":9.99999974737875e-05,"NAME":"speed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.0500000007450581,"DESCRIPTION":"","MAX":0.5,"MIN":0.00499999988824129,"NAME":"rotation","PARAMS":0.0640000030398369,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.0500000007450581,"DESCRIPTION":"","MAX":0.5,"MIN":0,"NAME":"R","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.125,"DESCRIPTION":"","MAX":0.5,"MIN":0,"NAME":"G","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.25,"DESCRIPTION":"","MAX":0.5,"MIN":0,"NAME":"B","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\hexvortex.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"HexVortex","IMAGES":null,"IMAGE_PATH":"hexvortex.synScene\\hexvortex.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"center\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t2,\n\t\t\t\t2\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t10,\n\t\t\t\t10\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"NAME\" : \"shape\",\n\t\t\t\"PARAMS\" : 0.084,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.0001,\n\t\t\t\"NAME\" : \"speed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.05,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0.005,\n\t\t\t\"NAME\" : \"rotation\",\n\t\t\t\"PARAMS\" : 0.064,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.05,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"R\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.125,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"G\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"B\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"hexvortex.png\",\n\t\"TITLE\" : \"HexVortex\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n\r\n///////////////////////////////////////////\r\n// HexVortex  by mojovideotech\r\n//\r\n// based on:\r\n// glslsandbox.com/\\e#4671.0\r\n//\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n///////////////////////////////////////////\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\n\r\n#define \te     \t2.718281828459045 \t// eulers number\r\n#define \tprphi\t2.028876065463213\t// PI root of phi\r\n#define \tsqPI \t1.772453850905516\t// square root of PI\r\n#define \tthPI  \t0.996272076220750\t// tanh(PI)\r\n#define \tlgPI  \t0.497149872694134 \t// log(PI)  \r\n#define \trcPI  \t0.318309886183791\t// reciprocal of PI  , 1/PI \r\n\r\n\r\nvec3 rotXY(vec3 p, vec2 rad) {\r\n\tvec2 s = sin(rad);\r\n\tvec2 c = cos(rad);\r\n\tmat3 m = mat3(c.y, 0.0, -s.y,\r\n\t\t-s.x * s.y, c.x, -s.x * c.y,\r\n\t\tc.x * s.y, s.x, c.x * c.y);\r\n\treturn m * p;\r\n}\r\n\r\nvec2 repeat(vec2 p, float n) {\r\n\tvec2 np = p * n;\r\n\tvec2 npfrct = fract(np);\r\n\tvec2 npreal = np - npfrct;\r\n\tnp.x += fract(npreal.y * lgPI);\r\n\treturn fract(np) * prphi - 1.0;\r\n}\r\n\r\nfloat hexDistance(vec2 ip) {\r\n\tconst float SQRT3 = sqPI;\r\n\tvec2 TRIG30 = vec2 (sin(rcPI), cos(thPI)); \r\n\tvec2 p = abs(ip * vec2(SQRT3 * shape.x * clamp(syn_BassHits*20.,.5,20.), shape.y* (syn_BassHits*12.)));\r\n\tfloat d = dot(p, vec2(-TRIG30.x, TRIG30.y)) - SQRT3 * 0.25;\r\n\treturn (d > 0.0)? min(d, (SQRT3 * 0.5 - p.x)) : min(-d, p.x);\r\n}\r\n\r\nfloat smoothEdge(float edge, float margin, float x) {\r\n\treturn smoothstep(edge - margin, edge + margin, x);\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tfloat T = ((syn_BassTime/30.)+(syn_Time/6)) * speed;\r\n\tvec3 rgb;\r\n\tvec2 nsc = (_xy.xy - RENDERSIZE * 0.5) / RENDERSIZE.yy * e;\r\n\tvec3 dir = normalize(vec3(nsc, -2.0));\r\n\tdir = rotXY(dir, vec2((center.yx - 0.5) * PI * 0.25));\r\n\tvec2 uv = vec2(atan(dir.y, dir.x) / (PI * 2.0) + 0.5, dir.z / length(dir.xy));\r\n\tvec2 pos = uv * vec2(1.0, 0.2) - vec2(T * rotation, T * 0.5);\r\n\tvec2 p = repeat(pos, 16.0);\r\n\tfloat d = hexDistance(p);\r\n\tfloat dist = dir.z/length(dir.xy);\r\n\td/=-dist;\r\n\tfloat fade = 1.0 / pow(1.0 / length(dir.xy) * 0.3, 1.0);\r\n\tfade = clamp(fade, 0.0, 1.0);\r\n\trgb  = mix(vec3(1.0)*fade, vec3(R,G,B), smoothEdge(0.03, 0.1, d));\r\n\t\r\n\tout_FragColor = vec4(rgb, 1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"HexVortex","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"feedback color intensity (12:00 is neutral)","MAX":1,"MIN":0,"NAME":"saturate","TYPE":"knob","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"alternate color palette","MAX":1,"MIN":0,"NAME":"palette","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"affects palette and 'density' behavior","MAX":1,"MIN":0,"NAME":"dark","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"color-based displacement","MAX":1,"MIN":0,"NAME":"warp","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.75,"DESCRIPTION":"hue range. no effect if 'media' maxed.","MAX":1,"MIN":0,"NAME":"hue_range","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"how color behaves with extreme settings of 'lighten'","MAX":1,"MIN":0,"NAME":"glitch","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"mix in media as color input","MAX":1,"MIN":0,"NAME":"media","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0.5,"DESCRIPTION":"feedback color lighten/darken (12:00 is neutral)","MAX":1,"MIN":0,"NAME":"lighten","TYPE":"knob","UI_GROUP":"color"},{"DEFAULT":0.800000011920929,"DESCRIPTION":"strobing rate of zoetrope effect","MAX":1,"MIN":0,"NAME":"rate","TYPE":"slider","UI_GROUP":"zoetrope"},{"DEFAULT":0,"DESCRIPTION":"modulates spin rate of zoetrope effect","MAX":1,"MIN":-1,"NAME":"tune","TYPE":"knob","UI_GROUP":"zoetrope"},{"DEFAULT":1,"DESCRIPTION":"reverse spin (may not be visible with high 'density')","MAX":-1,"MIN":1,"NAME":"reverse","TYPE":"toggle","UI_GROUP":"zoetrope"},{"DEFAULT":0,"DESCRIPTION":"go upside-down","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"zoetrope"},{"DEFAULT":2,"DESCRIPTION":"modulates spin rate","MAX":2,"MIN":1,"NAME":"spacing","TYPE":"toggle","UI_GROUP":"zoetrope"},{"DEFAULT":0.5,"DESCRIPTION":"modulates spin rate (3-position)","MAX":1,"MIN":0,"NAME":"wavelength","TYPE":"knob","UI_GROUP":"zoetrope"},{"DEFAULT":1,"DESCRIPTION":"gradually modulate 'tune'","MAX":1,"MIN":0,"NAME":"auto_tune","TYPE":"toggle","UI_GROUP":"zoetrope"},{"DEFAULT":0,"DESCRIPTION":"manually rotate zoetrope (invisible if 'rate' is high)","MAX":1,"MIN":0,"NAME":"manual","TYPE":"bang","UI_GROUP":"zoetrope"},{"DEFAULT":0.666999995708466,"DESCRIPTION":"height of input curve","MAX":1,"MIN":0.25,"NAME":"peak","TYPE":"slider","UI_GROUP":"shape, etc"},{"DEFAULT":0,"DESCRIPTION":"long vertical push","MAX":1,"MIN":0,"NAME":"push","PARAMS":0.025000000372529,"TYPE":"bang smooth","UI_GROUP":"shape, etc"},{"DEFAULT":0,"DESCRIPTION":"blend copies offset according to spin rate (no effect if 'auto density' enabled)","MAX":1,"MIN":0,"NAME":"density","TYPE":"knob","UI_GROUP":"shape, etc"},{"DEFAULT":1,"DESCRIPTION":"audio modulates peak","MAX":1,"MIN":0,"NAME":"auto_peak","TYPE":"toggle","UI_GROUP":"shape, etc"},{"DEFAULT":1,"DESCRIPTION":"audio modulates vertical motion","MAX":1,"MIN":0,"NAME":"auto_push","TYPE":"toggle","UI_GROUP":"shape, etc"},{"DEFAULT":0,"DESCRIPTION":"audio modulates density","MAX":1,"MIN":0,"NAME":"auto_density","TYPE":"toggle","UI_GROUP":"shape, etc"}],"CREDIT":"Victor S.","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\hills_eels.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Hills, Eels","IMAGES":null,"IMAGE_PATH":"hills_eels.synScene\\thumb.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n       {\n          \"DEFAULT\" : 0.5,\n          \"DESCRIPTION\" : \"feedback color intensity (12:00 is neutral)\",\n          \"MAX\" : 1,\n          \"MIN\" : 0,\n          \"NAME\" : \"saturate\",\n          \"TYPE\" : \"knob\",\n          \"UI_GROUP\" : \"color\"\n       },\n      {\n         \"DEFAULT\" : 0.8,\n         \"DESCRIPTION\" : \"strobing rate of zoetrope effect\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"rate\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"alternate color palette\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"palette\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"affects palette and 'density' behavior\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"dark\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"color-based displacement\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"warp\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0.75,\n         \"DESCRIPTION\" : \"hue range. no effect if 'media' maxed.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"hue_range\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"modulates spin rate of zoetrope effect\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"tune\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"how color behaves with extreme settings of 'lighten'\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"glitch\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"reverse spin (may not be visible with high 'density')\",\n         \"MAX\" : -1,\n         \"MIN\" : 1,\n         \"NAME\" : \"reverse\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"go upside-down\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"invert\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 2,\n         \"DESCRIPTION\" : \"modulates spin rate\",\n         \"MAX\" : 2,\n         \"MIN\" : 1,\n         \"NAME\" : \"spacing\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"modulates spin rate (3-position)\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"wavelength\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0.667,\n         \"DESCRIPTION\" : \"height of input curve\",\n         \"MAX\" : 1,\n         \"MIN\" : 0.25,\n         \"NAME\" : \"peak\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"shape, etc\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"long vertical push\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"PARAMS\": 0.025,\n         \"NAME\" : \"push\",\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"shape, etc\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"blend copies offset according to spin rate (no effect if 'auto density' enabled)\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"density\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"shape, etc\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"audio modulates peak\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_peak\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape, etc\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"audio modulates vertical motion\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_push\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape, etc\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"audio modulates density\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_density\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape, etc\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"mix in media as color input\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"gradually modulate 'tune'\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_tune\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"manually rotate zoetrope (invisible if 'rate' is high)\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"manual\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"zoetrope\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"feedback color lighten/darken (12:00 is neutral)\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"lighten\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"color\"\n      }\n   ],\n   \"CREDIT\" : \"Victor S.\",\n   \"DESCRIPTION\" : \"\",\n   \"WIDTH\" : 1920,\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"thumb.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1920,\n         \"TARGET\" : \"fb0\",\n         \"WIDTH\" : 1920\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1920,\n         \"TARGET\" : \"fb1\",\n         \"WIDTH\" : 1920\n      }\n   ],\n   \"TITLE\" : \"Hills, Eels\"\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1920,"TARGET":"fb0","WIDTH":1920},{"FLOAT":true,"HEIGHT":1920,"TARGET":"fb1","WIDTH":1920}],"SCRIPT_CODE":"var denoms = [11, 7, 5];\nvar framecount = 0;\n\nfunction clamp(x, lo, hi) {\n  return Math.max(Math.min(x, hi), lo)\n}\n\nfunction scale(x, lo, hi) {\n  return x * (hi - lo) + lo;\n}\n\nfunction getSpectrum() {\n  var highs = clamp(scale(inputs.syn_HighPresence, -1., 1.), 0, 1);\n  var mids = clamp(scale(inputs.syn_MidPresence - inputs.syn_BassLevel / 2., -0.5, 1), 0, 1);\n  var bass = Math.pow(Math.max(0.0, scale(inputs.syn_BassLevel, -.33, 1.)), 0.5);\n  var highmids = clamp(scale(inputs.syn_MidHighPresence, -0.5, 1), 0, 1);\n  return [bass, mids, highmids, highs];\n}\n\nfunction update(dt) {\n  getSpectrum().forEach(function(el, i) {\n    uniforms['spectrum_' + i] = el\n  })\n\n  uniforms.zoe_denom = denoms[Math.floor((denoms.length - 1) * inputs.wavelength + .5)];\n\n  uniforms.strobe = 1 * (\n    framecount % Math.floor(16 * Math.pow(1 - inputs.rate, 2) + 1) == 0 &&\n    inputs.rate > 0\n  );\n\n  framecount++;\n}","SHADER_CODE":"//TODO: improve audio-reactivity at low zoetrope rates?\n\nvec3 d = 1./vec3(RENDERSIZE, 1.);\n\nconst float pi = 3.14159265359;\nconst float eps = 1e-15;\n\nvec4 spectrum = vec4(spectrum_0, spectrum_1, spectrum_2, spectrum_3);\n\nfloat zoe_num = spacing;\nfloat zoe = zoe_num/zoe_denom;\n\nfloat mean(vec3 x){\n  return (x.r+x.g+x.b)/3;\n}\n\nvec4 fbMain(in sampler2D state, in vec2 p){\n  vec4 ant = vec4(.1);\n  float lift = 0.5*(1.125-peak + 0.5*(1-auto_push));\n  float w = (1+rate)*push*64 + lift*36 + auto_push*pow(\n    length((spectrum-ant)/(1.-ant)),\n    2\n  )*32;\n\n  float window = smoothstep(0, 1, min(1, 4*min(p.x, 1-p.x)));\n  vec4 e0 = window*(\n    cos(2*pi*(p.x*vec4(1,2,3,4)+spectrum.abgr/4+syn_BPMTwitcher*2./vec4(13,-14,15,-16)))*.5+.5 + d.y\n  );\n\n  float peak_ = peak*pow(2.,\n    auto_peak*(dot(spectrum,vec4(.5,.3,.15,.05))-.5)\n  );\n\n  vec4 c0 = .5+.5*cos(\n    2*pi*(p.x+spectrum)*vec4(2,1,3,1)*pow(2, -3*(1-hue_range))\n  );\n  c0 = mix(c0.rgba, c0.agba, .5);\n\n  if (media > 0){\n    c0 = mix(c0, texture(syn_UserImage, vec2(_uv.x, peak_-_uv.y)), media);\n  }\n\n  vec4 w0 = vec4(1, 0.667, 0.5, 0.33);\n  float ind = float( strobe > 0 || manual>0);\n\n  float h = pow(length(e0*w0)*peak_*0.7, 1.5)+2*d.y;\n  vec4 s0 = vec4(c0.rgb, float(p.y < h));\n  // vec4 lc = mix(vec4(1-dark), 1-s0, line_mode);\n  // s0 = mix(s0, lc, clamp(lines-abs(p.y-h)/d.y, 0, 1));\n\n  float h2 = d.y*length(e0*w0)*w;\n  float y_prev = clamp(p.y - min(h, h2), .5*d.y, 1);\n  float tune_ = tune + auto_tune*cos(2*pi*syn_Intensity);\n  vec4 c_prev = texture(state, vec2(\n    pow(2, tune_)*reverse*zoe*ind+p.x,\n    y_prev\n  ));\n\n  c_prev = mix(c_prev, c_prev.brga, .016)+(lighten-0.5)*.03;\n  vec4 c = mix(c_prev, s0, s0.a);\n  c  = mix(c, clamp(c+(c-mean(c.rgb))/2, 0, 1), saturate*0.06);\n  return mix(c, fract(c), glitch);\n}\nvec4 fbAux(in sampler2D state, in vec2 p){\n  vec4 c0 = texture(state, p);\n  if (warp > 0){\n    float amt = 32*syn_BassHits*warp;\n    return texture(state, vec2(\n      p.x+(c0.r-c0.g)*d.x*amt, max(d.y, p.y-c0.b*d.y*amt)\n    ));\n  }\n  return c0;\n}\nvec4 blur(in sampler2D state, in vec2 p){\n  return (2.*texture(state, p)\n    + texture(state, p+d.xz)\n    + texture(state, p-d.xz)\n    + texture(state, p+d.zy)\n    + texture(state, p-d.zy)\n    )/6.;\n}\nvec3 sorted(vec3 x){\n  if(x.r >= x.g && x.g >= x.b) return x.bgr;\n  if(x.r <= x.g && x.g <= x.b) return x;\n  if(x.g >= x.r && x.r >= x.b) return x.brg;\n  if(x.g <= x.r && x.r <= x.b) return x.grb;\n  if(x.r >= x.b && x.b >= x.g) return x.gbr;\n  return x.rbg;\n}\nvec4 colorize(vec4 c0){\n  if(palette<1){\n    float green = c0.g*(1-c0.r)*(1-c0.b);\n    c0 = mix(c0, vec4(0.0,0.4,0.7,1), green);\n    float magenta = c0.r*c0.b*(1-c0.g);\n    c0 = mix(c0, vec4(0.7, 0.1, 0.0, 1), magenta);\n    float yellow = c0.g*c0.r*(1-c0.b);\n    c0 = mix(c0, vec4(0.9,0.4,0.0,1), yellow);\n    float cyan = (1-c0.r)*c0.g*c0.b;\n    c0 = mix(c0, vec4(0.0,0.7,0.9,0), cyan);\n\n  }else{\n    float green = c0.g*(1-c0.r)*(1-c0.b);\n    c0 = mix(c0, vec4(1,0,0,1), green);\n    float yellow = c0.g*c0.r*(1-c0.b);\n    c0 = mix(c0, vec4(1,0,1,1), yellow);\n    float cyan = (1-c0.r)*c0.g*c0.b;\n    c0 = mix(c0, vec4(0.5,0,1,0), cyan);\n    // float white = c0.r*c0.g*c0.b;\n    // c0 = mix(c0, mix(vec4(1, 0.8, 0.7, 1), vec4(0.9, 0.7, 1, 1), _uv.y), white*white);\n    // float magenta = c0.r*c0.b*(1-c0.g);\n    // c0 = mix(c0, vec4(0.7, 0.8, 0.2, 1), magenta*magenta);\n  }\n\n  return c0;\n}\n\nvec4 postMain(in sampler2D state, in vec2 p){\n  if (invert>0) p = vec2(p.x, 1-p.y);\n  // vec4 spectrum = getSpectrum();\n  float drop = 0.5;\n  float drop_ = drop*peak;\n  float density_ctrl = sqrt(syn_MidHits*syn_MidHighHits);\n  float density_ = mix(density, density_ctrl, auto_density);\n\n  vec4 c0 = colorize(texture(state, (p+vec2(0, drop_))*vec2(1, 1./(1+drop_))));\n  vec4 c1;\n  for (int i=1; i<int(1+(zoe_denom-1)*density_); i++){\n    c1 = colorize(texture(state,\n      (p+vec2(-pow(2, tune)*reverse*i*zoe, drop_))\n      *vec2(1, 1./(1+drop_))\n    ));\n    vec3 lum = 2*vec3(.48, .81, 0.1);\n    float l1 = dot(c1.rgb, lum);\n    float l0 = dot(c0.rgb, lum);\n    float m = tanh(4*(l1 - l0)*(1-2*dark))*.5+.5;\n    c0 = mix(c0, c1, m);\n  }\n\n  c0 = clamp(c0, 0, 1);\n  return clamp(\n    mix(c0*1.3-0.05, c0*c0*abs(3-dot(c0, c0))*1.2-0.2, dark),\n    0, 1);\n}\nvec4 initialCondition(in vec2 p){\n  return vec4(0);\n}\n\nvec4 renderMain () {\n  if (FRAMECOUNT<=2){\n    return initialCondition(_uv);\n  }\n  if (PASSINDEX == 0.0){\n    // if (freeze > 0) return texture(fb1, _uv);\n    return fbMain(fb1, _uv);\n  }\n  else if (PASSINDEX == 1.0){\n    // if (freeze > 0) return texture(fb0, _uv);\n    return fbAux(fb0, _uv);\n    // return texture(fb0, _uv);\n    // return blur(fb0, _uv);\n  }\n  else if (PASSINDEX == 2.0){\n    return postMain(fb0, _uv);\n  }\n\n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Hills, Eels","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"invert_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":20,"MIN":0,"NAME":"zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"","MAX":0.300000011920929,"MIN":0.100000001490116,"NAME":"move_in_out","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.349999994039536,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"size","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00100000004749745,"DESCRIPTION":"","MAX":0.100000001490116,"MIN":0.00100000004749745,"NAME":"thickness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00100000004749745,"DESCRIPTION":"","MAX":0.200000002980232,"MIN":0,"NAME":"lineEffect","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"patternOffset","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"rSin","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"xCos","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"ySin","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.00499999988824129,"DESCRIPTION":"","MAX":0.5,"MIN":0.00100000004749745,"NAME":"blur","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"rotate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"pos","TYPE":"xy","UI_GROUP":"ungrouped"}],"CREDIT":"Joseph Fiola","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\hoop_dreams.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Hoop Dreams","IMAGES":null,"IMAGE_PATH":"hoop_dreams.synScene\\hoop_dreams.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"invert_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.3,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"move_in_out\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.35,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"size\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.001,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.1,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"thickness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.001,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.2,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"lineEffect\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"patternOffset\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"rSin\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"xCos\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"ySin\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.005,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"blur\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"rotate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"pos\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"Joseph Fiola\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"hoop_dreams.png\",\n\t\"TITLE\" : \"Hoop Dreams\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"// SaturdayShader Week 25 : HoopLoop\r\n// by Joseph Fiola (http://www.joefiola.com)\r\n// 2016-02-06\r\n\r\n\r\nconst int NUM_CIRCLES = 50;\r\nbool invert = (invert_bool > 0.5); \r\n\r\n#define TWO_PI 6.28318530718\r\n\r\nvec3 drawCircle(vec2 p, vec2 center, float radius, float edgeWidth, vec3 color)\r\n{\r\n    float dist = length(p - center);\r\n    vec3 ret;\r\n    float look;\r\n    look = abs(dist -size);\r\n\tret = color * (1.0 - lineEffect - smoothstep(radius, (radius+edgeWidth), look));\r\n\r\n    return ret;\r\n} \r\n\r\n\r\n\r\nvec3 invertColor(vec3 color) {\r\n    return vec3(color *-1.0 + 1.0);\r\n}\r\n\r\nvec2 rot(vec2 uv,float a){\r\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 fragColor = vec4(0.0);\r\n\tvec2 uv = _xy.xy / RENDERSIZE.xy;\r\n\tuv -= vec2(pos);\r\n\tuv.x*=RENDERSIZE.x/RENDERSIZE.y;\r\n\tuv *= zoom;\r\n\tuv=rot(uv,rotate*syn_BassTime/4 * PI);\r\n\tvec3 color = vec3(0.0);\r\n\tfloat angleIncrement = TWO_PI / float(NUM_CIRCLES);\r\n\tfor (int i = 0; i < NUM_CIRCLES; ++i) {\r\n\t\tfloat t = angleIncrement*(float(i));\r\n\t\tfloat r = sin(rSin * t + ((syn_BassTime)+(TIME))*move_in_out); \r\n\t\tvec2 p = vec2(r*cos(t*xCos), r*sin(t*ySin));\r\n\t\tuv=rot(uv,patternOffset * PI);\r\n        if (lineEffect >= 0.2) color = invertColor(color);\r\n       \tcolor += drawCircle(uv, p, thickness, blur, vec3(1.0));\r\n\t}\r\n\tif (invert) color = invertColor(color);\r\n\tfragColor = vec4(color,1.0);\r\n\r\nreturn fragColor;\r\n} \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Hoop Dreams","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.0799999982118607,"DESCRIPTION":"Take frame from media or let video feedback run unchecked.","MAX":0,"MIN":0.400000005960464,"NAME":"feedback","TYPE":"slider","UI_GROUP":"main_parameters"},{"DEFAULT":0.0199999995529652,"DESCRIPTION":"Find the sweet spot where ripple patterns exist.","MAX":0.100000001490116,"MIN":0,"NAME":"ripple_amt","TYPE":"slider","UI_GROUP":"main_parameters"},{"DEFAULT":0,"DESCRIPTION":"Generally keep near 0, but turn up for a different look.","MAX":0.0500000007450581,"MIN":0,"NAME":"sat_amt","TYPE":"slider","UI_GROUP":"main_parameters"},{"DEFAULT":0,"DESCRIPTION":"Simple mods for when it is too bright or dark.","MAX":1,"MIN":0,"NAME":"brighter","TYPE":"slider","UI_GROUP":"brightness"},{"DEFAULT":0,"DESCRIPTION":"Simple mods for when it is too bright or dark.","MAX":1,"MIN":0,"NAME":"darker","TYPE":"slider","UI_GROUP":"brightness"},{"DEFAULT":0,"DESCRIPTION":"Boom.","MAX":1,"MIN":0,"NAME":"fire_pulse","TYPE":"bang counter","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Becomes pixelated and glitches out on the beats. Modified by glitchdown_speed.","MAX":1,"MIN":0,"NAME":"glitchdown","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0.600000023841858,"DESCRIPTION":"Rate of downward flow during glitchdown.","MAX":1,"MIN":0,"NAME":"glitchdown_speed","TYPE":"slider","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Flying inward or outward.","MAX":1,"MIN":-1,"NAME":"zoom","TYPE":"slider","UI_GROUP":"flow_style"},{"DEFAULT":0,"DESCRIPTION":"Rays radiating outward.","MAX":1,"MIN":0,"NAME":"rays","TYPE":"toggle","UI_GROUP":"flow_style"},{"DEFAULT":0,"DESCRIPTION":"Less liquid, more pixelated.","MAX":1,"MIN":0,"NAME":"digital_mode","TYPE":"toggle","UI_GROUP":"flow_style"},{"DEFAULT":0,"DESCRIPTION":"Pick from one of 5 color palettes.","MAX":4,"MIN":0,"NAME":"color_palette","TYPE":"slider","UI_GROUP":"color"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\hue_review.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Hue Review","IMAGES":null,"IMAGE_PATH":"hue_review.synScene\\default_thumbnail.png","JSON_CODE":"{\n  \"TITLE\": \"Hue Review\",\n  \"CREDIT\":\"Meebs\",\n  \"PASSES\":[{\"TARGET\":\"backbuff\"}, {\"TARGET\":\"backbuff2\"}],\n  \"IMAGE\":\"default_thumbnail.png\",\n  \"CONTROLS\": [\n    {\"NAME\": \"feedback\",\n    \"MIN\":0.4,\n    \"MAX\":0.0,\n    \"DEFAULT\":0.08,\n    \"UI_GROUP\":\"main_parameters\",\n    \"DESCRIPTION\":\"Take frame from media or let video feedback run unchecked.\",\n    \"TYPE\": \"slider\"},\n\n    {\"NAME\": \"ripple_amt\",\n    \"MIN\":0.0,\n    \"MAX\":0.1,\n    \"DEFAULT\":0.02,\n    \"UI_GROUP\":\"main_parameters\",\n    \"DESCRIPTION\":\"Find the sweet spot where ripple patterns exist.\",\n    \"TYPE\": \"slider\"},\n\n    {\"NAME\": \"sat_amt\",\n    \"MIN\":0.0,\n    \"MAX\":0.05,\n    \"DEFAULT\":0.00,\n    \"UI_GROUP\":\"main_parameters\",\n    \"DESCRIPTION\":\"Generally keep near 0, but turn up for a different look.\",\n    \"TYPE\": \"slider\"},\n\n    {\"NAME\": \"brighter\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\":\"Simple mods for when it is too bright or dark.\",\n    \"UI_GROUP\":\"brightness\"},\n\n    {\"NAME\": \"darker\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\":\"Simple mods for when it is too bright or dark.\",\n    \"UI_GROUP\":\"brightness\"},\n\n    {\"NAME\": \"fire_pulse\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"DEFAULT\":0.0,\n    \"UI_GROUP\":\"action\",\n    \"DESCRIPTION\":\"Boom.\",\n    \"TYPE\": \"bang counter\"},\n\n    {\"NAME\": \"glitchdown\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"UI_GROUP\":\"action\",\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\":\"Becomes pixelated and glitches out on the beats. Modified by glitchdown_speed.\"\n    },\n    {\"NAME\": \"glitchdown_speed\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"UI_GROUP\":\"action\",\n    \"DEFAULT\":0.6,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\":\"Rate of downward flow during glitchdown.\"\n    },\n    {\"NAME\": \"zoom\",\n    \"MIN\":-1.0,\n    \"MAX\":1.0,\n    \"DEFAULT\":0.0,\n    \"UI_GROUP\":\"flow_style\",\n    \"DESCRIPTION\":\"Flying inward or outward.\",\n    \"TYPE\": \"slider\"},\n\n    {\"NAME\": \"rays\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"DEFAULT\":0.0,\n    \"UI_GROUP\":\"flow_style\",\n    \"DESCRIPTION\":\"Rays radiating outward.\",\n    \"TYPE\": \"toggle\"},\n\n    {\"NAME\": \"digital_mode\",\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"UI_GROUP\":\"flow_style\",\n    \"DESCRIPTION\":\"Less liquid, more pixelated.\",\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\"},\n    \n    {\"NAME\": \"color_palette\",\n    \"MIN\":0.0,\n    \"MAX\":4.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\":\"Pick from one of 5 color palettes.\",\n    \"UI_GROUP\":\"color\"}\n\n  ]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"backbuff","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"backbuff2","WIDTH":0}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = 0.25*bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count !== Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  }\n  this.timeWithinBeat = this.time-this.count;\n}\n\nfunction SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n}\n\nvar bpmcount = new BPMCounter();\nvar firepulse = new SmoothCounter();\n// var rightrot = new SmoothCounter();\n\nvar decimator = 0;\nvar t = 0;\n\nfunction update(dt) {\n  bpmcount.updateTime(inputs.syn_BPM, dt);\n  uniforms.bpmTime = bpmcount.time;\n  firepulse.update(dt, inputs.fire_pulse, 0.01);\n\n  uniforms.fire_pulse_scr = firepulse.currentValue;\n\n  // decimator++;\n  // if (decimator%20==0){\n  //   print(uniforms.fire_pulse_scr);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"vec2 uvCor = _uvc+vec2(0.2,0.0);\n\nvec4 renderRoom() {\n  \n  vec2 pos = _uv - vec2(0.5,0.5); \n  float horizon = 0.5*sin(TIME*0.01); \n  float fov = 0.02; \n  float scaling = 0.1;\n  float roofHeight = 0.2;\n  \n  float playerHeight = ((sin(TIME*0.2) + 1.0) / 4.0) + 0.1;\n  vec3 p = vec3(pos.x, fov, pos.y - horizon);   \n  p.xy = _rotate(p.xy, p.z);   \n  vec2 s = vec2(p.x/p.z, p.y/p.z);\n  // s.x += TIME*0.1+syn_BassTime*0.02;\n  s = _rotate(s, p.y+syn_BassTime*0.03);\n  s.x += sin(syn_HighTime*0.1);\n  if(p.z > 0.0) {\n    // Ceiling\n    s *= roofHeight - playerHeight;\n  } else {\n    // Floor\n    s *= playerHeight;\n  }\n  \n  //checkboard texture\n  \n  float color = sign((mod(s.x, 0.1) - 0.05) * (mod(s.y, 0.1) - 0.05));  \n  // //fading\n  color *= p.z*10.0;\n\n  vec3 colOut = (0.1+texture(backbuff2, p.xz).rgb*1.2)*color*0.75;\n  \n  return vec4(colOut, 1.0 );\n\n}\n\nvec4 renderMain () {\n  if (PASSINDEX == 0.0){\n    vec2 pixelSize = 1.0/RENDERSIZE;\n    vec2 diffusionDirection = vec2(0.0);\n    vec2 polarPos = _toPolarTrue(_uvc);\n\n    vec2 wp = 4.0/RENDERSIZE.xy;\n\n    vec2 uv = _uv + _uvc*0.02*zoom*vec2(RENDERSIZE.y/RENDERSIZE.x, 1.0);\n\n    vec4 cOrig = -1.+2.*texture(backbuff2, _uv);\n    vec4 c = cOrig;\n    float bri = dot(vec3(1.0),cOrig.rgb)/3.0;\n    c = -1.+2.*texture(backbuff2, _uv + vec2(0.1,-0.1)*wp*c.rg);\n    c = -1.+2.*texture(backbuff2, _uv - vec2(0.32,-0.135)*wp*c.ba);\n    c = -1.+2.*texture(backbuff2, _uv + vec2(0.17,-0.37)*wp*c.ar);\n    c = -1.+2.*texture(backbuff2, _uv - vec2(0.01,-0.01)*wp*c.gb);\n\n    diffusionDirection = mix(c.rg, c.ba, syn_Presence)*(1.0);\n    diffusionDirection = _rotate(diffusionDirection, polarPos.y*16*PI*rays*(-1.0+2.0*step(fract(polarPos.y*(30.0)),0.5)));\n    // diffusionDirection += _uvc*syn_OnBeat*10.0*dot(cOrig, vec4(1.0));\n    // diffusionDirection *= 1.0-pow(_fbm(_uvc*10.0),3.0);\n\n    if (digital_mode > 0.5){\n        diffusionDirection = _rotate(diffusionDirection, c.r*PI);\n        diffusionDirection = floor(diffusionDirection);\n    }\n\n    diffusionDirection = mix(diffusionDirection, vec2(0.0,_rand(_pixelate(abs(_uvc.x), 50.0)+syn_BeatTime))*(1.0+syn_HighHits)*pow(glitchdown_speed*2.0,5.0), glitchdown);\n\n    vec2 pos = uv;\n\n    float red = texture(backbuff2, pos+diffusionDirection*pixelSize*1.0).r;\n    float gre = texture(backbuff2, pos+diffusionDirection*pixelSize*2.0).g;\n    float blu = texture(backbuff2, pos+diffusionDirection*pixelSize*3.0).b;\n\n    vec4 diffusionCol = vec4(red, gre, blu, 1.0);\n    // diffusionCol /= 5.0;\n\n    vec4 finalCol = vec4(0.0);\n\n    vec4 img = renderRoom();\n\n    if (syn_MediaType > 0.5){\n        img = _loadUserImage();\n    }\n\n    //Feedback Step\n    finalCol = mix(diffusionCol, img, feedback);\n    finalCol = mix(finalCol, max(diffusionCol, finalCol), brighter);\n    finalCol = mix(finalCol, min(diffusionCol, finalCol), darker);\n\n    finalCol = clamp(finalCol, 0.0, 1.0);\n    float oscillator = _pulse(length(_uvc)+(bri-1.0)*0.4, -0.81+fract(fire_pulse_scr)*2.5, 0.01);\n    finalCol *= 1.0+oscillator*(1.0-bri)*5.0;\n    // finalCol *= 1.0-glitchdown*dot();\n    vec3 hsv = _rgb2hsv(finalCol.rgb);\n    hsv.r += ripple_amt;\n    hsv.g += sat_amt;\n    // hsv.g += glitchdown*(cos(bri*2*PI-syn_BassHits*PI))*0.2;\n    hsv.b += syn_BassHits*glitchdown*cos(dot(diffusionCol,vec4(1.0))*10.0-pow(syn_OnBeat,0.2)*10.0)*0.3;\n\n    hsv = _hsv2rgb(hsv);\n    finalCol.rgb = hsv;\n    // finalCol = vec4(oscillator);\n\n    return finalCol;\n  } else if (PASSINDEX == 1.0){\n    return texture(backbuff, _uv);\n  } else if (PASSINDEX == 2.0){\n    vec3 data = texture(backbuff2, _uv).rgb;\n    data = clamp(data, 0.0, 1.0);\n\n  float colMixer = color_palette;\n\n  vec3 col1 = vec3(0.8,0.5,0.0);\n  vec3 col2 = vec3(0.0,0.8,1.0);\n  vec3 col3 = vec3(1.0,0.0,0.0);\n\n  float passthru = 0.0;\n\n\n  float cm = smoothstep(0.25, 0.75, clamp(colMixer, 0.0, 1.0));\n\n\n\n  // *** Color Regime 4 ***\n  col1 = mix(col1, vec3(0.3,1.3,2.3)*1.0, cm);\n  col2 = mix(col2, -vec3(0.0,1.5,1.5), cm);\n  col3 = mix(col3, vec3(2.3,1.5,0.4)*1.0, cm);\n  passthru = mix(passthru, 0.5, cm);\n\n  colMixer = colMixer-1.0;\n  cm = smoothstep(0.25, 0.75, clamp(colMixer, 0.0, 1.0));\n\n  // *** Color Regime 3 ***\n  col1 = mix(col1, vec3(1.8,0.1,1.4), cm);\n  col2 = mix(col2, -vec3(2.0), cm);\n  col3 = mix(col3, vec3(1.6,2.7,1.0), cm);\n  passthru = mix(passthru, 0.5, cm);\n\n  colMixer = colMixer-1.0;\n  cm = smoothstep(0.25, 0.75, clamp(colMixer, 0.0, 1.0));\n  \n  // *** Color Regime 2 ***\n  col1 = mix(col1, vec3(1.8,0.3,1.0), cm);\n  col2 = mix(col2, -vec3(0.2,0.0,0.8), cm);\n  col3 = mix(col3, vec3(0.3,0.7,1.9), cm);\n\n  colMixer = colMixer-1.0;\n  cm = smoothstep(0.25, 0.75, clamp(colMixer, 0.0, 1.0));\n\n  // *** Color Regime 1 ***\n  col1 = mix(col1, vec3(2.0,1.7,1.0), cm);\n  col2 = mix(col2, -vec3(2.0), cm);\n  col3 = mix(col3, vec3(0.1,2.0,2.4), cm);\n  passthru = mix(passthru, 1.0, cm);\n\n    vec3 finalCol = vec3(0.0);\n    finalCol += data.r*col1;\n    finalCol += data.g*col2;\n    finalCol += data.b*col3;\n    // finalCol *= (-0.5+dot(finalCol.rgb, vec3(1.0))/3.0);\n    finalCol = clamp(finalCol, 0.0, 1.0);\n\n    vec3 corrCol = _hueSaturationContrast(vec4(finalCol,1.0), 0.0, 0.5, 1.0).rgb;\n\n    // vec3 hsv = _rgb2hsv(finalCol);\n    // hsv.g = clamp(hsv.g+0.5, 0.0, 1.0);\n    // // hsv.b = mix(0.0, 1.0-hsv.b, hsv.b)*2.0;\n\n    // hsv = _hsv2rgb(hsv);\n    // finalCol.rgb = hsv;\n\n    // finalCol = mix(finalCol.rgb, _loadUserImage().rgb, pow(hsv.b,2.0));\n    // finalCol = clamp(finalCol, 0.0, 1.0);\n\n    return vec4(mix(corrCol, finalCol.rgb, passthru), 1.0);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Hue Review","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"by mojovideotech","DESCRIPTION":"Automatically converted from https://www.shadertoy.com/view/4ds3zn by iq.  The classic standard apollonian/kleinian fractal (everybody needs to render one at some point).","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\iq_apollonianfractal.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"IQ_ApollonianFractal","IMAGES":null,"IMAGE_PATH":"iq_apollonianfractal.synScene\\iq_apollonianfractal.png","JSON_CODE":"{\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"Automatically converted from https://www.shadertoy.com/view/4ds3zn by iq.  The classic standard apollonian/kleinian fractal (everybody needs to render one at some point).\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"iq_apollonianfractal.png\",\n\t\"TITLE\" : \"IQ_ApollonianFractal\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// I can't recall where I learnt about this fractal.\r\n// Coloring and fake occlusions are done by orbit trapping, as usual.\r\n\r\n\r\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\r\n#define AA 1\r\n\r\nvec4 orb; \r\n\r\nfloat map( vec3 p, float s )\r\n{\r\n\tfloat scale = 1.5;\r\n\torb = vec4(1000.0); \r\n\t\r\n\tfor( int i=0; i<8;i++ )\r\n\t{\r\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\r\n\t\tfloat r2 = dot(p,p);\r\n        orb = min( orb, vec4(abs(p),r2) );\r\n\t\tfloat k = max(s/r2,0.1);\r\n\t\tp     *= k;\r\n\t\tscale *= k;\r\n\t}\r\n\t\r\n\treturn 0.25*abs(p.y)/scale;\r\n}\r\n\r\nfloat trace( in vec3 ro, in vec3 rd, float s )\r\n{\r\n\tfloat maxd = 24.0;\r\n    float t = 0.005;\r\n    for( int i=0; i<160; i++ )\r\n    {\r\n\t    float precis = 0.001 * t;\r\n\t    float h = map( ro+rd*t, s );\r\n        if( h<precis||t>maxd ) break;\r\n        t += h;\r\n    }\r\n    if( t>maxd ) t=-1.0;\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos, in float t, in float s )\r\n{\r\n    float precis = 0.001 * t;\r\n    vec2 e = vec2(1.0,-1.0)*precis;\r\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \r\n                      e.xxx*map( pos + e.xxx, s ) );\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\r\n{\r\n    // trace\t\r\n    vec3 col = vec3(0.0);\r\n    float t = trace( ro, rd, anim );\r\n    if( t>0.0 )\r\n    {\r\n        vec4 tra = orb;\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos, t, anim );\r\n\r\n        // lighting\r\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\r\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\r\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\r\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\r\n        float amb = (0.7+0.3*nor.y);\r\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\r\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\r\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\r\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\r\n\r\n        // material\t\t\r\n        vec3 rgb = vec3(1.0);\r\n        rgb = mix( rgb, vec3(1.0,0.15,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\r\n        rgb = mix( rgb, vec3(1.0,0.15,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\r\n\r\n        // color\r\n        col = rgb*brdf*exp(-0.2*t);\r\n    }\r\n\r\n    return sqrt(col);\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n    float time = ((syn_BassTime+TIME))*0.05;\r\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(time) );\r\n    \r\n    vec3 tot = vec3(0.0);\r\n    #if AA>1\r\n    for( int jj=0; jj<AA; jj++ )\r\n    for( int ii=0; ii<AA; ii++ )\r\n    #else\r\n    int ii = 1, jj = 1;\r\n    #endif\r\n    {\r\n        vec2 q = _xy.xy+vec2(float(ii),float(jj))/float(AA);\r\n        vec2 p = (2.0*q-RENDERSIZE.xy)/RENDERSIZE.y;\r\n\r\n        // camera\r\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\r\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\r\n        float roll = 0.2*cos(0.1*time);\r\n        vec3 cw = normalize(ta-ro);\r\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n        vec3 cu = normalize(cross(cw,cp));\r\n        vec3 cv = normalize(cross(cu,cw));\r\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\r\n\r\n        tot += render( ro, rd, anim );\r\n    }\r\n    \r\n    tot = tot/float(AA*AA);\r\n    \r\n\tout_FragColor = vec4( tot, 1.0 );\t\r\n\r\n\r\nreturn out_FragColor; \r\n } \r\n\r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"IQ_ApollonianFractal","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Automatically jumps to a new background location on percussive beats. Turn off for full manual control.","MAX":1,"MIN":0,"NAME":"auto_jumper","TYPE":"toggle","UI_GROUP":"jump"},{"DEFAULT":0,"DESCRIPTION":"Press to manually jump to a new background location.","MAX":1,"MIN":0,"NAME":"jump","TYPE":"bang counter","UI_GROUP":"jump"},{"DEFAULT":1,"DESCRIPTION":"Automatically pulses on bass hits. Turn off for full manual control.","MAX":1,"MIN":0,"NAME":"auto_pulse","TYPE":"toggle","UI_GROUP":"pulse"},{"DEFAULT":0,"DESCRIPTION":"Press to manually create a pulse.","MAX":1,"MIN":0,"NAME":"pulse","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"pulse"},{"DEFAULT":1,"DESCRIPTION":"Control the intensity of the pulse. Lower for subtle, high for a lot of motion.","MAX":2,"MIN":0,"NAME":"pulse_intensity","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"pulse"},{"DEFAULT":0,"DESCRIPTION":"Turn on to increase contrast. Less uniform and more distinct dots. Try with pulse intensity on high and slices ON.","MAX":1,"MIN":0,"NAME":"contrast","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Slices up the screen. Turn on, then turn pulse intensity up for a cool splitting effect.","MAX":1,"MIN":0,"NAME":"slices","TYPE":"toggle","UI_GROUP":"effects"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\inkshot.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"whichTwoColors","VALUES":[0,0.100000001490116,0.200000002980232]}],"HEIGHT":1080,"ID":"Ink Shot","IMAGES":null,"IMAGE_PATH":"inkshot.synScene\\inkshot.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Ink Shot\",\n \"IMAGE_PATH\": \"inkshot.jpg\",\n \"HARD_TRANSITIONS\": [{\n  \"UNIFORM\": \"whichTwoColors\",\n  \"VALUES\": [0.0, 0.1, 0.2]\n }],\n \"PASSES\": [ {\"TARGET\": \"forRGBSplit\", \"FLOAT\":false}\n ],\n \"CONTROLS\": [ \n  {\n \t\t\"NAME\": \"auto_jumper\", \n\t\t\"TYPE\": \"toggle\",\n\t\t\"DEFAULT\": 1.0,\n\t\t\"DESCRIPTION\": \"Automatically jumps to a new background location on percussive beats. Turn off for full manual control.\",\n    \"UI_GROUP\":\"jump\"\n\t},{\n \t\t\"NAME\": \"jump\", \n\t\t\"TYPE\": \"bang counter\",\n\t\t\"DESCRIPTION\": \"Press to manually jump to a new background location.\",\n    \"UI_GROUP\":\"jump\"\n\t},{\n \t\t\"NAME\": \"auto_pulse\", \n\t\t\"TYPE\": \"toggle\",\n\t\t\"DEFAULT\": 1.0,\n\t\t\"DESCRIPTION\": \"Automatically pulses on bass hits. Turn off for full manual control.\",\n    \"UI_GROUP\":\"pulse\"\n\t},{\n \t\t\"NAME\": \"pulse\", \n\t\t\"TYPE\": \"bang smooth\",\n\t\t\"PARAMS\": 0.05,\n\t\t\"DESCRIPTION\": \"Press to manually create a pulse.\",\n    \"UI_GROUP\":\"pulse\"\n\t},{\n \t\t\"NAME\": \"pulse_intensity\", \n\t\t\"TYPE\": \"slider smooth\",\n\t\t\"DEFAULT\": 1.0,\n\t\t\"MAX\": 2.0,\n\t\t\"PARAMS\": 0.05,\n\t\t\"DESCRIPTION\": \"Control the intensity of the pulse. Lower for subtle, high for a lot of motion.\",\n    \"UI_GROUP\":\"pulse\"\n\t},{\n \t\t\"NAME\": \"contrast\", \n \t\t\"UI_GROUP\":\"effects\",\n\t\t\"TYPE\": \"toggle\",\n\t\t\"DEFAULT\": 0.0,\n\t\t\"DESCRIPTION\": \"Turn on to increase contrast. Less uniform and more distinct dots. Try with pulse intensity on high and slices ON.\"\n\t},{\n \t\t\"NAME\": \"slices\", \n \t\t\"UI_GROUP\":\"effects\",\n\t\t\"TYPE\": \"toggle\",\n\t\t\"DEFAULT\": 0.0,\n\t\t\"DESCRIPTION\": \"Slices up the screen. Turn on, then turn pulse intensity up for a cool splitting effect.\"\n\t}\n ]\n}\n","PASSES":[{"FLOAT":false,"HEIGHT":0,"TARGET":"forRGBSplit","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"float vuTimeUncorrected = syn_Time;\nfloat bassTimeUncorrected = syn_BassTime;\nfloat highsTimeUncorrected = syn_HighTime;\nfloat beatTimeUncorrected = syn_BeatTime;\nfloat vuFadeToBlack = syn_FadeInOut;\nfloat highHits = syn_HighHits;\nfloat bassHits = syn_BassHits;\nfloat bassAccum = syn_BassLevel;\nfloat randomizerBeat = syn_RandomOnBeat;\n\nvec2 resolution = RENDERSIZE; // the rendering resolution (in pixels)\nfloat time = TIME;\nfloat vuTime = vuTimeUncorrected * (0.08);// 60000 to \"correct\", but we want it much smaller actually\nfloat bassTime = bassTimeUncorrected*6 * (0.01);\nfloat beatTime = syn_BeatTime*6;\nfloat highsTime = (syn_HighTime + syn_MidHighTime)*6.0 * (0.03);\nfloat rgbZoomAmt = ((pow(bassAccum,2.0)+syn_BassHits*syn_BassLevel)*auto_pulse+pulse)*0.25*pulse_intensity;\n\n#define TWO_PI (PI * 2.0)\n\nvec2 getNormPos() {\n  return vec2(-1+2*(gl_FragCoord.x/resolution.x),-1+2*(gl_FragCoord.y/resolution.y));\n}\n\nvec2 getNormPosBotLeft() {\n  return vec2(gl_FragCoord.xy/resolution.xy);\n}\n\nvec3 resonancePattern(vec2 posIn, float numIters)\n{\n  vec2 v = posIn;\n  // float pulser = ((pow(bassAccum,2.0)+syn_BassHits*syn_BassLevel)*auto_pulse+(1.0-auto_pulse)*pulse)*0.25*pulse_intensity;\n  // if (pulse_type>0.5){\n  //   v+=normalize(_uvc)*pow(2.0-length(_uvc)*0.1,0.1)*pulser;\n  // }\n\n  float col = 0.1;\n\n  for(float i = 0.0; i < numIters; i++)\n  {\n    // vec2 posTemp = v*10.0*(-10.0+numIters*1.0+i);\n    vec2 posTemp = v*70.23+10.0*(numIters);\n    float a = i * (TWO_PI/numIters+i*1.023);\n    col += cos(TWO_PI*(posTemp.x*cos(a)+posTemp.y*sin(a)+fract(highsTime*TWO_PI*0.1)+i*fract(highsTime*TWO_PI*0.1)+sin(time*0.04)*10.0));\n  }\n\n  col /= 5.0;\n\n  return vec3(col);\n}\n\nvec3 drippyColoring(float posMod, vec2 modCent){\n  vec3 p = vec3((gl_FragCoord.xy)/(resolution.y)*(1.0+posMod),modCent.x+sin(highsTime*0.1));\n  for (int i = 0; i < 40; i++){\n    p.xzy = vec3(1.3,0.999,0.7-syn_BassPresence*0.1)*(abs((abs(p)/dot(p,p)-vec3(1.0,1.0,modCent.y*0.3))));\n  }\n  vec3 col = p;\n  return col;\n}\n\nvec4 renderMain(void)\n{\n  beatTime += jump*4;\n  if (auto_jumper<0.5){\n    beatTime = jump*6;\n  }\n\n  vec2 modifiedCenter = 0.75+vec2(sin(beatTime*2*PI*0.0215),cos(beatTime*2*PI*0.0237))*1.5;\n  if (PASSINDEX == 0.0){\n    vec2 posBL = getNormPosBotLeft();\n    posBL.x *=resolution.x/resolution.y;\n    modifiedCenter.x *=resolution.x/resolution.y;\n    posBL *= vec2(1.2, 1.0);\n    modifiedCenter *= vec2(1.2, 1.0);\n    vec2 modPos = posBL-modifiedCenter;\n    modPos = modPos*modPos;\n    float modder = modPos.x-modPos.y;\n    // if (modder < 0.1){\n    //   posBL = vec2(0.0);\n    // }\n    float bkgNoiseRegime = mod(floor(beatTime+modder),4.0)*2.0+4.0;\n    vec3 col = resonancePattern(posBL, bkgNoiseRegime);\n    // if (mod(floor(modder),2.0)==0.0){\n    //   col = vec3(0.2)-col;\n    // }\n    float alpha = 1.0;\n    if (slices>0.5){\n      col *= mod(bkgNoiseRegime/2,2.0);\n      alpha = mod(bkgNoiseRegime/2,2.0);\n    }\n    return vec4(col, alpha);\n  }\n  else if (PASSINDEX == 1.0){\n    vec3 col;\n    vec2 posBL = getNormPosBotLeft();\n    vec2 modPos = posBL;\n    modPos.x *=resolution.x/resolution.y;\n    modPos *= vec2(1.2, 1.0);\n\n      rgbZoomAmt*=sin(length(modPos-modifiedCenter)*2*PI)*1.0+0.5;\n    \n    \n\n    vec2 rPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmt*0.05*5.0))+modifiedCenter;\n    vec2 gPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmt*0.07*5.0))+modifiedCenter;\n    vec2 bPos = (posBL - modifiedCenter)*(1.0/(1.0+rgbZoomAmt*0.03*5.0))+modifiedCenter;\n\n    vec3 col1, col2, col3;\n    col1 = vec3(1.0, 0.0, 1.0)*(1.0+rgbZoomAmt);\n    col2 = vec3(1.0, 1.0, 0.0)*(1.0+rgbZoomAmt);\n    col3 = vec3(0.0, 1.0, 1.0)*(1.0+rgbZoomAmt);\n    if (whichTwoColors == 0.0){\n      col1 = vec3(1.0)*0.33;\n    } else if (whichTwoColors == 0.1){\n      col2 = vec3(1.0)*0.33;\n    } else if (whichTwoColors == 0.2){\n      col3 = vec3(1.0)*0.33;\n    }\n\n    col1 *= texture(forRGBSplit, rPos).r;\n    col2 *= texture(forRGBSplit, gPos).g;\n    col3 *= texture(forRGBSplit, bPos).b;\n    float alpha = texture(forRGBSplit, bPos).a;\n    // return vec4(col1);\n    col = col1+col2+col3;\n    col *= vuFadeToBlack;\n\n    // col += texture(forRGBSplit, posBL).bgr;\n\n    vec3 colDrip = drippyColoring(rgbZoomAmt*0.01,modifiedCenter*0.5);\n    col = pow(col,vec3(1.2));\n\n    if (contrast == 1.0){\n      colDrip = vec3(1.0)-colDrip;\n      col = pow(col,vec3(2.0));\n    }\n\n    vec3 normCol = pow(1.0-texture(forRGBSplit, _uv).rgb,vec3(2.0));\n\n    if (_exists(syn_UserImage)){\n      col = mix(col*colDrip, _loadUserImage().rgb*pow(colDrip,vec3(2.0)*normCol)*alpha, _loadUserImageAsMask().r);\n    } else {\n      col *= colDrip;\n    }\n\n\n    return vec4(col,1.0);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Ink Shot","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Applies extra constant rotational motion to the fractal.","MAX":1,"MIN":0,"NAME":"unfolding","TYPE":"toggle","UI_GROUP":"fractal"},{"DEFAULT":1,"DESCRIPTION":"X, Y, and Z params control the shape of the fractal.","MAX":1.5,"MIN":0.5,"NAME":"x_param","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"fractal"},{"DEFAULT":1,"DESCRIPTION":"X, Y, and Z params control the shape of the fractal.","MAX":1.5,"MIN":0.5,"NAME":"y_param","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"fractal"},{"DEFAULT":1,"DESCRIPTION":"X, Y, and Z params control the shape of the fractal.","MAX":2,"MIN":0,"NAME":"z_param","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"fractal"},{"DEFAULT":0,"DESCRIPTION":"This controls the size of the blocks that form the fractal.","MAX":-0.200000002980232,"MIN":0.0500000007450581,"NAME":"size","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"fractal"},{"DEFAULT":[0,0],"DESCRIPTION":"Move the X-axis to spin about your main axis, or move the Y-axis to tilt forwards or backwards.","MAX":[1,1],"MIN":[-1,-1],"NAME":"lookXY","PARAMS":0.0299999993294477,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"ON: time variable is influenced by the audio bass. OFF: constant rate.","MAX":1,"MIN":0,"NAME":"reactive_time","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"How fast the time variable grows, whether it is reactive time or constant time.","MAX":4,"MIN":-4,"NAME":"rate_in","TYPE":"knob","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Blue, reflective lighting. Turn down to use more alternate lighting.","MAX":1,"MIN":0,"NAME":"standard_lighting","PARAMS":0.100000001490116,"TYPE":"knob smooth","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"Alternate lighting pattern, using built-in texture or user selected media. Scan it in and out with 'scan alt light'.","MAX":1,"MIN":0,"NAME":"alternate_lighting","PARAMS":0.200000002980232,"TYPE":"knob smooth","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"Moves the 'alternate lighting' source further from the camera.","MAX":1,"MIN":0,"NAME":"scan_alt_light","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"lighting"},{"DEFAULT":0,"DESCRIPTION":"A rendering glitch that causes a strange liquifying effect near hard edges.","MAX":1,"MIN":0,"NAME":"liquify","TYPE":"slider","UI_GROUP":"render glitches"},{"DEFAULT":1,"DESCRIPTION":"Brings in the far wall, resulting in very interesting patterns when brought up close.","MAX":1,"MIN":0.00999999977648258,"NAME":"far_wall","TYPE":"slider","UI_GROUP":"render glitches"}],"CREDIT":"Shane","DESCRIPTION":"Constructing a basic fractal object with Knighty's Kaleidoscopic IFS procedure.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\kifs_flythrough.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"KIFS Flythrough","IMAGES":[{"NAME":"image3","PATH":"images/3.jpg"},{"NAME":"image10","PATH":"images/10.jpg"},{"NAME":"geom","PATH":"images/geo.jpg"}],"IMAGE_PATH":"kifs_flythrough.synScene\\kifs_flythrough.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"NAME\" : \"unfolding\",\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Applies extra constant rotational motion to the fractal.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"fractal\"\n      },{\n         \"NAME\" : \"x_param\",\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"X, Y, and Z params control the shape of the fractal.\",\n         \"MAX\" : 1.5,\n         \"MIN\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"fractal\"\n      },{\n         \"NAME\" : \"y_param\",\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"X, Y, and Z params control the shape of the fractal.\",\n         \"MAX\" : 1.5,\n         \"MIN\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"fractal\"\n      },{\n         \"NAME\" : \"z_param\",\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"X, Y, and Z params control the shape of the fractal.\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.0,\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"fractal\"\n      },{\n         \"NAME\" : \"size\",\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"This controls the size of the blocks that form the fractal.\",\n         \"MAX\" : -0.2,\n         \"MIN\" : 0.05,\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"fractal\"\n      },{\n         \"DEFAULT\" : 0,\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"lookXY\",\n         \"PARAMS\" : 0.03,\n         \"TYPE\" : \"xy smooth\",\n         \"DESCRIPTION\":\"Move the X-axis to spin about your main axis, or move the Y-axis to tilt forwards or backwards.\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"NAME\" : \"reactive_time\",\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"ON: time variable is influenced by the audio bass. OFF: constant rate.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"NAME\" : \"rate_in\",\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"How fast the time variable grows, whether it is reactive time or constant time.\",\n         \"MAX\" : 4,\n         \"MIN\" : -4,\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"NAME\" : \"standard_lighting\",\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Blue, reflective lighting. Turn down to use more alternate lighting.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"lighting\"\n      },\n      {\n         \"NAME\" : \"alternate_lighting\",\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Alternate lighting pattern, using built-in texture or user selected media. Scan it in and out with 'scan alt light'.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"lighting\"\n      },{\n         \"NAME\" : \"scan_alt_light\",\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Moves the 'alternate lighting' source further from the camera.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"lighting\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"A rendering glitch that causes a strange liquifying effect near hard edges.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"liquify\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"render glitches\"\n      },\n      {\n         \"NAME\" : \"far_wall\",\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Brings in the far wall, resulting in very interesting patterns when brought up close.\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.01,\n         \"TYPE\" : \"slider\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"render glitches\"\n      }\n   ],\n   \"CREDIT\" : \"Shane\",\n   \"DESCRIPTION\" : \"Constructing a basic fractal object with Knighty's Kaleidoscopic IFS procedure.\",\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image3\",\n         \"PATH\" : \"images/3.jpg\"\n      },\n      {\n         \"NAME\" : \"image10\",\n         \"PATH\" : \"images/10.jpg\"\n      },\n      {\n         \"NAME\" : \"geom\",\n         \"PATH\" : \"images/geo.jpg\"\n      }\n   ],\n   \"PASSES\":[\n   {\"TARGET\":\"fractalPass\", \"WIDTH\":1280, \"HEIGHT\":720}],\n   \"HEIGHT\":1080,\n   \"WIDTH\":1920,\n   \"IMAGE_PATH\" : \"kifs_flythrough.png\",\n   \"TITLE\" : \"KIFS Flythrough\"\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"fractalPass","WIDTH":1280}],"SCRIPT_CODE":"function Timer () {\n  this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function(rate, val, dt) {\n  this.time = this.time+rate*dt*val;\n}\n\nfunction SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n}\n\n// var bpmcount = new BPMCounter();\n// var downrot = new SmoothCounter();\n// var rightrot = new SmoothCounter();\n\nvar bassTimevar = new Timer();\nvar timevar = new Timer();\n\nvar decimator = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  try {\n    bassTimevar.updateTime(0.1, (inputs.syn_BassLevel*2.0+inputs.syn_BassPresence+inputs.syn_BassHits*2.0)*inputs.rate_in, dt);\n    timevar.updateTime(0.4, inputs.rate_in, dt);\n\n    uniforms.script_time = timevar.time;\n    uniforms.bass_time = bassTimevar.time;\n\n    // downrot.update(dt, inputs.down_rot, 0.1);\n\n    // uniforms.down_rot_scr = downrot.currentValue;\n\n  }  \n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n    catch (e){\n    print(e);\n  }\n\n}","SHADER_CODE":"/*\n\n    KIFS Flythrough\n    ---------------\n\n    After looking at Zackpudil's recent fractal shaders, I thought I'd put together something \n\tfractal in nature. It's nothing exciting, just the standard IFS stuff you see here and there. \n\tLike many examples, this particular one is based on Syntopia and Knighty's work.\n\n    The construction is pretty similar to that of an infinite sponge, but it has a bit of rotating, \n\tfolding, stretching, etc, thrown into the mix.\n\n    The blueish environmental lighting is experimental, and based on XT95s environment mapping in \n\this UI example. The idea is very simple: Instead of passing a reflective ray into a cubic \n\ttexture in cartesian form, convert it to its polar angles, then index into a 2D texture. The \n\tresults are abstract, and no substitute for the real thing, but not too bad, all things \n\tconsidered.\n\n\tThe comments are a little rushed, but I'll tidy them up later.\n\n\tExamples and references:\n\n    Menger Journey - Syntopia\n    https://www.shadertoy.com/view/Mdf3z7\n\n    // Explains the process in more detail.\n    Kaleidoscopic (escape time) IFS - Knighty\n    http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n\n    Ancient Generators - Zackpudil\n    https://www.shadertoy.com/view/4sGXzV\n\n*/\n\n#define FAR 40.0\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize\n    // that it's redundant, due to the normalization that follows. I'd never noticed on account\n    // of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(abs(n) - 0.2, 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    // Rought sRGB to linear RGB conversion in preperation for eventual gamma correction.\n    return p*p; \n}\n\n\n// IFS, or KIFS in particular. The following explains the process in more detail.\n//\n// Kaleidoscopic (escape time) IFS - Knighty\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n//\n// Here's a quick, rushed expanation. Take an input point, and repeat it. After that, rotate\n// it, fold it, stretch and translate it about an offset point. Form an object with it and compare\n// it to the object formed in the repeat layer. Repeat ad infinitum...\n//\n// OK, that was a little vague, but it really is a pretty simple process. Playing around with the \n// code will give it more meaning. Change the rotation angles, iteration number, comment some\n// things out, etc. I'd also recommend reading Syntopia's blog. He explains things really well...\n// and there's so many pretty pictures. :)\n//\n// Syntopia - http://blog.hvidtfeldts.net/\n//\nfloat map(vec3 p){\n    \n    // I'm never sure whether I should take constant stuff like the following outside the function, \n    // or not. My 1990s CPU brain tells me outside, but it doesn't seem to make a difference to frame \n    // rate in this environment one way or the other, so I'll keep it where it looks tidy. If a GPU\n    // architecture\\compiler expert is out there, feel free to let me know.\n    \n    vec3 offs = vec3(1.0*x_param, 0.75*y_param, 0.5*z_param); // Offset point.\n    // const vec3 offs = vec3(1.0, 0.75, 0.5);\n    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);\n    const mat2 m = mat2(a.y, -a.x, a);\n    vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4. + p.z*0.3+TIME*0.1*unfolding);\n    mat2 m2 = mat2(a2.y, -a2.x, a2);\n    \n    const float s = 5.; // Scale factor.\n    \n    float d = 1e5; // Distance.\n    \n    \n    p  = abs(fract(p*.5)*2. - 1.); // Standard spacial repetition.\n     \n    \n    float amp = 1./s; // Analogous to layer amplitude.\n    \n   \n    // With only two iterations, you could unroll this for more speed,\n    // but I'm leaving it this way for anyone who wants to try more\n    // iterations.\n    for(int i=0; i<2; i++){\n        \n        // Rotating.\n        p.xy = m*p.xy;\n        p.yz = m2*p.yz;\n        \n        p = abs(p);\n\n  \t\t// Folding about tetrahedral planes of symmetry... I think, or is it octahedral? \n        // I should know this stuff, but topology was many years ago for me. In fact, \n        // everything was years ago. :)\n\t\t// Branchless equivalent to: if (p.x<p.y) p.xy = p.yx;\n        p.xy += step(p.x, p.y)*(p.yx - p.xy);\n        p.xz += step(p.x, p.z)*(p.zx - p.xz);\n        p.yz += step(p.y, p.z)*(p.zy - p.yz);\n \n        // Stretching about an offset.\n\t\tp = p*s + offs*(1. - s);\n        \n\t\t// Branchless equivalent to:\n        // if( p.z < offs.z*(1. - s)*.5)  p.z -= offs.z*(1. - s);\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\n        \n        // Loosely speaking, construct an object, and combine it with\n        // the object from the previous iteration. The object and\n        // comparison are a cube and minimum, but all kinds of \n        // combinations are possible.\n        p=abs(p);\n//standard cubes\n        d = min(d, max(max(p.x, p.y), p.z)*amp);\n\n//cool pattern        \n        // d = mix(d, min(d, mix(max(max(p.x, p.y), p.z), length(p), sin(p.y*2.0))*amp*0.5), bubbly);\n\n//pointy        \n        // d = mix(d, min(d, mix(max(max(p.x, p.y), p.z), length(p), sin(p.z*2.0+TIME))*amp*0.5), pointy);\n\n        // d = min(d, max(max(p.x, p.y), p.z)*amp*1.5);\n\n        amp /= s; // Decrease the amplitude by the scaling factor.\n    }\n \n \treturn d - .035 + size; // .35 is analous to the object size.\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\n// vec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n//     const vec2 e = vec2(0.001, 0);\n//     // Gradient vector, constructed with offset greyscale texture values.\n//     //vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n//     mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n//     vec3 g = vec3(0.299, 0.587, 0.114)*m;\n//     g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n//     return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n// }\n\n\n// Very basic raymarching equation.\nfloat trace(vec3 ro, vec3 rd){\n\n    \n    float t = 0.;//hash(dot(rd, vec3(7, 157, 113)))*0.01;\n    for(int i=0; i< 64-liquify*liquify*60; i++){\n        \n        float d = map(ro + rd*t);\n        if (d < 0.0025*(1. + t*.125) || t>FAR*0.5*far_wall*far_wall) break;\n        t += d;\n    } \n    return t;\n}\n\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n// Apart from being faster, it can produce a subtley different aesthetic to the 6 tap version, which I sometimes prefer.\nvec3 normal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function.\nvec3 normal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 16; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.02, 0.25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.25, 1.0); \n}\n\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected ray at the surface hit point, \n// convert the 3D ray coordinates (rd) to polar coordinates (the angular components) and \n// index into a repeat texture. It can be pretty convincing (in an abstract way) and\n// facilitates environment mapping without the need for a cube map, or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 rd, vec3 n){\n    \n    //vec3 col2 = tex3D(image10, rd/4., n).zyx;//*(1.-lod*.8)\n    //return smoothstep(.0, 1., col2*2.);\n    \n\n    // I got myself a little turned around here, but I think texture size\n    // manipulation has to be performed at this level, if you want the angular\n    // polar coordinates to wrap... Not sure though... It'll do. :)\n    rd /= 8.; \n    \n    vec2 uv = vec2(atan(rd.y, rd.x)/6.283, acos(rd.z)/3.14159);\n    uv = fract(uv);\n   \n    vec3 col = texture(image10, uv).zyx;//*(1.-lod*.8)\n    return smoothstep(.1, 1., col*col*2.);\n    \n}\n\n\n\n// Pseudo environment mapping. Simlilar to above, but using tri-planar texturing for a more \n// even spread.\n// vec3 envMap(vec3 rd, vec3 n){\n    \n//     vec3 col = tex3D(image10, rd/4., n).zyx;\n//     return smoothstep(.1, 1., col*2.);\n// }\n\n//////\n\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n    \n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - RENDERSIZE.xy, RENDERSIZE.y));\n    \n    // Barrel distortion;\n    // rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z - dot(rd.xy, rd.xy)*disto_knob)));\n    // rd = mix(rd, normalize(vec3(_uvc, 1.0)), )\n    rd = normalize(vec3(_uvc, 1.0));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    // vec2 m = sin(vec2(1.57079632, 0) + blur_out*2*PI);\n    // rd.xy = rd.xy*mat2(m.xy, -m.y, m.x);\n    // rd.xz = rd.xz*mat2(m.xy, -m.y, m.x);\n    rd.yz = _rotate(rd.yz, lookXY.y*PI);\n    rd.xy = _rotate(rd.xy, lookXY.x*PI);\n    \n    // Ray origin, set off in the YZ direction. Note the \"0.5.\" It's an old lattice trick.\n    vec3 ro = vec3(0.0, 0.0, mix(script_time*0.5, bass_time*1.0, reactive_time));\n    vec3 lp = ro + vec3(0.0, .25, .25); // Light, near the ray origin.\n\n    // Set the scene color to black.\n    vec3 col = vec3(0);\n\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Surface hit, so light it up.\n    if(t<FAR){\n    \n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n\n\n        const float sz = 1.; // Texture size.\n\n        // sn = db(image3, sp*sz, sn, .002/(1. + t/FAR)); // Texture bump.\n\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n\n        vec3 oCol = tex3D(image3, sp*sz, sn); // Texture color at the surface point.\n        oCol = smoothstep(0., 1., oCol)*standard_lighting;\n\n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn)*.5 + .5; // Self shadows. Not too much.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n\n        float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*.075); // Attenuation.\n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff + vec3(.4, .25, .2)) + vec3(1., .6, .2)*spec*2.*standard_lighting;\n        \n        // Faux environmental mapping.\n        col += envMap(reflect(rd, sn), sn)*standard_lighting;\n        vec3 texo = tex3D(geom, sp*sz*0.5, vec3(1.0,1.0,0.0));\n        if (syn_MediaType>0.5){\n            texo = 1.0-tex3D(syn_UserImage, sp*sz, vec3(1.0,1.0,0.0));\n        }\n\n        vec3 colPal = _palette(fract(sp.z), vec3(0.620, 0.860, -0.040), vec3(0.500, 1.000, 0.500), vec3(0.500, 0.345, 0.750), vec3(0.500, 0.440, 0.220));\n        col += (1.0-texo)*mix(colPal, vec3(0.0,0.4,0.8), sp.y)*10.0*_pulse(length(ro-sp)*10.0, scan_alt_light*50.0, 1.0*(1.0+alternate_lighting*50.0));\n        // Environment mapping with a cubic texture, for comparison.\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*pow(ao,10.0), 1.);\n        \n        \n\n        //col = clamp(col + hash(dot(rd, vec3(7, 157, 113)))*0.1 - 0.05, 0., 1.);\n        \n    }\n    \n    \n    // Blend the scene and the background with some very basic, 8-layered smokey haze.\n    // float mist = getMist(ro, rd, lp, t);\n    // float mist = 0.5;\n    // vec3 sky = vec3(.35, .6, 1)* mix(1., .75, mist);//*(rd.y*.25 + 1.);\n    \n    // // Mix the smokey haze with the object.\n    // col = mix(sky, col, 1./(t*t/FAR/FAR*128. + 1.));\n\n      vec3 bg = mix(vec3(1.0, .0, 0.0), vec3(0.0, 0.0, 1.0), -rd.y*.35 + .35)*0.5;\n\n\n      col = mix(col, bg, smoothstep(0., FAR-15., t));//min(bg.zyx*vec3(1.3, .6, .2)*1.5, 1.)\n\n      float vig = pow(16.*_uv.x*_uv.y*(1.-_uv.x)*(1.-_uv.y), 0.125);\n      col *= vec3(1.2, 1.1, .85)*vig;\n\n    // Statistically unlikely 2.0 gamma correction, but it'll do. :)\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    float collisionDist = 0.01;\n    // if (t < collisionDist){\n    //     fragColor.rgb = vec3(t*100);\n    // }\n    // if (t>FAR*0.05){\n    //     fragColor *= 0.5;\n    // }\n\treturn fragColor; \n } \n\n vec3 filter_() {\n  vec2 delta = 1. / RENDERSIZE;\n  \n  vec3 val = texture(fractalPass, _uv).xyz;\n\n  vec3 l = texture(fractalPass, _uv + vec2(0., delta.y)).xyz;\n  vec3 r = texture(fractalPass, _uv - vec2(0., delta.y)).xyz;\n  vec3 u = texture(fractalPass, _uv + vec2(delta.x, 0.)).xyz;\n  vec3 d = texture(fractalPass, _uv - vec2(delta.x, 0.)).xyz;\n\n  vec3 n = vec3(_rand(_uvc+fract(TIME))) - 0.5;\n  \n  vec3 bloom = max(val, max(max(l, r), max( u, d)));\n  bloom = bloom  + l + r + u + d;\n  bloom /= 5.; // orlando;\n  return bloom;\n\n}\n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n    else if(PASSINDEX == 1){\n        vec4 fractal = vec4(filter_(),1.0);\n        return fractal;\n    }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"KIFS Flythrough","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.25,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"rate_color","TYPE":"knob","UI_GROUP":"speed"},{"DEFAULT":0.25,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"rate_forward","TYPE":"knob","UI_GROUP":"speed"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"beat_reaction","TYPE":"slider","UI_GROUP":"speed"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"smooth_rotate","TYPE":"slider","UI_GROUP":"rotate"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"jump_rotate","TYPE":"toggle","UI_GROUP":"rotate"},{"DEFAULT":3,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"color_selector","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0.0500000007450581,"DESCRIPTION":"","MAX":0.5,"MIN":0,"NAME":"media_distort","PARAMS":0.150000005960464,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"sunset","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"two_color_minimal","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":[1,0,0],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"col1","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":[0,1,1],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"col2","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"square","TYPE":"toggle","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"octagon","TYPE":"toggle","UI_GROUP":"shape"},{"DEFAULT":1,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"complexity","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"shape"}],"CREDIT":"Meebs","DESCRIPTION":"kalidescopes whoa","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\kaleidowhoa_man.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"KaleidoWHOA, MAN","IMAGES":null,"IMAGE_PATH":"kaleidowhoa_man.synScene\\kaleidowhoa_man.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"rate_color\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"speed\"\n      },\n      {\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"rate_forward\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"speed\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"beat_reaction\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"speed\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"smooth_rotate\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"rotate\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"jump_rotate\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"rotate\"\n      },\n      {\n         \"DEFAULT\" : 3.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 3,\n         \"MIN\" : 0,\n         \"NAME\" : \"color_selector\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.05,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.5,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_distort\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"sunset\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"two_color_minimal\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"col1\",\n         \"DEF_COLOR\":[1.0,0.0,0.0],\n         \"TYPE\" : \"color\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"DEF_COLOR\":[0.0,1.0,1.0],\n         \"NAME\" : \"col2\",\n         \"TYPE\" : \"color\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"square\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"octagon\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"complexity\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"shape\"\n      }\n   ],\n   \"CREDIT\" : \"Meebs\",\n   \"DESCRIPTION\" : \"kalidescopes whoa\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"kaleidowhoa_man.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 792,\n         \"TARGET\" : \"backTex\",\n         \"WIDTH\" : 1408\n      }\n   ],\n   \"TITLE\" : \"KaleidoWHOA, MAN\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":792,"TARGET":"backTex","WIDTH":1408}],"SCRIPT_CODE":"// function ApproachRandomSpot () {\n//   this.goal = 0.0;\n//   this.currentSpot = 0.0;\n// }\n\n// ApproachRandomSpot.prototype.update = function(amt) {\n//   this.currentSpot = this.currentSpot + (this.goal-this.currentSpot)*amt;\n// }\n\n// var mover = new ApproachRandomSpot();\n\nvar decimator = 0;\nvar time_forward = 0;\nvar time_color = 0;\nvar time_bass = 0;\nvar time_highs = 0;\n\nfunction update(dt) {\n\n  // if (inputs.syn_OnBeat > 0.9){\n  //   mover.goal = Math.random();\n  // }\n  // // mover.goal = 0.5+0.5*Math.sin(inputs.TIME);\n  // mover.update(0.02);\n  // uniforms.random_spot = mover.currentSpot;\n\n  time_forward += 0.005*(inputs.syn_BassLevel*inputs.syn_BassLevel*1.5 + inputs.syn_Presence*0.3)*inputs.rate_forward;\n  time_color += 0.01*(inputs.syn_HighHits + inputs.syn_Level*inputs.syn_Level)*inputs.rate_color;\n  time_bass += 0.05*(inputs.syn_BassLevel + inputs.syn_BassLevel*inputs.syn_BassLevel)*inputs.smooth_rotate;\n  time_highs += 0.1*(inputs.syn_HighHits + inputs.syn_HighHits*inputs.syn_HighHits)*inputs.rate_color;\n\n  uniforms.time_forward = time_forward;\n  uniforms.time_color = time_color;\n  uniforms.time_bass = time_bass;\n  uniforms.time_highs = time_highs;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(time_bass);\n  // }\n}\n\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"float time = 0.0;\nfloat rotTime = time_bass + syn_BeatTime*jump_rotate;\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat length8(vec3 x)\n{\n \treturn pow(dot(vec3(1.0, 2.0, 1.0), pow(abs(x), vec3(8.0))), 1.0/8.0)  ;\n}\n\nfloat length8(vec2 x)\n{\n \treturn pow(dot(vec2(1.0, 1.0), pow(abs(x), vec2(8.0))), 1.0/8.0)  ;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    \n  vec2 q = vec2(length8(p.xy)-t.x,p.z);\n  return length8(q)-t.y;\n}\n\nfloat nsin(float x)\n{\n    return sin(x) * 0.5 + 0.5;\n    \n}\n\nfloat map(vec3 p)\n{\n\n    vec3 q = p;\n\n    float rep = 0.01;\n        \n    vec3 c = vec3(rep);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n\n    \n    vec3 p_s;\n        \n    float bars = 1000.0;\n    float inner = 1000.0;\n    float angle = 3.1415 * 0.33;\n    \n    float blockID = floor(q.z / rep);\n\n    for ( int i = 0; i < 5; i ++)\n    {\n        \n        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));\n        \n        \n        float cutout = 10000.;\n        vec2 line = vec2( nsin(q.z*33.0), 0.005 * nsin(10.0 * q.z));\n        \n        p_s = p_s + vec3(\n            sin(blockID * 11.0)* 0.1 + 0.3 -0.01*pow(syn_OnBeat,0.3)*beat_reaction,\n            sin(q.z * sin(q.z+ rotTime* 0.01)) * sin(p.z* 4.0),\n            0.0);\n         \n        p_s = p_s * rotationMatrix(vec3(0.0, 0.0, 1.0), 1.1 *  rotTime * 0.05  );\n     \tp_s = p_s * vec3(5.0*complexity, 1.0, 1.0);\n\n        cutout = sdTorus88(p_s, line);\n        \n        inner = min(inner, cutout);\n\n    }\n\n        \n    \n    float result = inner;  \n    return result;\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = time;\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx) - map(p-e.yxx),\n\t\t\t\t\tmap(p+e.xyx) - map(p-e.xyx),\n\t\t\t\t\tmap(p+e.xxy) - map(p-e.xxy)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    if (_toPolarTrue(_uvc).y>1.0/6.0){\n        discard;\n    }\n\ttime = time_forward*0.5;\n    vec2 _p = (-RENDERSIZE.xy + 2.0*fragCoord.xy) / RENDERSIZE.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.1, d = 0.0, iter = 0.0, glow = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 80; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.0005) {\n\t\t\thit = true;\n            break;\n        }\n        if ( depth > 20.0)\n            break;      \n        \n        float ratio =  nsin(time * 0.1) * 0.01 + 0.03 + nsin(time)* 0.02;\n\t\tdepth += d * ratio;\n        glow += 0.01/sqrt(d);\n\t\titer++;\n                   \n    }\n    vec3 col = vec3(0.0);\n    \n    // if(hit)\n    // \tcol = vec3(1.0 - iter / 80.0);\n\n    // // col = pow(col, vec3(\n    // //     cos(floor(p.z *300.0 )) * 0.8 + 0.9 , \n    // //     0.9, \n    // //     sin(floor(p.z / 0.1)) * 0.3 + 0.4 ));\n    \n    fragColor = vec4(1.0 - iter / 80.0, depth, hit, glow);\n    \n\treturn fragColor; \n } \n\nvec2 kaleidoscope(vec2 uvIn, float n) {\n  vec2 uv = uvIn;\n  float angle = PI/n;\n  \n  // uv = uv*vec2(RENDERSIZE.x/RENDERSIZE.y,1.0);\n  float r = fract(length(uv));\n  float a = atan(uv.y, uv.x)/angle;\n  \n  a = mix(fract(a), 1.0 - fract(a), mod(floor(a), 2.0))*angle;\n  \n  return vec2(cos(a), sin(a+0.05))*(r+0.03);\n}\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n    if(PASSINDEX == 1){\n        // vec2 uv = _rotate(_uvc*0.5,TIME);\n        vec2 uv = _rotate(_uvc, PI/2);\n        float sides = 6.0 - 2.0*square + 2.0*octagon;\n        uv = kaleidoscope(uv, sides);\n        // uv = \n        uv *= 0.5;\n        uv += 0.5;\n        vec4 img = texture(backTex, uv);\n        vec2 RENDERSIZE_FIRST = vec2(1408, 792);\n        vec4 imgn = texture(backTex, uv+vec2(0,1)/RENDERSIZE_FIRST);\n        vec4 imgs = texture(backTex, uv+vec2(0,-1)/RENDERSIZE_FIRST);\n        vec4 imgw = texture(backTex, uv+vec2(1,0)/RENDERSIZE_FIRST);\n        vec4 imge = texture(backTex, uv+vec2(-1,0)/RENDERSIZE_FIRST);\n\n\n        vec3 finalCol = vec3(0.0);\n        vec4 dat = (img*6.0+imgn*1.0+imgs*1.0+imgw*1.0+imge*1.0)/10.0;\n        float glow = clamp(dat.a/12.0, 0.0, 1.0);\n        float hit = dat.b;\n        if (sunset>0.5){\n            vec3 hsv = vec3(dat.g*1.0+time_color+color_selector+length(_uvc)*0.3+glow*0.25, 0.85, dat.r+glow);\n            // finalCol.rgb = _rgb2hsv(finalCol.rgb);\n            // finalCol.r = dat.r+time_color;\n            // finalCol.r += length(_uvc)+finalCol.b;\n            // finalCol.g += 0.5;\n            finalCol = _hsv2rgb(hsv);\n            finalCol.g -= pow((1.0-finalCol.r),1.5)*0.35+pow((1.0-finalCol.b), 1.5)*0.35;\n            finalCol.g *= 2.0;\n            if (finalCol.g > max(finalCol.b, finalCol.r)-glow*0.5){\n                finalCol.g -= finalCol.g;\n            }\n            finalCol.b -= finalCol.r*0.4;\n            finalCol.b *= 0.7;\n            // finalCol.g += finalCol.b*0.2;\n        }\n        else if (two_color_minimal>0.5){\n            finalCol = vec3(0.0);\n            finalCol += (0.5+0.5*sin(dat.g*20.0+time_highs*4.0))*(1.0-hit)*col2;\n            finalCol += glow*glow*1.5*col1;\n\n        }\n        else {\n            finalCol.rgb = vec3(dat.r);\n            finalCol.rgb = _rgb2hsv(finalCol.rgb);\n            finalCol.r = glow*0.2+time_color*1.5+color_selector;\n            finalCol.r += length(_uvc)+dat.g;\n            finalCol.g += 0.8;\n            finalCol.b += pow(glow,2.0);\n            finalCol.b = clamp(finalCol.b, 0.0, 1.0);\n            finalCol = _hsv2rgb(finalCol);\n        }\n        if (syn_MediaType > 0.5){\n            vec3 imgCol = _loadUserImage(_rotate(vec2(1.0,1.0), 2*PI*(dat.r+dat.g + glow))*media_distort*media_distort).rgb;\n            finalCol -= dot(imgCol, vec3(1.0))/3.0;\n            finalCol = clamp(finalCol, 0.0, 1.0);\n            finalCol += imgCol;\n        }\n        return vec4(finalCol, 1.0);\n    }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"KaleidoWHOA, MAN","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[2,2],"MIN":[-2,-2],"NAME":"center","PARAMS":0.0780000016093254,"TYPE":"xy smooth","UI_GROUP":"primary"},{"DEFAULT":0.670000016689301,"DESCRIPTION":"","MAX":1,"MIN":0.100000001490116,"NAME":"zoom","PARAMS":0.129999995231628,"TYPE":"slider smooth","UI_GROUP":"primary"},{"DEFAULT":1,"DESCRIPTION":"","MAX":3,"MIN":0.00999999977648258,"NAME":"rate","PARAMS":0.20100000500679,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":15,"DESCRIPTION":"","MAX":24,"MIN":8,"NAME":"loops","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.0299999993294477,"DESCRIPTION":"","MAX":0.0500000007450581,"MIN":0.00999999977648258,"NAME":"intensity","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.14000010490417,"DESCRIPTION":"","MAX":5,"MIN":0.5,"NAME":"focus","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":30,"DESCRIPTION":"","MAX":60,"MIN":6,"NAME":"pulse","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":10,"DESCRIPTION":"","MAX":100,"MIN":-100,"NAME":"glow","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\kalicircuitsexplorer.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"KaliCircuitsExplorer","IMAGES":null,"IMAGE_PATH":"kalicircuitsexplorer.synScene\\kalicircuitsexplorer.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t2,\n\t\t\t\t2\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-2,\n\t\t\t\t-2\n\t\t\t],\n\t\t\t\"NAME\" : \"center\",\n\t\t\t\"PARAMS\" : 0.078,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"primary\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.67,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"PARAMS\" : 0.13,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"primary\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"PARAMS\" : 0.201,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 15,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 24,\n\t\t\t\"MIN\" : 8,\n\t\t\t\"NAME\" : \"loops\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.03,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.05,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"intensity\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.14,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"focus\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 30,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 60,\n\t\t\t\"MIN\" : 6,\n\t\t\t\"NAME\" : \"pulse\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 10,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : -100,\n\t\t\t\"NAME\" : \"glow\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"kalicircuitsexplorer.png\",\n\t\"TITLE\" : \"KaliCircuitsExplorer\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n////////////////////////////////////////////////////////////////////\r\n// KaliCircuitsExplorer  by mojovideotech\r\n//\r\n// based on :\r\n// shadertoy.com/XlX3Rj  by Kali\r\n//\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n////////////////////////////////////////////////////////////////////\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\t\r\nfloat S = (101.0 + glow) * intensity;\r\nvec3 color = vec3(0.0);\r\n\r\nvoid formula(vec2 z, float t) \r\n{\r\n\tfloat M = 0.0;\r\n\tfloat o, ot2, ot=ot2=1000.0;\r\n\tfloat K = floor(loops/4.0)+floor(5.0 * zoom);\r\n\tfor (int i=0; i<11; i++) {\r\n\t\tz = abs(z) / clamp(dot(z, z), 0.1, 0.5) - t;\r\n\t\tfloat l = length(z);\r\n\t\to = min(max(abs(min(z.x, z.y)), -l + 0.25), abs(l - 0.25));\r\n\t\tot = min(ot, o);\r\n\t\tot2 = min(l * 0.1, ot2);\r\n\t\tM = max(M, float(i) * (1.0 - abs(sign(ot - o))));\r\n\t\tif (K <= 0.0) break;\r\n\t\tK -= 1.0;\r\n\t}\r\n\tM += 1.0;\r\n\tfloat w = (intensity * zoom) * M;\r\n\tfloat circ = pow(max(0.0, w - ot2) / w, 6.0);\r\n\tS += max(pow(max(0.0, w - ot) / w, 0.25), circ);\r\n\tvec3 col = normalize(0.1 + vec4(0.45, 0.75, M * 0.1, 1.0).rgb);\r\n\tcolor += col * (0.4 + mod(M / 9.0 - t * pulse + ot2 * 2.0, 1.0));\r\n\tcolor += vec3(1.0, 0.7, 0.3) * circ * (10.0 - M) * 3.0;\r\n}\r\n\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tfloat R = 0.0;\r\n\tfloat N = (TIME/4+syn_Time/20) * 0.01 * rate;\r\n\tfloat T = 2.0 * rate;\r\n\tif (N > 6.0 * rate) { \r\n\t\tR += 1.0;\r\n\t\tN -= (R * 8.0 * rate);\r\n\t}\r\n\tif (N < 4.0 * rate) T += N;\r\n\telse  T = 8.0 * rate - N;\r\n\tfloat Z = (1.05-zoom);\r\n\tvec2 pos = _xy.xy / RENDERSIZE.xy - 0.5;\r\n\tpos.x *= RENDERSIZE.x/RENDERSIZE.y;\r\n\tvec2 uv = pos + center;\r\n\tfloat sph = length(uv)*(0.1*(syn_BassHits+1.)); \r\n\tsph = sqrt(1.0 - sph * sph) * 2.0 ;\r\n\tfloat a = T * PI;\r\n\tfloat b = a + T;\r\n\tfloat c = cos(a) + sin(b);\r\n\tuv *= mat2(cos(b), sin(b), -sin(b), cos(b));\r\n\tuv *= mat2(cos(a),-sin(a), sin(a),cos(a));\r\n\tuv -= vec2(sin(c), cos(c)) / PI;\r\n\tuv *= Z;\r\n\tfloat PIx = 0.5 / RENDERSIZE.x * Z / sph;\r\n\tfloat dof = (zoom * focus) + (T * 0.25);\r\n\tfloat L = floor(loops);\r\n\tfor (int aa=0; aa<24; aa++) {\r\n\t\tvec2 aauv = floor(vec2(float(aa) / 6.0, mod(float(aa), 6.0)));\r\n\t\tformula(uv + aauv * PIx * dof, T);\r\n\t\tif (L <= 0.0) break;\r\n\t\tL -= 1.0;\r\n\t}\r\n\tS /= floor(loops); \r\n\tcolor /= floor(loops);\r\n\tvec3 colo = mix(vec3(0.15), color, S) * (1.0 - length(pos)+clamp(syn_HighHits,.1,.15));\t\r\n\tcolo *=vec3(1.2, 1.1, 1.0);\r\n\tout_FragColor = sqrt(max(vec4(colo, 1.0), 0.0) -0.2);\r\n\r\nreturn out_FragColor; \r\n } \r\n\r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"KaliCircuitsExplorer","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Offset_X","MAX":20,"MIN":-20,"NAME":"Offset_X","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"Speed","MAX":5,"MIN":0,"NAME":"Speed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"typical","MAX":5,"MIN":0,"NAME":"typical","TYPE":"slider","UI_GROUP":"group2"}],"CREDIT":"converted by Imimot. Original: https://www.shadertoy.com/view/4dfSDj","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\linescape.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Linescape","IMAGES":null,"IMAGE_PATH":"linescape.synScene\\linescape.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Offset_X\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : -20,\n\t\t\t\"NAME\" : \"Offset_X\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Speed\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"Speed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"typical\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"typical\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"group2\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"converted by Imimot. Original: https://www.shadertoy.com/view/4dfSDj\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"linescape.png\",\n\t\"TITLE\" : \"Linescape\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"/////////////////////////////////////////////////////////////////////////////\r\n// XBE\r\n// Retro style terrain rendering\r\n//\r\n\r\n// Noise from IQ\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\tconst float K1 = 0.366025404;\r\n\tconst float K2 = 0.211324865;\r\n\t\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n\tvec2 a = p - i + (i.x+i.y)*K2;\r\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\r\n\tvec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\t\r\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\t\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\t\r\n\treturn dot( n, vec3(70.0) );\r\n}\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat fbm4( in vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n\r\nfloat fbm6( in vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p ); p = m*p*2.04;\r\n    f += 0.031250*noise( p ); p = m*p*2.01;\r\n    f += 0.015625*noise( p );\r\n    return f;\r\n}\r\n\r\nmat4 CreatePerspectiveMatrix(in float fov, in float aspect, in float near, in float far)\r\n{\r\n    mat4 m = mat4(0.0);\r\n    float angle = (fov / 180.0) * PI;\r\n    float f = 1. / tan( angle * 0.5 );\r\n    m[0][0] = f / aspect;\r\n    m[1][1] = f;\r\n    m[2][2] = (far + near) / (near - far);\r\n    m[2][3] = -1.;\r\n    m[3][2] = (2. * far*near) / (near - far);\r\n    return m;\r\n}\r\n\r\nmat4 CamControl( vec3 eye, float pitch)\r\n{\r\n    float cosPitch = cos(pitch);\r\n    float sinPitch = sin(pitch);\r\n    vec3 xaxis = vec3( 1, 0, 0. );\r\n    vec3 yaxis = vec3( 0., cosPitch, sinPitch );\r\n    vec3 zaxis = vec3( 0., -sinPitch, cosPitch );\r\n    // Create a 4x4 view matrix from the right, up, forward and eye position vectors\r\n    mat4 viewMatrix = mat4(\r\n        vec4(       xaxis.x,            yaxis.x,            zaxis.x,      0 ),\r\n        vec4(       xaxis.y,            yaxis.y,            zaxis.y,      0 ),\r\n        vec4(       xaxis.z,            yaxis.z,            zaxis.z,      0 ),\r\n        vec4( -dot( xaxis, eye ), -dot( yaxis, eye ), -dot( zaxis, eye ), 1 )\r\n    );\r\n    return viewMatrix;\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tvec2 uv = _xy.xy/RENDERSIZE.xy;\r\n    vec2 p = 2.*uv-1.;\r\n\tp.x *= RENDERSIZE.x/RENDERSIZE.y;\r\n\t\t \r\n\tvec3 eye = vec3(0.+Offset_X, 0.25+0.25*cos(0.5*TIME)*1.0, 0.);\r\n    mat4 projmat = CreatePerspectiveMatrix(50., RENDERSIZE.x/RENDERSIZE.y, 0.1, 10.0);\r\n    mat4 viewmat = CamControl(eye, -5.*PI/180.);\r\n    mat4 vpmat = viewmat*projmat;\r\n    \r\n\tvec3 col = vec3(0.);\r\n\tvec3 acc = vec3(0.);\r\n\tfloat d;\r\n\t\r\n    vec4 pos = vec4(0.);\r\n\tfloat lh = -RENDERSIZE.y;\r\n\tfloat off = 0.03*(syn_BassTime + TIME)*Speed;\r\n\tfloat h = 0.;\r\n\tfloat z = 0.1;\r\n\tfloat zi = 0.05;\r\n\tfor (int i=0; i<20; ++i)\r\n\t{\r\n        pos = vec4(p.x, 0.5*fbm4(0.5*vec2(eye.x+p.x, z+off)), eye.z+z+0., 1.);\r\n        h = (vpmat*pos).y - p.y;\r\n\t\tif (h>lh)\r\n\t\t{\r\n\t\t\td = abs(h);\r\n\t\t\tcol = vec3( d<0.005?smoothstep(1.,0.,d*192.):0. );\r\n\t\t\tcol *= exp(-0.1*float(i));\r\n            acc += col;\r\n\t\t\tlh = h;\r\n\t\t}\r\n\t\tz += zi;\r\n\t}\r\n\tcol = sqrt(clamp(acc, 0., 1.));\r\n\tout_FragColor = vec4(col,1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Linescape","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Make the sauce twitch rhythmically","MAX":1,"MIN":0,"NAME":"synced_twitcher","TYPE":"toggle","UI_GROUP":"time"},{"DEFAULT":0,"DESCRIPTION":"Hue rotate the main color palette","MAX":1,"MIN":0,"NAME":"hue_adjust","TYPE":"slider","UI_GROUP":"coloration"},{"DEFAULT":0,"DESCRIPTION":"Monochrome flash on beat","MAX":1,"MIN":0,"NAME":"mode_2","TYPE":"toggle","UI_GROUP":"coloration"},{"DEFAULT":0,"DESCRIPTION":"Degenerate the sauce into pixel garbage","MAX":1,"MIN":0,"NAME":"pixel_garbage","PARAMS":0.400000005960464,"TYPE":"toggle smooth","UI_GROUP":"coloration"},{"DEFAULT":1,"DESCRIPTION":"Amount of feedback the sauce has","MAX":2,"MIN":0.00999999977648258,"NAME":"feedback_amt","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":1,"DESCRIPTION":"Number of iterations of the sauce","MAX":1,"MIN":0.00499999988824129,"NAME":"iterations","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":0.5,"DESCRIPTION":"How big or small is the sauce","MAX":1,"MIN":0,"NAME":"scale","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"feedback"},{"DEFAULT":0.5,"DESCRIPTION":"Thickness of the lines that feed the sauce","MAX":1,"MIN":0,"NAME":"feed_thickness","PARAMS":0.800000011920929,"TYPE":"slider smooth","UI_GROUP":"feedback"},{"DEFAULT":1,"DESCRIPTION":"Add the media to the feedback","MAX":1,"MIN":0,"NAME":"media_feeder","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Mask the feedback with the media","MAX":1,"MIN":0,"NAME":"media_mask","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Change feedback based on brightness of media","MAX":1,"MIN":0,"NAME":"media_refract","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Add the media colors into the sauce","MAX":1,"MIN":0,"NAME":"media_color","TYPE":"slider","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Subtract the media from the sauce","MAX":2,"MIN":0,"NAME":"media_subtract","TYPE":"slider","UI_GROUP":"media"}],"CREDIT":"Keijiro Takahashi x Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\lost_in_the_sauce.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Lost in the Sauce","IMAGES":null,"IMAGE_PATH":"lost_in_the_sauce.synScene\\lost_in_the_sauce.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Make the sauce twitch rhythmically\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"synced_twitcher\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"time\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Hue rotate the main color palette\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"hue_adjust\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"coloration\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Monochrome flash on beat\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"mode_2\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"coloration\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Degenerate the sauce into pixel garbage\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pixel_garbage\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"coloration\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Amount of feedback the sauce has\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.01,\n         \"NAME\" : \"feedback_amt\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"feedback\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Number of iterations of the sauce\",\n         \"MAX\" : 1,\n         \"MIN\" : 0.005,\n         \"NAME\" : \"iterations\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"feedback\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"How big or small is the sauce\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"scale\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"feedback\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Thickness of the lines that feed the sauce\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"feed_thickness\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.8,\n         \"UI_GROUP\" : \"feedback\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Add the media to the feedback\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_feeder\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Mask the feedback with the media\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_mask\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Change feedback based on brightness of media\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_refract\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Add the media colors into the sauce\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_color\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Subtract the media from the sauce\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_subtract\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"media\"\n      }\n   ],\n   \"PASSES\":[{\"TARGET\":\"feedback\", \"TYPE\":\"float\", \"WIDTH\":2176, \"HEIGHT\":1224}, {\"TARGET\":\"finalPass\", \"TYPE\":\"float\"}],\n   \"CREDIT\" : \"Keijiro Takahashi x Meebs\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"lost_in_the_sauce.png\",\n   \"TITLE\" : \"Lost in the Sauce\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1224,"TARGET":"feedback","WIDTH":2176},{"FLOAT":true,"HEIGHT":0,"TARGET":"finalPass","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"mat2 rotate(float x)\n{\n    vec2 sc = vec2(sin(x), cos(x));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nvec3 hue2rgb(float h)\n{\n    h = fract(h) * 6 - 2;\n    vec3 c = vec3(abs(h - 1) - 1, 2 - abs(h), 2 - abs(h - 2));\n    return clamp(c, vec3(0), vec3(1));\n}\n\nvec3 fade(vec3 x) { return x * x * x * (x * (x * 6 - 15) + 10); }\n\nvec3 phash(vec3 p)\n{\n    p = fract(mat3(1.2989833, 7.8233198, 2.3562332,\n                   6.7598192, 3.4857334, 8.2837193,\n                   2.9175399, 2.9884245, 5.4987265) * p);\n    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;\n    return normalize(fract(p) * 2 - 1);\n}\n\nfloat cnoise(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    ip += fp*pixel_garbage*pixel_garbage*0.00001;\n    float d000 = dot(phash(ip), fp);\n    float d001 = dot(phash(ip + vec3(0, 0, 1)), fp - vec3(0, 0, 1));\n    float d010 = dot(phash(ip + vec3(0, 1, 0)), fp - vec3(0, 1, 0));\n    float d011 = dot(phash(ip + vec3(0, 1, 1)), fp - vec3(0, 1, 1));\n    float d100 = dot(phash(ip + vec3(1, 0, 0)), fp - vec3(1, 0, 0));\n    float d101 = dot(phash(ip + vec3(1, 0, 1)), fp - vec3(1, 0, 1));\n    float d110 = dot(phash(ip + vec3(1, 1, 0)), fp - vec3(1, 1, 0));\n    float d111 = dot(phash(ip + vec3(1, 1, 1)), fp - vec3(1, 1, 1));\n    fp = fade(fp);\n    // fp = mix(fp, step(fp, vec3(_uv.x+_uv.y+length(_uvc)))*2.0, pixelate);\n    return mix(mix(mix(d000, d001, fp.z), mix(d010, d011, fp.z), fp.y),\n               mix(mix(d100, d101, fp.z), mix(d110, d111, fp.z), fp.y), fp.x);\n}\n\nvec3 magma_quintic( float x )\n{\n\tx = clamp( x, 0.0, 1.0);\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( -0.023226960, +1.087154378, -0.109964741, +6.333665763 ) ) + dot( x2.xy, vec2( -11.640596589, +5.337625354 ) ),\n\t\tdot( x1.xyzw, vec4( +0.010680993, +0.176613780, +1.638227448, -6.743522237 ) ) + dot( x2.xy, vec2( +11.426396979, -5.523236379 ) ),\n\t\tdot( x1.xyzw, vec4( -0.008260782, +2.244286052, +3.005587601, -24.279769818 ) ) + dot( x2.xy, vec2( +32.484310068, -12.688259703 ) ) );\n}\n\nvec3 plasma_quintic( float x )\n{\n\tx = clamp( x, 0.0, 1.0);\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),\n\t\tdot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),\n\t\tdot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );\n}\n\nvec3 samplef(vec2 tc)\n{\n  if (mod(tc.x, 2.0) > 1.0){\n    tc.x = 1.0-tc.x;\n  }\n  if (mod(tc.y, 2.0) > 1.0){\n    tc.y = 1.0-tc.y;\n  }\n    return pow(texture(syn_UserImage, tc).xyz, vec3(2.2, 2.2, 2.2));\n}\n\nvec3 blur(vec2 tc, float offs)\n{\n    vec2 imgScale = textureSize(syn_UserImage, 0);\n    vec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / imgScale.x;\n    vec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / imgScale.y;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    color += samplef(tc + vec2(xoffs.x, yoffs.x)) * 0.00366;\n    color += samplef(tc + vec2(xoffs.y, yoffs.x)) * 0.01465;\n    color += samplef(tc + vec2(    0.0, yoffs.x)) * 0.02564;\n    color += samplef(tc + vec2(xoffs.z, yoffs.x)) * 0.01465;\n    color += samplef(tc + vec2(xoffs.w, yoffs.x)) * 0.00366;\n    \n    color += samplef(tc + vec2(xoffs.x, yoffs.y)) * 0.01465;\n    color += samplef(tc + vec2(xoffs.y, yoffs.y)) * 0.05861;\n    color += samplef(tc + vec2(    0.0, yoffs.y)) * 0.09524;\n    color += samplef(tc + vec2(xoffs.z, yoffs.y)) * 0.05861;\n    color += samplef(tc + vec2(xoffs.w, yoffs.y)) * 0.01465;\n    \n    color += samplef(tc + vec2(xoffs.x, 0.0)) * 0.02564;\n    color += samplef(tc + vec2(xoffs.y, 0.0)) * 0.09524;\n    color += samplef(tc + vec2(    0.0, 0.0)) * 0.15018;\n    color += samplef(tc + vec2(xoffs.z, 0.0)) * 0.09524;\n    color += samplef(tc + vec2(xoffs.w, 0.0)) * 0.02564;\n    \n    color += samplef(tc + vec2(xoffs.x, yoffs.z)) * 0.01465;\n    color += samplef(tc + vec2(xoffs.y, yoffs.z)) * 0.05861;\n    color += samplef(tc + vec2(    0.0, yoffs.z)) * 0.09524;\n    color += samplef(tc + vec2(xoffs.z, yoffs.z)) * 0.05861;\n    color += samplef(tc + vec2(xoffs.w, yoffs.z)) * 0.01465;\n    \n    color += samplef(tc + vec2(xoffs.x, yoffs.w)) * 0.00366;\n    color += samplef(tc + vec2(xoffs.y, yoffs.w)) * 0.01465;\n    color += samplef(tc + vec2(    0.0, yoffs.w)) * 0.02564;\n    color += samplef(tc + vec2(xoffs.z, yoffs.w)) * 0.01465;\n    color += samplef(tc + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n    return color;\n}\n\nvec3 glow()\n{\n    vec2 tc = _correctImageCoords(textureSize(syn_UserImage, 0));\n    tc = _invertYAxisVideo(tc);\n\n    vec3 color = blur(tc, 2.0);\n    color += blur(tc, 3.0);\n    color += blur(tc, 5.0);\n    color += blur(tc, 7.0);\n    color /= 4.0;\n    \n    color += samplef(tc);\n    return color;\n}\n\nfloat _lum(vec3 colIn){\n  return dot(colIn, vec3(1.0))/3.0;\n}\n\nfloat _sqPulseFuzz(float variable, float center, float width, float fuzz){\n  return (smoothstep(center-width-fuzz, center-width, variable)-(smoothstep(center+width, center+width+fuzz, variable)));\n}\n//+PASSINDEX*0.001*mix(0.3588, 2.4224, feed_amt)\nvec4 renderMain(void)\n{\n\tif (PASSINDEX == 0){\n    \tvec2 uv = gl_FragCoord.xy / RENDERSIZE;\n        vec3 imgCol = vec3(0.0);\n        float lum = 0.0;\n        if (syn_MediaType > 0.5){\n            imgCol = _loadUserImage().rgb;\n            lum = _lum(imgCol);\n        }\n\n        // side lines\n        float dx = cnoise(vec3(uv.y*2+syn_CurvedTime*1.0+TIME*0.05))*0.1;\n        float dy = cnoise(vec3(uv.x*2+syn_CurvedTime*1.0+TIME*0.05))*0.1;\n        float fade = 0.05;\n        float thickness = mix(0.905, 0.7, feed_thickness);\n\n        float cVal = smoothstep(thickness, thickness+fade, abs(_uvc.x - dx));\n        vec3 lineCol = vec3(0.0);\n\n        float cVal2 = _sqPulse(_uv.x, 0.5, 0.01);\n        float pulser = fract(syn_OnBeat)+step(0.9,syn_BassLevel)+1.0;\n        vec3 lineCol2 = vec3(pulser)*cVal2*10.0;\n\n        if (mode_2>0.5){\n            cVal = cVal2;\n            lineCol = lineCol2;\n            lineCol = mix(lineCol, lineCol+lum*lum*pulser, media_color);\n\n            // lineCol = magma_quintic(cVal)*cVal;\n        } else {\n            if ((syn_MediaType > 0.5)&&(media_feeder>0.5)){\n                cVal = pow(lum,2.0)*4.0;\n            }\n            lineCol = pow(magma_quintic(0.45+0.4*sin(_uv.x*PI+_uv.y*PI+TIME*0.1)), vec3(2.0))*1.5;\n            lineCol = mix(lineCol*cVal, imgCol*imgCol*0.25, media_color);\n            lineCol = clamp(lineCol, 0, 1)*(1.0+syn_OnBeat);\n            lineCol = _rgb2hsv(lineCol);\n            lineCol.r += hue_adjust;\n            lineCol = _hsv2rgb(lineCol);\n        }\n\n\n        // displacement\n        vec2 d = vec2(cnoise(vec3(0.13 - _uvc * 6 * scale, + syn_BassTime*0.15)),\n                      cnoise(vec3(3.17 + _uvc * 6 * scale, - syn_BassTime*0.15)))*0.25;\n\n        float rotVar = uv.y*6;\n        if (syn_MediaType > 0.5){\n            d *= mix(1.0, lum*lum*2.0, media_refract);\n    \t\t// rotVar *= (1.0+lum*media_refract);\n        }\n        d = rotate(mix(TIME, syn_BPMTwitcher, synced_twitcher) + rotVar) * d;\n        \n        // feedback\n        d.x *= RENDERSIZE.x / RENDERSIZE.y;\n        vec3 fb = texture(finalPass, uv + d*feedback_amt).rgb;\n\n        if (mode_2 > 0.5){\n            vec3 hueCol = vec3(0.9, 0.95, 1.0);\n            hueCol = _rgb2hsv(hueCol);\n            hueCol.r += hue_adjust;\n            hueCol = _hsv2rgb(hueCol);\n            fb *= hueCol;\n            // fb += fb*vec3(0.0,0.0,1.0);\n            // fb *= 0.9;\n        }\n\n        // coloring\n        // vec3 amp = mix(plasma_quintic(0.5+0.5*sin(TIME)), vec3(1.0), 0.9) * 1.05;\n        vec3 col = vec3(lineCol + fb*0.9*sqrt(iterations));\n        return vec4(col, lum);\n    } else if (PASSINDEX == 1){\n    \treturn texture(feedback, _uv);\n    } else if (PASSINDEX == 2){\n        float cVal2 = _sqPulseFuzz(_uv.x, 0.5, 0.01, 0.000275);\n        vec3 lineCol2 = vec3(fract(syn_OnBeat)+step(0.9,syn_BassLevel)+1.0)*cVal2*10.0;\n\n        // return texture(finalPass, _uv);\n        float zoomfactor = 0.05+feed_thickness*0.25;\n        float lum = texture(feedback, _uv*(1.0-zoomfactor)+zoomfactor*0.5).a;\n        vec2 lookupCoords = _uv*(1.0-zoomfactor)+zoomfactor*0.5;\n        if (mode_2 > 0.5){\n            lookupCoords = _uv;\n        }\n\n        vec4 finalCol = texture(finalPass, lookupCoords)*mix(1.0, clamp(pow(lum, 1.5)*1.2,0.0,1.0), media_mask)-lum*media_subtract;\n        finalCol -= vec4(lineCol2, 0.0)*mode_2;\n        return finalCol;\n    }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Lost in the Sauce","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_0","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":1,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_1","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":0,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_2","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":1,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_3","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":0,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_4","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":1,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_5","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":0,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_6","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":1,"DESCRIPTION":"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.","MAX":0.899999976158142,"MIN":0.0500000007450581,"NAME":"TOGGLE_7","PARAMS":0.150000005960464,"TYPE":"toggle smooth","UI_GROUP":"toggle"},{"DEFAULT":0.125,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_0","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0.25,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_1","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0.375,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_2","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0.5,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_3","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0.625,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_4","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0.75,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_5","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0.875,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_6","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":1,"DESCRIPTION":"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.","MAX":0.949999988079071,"MIN":0.0500000007450581,"NAME":"SLIDER_7","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"slider"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_0","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_1","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_2","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_3","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_4","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_5","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_6","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0,"DESCRIPTION":"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.","MAX":1,"MIN":0,"NAME":"BANG_7","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"bang"},{"DEFAULT":0.125,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_0","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":0.25,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_1","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":0.375,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_2","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":0.5,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_3","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":0.625,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_4","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":0.75,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_5","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":0.875,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_6","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":1,"DESCRIPTION":"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.","MAX":1,"MIN":0,"NAME":"KNOB_7","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"knob"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.","MAX":[1,1],"MIN":[0,0],"NAME":"XY_0","PARAMS":0.300000011920929,"TYPE":"xy smooth","UI_GROUP":"xy"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.","MAX":[1,1],"MIN":[0,0],"NAME":"XY_1","PARAMS":0.300000011920929,"TYPE":"xy smooth","UI_GROUP":"xy"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.","MAX":[1,1],"MIN":[0,0],"NAME":"XY_2","PARAMS":0.300000011920929,"TYPE":"xy smooth","UI_GROUP":"xy"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.","MAX":[1,1],"MIN":[0,0],"NAME":"XY_3","PARAMS":0.300000011920929,"TYPE":"xy smooth","UI_GROUP":"xy"},{"DEFAULT":0,"DESCRIPTION":"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.","MAX":5,"MIN":0,"NAME":"DROPDOWN_0","TYPE":"dropdown","UI_GROUP":"dropdown","VALUES":[0,1,2,3,4,5]},{"DEFAULT":1,"DESCRIPTION":"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.","MAX":5,"MIN":0,"NAME":"DROPDOWN_1","TYPE":"dropdown","UI_GROUP":"dropdown","VALUES":[0,1,2,3,4,5]},{"DEFAULT":4,"DESCRIPTION":"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.","MAX":5,"MIN":0,"NAME":"DROPDOWN_2","TYPE":"dropdown","UI_GROUP":"dropdown","VALUES":[0,1,2,3,4,5]},{"DEFAULT":5,"DESCRIPTION":"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.","MAX":5,"MIN":0,"NAME":"DROPDOWN_3","TYPE":"dropdown","UI_GROUP":"dropdown","VALUES":[0,1,2,3,4,5]}],"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\midi_mapping.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"MIDI_MAPPING","IMAGES":null,"IMAGE_PATH":"midi_mapping.synScene\\midi_mapping.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_0\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_1\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_2\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_3\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_4\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_5\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_6\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Toggles respond well to NOTE ON/OFF messages, but can also take CC messages, and will go OFF below 64, or ON above it.\",\n         \"MAX\" : 0.9,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"TOGGLE_7\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.15,\n         \"UI_GROUP\" : \"toggle\"\n      },{\n         \"DEFAULT\" : 0.125,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_0\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_1\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0.375,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_2\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_3\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0.625,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_4\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0.75,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_5\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0.875,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_6\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Sliders respond best to CC messages. 0 will be 0% on the slider, 127 will be 100%. NOTE ON will be treated as 100%, NOTE OFF will be 0%.\",\n         \"MAX\" : 0.95,\n         \"MIN\" : 0.05,\n         \"NAME\" : \"SLIDER_7\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"slider\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_0\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_1\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_2\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_3\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_4\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_5\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_6\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bangs respond best to NOTE ON/OFF messages. A NOTE ON will trigger the bang, while a NOTE OFF will do nothing. Any new CC value over 64 will trigger the bang, so knobs and faders are not ideal.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"BANG_7\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"bang\"\n      },{\n         \"DEFAULT\" : 0.125,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_0\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_1\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.375,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_2\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_3\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.625,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_4\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.75,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_5\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.875,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_6\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Knobs behave just like sliders, responding best to CC messages, but they do not share mappings with sliders. They must be independently mapped.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"KNOB_7\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"knob\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"XY_0\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.3,\n         \"UI_GROUP\" : \"xy\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"XY_1\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.3,\n         \"UI_GROUP\" : \"xy\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"XY_2\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.3,\n         \"UI_GROUP\" : \"xy\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"XY pads can be thought of as two independent sliders in one control. If you have an XY pad on your MIDI controller, map that! Otherwise, you can just map two adjacent knobs or faders, one for each axis.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"XY_3\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.3,\n         \"UI_GROUP\" : \"xy\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.\",\n         \"NAME\" : \"DROPDOWN_0\",\n         \"VALUES\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n         \"TYPE\" : \"dropdown\",\n         \"UI_GROUP\" : \"dropdown\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.\",\n         \"NAME\" : \"DROPDOWN_1\",\n         \"VALUES\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n         \"TYPE\" : \"dropdown\",\n         \"UI_GROUP\" : \"dropdown\"\n      },{\n         \"DEFAULT\" : 4,\n         \"DESCRIPTION\" : \"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.\",\n         \"NAME\" : \"DROPDOWN_2\",\n         \"VALUES\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n         \"TYPE\" : \"dropdown\",\n         \"UI_GROUP\" : \"dropdown\"\n      },{\n         \"DEFAULT\" : 5,\n         \"DESCRIPTION\" : \"Dropdowns work best with CC messages. The CC value between 0 and 127 will be interpolated as an index to select one of the dropdown options.\",\n         \"NAME\" : \"DROPDOWN_3\",\n         \"VALUES\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n         \"TYPE\" : \"dropdown\",\n         \"UI_GROUP\" : \"dropdown\"\n      }\n   ],\n   \"CREDIT\" : \"Synesthesia\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"midi_mapping.png\",\n   \"TITLE\" : \"MIDI_MAPPING\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec4 midiBlue = vec4(0.2,0.2,0.2,1.0);\n\nvec4 renderMain(void)\n{\n\tif (_uv.y > 0.8){\n\t\tvec4 colOut = vec4(0.0);\n\t\tvec2 pos = _uv;\n\t\tpos.x = fract(_uv.x*16.0);\n\t\tpos.y = (_uv.y-0.8)*1/0.2;\n\t\tint ind = int(_uv.x*16.0);\n\t\tvec4 toggleCol = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pos.y);\n\n\t\tif (ind == 0) colOut = toggleCol*smoothstep(TOGGLE_0+0.05, TOGGLE_0, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_0, 0.025);\n\t\tif (ind == 1) colOut = toggleCol*smoothstep(TOGGLE_1+0.05, TOGGLE_1, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_1, 0.025);\n\t\tif (ind == 2) colOut = toggleCol*smoothstep(TOGGLE_2+0.05, TOGGLE_2, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_2, 0.025);\n\t\tif (ind == 3) colOut = toggleCol*smoothstep(TOGGLE_3+0.05, TOGGLE_3, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_3, 0.025);\n\t\tif (ind == 4) colOut = toggleCol*smoothstep(TOGGLE_4+0.05, TOGGLE_4, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_4, 0.025);\n\t\tif (ind == 5) colOut = toggleCol*smoothstep(TOGGLE_5+0.05, TOGGLE_5, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_5, 0.025);\n\t\tif (ind == 6) colOut = toggleCol*smoothstep(TOGGLE_6+0.05, TOGGLE_6, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_6, 0.025);\n\t\tif (ind == 7) colOut = toggleCol*smoothstep(TOGGLE_7+0.05, TOGGLE_7, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, TOGGLE_7, 0.025);\n\n\t\tif (abs(pos.y-0.5)>0.45){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\t\tif (fract(pos.x)>0.95||fract(pos.x)<0.05){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\n\t\tif (_uv.x>0.5){\n\t\t\tvec4 colOut = vec4(0.0);\n\t\t\tvec2 pos = _uv;\n\t\t\tpos.x = fract(_uv.x/0.25);\n\t\t\tpos.y = (_uv.y)*1/0.5;\n\t\n\t\t\tvec2 gridPos = pos;\n\n\t\t\tvec2 polar = _toPolarTrue(pos-0.5);\n\t\t\t// int indX = int((_uv.x/0.25)*2.0);\n\t\t\t// int indY = int(_uv.y,2.0);\n\n\t\t\tvec2 xyPos = fract(gridPos*2.0);\n\t\t\txyPos += vec2(-0.05,-0.1)*2.0;\n\t\t\txyPos *= vec2(1.1,1.2);\n\t\t\tvec2 xyGrid = vec2((_uv.x-0.5)*2.0*4.0, fract(_uv.y*5.0));\n\n\t\t\tif ((xyGrid.x > 0.00)&&(xyGrid.x < 1.00)) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0),dot(xyPos, vec2(1.0))/3.0)+vec4(0.0,1.0,1.0,1.0)*_pulse(distance(XY_0, xyPos), 0.07, 0.02)+vec4(1.0,1.0,1.0,1.0)*(1.0-smoothstep(distance(XY_0, xyPos), 0.02, 0.05));\n\t\t\tif ((xyGrid.x > 1.00)&&(xyGrid.x < 2.00)) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0),dot(xyPos, vec2(1.0))/3.0)+vec4(0.0,1.0,1.0,1.0)*_pulse(distance(XY_1, xyPos), 0.07, 0.02)+vec4(1.0,1.0,1.0,1.0)*(1.0-smoothstep(distance(XY_1, xyPos), 0.02, 0.05));\n\t\t\tif ((xyGrid.x > 2.00)&&(xyGrid.x < 3.00)) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0),dot(xyPos, vec2(1.0))/3.0)+vec4(0.0,1.0,1.0,1.0)*_pulse(distance(XY_2, xyPos), 0.07, 0.02)+vec4(1.0,1.0,1.0,1.0)*(1.0-smoothstep(distance(XY_2, xyPos), 0.02, 0.05));\n\t\t\tif ((xyGrid.x > 3.00)&&(xyGrid.x < 4.00)) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0),dot(xyPos, vec2(1.0))/3.0)+vec4(0.0,1.0,1.0,1.0)*_pulse(distance(XY_3, xyPos), 0.07, 0.02)+vec4(1.0,1.0,1.0,1.0)*(1.0-smoothstep(distance(XY_3, xyPos), 0.02, 0.05));\n\n\t\t\tfloat onGrid = _sqPulse(fract(xyGrid.x), 0.0, 0.1);\n\t\t\tonGrid += _sqPulse(fract(xyGrid.y), 0.0, 0.05);\n\t\t\tif (onGrid > 0.5){\n\t\t\t\tcolOut = midiBlue;\n\t\t\t}\n\n\t\t\treturn colOut;\n\t\t}\n\n\t\treturn colOut;\n\t}\t\n\n\telse if (_uv.y > 0.6){\n\t\tvec4 colOut = vec4(0.0);\n\t\tvec2 pos = _uv;\n\t\tpos.x = fract(_uv.x*8.0);\n\t\tpos.y = (_uv.y-0.6)*1/0.2;\n\t\tint ind = int(_uv.x*8.0);\n\t\tvec2 gridPos = pos;\n\t\tpos*=vec2(1.1,1.0);\n\t\tpos.x-=0.05;\n\t\tvec2 polar = _toPolarTrue(pos-0.5);\n\t\tvec4 bangCol = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(BANG_0,0.2));\n\t\tif (ind == 0) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_0,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_0, polar.x))+_pulse(polar.x, 0.3+BANG_0, 0.02);\n\t\tif (ind == 1) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_1,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_1, polar.x))+_pulse(polar.x, 0.3+BANG_1, 0.02);\n\t\tif (ind == 2) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_2,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_2, polar.x))+_pulse(polar.x, 0.3+BANG_2, 0.02);\n\t\tif (ind == 3) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_3,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_3, polar.x))+_pulse(polar.x, 0.3+BANG_3, 0.02);\n\t\tif (ind == 4) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_4,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_4, polar.x))+_pulse(polar.x, 0.3+BANG_4, 0.02);\n\t\tif (ind == 5) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_5,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_5, polar.x))+_pulse(polar.x, 0.3+BANG_5, 0.02);\n\t\tif (ind == 6) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_6,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_6, polar.x))+_pulse(polar.x, 0.3+BANG_6, 0.02);\n\t\tif (ind == 7) colOut = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pow(polar.x,2.0)*2.0+pow(BANG_7,0.2))*(1.0-smoothstep(0.25, 0.4+BANG_7, polar.x))+_pulse(polar.x, 0.3+BANG_7, 0.02);\n\n\t\tif (abs(gridPos.y-0.5)>0.45){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\t\tif (fract(gridPos.x)>0.95||fract(gridPos.x)<0.05){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\n\t\treturn colOut;\n\t}\t\n\n\telse if (_uv.y > 0.4){\n\t\tvec4 colOut = vec4(0.0);\n\t\tvec2 pos = _uv;\n\t\tpos.x = fract(_uv.x*8.0);\n\t\tpos.y = (_uv.y-0.4)*1/0.2;\n\t\tint ind = int(_uv.x*8.0);\n\t\t\t\tvec2 gridPos = pos;\n\t\tpos*=vec2(1.1,1.0);\n\t\tpos.x-=0.05;\n\t\tvec2 polar = _toPolarTrue(_rotate(pos-0.5, PI*3/2));\n\t\tpolar.y = 1.0-polar.y;\n\t\tvec4 toggleCol = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), polar.y);\n\n\t\tif ((KNOB_0 > polar.y)&&(ind == 0)) colOut = toggleCol+_pulse(polar.y, KNOB_0, 0.03);\n\t\tif ((KNOB_1 > polar.y)&&(ind == 1)) colOut = toggleCol+_pulse(polar.y, KNOB_1, 0.03);\n\t\tif ((KNOB_2 > polar.y)&&(ind == 2)) colOut = toggleCol+_pulse(polar.y, KNOB_2, 0.03);\n\t\tif ((KNOB_3 > polar.y)&&(ind == 3)) colOut = toggleCol+_pulse(polar.y, KNOB_3, 0.03);\n\t\tif ((KNOB_4 > polar.y)&&(ind == 4)) colOut = toggleCol+_pulse(polar.y, KNOB_4, 0.03);\n\t\tif ((KNOB_5 > polar.y)&&(ind == 5)) colOut = toggleCol+_pulse(polar.y, KNOB_5, 0.03);\n\t\tif ((KNOB_6 > polar.y)&&(ind == 6)) colOut = toggleCol+_pulse(polar.y, KNOB_6, 0.03);\n\t\tif ((KNOB_7 > polar.y)&&(ind == 7)) colOut = toggleCol+_pulse(polar.y, KNOB_7, 0.03);\n\n\t\tcolOut *= step(polar.x, 0.4);\n\n\t\tif (abs(gridPos.y-0.5)>0.45){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\t\tif (fract(gridPos.x)>0.95||fract(gridPos.x)<0.05){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\n\t\treturn colOut;\n\t}\t\n\n\telse if ((_uv.y > 0.0)&&(_uv.x<0.75)){\n\t\tvec4 colOut = vec4(0.0);\n\t\tvec2 pos = _uv;\n\t\tpos.x = fract((_uv.x/0.75)*8.0);\n\t\tpos.y = (_uv.y)*1/0.4;\n\t\tint ind = int((_uv.x/0.75)*8.0);\n\t\tvec4 sliderCol = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), pos.y);\n\t\tif (ind == 0) colOut = sliderCol*smoothstep(SLIDER_0+0.05, SLIDER_0, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_0, 0.025);\n\t\tif (ind == 1) colOut = sliderCol*smoothstep(SLIDER_1+0.05, SLIDER_1, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_1, 0.025);\n\t\tif (ind == 2) colOut = sliderCol*smoothstep(SLIDER_2+0.05, SLIDER_2, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_2, 0.025);\n\t\tif (ind == 3) colOut = sliderCol*smoothstep(SLIDER_3+0.05, SLIDER_3, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_3, 0.025);\n\t\tif (ind == 4) colOut = sliderCol*smoothstep(SLIDER_4+0.05, SLIDER_4, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_4, 0.025);\n\t\tif (ind == 5) colOut = sliderCol*smoothstep(SLIDER_5+0.05, SLIDER_5, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_5, 0.025);\n\t\tif (ind == 6) colOut = sliderCol*smoothstep(SLIDER_6+0.05, SLIDER_6, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_6, 0.025);\n\t\tif (ind == 7) colOut = sliderCol*smoothstep(SLIDER_7+0.05, SLIDER_7, pos.y)+vec4(1.0,1.0,1.0,1.0)*_pulse(pos.y-0.025, SLIDER_7, 0.025);\n\n\n\t\tif (abs(pos.y-0.5)>0.475){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\t\tif (fract(pos.x)>0.925||fract(pos.x)<0.075){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\n\t\treturn colOut;\n\t}\n\n\telse if ((_uv.y > 0.0)&&(_uv.x>0.75)){\n\t\tvec4 colOut = vec4(0.0);\n\t\tvec2 pos = vec2((_uv.x-0.75)*4.0, _uv.y/(2.0/5.0));\n\t\tvec2 gridPos = pos*vec2(4.0, 1.0);\n\t\tvec2 inGridPos = fract(gridPos);\n\n\t\tvec2 selPos = vec2(inGridPos.x, inGridPos.y*6.0);\n\t\tvec2 indPos = fract(selPos);\n\n\t\tvec2 selArt = abs((indPos-0.5+vec2(0.05,-0.05))*vec2(1.0,1.0));\n\t\tvec4 indicatorCol = mix(vec4(0.2,0.0,0.0,1.0), vec4(1.2,0.6,0.0,1.0), clamp(pow(1.0-max(selArt.x, selArt.y),2.0), 0.0, 1.0));\n\n\t\tfloat sticky0 = floor(DROPDOWN_0);\n\t\tfloat sticky1 = floor(DROPDOWN_1);\n\t\tfloat sticky2 = floor(DROPDOWN_2);\n\t\tfloat sticky3 = floor(DROPDOWN_3);\n\t\tif ((gridPos.x > 0.0)&&(gridPos.x < 1.0)) colOut = indicatorCol*_sqPulse(selPos.y-0.5, sticky0, 0.5);\n\t\tif ((gridPos.x > 1.0)&&(gridPos.x < 2.0)) colOut = indicatorCol*_sqPulse(selPos.y-0.5, sticky1, 0.5);\n\t\tif ((gridPos.x > 2.0)&&(gridPos.x < 3.0)) colOut = indicatorCol*_sqPulse(selPos.y-0.5, sticky2, 0.5);\n\t\tif ((gridPos.x > 3.0)&&(gridPos.x < 4.0)) colOut = indicatorCol*_sqPulse(selPos.y-0.5, sticky3, 0.5);\n\n\t\tfloat whiteDividers = _pulse(fract(indPos.y), 0.0, 0.1);\n\t\tif (whiteDividers > 0.5){\n\t\t\tcolOut = vec4(0.5);\n\t\t}\n\n\n\t\tfloat onGrid = _sqPulse(fract(gridPos.x+0.1), 0.0, 0.1);\n\t\tonGrid += _sqPulse(fract(gridPos.y), 0.0, 0.025);\n\t\tif (onGrid > 0.5){\n\t\t\tcolOut = midiBlue;\n\t\t}\n\n\t\treturn colOut;\n\n\t}\n\n\n\treturn vec4(_uv.x, BANG_0, _uv.y, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"MIDI_MAPPING","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.200000002980232,"DESCRIPTION":"This controls the overall detail in the scene. Works great with the ghostly control.","MAX":1,"MIN":0,"NAME":"intricacy","PARAMS":0.150000005960464,"TYPE":"slider smooth","UI_GROUP":"field"},{"DEFAULT":0,"DESCRIPTION":"Pulses the coordinates of the noise field, causing the whole scene to jump.","MAX":1,"MIN":0,"NAME":"pulse","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"field"},{"DEFAULT":0.5,"DESCRIPTION":"Adjusts the constant speed going forward or backwards for the scene.","MAX":2,"MIN":-2,"NAME":"speed","TYPE":"slider","UI_GROUP":"field"},{"DEFAULT":1,"DESCRIPTION":"Creates a morphing, audio reactive noise field. This toggle makes the scene much more dynamic.","MAX":1,"MIN":0,"NAME":"audio_reactive","TYPE":"toggle","UI_GROUP":"field"},{"DEFAULT":1.5,"DESCRIPTION":"ups the scaling of the fractal noise, creating thicker bands and stronger colors. Use this with the glass marble effect for a morphing sphere.","MAX":4.5,"MIN":1,"NAME":"scale","TYPE":"slider","UI_GROUP":"field"},{"DEFAULT":0,"DESCRIPTION":"Creates a secondary color scheme.","MAX":1,"MIN":0,"NAME":"colMode","TYPE":"toggle","UI_GROUP":"coloring"},{"DEFAULT":0,"DESCRIPTION":"Creates a transparent etheral look that makes the noise feel more minimal.","MAX":1,"MIN":0,"NAME":"ghostly","TYPE":"slider","UI_GROUP":"coloring"},{"DEFAULT":0,"DESCRIPTION":"Turns the scene into 3d voxels.","MAX":1,"MIN":0,"NAME":"pixelate","TYPE":"toggle","UI_GROUP":"fx"},{"DEFAULT":1,"DESCRIPTION":"Creates an irradiated orb at the center of the field that takes on the color of the fractal field","MAX":1,"MIN":0,"NAME":"solar_flare","TYPE":"toggle","UI_GROUP":"fx"},{"DEFAULT":0,"DESCRIPTION":"Contains the field to a sphere, creating a morphing orb effect","MAX":1,"MIN":0,"NAME":"contain_field","TYPE":"toggle","UI_GROUP":"fx"},{"DEFAULT":1,"DESCRIPTION":"Creates pulsing bands of light that flash across the field. Works great with the solar flare effect enabled.","MAX":1,"MIN":0,"NAME":"reactive_lights","TYPE":"toggle","UI_GROUP":"lighting"},{"DEFAULT":1,"DESCRIPTION":"Controls the main lighting of the scene. Turn this down with the reactive lights on to create a more dynamic scene","MAX":1,"MIN":0,"NAME":"main_light","TYPE":"knob","UI_GROUP":"lighting"}],"CREDIT":"Synesthesia","DESCRIPTION":"A swirling sphere of fractal noise. It can sometimes appear like a glass marble or a solar flare. From the Synesthesia archive, original artist is nimitz.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\.marketplace\\magnetismic.synScene","GPU":4,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Magnetismic","IMAGES":[{"NAME":"colornoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"magnetismic.synScene\\magnetismic.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.200000002980232,\n         \"DESCRIPTION\" : \"This controls the overall detail in the scene. Works great with the ghostly control.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"intricacy\",\n         \"PARAMS\" : 0.150000005960464,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"field\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Pulses the coordinates of the noise field, causing the whole scene to jump.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pulse\",\n         \"PARAMS\" : 0.0500000007450581,\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"field\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Adjusts the constant speed going forward or backwards for the scene.\",\n         \"IS_META\" : false,\n         \"MAX\" : 2,\n         \"MIN\" : -2,\n         \"NAME\" : \"speed\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"field\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Creates a morphing, audio reactive noise field. This toggle makes the scene much more dynamic.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"audio_reactive\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"field\"\n      },\n      {\n         \"DEFAULT\" : 1.5,\n         \"DESCRIPTION\" : \"ups the scaling of the fractal noise, creating thicker bands and stronger colors. Use this with the glass marble effect for a morphing sphere.\",\n         \"IS_META\" : false,\n         \"MAX\" : 4.5,\n         \"MIN\" : 1,\n         \"NAME\" : \"scale\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"field\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Creates a secondary color scheme.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"colMode\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"coloring\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Creates a transparent etheral look that makes the noise feel more minimal.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"ghostly\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"coloring\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turns the scene into 3d voxels.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pixelate\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"fx\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Creates an irradiated orb at the center of the field that takes on the color of the fractal field\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"solar_flare\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"fx\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Contains the field to a sphere, creating a morphing orb effect\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"contain_field\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"fx\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Creates pulsing bands of light that flash across the field. Works great with the solar flare effect enabled.\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"reactive_lights\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"lighting\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Controls the main lighting of the scene. Turn this down with the reactive lights on to create a more dynamic scene\",\n         \"IS_META\" : false,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"main_light\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"lighting\"\n      }\n   ],\n   \"CREDIT\" : \"Synesthesia\",\n   \"DESCRIPTION\" : \"A swirling sphere of fractal noise. It can sometimes appear like a glass marble or a solar flare. From the Synesthesia archive, original artist is nimitz.\",\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"colornoise\",\n         \"PATH\" : \"images/colornoise.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"magnetismic.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : false,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"backbuffer\",\n         \"WIDTH\" : 1920\n      }\n   ],\n   \"SMOOTH_TRANSITIONS\" : [\n      {\n         \"DURATION\" : 5,\n         \"UNIFORMS\" : [ \"c0\", \"c1\", \"c2\", \"c3\", \"c4\" ]\n      },\n      {\n         \"DURATION\" : 2.5,\n         \"UNIFORMS\" : [ \"r0\", \"r1\", \"r2\", \"r3\" ]\n      },\n      {\n         \"DURATION\" : 5,\n         \"UNIFORMS\" : [ \"a0\", \"a1\", \"a2\", \"a3\", \"a4\" ]\n      }\n   ],\n   \"TITLE\" : \"Magnetismic\",\n   \"WIDTH\" : 1920,\n   \"VERSION\" : 2,\n   \"TAGS\": [\"raymarching\", \"dark\"],\n   \"GPU\": 4\n}\n","PASSES":[{"FLOAT":false,"HEIGHT":1080,"TARGET":"backbuffer","WIDTH":1920}],"SCRIPT_CODE":"var decimator = 0;\n\nvar script_time = 0.0;\nvar script_bass_time = 0.0;\n\nvar cameraTime = 0.0;\n\nfunction update(dt) {\n\n\n\n  script_time += (inputs.syn_Intensity*0.75+inputs.syn_BassLevel*0.25)*inputs.speed;\n  script_bass_time += (inputs.syn_BassLevel*0.75+inputs.syn_BassLevel*0.25)*inputs.speed;\n\n  uniforms.script_time = script_time;\n\n  uniforms.script_bass_time = script_bass_time;\n\n\n\n  cameraTime += inputs.camera_speed;\n\n  uniforms.cameraTime = cameraTime;\n\n\n\n  decimator++;\n\n  if (decimator%120==0){\n\n\n\n  }\n\n}\n\n\n\nfunction transition() {\n\n  //log(5);\n\n}\n\n","SHADER_CODE":"//Magnetismic by nimitz (twitter: @stormoid)\n\n//Getting 60fps here at high quality\n#define HIGH_QUALITY\n//ao is a little too expensive currently -> drops a 1060 to 15ps\n// #define ADD_AO\n\n#define PIXELATE pixelate>0.5\n#ifdef HIGH_QUALITY\n#define STEPS 40\n#define ALPHA_WEIGHT 0.03\n#define BASE_STEP 0.05\n#else\n#define STEPS 20\n#define ALPHA_WEIGHT 0.10\n#define BASE_STEP 1.0\n#endif\n\nfloat speed_var = script_time;\n\n// vec2 iMouse = vec2(floor(sin(TIME*0.2)), floor(sin(syn_Time*0.3)));\n\nfloat time =  TIME/10.0 + syn_Time/14.0 + speed_var/15.0;\n\nvec3 spectral_color(float l) // RGB <0,1> <- lambda l <400,700> [nm]\n{\n  l=l*300+400;\n  float r=0.0,g=0.0,b=0.0;\n  if ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n  else if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n  else if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n  else if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n  else if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n  if ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n  else if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n  else if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n  if ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n  else if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n  return vec3(r,g,b);\n}\n\n\nvec2 mo;\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noise(in vec3 p) //iq's ubiquitous 3d noise\n{\n\tvec3 ip = floor(p), f = fract(p);\n    #ifdef HIGH_QUALITY\n    f = f*f*f*(f*(f*6. - 15.) + 10.); //Quintic smoothing\n    #else\n    f = f*f*(3.0-2.0*f); //Cubic smoothing\n    #endif\n\tvec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + f.xy;\n\tvec2 rg = texture(colornoise, (uv+ 0.5)/256.0, -100.0 ).yx;\n\t// vec2 rg = vec2(_rand(_uv),_rand(_uv + 100));\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat fbm(in vec3 p, in float sr)\n{\n    p *= 3.5;\n    float rz = 0., z = 1.;\n    for(int i=0;i<4;i++)\n    {\n        float n = noise(p-time*.6);\n        rz += (sin(n*4.4)-.45)*z;\n        z *= .47;\n        p *= 3.5;\n    }\n    return rz;\n}\n\n\nfloat sphere(vec3 p) {\n\treturn length(p) - 0.3;\n}\n\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 _grad4(vec3 col1, vec3 col2, vec3 col3, vec3 col4, float mixVal){\n    mixVal *= 3.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    vec3 firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    return mix(firstTwo, mix(col3, col4, mix3), step(2.0, mixVal));\n}\n\nvec4 map(in vec3 p)\n{\n\t\tvec3 pos = p;\n    float baseSphere = sphere(pos, 0.25)*step(0.25, sphere(pos, 0.25));\n    float offsetSphere = sphere(pos, 0.35)*step(0.35, sphere(pos, 0.35));\n    float smallSphere = (1.0 - step(0.25, baseSphere));\n    float largeSphere = 1.0 - step(1.3, baseSphere);\n    // float largeSphere = sphere(pos, 0.84)*step(0.84, sphere(pos, 0.84));\n    float dtp = dot(p,p);\n\t\tp = .5*p/(dtp + .2);\n    p.xz = rot(p.xz, p.y*mix(2.5, 5.0, a4));\n    p.xy = rot(p.xz, p.y*mix(2, 20, a4));\n\n    p = mix(p, vec3(max(p.x,p.y), max(p.y, p.x), max(p.y, p.x)), pulse);\n\n    float dtp2 = dot(p, p);\n    p = (mo.y + pow(intricacy,2.0)*10.0)*3.*p/(dtp2 - 5.);\n    float r = clamp(fbm(p, dtp*0.1)*scale-dtp*((.35)-sin(time*0.13+(syn_BPMTwitcher*0.2+script_bass_time*0.2)*audio_reactive)*0.15)*scale, 0. ,1.);\n    // float r = clamp(fbm(p, dtp*0.5)*scale-dtp*((.35 + scale*0.2)-fbm(p, sin(time*0.13*audio_reactive))-(sin(time*0.13+(syn_BPMTwitcher*0.2+script_bass_time*0.2))*audio_reactive)*(scale*0.04)), 0. ,0.9);\n    //reduce coloring blowouts produced by the scale knob\n    // r = r*r-clamp(log(scale)*0.15, 0.0, 0.4);\n    r = r*r;\n    vec4 col = vec4(.6,1.4,.65,.96);\n\n    col = mix(col, vec4(1.2, 0.5, 0.5, 0.96) , r1);\n    col = mix(col, vec4(0.2, 1.4, 0.5, 0.96) , r2);\n    col = mix(col, vec4(0.5, 0.5, 1.2, 0.96) , r3);\n\n\t\tcol *= r;\n\n    float grd = clamp((dtp+.7)*0.4,0.,1.);\n    col.b += grd*.6;\n    col.r -= grd*.5;\n    vec3 lv = mix(p,vec3(0.3),2.);\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\n\n\n    vec3 col0 = col.rgb;\n    vec3 col1 = col.rgb * vec3(.5, 0.4, .6)*grd + vec3(1.6,0.,.4);\n    vec3 col2 = col.rgb * vec3(0.2, 0.6, 1.0)*grd + vec3(0.8,0.8,.2);\n    vec3 col3 = col.rgb * vec3(1.2, 0.2, 1.2)*grd + vec3(0.8,0.4,.0);\n    \n\n    col.rgb = mix(col0, col1, c1);\n    col.rgb = mix(col0, col2, c2);\n    col.rgb = mix(col0, col3, c3);\n    \n    col.rgb = col.rgb*0.6+col.rgb*abs(sin(p.x)+cos(p.z)-sin(p.y))*0.4;\n\n    if (colMode > 0.5){\n    \tcol = mix(col, vec4(spectral_color(clamp(2.*r-pow((dtp-p.y),0.5)*0.85, 0.0,1.0)+p.z*syn_MidLevel/2.),col.a), 1.0);\n    \t// col *= r;\n    }\n\n    col *= mix(1.0, ((2.2+scale*(0.55-0.07*scale))-r*(1.9+scale*(0.4-0.05*scale))), ghostly);\n    \n    vec3 sphereColor = vec3((col*1.1))*pow(smallSphere, 2.)*0.9+0.17*(col.r + col.b+col.g)+0.1 + 0.2*col.a + smallSphere*(pos.x-0.8) + smallSphere*(pos.y-0.8);\n    vec4 sphereCore = vec4(sphereColor, (col.r + col.b+col.g)*0.33+col.a*0.2-pow(smallSphere, 2.));\n    // \n    sphereCore += vec4(vec3(0.7), smallSphere);\n      col = mix(col, sphereCore, (smallSphere)*solar_flare);\n\n    //white pulsing highlights\n    float lightPulse1 = _pulse(p.y, tan(syn_Time*0.2), 0.6*r)*(col.r+col.b+col.g)*0.33;\n    float lightPulse2 = _pulse(p.z, tan(time), 0.4*r)*(col.r+col.b+col.g)*0.33-_pulse(p.x, cos(time), 0.4*r)*(col.r+col.b+col.g)*0.33;\n    col.rgb = mix(col.rgb*main_light, col.rgb*main_light+col.rgb*lightPulse1*1.1+lightPulse1*r*0.15+pow(lightPulse1, 3.)/3.5, reactive_lights);\n    col.rgb += mix(vec3(0.0), col.rgb*lightPulse2*0.25+pow(lightPulse1, 3.), vec3(reactive_lights));\n\n    //irridiate inner sphere\n    col.rgba  = mix(col, col + _pulse(smallSphere,0.8, 0.5), solar_flare);\n\n    //use this for an alternate coloring\n    // col.rgb = _grad4(vec3(0.2,0.0,0.0), vec3(0.85,0.5,0.0), vec3(1.0,1.0,0.0), vec3(1.0), 1.0-r);\n    col.a = min(col.a, 1.0);\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+mix(0.4,0.975, syn_FadeInOut);\n  // col = vec4(smallSphere);\n    col = mix(col, min(vec4(largeSphere*2.), col), contain_field);\n\n    return col;\n}\n\n// float calculateAO(in vec3 p, in vec3 n)\n// {\n// \tfloat sca = 1., occ = 0.;\n//     for(float i=0.; i<5.; i++){\n//         float hr = .01 + i*.35/5.;\n//         vec4 dd = map(n * hr + p);\n//         occ += (hr - dd.a)*sca;\n//         sca *= 0.3;\n//     }\n//     return clamp(1.0 - occ, 0., 1.);\n// }\n\nvec3 transform(vec3 p) {\n\tvec3 pos = p;\n\n\tfloat pixel = 7 + 5 * sin(syn_BeatTime/10);\n\tif (PIXELATE) {\n\t\tpos = _pixelate(pos, pixel) + 1.0/pixel/2;\n\n\t\tvec3 d = pos - p;\n\t\tif (length(d) > mix(2, 1.0/pixel/2.0, r0)) {\n\t\t\treturn vec3(100);\n\t\t}\n\t}\n\n\n\tpos = vec3(_rotate(pos.xy, a4 * pos.z / (0.05 + length(pos.xy))), pos.z);\n\n\tvec3 noise = vec3(\n\t\t_noise(pos.xyz)\n\t);\n\tvec2 rect = _toRect(pos.yz);\n\n\tpos.yz = mix(pos.yz, rect, a1);\n\tpos = mix(pos, pos + noise, a2);\n\t// pos = mix(pos, accretion, a4);\n\n\tfloat zoom = mix(1, 0.5, a3);\n\tpos *= zoom;\n\n\treturn pos;\n}\n\nvec4 vmarch(in vec3 ro, in vec3 rd)\n{\n\tvec4 rz = vec4(0);\n\tfloat t = 3.5;\n    t += 0.03*hash21(gl_FragCoord.xy);\n\n\tfor(int i=0; i<STEPS; i++)\n\t{\n\t\tif(rz.a > 0.97 || t > 5)break;\n\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 p = pos;\n\t\tpos = transform(pos);\n\n    vec4 col = map(pos);\n    float den = col.a;\n\n    float ao = 1.0;\n    \n    // #ifdef ADD_AO\n    //   ao = calculateAO(pos, col.rgb);\n    // #endif\n    \n\n    col.a *= ALPHA_WEIGHT/2 * mix(1.0, 1.1, syn_HighLevel);\n\n\t\t// Accretion Disk\n\t\tfloat alpha = mix(1, abs(p.z)/(0.05 + length(p.xy)), a4 );\n\t\tcol.a = mix(0,col.a,alpha);\n\n\t\t// if (a4 > -1 && length(p.xy) < 0.01) {\n\t\t\t// col.a = pow(col.a, 0.2);\n\t\t// }\n    col.rgb = col.rgb*vec3(ao);\n\t\tcol.rgb *= col.a*(0.9  + syn_HighHits*0.3*audio_reactive);\n\t\trz += col*(1. - rz.a);\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\n\t}\n\n\n    return rz;\n}\n\nvec4 renderMain() {\n\tif (PASSINDEX == 0){\n\t\tvec2 p = _xy/RENDERSIZE.xy*2. - 1.;\n\t\tp.x *= RENDERSIZE.x/RENDERSIZE.y*1.0;\n\t\t// mo = 2.0*iMouse;\n    mo = vec2(0.0, 2.5*(sin(script_bass_time*0.03)+1.0)*audio_reactive);\n\t    // mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\n\n\t\tvec3 ro = mix(5, 4, syn_Intensity)*normalize(\n\t    vec3(\n\t      cos(2.75-2.0*(mo.x+time*0.05)),\n\t      sin(time*0.22)*0.2,\n\t      sin(2.75-2.0*(mo.x+time*0.05))));\n\n\n\t\tvec3 eye = normalize(vec3(0) - ro);\n\t\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\n\t\tvec3 up = cross(eye,rgt);\n\t\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\n\n\t\tvec4 col = vmarch(ro, rd);\n\n    col = _contrast(col, 1.05);\n    col = _gamma(col, 0.95);\n\t  return col*col;\n\t}\n  if (PASSINDEX == 1) {\n    return texture(backbuffer,_uv);\n  }\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":5,"UNIFORMS":["c0","c1","c2","c3","c4"]},{"DURATION":2.5,"UNIFORMS":["r0","r1","r2","r3"]},{"DURATION":5,"UNIFORMS":["a0","a1","a2","a3","a4"]}],"TAGS":["raymarching","dark"],"TITLE":"Magnetismic","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.25,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"mX","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-0.75,"DESCRIPTION":"","MAX":1,"MIN":-2,"NAME":"mY","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":4,"DESCRIPTION":"","MAX":40,"MIN":2,"NAME":"sides","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":5,"MIN":0.5,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":4,"DESCRIPTION":"","MAX":6,"MIN":0,"NAME":"multiply","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":24,"DESCRIPTION":"","MAX":72,"MIN":6,"NAME":"loops","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"iR_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"iG_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"iB_bool","TYPE":"toggle","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\mandalascope.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"MandalaScope","IMAGES":null,"IMAGE_PATH":"mandalascope.synScene\\mandalascope.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mX\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -0.75,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"mY\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 4,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 40,\n\t\t\t\"MIN\" : 2,\n\t\t\t\"NAME\" : \"sides\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 4,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 6,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"multiply\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 24,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 72,\n\t\t\t\"MIN\" : 6,\n\t\t\t\"NAME\" : \"loops\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"iR_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"iG_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"iB_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"mandalascope.png\",\n\t\"TITLE\" : \"MandalaScope\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"bool iB = (iB_bool > 0.5); \nbool iG = (iG_bool > 0.5); \nbool iR = (iR_bool > 0.5); \n\n\n////////////////////////////////////////////////////////////\n// MandalaScope  by mojovideotech\n//\n// based on :\n// glslsandbox.com/\\e#42620.1\n// shadertoy.com/\\llXcRl \n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n#define \tpi   \t3.141592653589793 \t// pi\n#define \trcpi  \t0.318309886183791\t// reciprocal of pi  , 1/pi \n\nfloat T = TIME * rate;\n\nvec2 Kscope(vec2 uv, float k) {\n  \tfloat angle = abs (mod (atan (uv.y, uv.x), 2.0 * k) - k) + 0.1*T;\n  \treturn length(uv) * vec2(cos(angle), sin(angle));\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n  \tvec2 uv = (5.5-scale)*(2.0 * _xy.xy / RENDERSIZE.xy - 1.0);\n  \tuv.x *= RENDERSIZE.x / RENDERSIZE.y;\n\tfloat k = pi / floor(sides);\n  \tvec2 s = Kscope(uv,k);\n  \tvec2 t = Kscope(s,k);\n  \tfloat v = dot(t,s);\n\tvec2 u = mix(s,t,cos(v));\n\tif (multiply>0.001) { u.yx += mod(mod(u.yx,floor(multiply)),-u.xy); }\n  \tvec3 p = vec3 (u, mX*v);\n  \tfor (int i = 0; i < 73; i++) {\n  \t\tif (float(i)>floor(loops)) { break; }\n    \tp.xzy = vec3(1.3,0.999,0.678)*(abs((abs(p)/dot(p,p)-vec3(1.0,1.02,mY*rcpi))));\n  \t}\n  \tif (iR) { p.x = 1.0-p.x; }\n  \tif (iG) { p.y = 1.0-p.y; }\n  \tif (iB) { p.z = 1.0-p.z; }\n  \t\n  \tout_FragColor = vec4(p,1.0);\n  \t\n\nreturn out_FragColor; \n } \n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"MandalaScope","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"Move camera to explore the fractal","MAX":[1,1],"MIN":[-1,-1],"NAME":"navigate","PARAMS":0.00499999988824129,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Camera will constantly be slowly rotating","MAX":1,"MIN":0,"NAME":"constant_rotate","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Camera will automatically jump around on the beat","MAX":1,"MIN":0,"NAME":"auto_camera_jumps","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Manually do a random camera jump","MAX":1,"MIN":0,"NAME":"random_camera","TYPE":"bang","UI_GROUP":"camera"},{"DEFAULT":1.39999997615814,"DESCRIPTION":"Zoom in or out of the fractal","MAX":10,"MIN":0,"NAME":"zoom","PARAMS":0.0199999995529652,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":[0,0],"DESCRIPTION":"Move the media around within the fractal","MAX":[1,1],"MIN":[-1,-1],"NAME":"media_xy","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Media appears in flat layers or branching curves","MAX":0,"MIN":1,"NAME":"media_style","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Subtract the grid pattern from the media","MAX":1,"MIN":0,"NAME":"sub_pattern","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Affect the grid shape","MAX":3,"MIN":0.00100000004749745,"NAME":"grid","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"Subtle morphing of the fractal shape for extra action","MAX":1,"MIN":0,"NAME":"bubbling","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"Remove the grid pattern and reflections","MAX":1,"MIN":0,"NAME":"minimal","TYPE":"toggle","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"Send a smooth white pulse down","MAX":1,"MIN":0,"NAME":"pulser","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Send a black/white pulse down","MAX":1,"MIN":0,"NAME":"pulse2","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"action"},{"DEFAULT":1,"DESCRIPTION":"Flasher rising up in sync with the beat","MAX":1,"MIN":0,"NAME":"flasher_on","TYPE":"toggle","UI_GROUP":"action"}],"CREDIT":"Shane","DESCRIPTION":"Applying a simple pattern and coloring to a standard iterative Mandelbrot transformation.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\mandelbrot_decoration.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Mandelbrot Decoration","IMAGES":null,"IMAGE_PATH":"mandelbrot_decoration.synScene\\mandelbrot_decoration.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Move camera to explore the fractal\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"navigate\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.005,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Camera will constantly be slowly rotating\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"constant_rotate\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Camera will automatically jump around on the beat\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_camera_jumps\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Manually do a random camera jump\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"random_camera\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 1.4,\n         \"DESCRIPTION\" : \"Zoom in or out of the fractal\",\n         \"MAX\" : 10,\n         \"MIN\" : 0,\n         \"NAME\" : \"zoom\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.02,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Move the media around within the fractal\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"media_xy\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Media appears in flat layers or branching curves\",\n         \"MAX\" : 0,\n         \"MIN\" : 1,\n         \"NAME\" : \"media_style\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Subtract the grid pattern from the media\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"sub_pattern\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Affect the grid shape\",\n         \"MAX\" : 3,\n         \"MIN\" : 0.001,\n         \"NAME\" : \"grid\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Subtle morphing of the fractal shape for extra action\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"bubbling\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"shape\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Remove the grid pattern and reflections\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"minimal\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Send a smooth white pulse down\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pulser\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"action\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Send a black/white pulse down\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pulse2\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.01,\n         \"UI_GROUP\" : \"action\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Flasher rising up in sync with the beat\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flasher_on\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"action\"\n      }\n   ],\n   \"CREDIT\" : \"Shane\",\n   \"DESCRIPTION\" : \"Applying a simple pattern and coloring to a standard iterative Mandelbrot transformation.\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"mandelbrot_decoration.png\",\n   \"TITLE\" : \"Mandelbrot Decoration\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"function ApproachRandomSpot () {\n  this.goalX = 0.0;\n  this.goalY = 0.0;\n  this.goalZoom = 1.0;\n  this.x = 0.0;\n  this.y = 0.0;\n  this.z = 1.0;\n\n}\n\nApproachRandomSpot.prototype.update = function(amt) {\n  this.x = this.x + (this.goalX-this.x)*amt;\n  this.y = this.y + (this.goalY-this.y)*amt;\n  this.z = this.z + (this.goalZoom-this.z)*amt;\n}\n\nvar mover = new ApproachRandomSpot();\n\nvar decimator = 0;\nvar time = 0;\n\nfunction update(dt) {\n\n  if (((inputs.syn_OnBeat > 0.9)&&(inputs.auto_camera_jumps > 0.5))||(inputs.random_camera > 0.5)){\n    mover.goalX = -0.5+1.0*Math.random();\n    mover.goalY = -0.5+1.0*Math.random();\n    mover.goalZoom = 0.25+Math.random()*1.25;\n\n  }\n  // mover.goal = 0.5+0.5*Math.sin(inputs.TIME);\n  mover.update(0.01);\n  uniforms.random_spot = mover;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n}\n\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"/*\n\n\n\tMandelbrot Pattern Decoration\n\t-----------------------------\n\n\n\tAfter looking at Fabrice's Mandelbrot derivative example, it occurred\n\tto me that I have a heap of simple Mandelbrot and Julia related \n    demonstrations that I've never gotten around to posting, so here's one \n    of them. I put it together a long time ago using the standard base code, \n    which you'll find in countless examples on the internet. I'm pretty sure \n    I started with IQ's \"Orbit Traps\" shader, which is a favorite amongst \n    many on here, then added a few extra lines to produce the effect you \n\tsee. There's not a lot to this at all, so hopefully, it'll be easy to \n    consume.\n\n    Producing Mandelbrot and Julia patterns is pretty straight forward. At \n    it's core you're simply transforming each point on the screen in a \n    certain way many times over, then representing the transformed point \n    in the form of shades and colors.\n\n    In particular, you treat each point as if it were on a 2D complex plane, \n    then perform an iterative complex operation -- which, ironically, is not \n    complex at all. :) In this particular example, the iterative complex \n    derivative is recorded also, which is used for a bit of shading.\n\n    In regard to the shading process itself, most people tend to set a \n    bailout, then provide a color based on the transformed point distance,\n\tand leave it at that. However, with barely any extra code, it's \n    possible to makes things look more interesting.    \n\n    The patterns look pretty fancy, but they're nothing more than repeat \n    circles and grid boundaries applied after transforming the coordinates. \n    The shading and highlights were made up on the spot, but none of it was\n    complex, nor was it based on reality (no pun intended).\n\n\t\n\n    Related examples:\n\n    Based on one of IQ's really nice Mandelbrot example. I love the\n    subtle feathering.\n \tMandelbrot - orbit traps -- IQ\n \thttps://www.shadertoy.com/view/ldf3DN\n\n    // Beautiful example.\n\tHeading To The Sun -- NivBehar\n\thttps://www.shadertoy.com/view/wtdSzS\n\n*/\n\nvec4 texMirror(sampler2D samplerIn, vec2 uvIn){\n  if (mod(uvIn.x, 2.0) > 1.0){\n    uvIn.x = 1.0-uvIn.x;\n  }\n  if (mod(uvIn.y, 2.0) > 1.0){\n    uvIn.y = 1.0-uvIn.y;\n  }\n  return texture(samplerIn, uvIn);\n}\nvec3 _grad4(vec3 col1, vec3 col2, vec3 col3, vec3 col4, float mixVal){\n    mixVal *= 3.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    vec3 firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    return mix(firstTwo, mix(col3, col4, mix3), step(2.0, mixVal));\n}\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n    \n    // Base color.\n    vec3 col = vec3(0);\n    vec3 mediaOut = vec3(0.0);\n    float audioTime = syn_MidHighTime*0.75;\n    float cameraTime = (TIME*0.5 + syn_Time*0.05)*0.5;\n    // Anitaliasing: Just a 2 by 2 sample. You could almost get away with not using\n    // it at all, but it is necessary.\n    #define AA 2\n    for(int j=0; j<AA; j++){\n        for(int i=0; i<AA; i++){\n\n            // Offset centered coordinate -- Standard AA stuff.\n            vec2 p = (fragCoord + vec2(i, j)/float(AA) - RENDERSIZE.xy*.5)/RENDERSIZE.y;\n            \n\n            // Time, rotating back and forth.\n            float ttm = cos(sin(constant_rotate*cameraTime/8.))*6.2831;\n           \n            // Rotating and translating the canvas... More effort needs to be put in here,\n            // but it does the job.\n            p *= mat2(cos(ttm), sin(ttm), -sin(ttm), cos(ttm));\n            p -= vec2(cos(constant_rotate*cameraTime/2.)/2., sin(constant_rotate*cameraTime/3.)/5.);\n            p *= zoom*zoom;\n            p += random_spot.xy*zoom*zoom;\n            p *= random_spot.z*zoom;\n\n            // Jump off point and zoom... Where and how much you zoom in greatly effects what\n            // you see, so I probably should have put more effort in here as well, but this\n            // shows you a enough.\n            float zm = (200. + sin(constant_rotate*cameraTime/7.)*50.);\n            vec2 cc = vec2(-.57735 + .004, .57735) + p/zm + vec2(navigate)*0.05*zoom*zoom;\n \n\n            // Position and derivative. Initialized to zero.\n            vec2 z = vec2(0), dz = vec2(0);\n\n            // Iterations: Not too many. You could get away with fewer, if need be.\n            const int iter = 128;\n            int ik = 128; // Bail out value. Set to the largest to begin with.\n            vec3 fog = vec3(0); //vec3(.01, .02, .04);\n             \n            for(int k=0; k<iter; k++){\n\n                // Derivative: z' = z*z'*2. + 1.\n                // Imaginary partial derivatives are similar to real ones.\n                dz = mat2(z, -z.y, z.x)*dz*2.0*(1.0-_pulse(k, (1.0-pulse2)*iter, 30.0)) + vec2(1, 0); // A better way. Thanks, Fabrice. :)\n                //dz = vec2(z.x*dz.x - z.y*dz.y, z.x*dz.y + z.y*dz.x)*2. + vec2(1, 0);\n              \n                \n                // Position: z = z*z + c.\n                // Squaring an imaginary point is slightly different to squaring a real\n                // one, but at the end of the day, it's just a transformation.\n                z =  mat2(z, -z.y, z.x)*z + cc;\n                //z = (vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y)) + cc;\n                z *= (1.0+bubbling*0.03*_pulse(k, 27.5+sin(syn_Time*0.1+TIME*0.1)*10.0, 8.0));\n                // Experimental transformation with twisting... It's OK, but I wasn't\n                // feeling it.\n                //float l = (float(k)/500.);\n                //z = mat2(cos(l), sin(l), -sin(l), cos(l))*mat2(z, -z.y, z.x)*z + cc;\n \n               \n                // If the length (squared to save cycles) of the transformed point goes \n                // out of bounds, break. In layperson's terms, points that stay within \n                // the set boundaries longer appear brighter... or darker, depending what\n                // you're trying to achieve.\n                if(dot(z, z) > 1./.005){\n                    ik = k; // Record the break number, or however you say it.\n                    break;\n                }\n            }\n            \n            float depth = ik/float(iter);\n            \n            // Lines and shading. There'd be a few ways to represent a boundary line, and\n            // I'd imagine there'd be better ways than this, but it works, so it'll do.\n            float ln = step(0., length(z)/15.5  - 1.);\n            \n            // Distance... shade... It's made up, but there's a bit of logic there. Smooth \n            // coloring involves the log function. I remember reading through a proof a few \n            // years back, when I used to like that kind of thing. It made sense at the time. :)\n            float d = sqrt(1./max(length(dz), .0001))*log(dot(z, z));\n            // Mapping the distance from zero to one.\n            d = clamp(d*50., 0., 1.); \n\n            // Flagging successive layers. You can use this to reverse directions, alternate\n            // colors, etc.\n            float dir = mod(float(ik), 2.)<.5? -1. : 1.;\n\n            // Layer coloring and shading. Also made up.\n            float sh = (float(iter - ik))/float(iter); // Shade.\n            vec2 tuv = z/320.; // Transformed UV coordinate.\n\n            // Rotating the coordinates, based on the global canvas roations and distance\n            // for that parallax effect to aid the depth illusion.\n            // float ttm2 = cos(sin(time_off*audioTime/8.))*6.2831;\n            float ttm2 = audioTime/6.0;\n            float tm = (-ttm2*sh*sh*16.);\n            // Rotated, repeat coordinates.\n            tuv *= mat2(cos(tm), sin(tm), -sin(tm), cos(tm));\n            vec2 viduv = tuv;\n            if (media_style > 0.5){\n                viduv = vec2(viduv.x*0.1+cc.x*100.0 + depth*100.0, cc.y*200.0 + depth*100.0);\n                viduv += media_xy;\n                viduv /= zoom*zoom;\n            } else {\n                viduv = vec2(tuv.x, depth*50.0);\n                viduv += media_xy;\n            }\n            tuv += vec2(0.0, 0.5);\n            // viduv *= vec2(1.0, 0.5);\n            tuv = abs(mod(tuv, 1./(grid*8.)) - 1./16.); \n          \n            vec3 media = texMirror(syn_UserImage, viduv).rgb;\n            mediaOut += mix(fog, media, sh*d);\n\n            // Rendering a grid of circles, and showing the grid boundaries. Anything is \n            // possible here: Truchets, Voronoi, etc.\n            float pat = smoothstep(0., 1./length(dz), length(tuv) - 1./32.);\n            pat = min(pat, smoothstep(0., 1./length(dz), abs(max(tuv.x, tuv.y) - 1./16.) - .04/16.));\n            // Coloring the layer. These are based on the shaded distance value, but you can\n            // choose anything you want.\n            // vec3 lCol = _palette()\n            // vec3 lCol = (.55 + .45*cos(6.2831*(d*d)/3. + vec3(0, 1, 2) - 4.))*1.25;\n            vec3 lCol = pow(min(vec3(1.5, 1, 1)*min(d*.85, .96), 1.), vec3(1, 3, 16))*1.15;\n            // vec3 lCol = _gamma(vec4(_grad4(vec3(106, 93, 60), vec3(92, 179, 155), vec3(162, 230, 192), vec3(251, 245, 192), d)/255.0, 0.0), fiddle).rgb;\n            // lCol.rgb = lCol.grb\n            vec3 lColOrig = lCol;\n            // Appolying the circular grid pattern to the color, based on successive layer count.\n            // We're also applying a boundary line.\n            float bLine, wLine;\n            bLine = min(pat, ln);\n            wLine = max(1. - pat, 1. - ln);\n            // lCol = dir<.0 ? lCol : (sqrt(lCol)*.5 + .7);\n            // lCol *= (0.5+0.5*sin(depth*100.0-syn_BassTime*2.0));\n            lCol = dir<.0 ? lCol-wLine : vec3(0.0)+wLine;\n            // lCol += vec3(wLine);\n            // lCol -= bLine;\n            // lCol -= wLine;\n\n            \n            // A fake unit direction vector to provide a fake reflection vector in order\n            // to produce a fake glossy diffuse value for fake highlights. The knowledge\n            // behind all this is also fake. :D\n            vec3 rd = normalize(vec3(p, 1.));\n            rd = reflect(rd, vec3(0, 0, -1));\n            // Synchronizing the gloss movement... It wasn't for me.\n            // rd.xy = mat2(cos(tm), sin(tm), -sin(tm), cos(tm))*rd.xy; \n            float diff = clamp(dot(z*.5 + .5, rd.xy), 0., 1.)*d;\n            \n            \n            // Fake reflective pattern, which has been offset slightly, and moved in a \n            // reflective manner.\n            tuv = z/200.;\n            tm = -tm/1.5 + .5;\n            tuv *= mat2(cos(tm), sin(tm), -sin(tm), cos(tm));\n            tuv = abs(mod(tuv, 1./8.) - 1./16.); \n            pat = smoothstep(0., 1./length(dz), length(tuv) - 1./32.);\n            pat = min(pat, smoothstep(0., 1./length(dz), abs(max(tuv.x, tuv.y) - 1./16.) - .04/16.));\n\n            \n            // Adding the fake gloss. The \"ln\" variable is there to stop the gloss from \n            // reaching the outer fringe, since I thought that looked a little better.\n            lCol += mix(lCol, vec3(1)*ln, .5)*diff*diff*.5*(pat*.6 + .6);\n            lCol = mix(lCol, lColOrig, minimal);\n            // Swizzling the color on every sixth layer -- I thought it might break up the\n            // orange and red a little.\n            float flasher_mod = flasher_on*length(z)*.15*float(ik)/float(iter)*sqrt(1.0-fract(syn_BPMTwitcher))*mix(1.5, 4.0, step(0.5, syn_MediaType));\n            float index8 = mod(float(ik+floor(syn_BPMTwitcher*flasher_on)), 8.);\n            float index8NoMove = mod(float(ik), 8.);\n            if (index8NoMove <.5) {\n                if (dir<0.0){\n                    lCol = lCol.grb;\n                }\n             } else if ((index8NoMove < 5.0)&&(index8NoMove >= 4.0)){\n                lCol = lCol.grb;\n            }\n            if (index8 <.5) {\n                if (dir<0.0){\n                    lCol = lCol+flasher_mod;\n                } else {\n                    lCol += lColOrig.grb+flasher_mod;\n                }\n                mediaOut = mediaOut*(1.0+flasher_mod);\n            }\n            lCol = mix(lCol.rbg, lCol, d/1.2); // Shade based coloring, for something to do.\n            \n            // This was a last minute addition. I put some deep black lined fringes on the layers\n            // to add more illusion of depth. Comment it out to see what it does.\n            lCol = mix(lCol, vec3(0), (1. - step(0., -(length(z)*.05*float(ik)/float(iter)  - 1.)))*.95);\n\n            // Applying the fog.\n            lCol = mix(fog, lCol, sh*d);\n\n\n            \n            float curvPulse = pow(pulser, 0.05);\n            vec3 pulsePat = vec3(1.0)*_sqPulse(1.0-depth, curvPulse-0.02, 0.01);\n            pulsePat *= 1.0-smoothstep(0.5, 0.3, curvPulse);\n            col += pulsePat;\n            mediaOut += pulsePat;\n            // Used for colored fog.\n            //lCol *= step(0., d - .25/(1. + float(ik)*.5));\n            mediaOut -= sub_pattern*wLine;\n\n            lCol.rgb = _rgb2hsv(lCol.rgb);\n            lCol.r = clamp(lCol.r+1.0-pow(pulse2,3.0)*0.3, 0.0, 2.0);\n            lCol.b = clamp(lCol.b-pow(pulse2,9.0), 0.0, 1.0);\n            lCol.rgb = _hsv2rgb(lCol.rgb);\n\n            // Applying the color sample.\n            col += min(lCol, 1.);\n            // col = vec3(z.xy/100.0, 0);\n            // col = vec3(dz.xy/1000000.0, 0);\n        }\n    }\n    \n    // Divide by the sample number.\n    mediaOut /= float(AA*AA);\n    mediaOut = _gamma(vec4(mediaOut, 0.0), 0.7).rgb*1.5;\n\tcol /= float(AA*AA);\n    \n    if (syn_MediaType > 0.5){\n        col = mediaOut;\n    }\n    // Toning down the highlights... but I'm going to live on the edge and leave it as is. :D\n    //col = (1. - exp(-col))*1.25;\n    \n     // Subtle vignette.\n    vec2 uv = fragCoord/RENDERSIZE.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.25;\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1.0 );\n  return fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Mandelbrot Decoration","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Only at 100% will you see all the plots. Otherwise, turn this down to select a plot. The XY pad will change your selection.","MAX":1,"MIN":0,"NAME":"TURN_ME_DOWN","TYPE":"slider","UI_GROUP":"graph_select"},{"DEFAULT":[0.129999995231628,0.129999995231628],"DESCRIPTION":"12 different interference patterns. Use this XY pad to select which one you want. You can view all 12 and your cursor only when 'TURN ME DOWN' is at 100%.","MAX":[1,1],"MIN":[0,0],"NAME":"GRAPH_SELECT","TYPE":"xy","UI_GROUP":"graph_select"},{"DEFAULT":0,"DESCRIPTION":"Invert the color, black space becomes white space.","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Like a smooth invert, morphs black into white.","MAX":2,"MIN":0,"NAME":"color_mod","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Higher to make the white lines thicker, lower for thinner.","MAX":0,"MIN":2,"NAME":"thickness","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":1,"DESCRIPTION":"Sort of like a zoom level. Higher for more, smaller details. Lower for fewer larger details.","MAX":2,"MIN":0,"NAME":"frequency","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":[1,1],"DESCRIPTION":"Adjusts the spatial parameters of each plot slightly differently.","MAX":[1,1],"MIN":[0,0],"NAME":"xy_modifier","PARAMS":0.100000001490116,"TYPE":"xy smooth","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"Time moving forwards or backwards.","MAX":1,"MIN":-1,"NAME":"time_direction","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"reactive time"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"Constant time element. Turn down for more reactive contribution.","MAX":1,"MIN":0,"NAME":"constant_mix","PARAMS":0.200000002980232,"TYPE":"knob smooth","UI_GROUP":"reactive time"},{"DEFAULT":0,"DESCRIPTION":"Audio reactive time contribution from the highs.","MAX":1,"MIN":0,"NAME":"highs_mix","PARAMS":0.200000002980232,"TYPE":"knob smooth","UI_GROUP":"reactive time"},{"DEFAULT":0,"DESCRIPTION":"Audio reactive time contribution from the lows.","MAX":1,"MIN":0,"NAME":"bass_mix","PARAMS":0.200000002980232,"TYPE":"knob smooth","UI_GROUP":"reactive time"},{"DEFAULT":0,"DESCRIPTION":"Auto smooth zooming in and out with the energy of the music.","MAX":1,"MIN":0,"NAME":"auto_zoom","PARAMS":0.100000001490116,"TYPE":"toggle smooth","UI_GROUP":"reactive time"}],"CREDIT":"aiekick","DESCRIPTION":"Each cells is a similar 2d metaball code\nClick on cell and keep down to see in full size","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\meta_experiment_3.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Meta Experiment 3","IMAGES":null,"IMAGE_PATH":"meta_experiment_3.synScene\\meta_experiment_3.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"TURN_ME_DOWN\",\n         \"DESCRIPTION\":\"Only at 100% will you see all the plots. Otherwise, turn this down to select a plot. The XY pad will change your selection.\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"graph_select\"\n      },\n      {\n         \"DEFAULT\" : 0.13,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"GRAPH_SELECT\",\n         \"DESCRIPTION\":\"12 different interference patterns. Use this XY pad to select which one you want. You can view all 12 and your cursor only when 'TURN ME DOWN' is at 100%.\",\n         \"TYPE\" : \"xy\",\n         \"UI_GROUP\" : \"graph_select\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Invert the color, black space becomes white space.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"invert\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Like a smooth invert, morphs black into white.\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"color_mod\",\n         \"PARAMS\" : 0.10000000149011612,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Higher to make the white lines thicker, lower for thinner.\",\n         \"MAX\" : 0,\n         \"MIN\" : 2,\n         \"NAME\" : \"thickness\",\n         \"PARAMS\" : 0.20000000298023224,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"shape\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Sort of like a zoom level. Higher for more, smaller details. Lower for fewer larger details.\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"frequency\",\n         \"PARAMS\" : 0.05000000074505806,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"shape\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Adjusts the spatial parameters of each plot slightly differently.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"xy_modifier\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"shape\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Time moving forwards or backwards.\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"time_direction\",\n         \"PARAMS\" : 0.20000000298023224,\n         \"TYPE\" : \"toggle smooth\",\n         \"UI_GROUP\" : \"reactive time\"\n      },{\n         \"DEFAULT\" : 0.40000000596046448,\n         \"DESCRIPTION\" : \"Constant time element. Turn down for more reactive contribution.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"constant_mix\",\n         \"PARAMS\" : 0.20000000298023224,\n         \"TYPE\" : \"knob smooth\",\n         \"UI_GROUP\" : \"reactive time\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Audio reactive time contribution from the highs.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"highs_mix\",\n         \"PARAMS\" : 0.20000000298023224,\n         \"TYPE\" : \"knob smooth\",\n         \"UI_GROUP\" : \"reactive time\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Audio reactive time contribution from the lows.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"bass_mix\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"knob smooth\",\n         \"UI_GROUP\" : \"reactive time\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Auto smooth zooming in and out with the energy of the music.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_zoom\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"toggle smooth\",\n         \"UI_GROUP\" : \"reactive time\"\n      }\n   ],\n   \"CREDIT\" : \"aiekick\",\n   \"DESCRIPTION\" : \"Each cells is a similar 2d metaball code\\nClick on cell and keep down to see in full size\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"meta_experiment_3.png\",\n   \"TITLE\" : \"Meta Experiment 3\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"function Timer () {\n  this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function(rate, val, dt) {\n  this.time = this.time+rate*dt*val;\n}\n\nvar actualTime = 0.0;\nvar highsTimeToAdd = 0.0;\nvar bassTimeToAdd = 0.0;\nvar twitchyTimeToAdd = 0.0;\n\nvar constTimeToAdd = 0.0;\n\nvar decimator = 0;\n\nfunction update(dt) {\n  \n  var neg = inputs.time_direction;\n  // if (inputs.constant_motion < 0.0){\n  //   neg = 1.0;\n  // }\n\n  highsTimeToAdd = dt*neg*(Math.pow(inputs.syn_HighHits,3.0)*10.0)*inputs.highs_mix*1.2;\n  bassTimeToAdd = dt*neg*(Math.pow(inputs.syn_BassLevel,2.0)*3.0+Math.pow(inputs.syn_BassHits,2.0)*1.0)*inputs.bass_mix;\n  constTimeToAdd = dt*2.0*neg*Math.pow(inputs.constant_mix*1.3, 2.0);\n\n  actualTime +=  highsTimeToAdd + bassTimeToAdd + constTimeToAdd;\n\n  uniforms.script_time = actualTime;\n\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"vec4 iMouse = vec4(GRAPH_SELECT*RENDERSIZE, 0.0, 0.0); \n\n\n// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 gridSize = vec2(4.,3.);//grid size (columns, rows)\n    \nvec2 s,g,h,m;\nfloat z,t;\nvec2 xyInPow = pow(xy_modifier, vec2(0.7));\nfloat x_amp = xyInPow.x;\nfloat y_amp = xyInPow.y;\n\nfloat e0(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv * vec2(cos(uv.y*p-t)*x_amp,sin(uv.x*p-t)*y_amp)*a;\n   \treturn 0.3/dot(uvSin.xyxy,uvSin.yxxy);\n}\nfloat e1(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t)*x_amp,sin(uv.x*p-t)*y_amp)*a;\n   \treturn 0.3/dot(uvSin.xyxy,uvSin.yxxy);\n}\nfloat e2(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t)*x_amp,sin(uv.x*p-t)*y_amp)*a;\n   \treturn 0.3/dot(uvSin,uvSin);\n}\nfloat e3(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t)*x_amp,sin(uv.x*p-t)*y_amp)*a;\n   \treturn 0.3/dot(uvSin.xy,uvSin.yx);\n}\nfloat e4(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(tan(uv.y*p-t)*x_amp,sin(uv.x*p-t)*y_amp)*a;\n   \treturn 0.3/dot(uvSin.xx,uvSin.yx);\n}\nfloat e5(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y/p-t)*x_amp,sin(uv.x*p-t)*y_amp)/a/a;\n    return 0.3/dot(uvSin.xy,uvSin.yy);\n}\nfloat e6(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv + vec2(cos(uv.y*p-t)*x_amp,sin(uv.x/p-t)*y_amp)/a/p;\n    return 0.3/dot(uvSin.xxyx,uvSin.xyxx);\n}\nfloat e7(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.2/dot(uv,uv) * vec2(cos(uv.y*p-t)*x_amp*p/a,sin(uv.x*p)*y_amp)*a;\n   \treturn dot(uvSin,uvSin)/1.2;\n}\nfloat e8(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.2/dot(uv,uv.xx) * vec2(cos(uv.y*p-t)*x_amp*p/a,sin(uv.x*p)*y_amp)*a;\n   \treturn dot(uvSin,uvSin)/(p*p*0.25);\n}\nfloat e9(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.3/dot(uv.xyyx,uv.yxxy) * vec2(cos(uv.y*p-t)*x_amp/p,sin(uv.x*p-t)*y_amp*p)/a;\n   \treturn dot(uvSin.xyxy,uvSin.yxxy)/1.2;\n}\nfloat e10(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = 0.3/dot(uv.xxy,uv.yxx) / vec2(cos(uv.y*p)*p*x_amp,sin(uv.x*p-t)*y_amp/p)/a;\n   \treturn 0.3/dot(uvSin,uvSin/p);\n}\nfloat e11(vec2 uv, float a, float p, float t) // ok\n{\n    vec2 uvSin = uv / vec2(cos(uv.y*p-t)*x_amp,sin(uv.x*p-t))*y_amp*a/p;\n   \treturn 0.1/dot(uvSin,uvSin);\n}\nfloat EncID(vec2 s, vec2 h, vec2 sz) // encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    return cy*sz.x+cx;\n}\nvec2 DecID(float id, vec2 sz) // decode id to coord // id:cellId / sz=gridSize\n{\n    float cx = mod(float(id), sz.x);\n    float cy = (float(id)-cx)/sz.x;\n    return vec2(cx,cy);\n}\nvec3 getcell(vec2 s, vec2 h, vec2 sz) // return id / uv\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s/sz;\n    float ratio = size.x/size.y;\n    vec2 uv = (2.*(h)-size)/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    z = 3.;\n    t = script_time*5.0;\n    s = RENDERSIZE.xy;\n    h = fragCoord.xy;\n    g = z*(2.*h-s)/s.y;\n    m = iMouse.xy;\n    \n    float d=0.;\n    vec3 cell = getcell(s,h,gridSize);\n    float mouseCol = 0.0;\n    if(TURN_ME_DOWN<=0.99) {\n      cell.x = EncID(s,m,gridSize);\n      cell.yz = g;\n      cell.yz *= mix(1.0, (2.0-syn_Presence), auto_zoom);\n    } else {\n      mouseCol = smoothstep(0.05,0.04,distance(_uvc, (-0.5+GRAPH_SELECT.xy)*vec2(RENDERSIZE.x/RENDERSIZE.y,1.0)));\n    }\n\n    float aSet = pow(thickness, 2.0)*1.5;\n    float frequencyIn = pow(frequency, 2.0)*10.0;\n\n    if (cell.x == 0.) d = e0(cell.yz, aSet, frequencyIn, t);\n    else if (cell.x == 1.) d = e1(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 2.) d = e2(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 3.) d = e3(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 4.) d = e4(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 5.) d = e5(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 6.) d = e6(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 7.) d = e7(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 8.) d = e8(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 9.) d = e9(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 10.) d = e10(cell.yz, aSet, frequencyIn, t);\n   \telse if (cell.x == 11.) d = e11(cell.yz, aSet, frequencyIn, t);\n   \t \n    vec3 c = vec3(mix(1.0/d, d, color_mod));\n    \n    fragColor.rgb = clamp(c, 0.0, 1.0);\n\n    fragColor.rgb = mix(fragColor.rgb, 1.0-fragColor.rgb, mouseCol);\n\n    fragColor.rgb = mix(fragColor.rgb, 1.0-fragColor.rgb, invert);\n\n    if (syn_MediaType > 0.5){\n      fragColor.rgb *= _loadUserImage().rgb;\n    }\n\n    fragColor.a = 1.;\n\t  return fragColor; \n} \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Meta Experiment 3","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"invert lightness on beat. smooth, smoky, flashing","MAX":1,"MIN":0,"NAME":"smoke","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"draw colors from audio spectrum","MAX":1,"MIN":0,"NAME":"spectral_color","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"alternate color postprocessing","MAX":1,"MIN":0,"NAME":"bile","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.0799999982118607,"DESCRIPTION":"color feed magnitude. zero in center","MAX":0.200000002980232,"MIN":-0.200000002980232,"NAME":"feed","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"invert color feed in central egg/eye","MAX":1,"MIN":0,"NAME":"radius","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"audio and color-based upward jump","MAX":1,"MIN":0,"NAME":"jump","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"horizontal sinusoidal twitch","MAX":1,"MIN":0,"NAME":"twitch","TYPE":"bang","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"swap center/sides","MAX":1,"MIN":0,"NAME":"swap","TYPE":"bang","UI_GROUP":"motion"},{"DEFAULT":0.5,"DESCRIPTION":"overall scale of displacement","MAX":1,"MIN":0,"NAME":"warp","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"vertical drift. zero in center","MAX":8,"MIN":-8,"NAME":"drift","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"lower warp in center for concave appearance","MAX":1,"MIN":0,"NAME":"pinch","TYPE":"toggle","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"soft vertical mirror","MAX":1,"MIN":0,"NAME":"mirror","TYPE":"slider","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"media mix. no effect if media is all black","MAX":1,"MIN":0,"NAME":"media_mix","TYPE":"slider","UI_GROUP":"media"}],"CREDIT":"Victor S.","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\milk_honey_smoke_bile.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Milk, Honey, Smoke, Bile","IMAGES":null,"IMAGE_PATH":"milk_honey_smoke_bile.synScene\\thumb.png","JSON_CODE":"{\n  \"CONTROLS\" : [\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"invert lightness on beat. smooth, smoky, flashing\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"smoke\",\n      \"TYPE\" : \"toggle\",\n      \"UI_GROUP\" : \"color\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"audio and color-based upward jump\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"jump\",\n      \"TYPE\" : \"toggle\",\n      \"UI_GROUP\" : \"motion\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"horizontal sinusoidal twitch\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"twitch\",\n      \"TYPE\" : \"bang\",\n      \"UI_GROUP\" : \"motion\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"swap center/sides\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"swap\",\n      \"TYPE\" : \"bang\",\n      \"UI_GROUP\" : \"motion\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"draw colors from audio spectrum\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"spectral_color\",\n      \"TYPE\" : \"toggle\",\n      \"UI_GROUP\" : \"color\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"alternate color postprocessing\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"bile\",\n      \"TYPE\" : \"toggle\",\n      \"UI_GROUP\" : \"color\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"lower warp in center for concave appearance\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"pinch\",\n      \"TYPE\" : \"toggle\",\n      \"UI_GROUP\" : \"shape\"\n    },\n    {\n      \"DEFAULT\" : 0.08,\n      \"DESCRIPTION\" : \"color feed magnitude. zero in center\",\n      \"MAX\" : 0.2,\n      \"MIN\" : -0.2,\n      \"NAME\" : \"feed\",\n      \"TYPE\" : \"slider\",\n      \"UI_GROUP\" : \"color\"\n    },\n    {\n      \"DEFAULT\" : 0.5,\n      \"DESCRIPTION\" : \"overall scale of displacement\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"warp\",\n      \"TYPE\" : \"slider\",\n      \"UI_GROUP\" : \"motion\"\n    },\n    {\n      \"DEFAULT\" : 0,\n      \"DESCRIPTION\" : \"soft vertical mirror\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"mirror\",\n      \"TYPE\" : \"slider\",\n      \"UI_GROUP\" : \"shape\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"invert color feed in central egg/eye\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"radius\",\n      \"TYPE\" : \"slider\",\n      \"UI_GROUP\" : \"color\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"vertical drift. zero in center\",\n      \"MAX\" : 8,\n      \"MIN\" : -8,\n      \"NAME\" : \"drift\",\n      \"TYPE\" : \"slider\",\n      \"UI_GROUP\" : \"motion\"\n    },\n    {\n      \"DEFAULT\" : 0.0,\n      \"DESCRIPTION\" : \"media mix. no effect if media is all black\",\n      \"MAX\" : 1,\n      \"MIN\" : 0,\n      \"NAME\" : \"media_mix\",\n      \"TYPE\" : \"slider\",\n      \"UI_GROUP\" : \"media\"\n    }\n  ],\n  \"CREDIT\" : \"Victor S.\",\n  \"DESCRIPTION\" : \"\",\n  \"WIDTH\" : 1920,\n  \"HEIGHT\" : 1080,\n  \"IMAGE_PATH\" : \"thumb.png\",\n  \"PASSES\" : [\n    {\n       \"FLOAT\" : true,\n       \"TARGET\" : \"fb0\"\n    },\n    {\n       \"FLOAT\" : true,\n       \"TARGET\" : \"fb1\"\n    }\n  ],\n  \"TITLE\" : \"Milk, Honey, Smoke, Bile\"\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"fb0","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"fb1","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"vec3 d = 1./vec3(RENDERSIZE, 1.);\n\nconst float pi = 3.14159265359;\nconst float eps = 1e-15;\n\n//get 2d hue from rgb\n// x is yellow, y is\nvec2 rgb2uv(vec3 c){\n  const vec3 b0 = normalize(vec3(1., 1., -2.));\n  const vec3 b1 = normalize(vec3(-1., 1., 0));\n  vec2 uv = vec2(dot(c, b0), dot(c, b1));\n  return uv/(length(uv)+eps);\n}\n\n//complex multiplication-based rotation\n//a in radians\nvec2 rot(vec2 v, float a){\n  vec2 w = vec2(cos(a), sin(a));\n  return vec2(v.x*w.x-v.y*w.y, v.x*w.y+v.y*w.x);\n}\n\nvec3 sorted_broken(vec3 x){\n  if(x.r >= x.g && x.g >= x.b) return x.bgr;\n  if(x.r <= x.g && x.g <= x.b) return x;\n  if(x.g >= x.r && x.r >= x.b) return x.brg;\n  if(x.g <= x.r && x.r <= x.b) return x.grb;\n  if(x.r >= x.b && x.b >= x.g) return x.rbg;\n  return x.gbr;\n}\nvec3 sorted(vec3 x){\n  if(x.r >= x.g && x.g >= x.b) return x.bgr;\n  if(x.r <= x.g && x.g <= x.b) return x;\n  if(x.g >= x.r && x.r >= x.b) return x.brg;\n  if(x.g <= x.r && x.r <= x.b) return x.grb;\n  if(x.r >= x.b && x.b >= x.g) return x.gbr;\n  return x.rbg;\n}\n\nvec3 _rgb2hsl(vec3 rgb){\n  vec2 hs = _rgb2hsv(rgb).xy;\n  float l = mix(\n    max(rgb.r, max(rgb.g, rgb.b)),\n    min(rgb.r, min(rgb.g, rgb.b)),\n    .5);\n  return vec3(hs, l);\n}\nvec3 _hsl2rgb(vec3 hsl){\n  float v = hsl.z/_scale(hsl.y, 1., .5);\n  return _hsv2rgb(vec3(hsl.xy, v));\n}\n\nvec4 fbMain(in sampler2D state, in vec2 p){\n  float highs = clamp(_scale(syn_HighLevel, -1.-syn_HighPresence, 1.), 0., 1.);\n  float mids = clamp(_scale(syn_MidLevel-syn_BassHits/2., -0.5-syn_MidPresence, 1), 0, 1);\n  float bass = sqrt(max(0.0, _scale(syn_BassHits, -.33, 1.)));\n  float highmids = clamp(_scale(syn_MidHighLevel, -0.5-syn_MidHighPresence, 1), 0, 1);\n  vec4 spectrum = vec4(bass, mids, highmids, highs);\n  float drag = _scale(pow(bass, 3.), 0.97, 0.75);\n\n  vec2 driftv = -d.xy*vec2(0, drift);\n  driftv.x =\n    twitch * .1 * (\n      sin((p.y+syn_RandomOnBeat)*2*pi)\n      + .5*sin((p.y+fract(syn_RandomOnBeat*100))*4*pi)\n    ) + swap * .5;\n\n  vec4 c0 = texture(state, p+driftv);\n  driftv.y -= d.y*pow(2, c0.a*4.*(1+spectrum.x)-2.)*jump;\n\n  vec4 c1 = texture(state, p+driftv);\n  vec2 disp = vec2(0);\n  for (int i=0; i<7; i++){\n    vec4 cs = vec4(sorted_broken(c1.bar), c1.g);\n    vec4 cd = log(mix(exp(cs), exp(c1), spectrum.y));\n    disp += (\n      mix(1., 1.2*length(_uvc)+0.125, pinch)\n      * d.xy * _scale(warp*warp, 0.125, 4.)\n      * pow(_scale(pow(spectrum.x, 0.25), 1.667, 1.33), i)\n      * rot(rgb2uv(cd.rgb), (spectrum.z*.25+cd.a+float(i)*0.5)*pi)\n    );\n    float update = _scale(pow(spectrum.w, 0.33), 0.3, 0.8);\n    c1 = mix(\n      c1,\n      texture(state, p+disp+driftv),\n      update\n    );\n  }\n\n  vec4 ff = feed * mix(\n    vec4(2., 3., 5., 7.)*.25,\n    (spectrum)/(length(spectrum)+eps+.5),\n    spectral_color\n  );\n  ff *= float(\n    length(_uvc-(1-radius)*24*driftv*spectrum.x) > radius*sqrt(spectrum.x)\n  )*2-1;\n  ff.a += sin(_uv.y*2*pi+syn_Time)*smoke*.08; //prevent die-out when smoke on\n\n  vec4 c2 = (c1).gbar;\n  vec4 sat = c2 - sorted(c2.rgb).gggg;\n  sat = mix(0.02, 0.1, smoke)*sat/(length(sat)+eps);\n\n  c2 = fract(c2+sat+ff);\n\n  vec4 c3 = mix(c2, c1, drag);\n  if(syn_OnBeat*smoke==1.0){\n    vec3 hsl = _rgb2hsl(c3.rgb);\n    c3 = vec4(\n      _hsl2rgb(vec3(\n        hsl.xy,\n        clamp(1.-hsl.z*hsl.z*2., 0., 1.)\n      )),\n      .5+.5*sin(c3.a*3.*pi)\n    );\n    c3 = tanh((c3-0.5)*3.)*0.5+0.5;\n  }\n  return c3;\n}\nvec4 softmirror(in sampler2D state, float m){\n  return mix(texture(state, _uv), texture(state, vec2(1.-_uv.x, _uv.y)), m);\n}\n\nvec4 postMain(in sampler2D state, in vec2 p){\n  vec4 c = texture(state, p);\n  if(bile>0.){\n    int i = int(syn_BPMTwitcher);\n    float cc = mix(c[i%4], c[(i+1)%4], fract(syn_BPMTwitcher));\n    c = vec4(\n      _hsv2rgb(tanh(2.*c.rgb-cc)),\n      1.);\n    c = clamp(c, 0, 1);\n    c = mix(c, vec4(1, 0, 0, 1), clamp(\n        c.r*c.b*(1-c.g)\n        + (1-c.r)*(1-c.b)*c.g,\n      0, 1));\n  } else {\n    c = mix(c, vec4(1, 0, 0, 1), clamp(\n        c.r*c.b*(1-c.g),\n      0, 1));\n  }\n  return c;\n}\n\nvec4 secondaryMain(in sampler2D state){\n  vec4 c = softmirror(state, pow(mirror, 2)*.5);\n  if (media_mix > 0){\n    vec4 m = _loadUserImage();\n    m.a = 0;\n    c = mix(\n      c, m,\n      pow(clamp(dot(m, vec4(.33333)), 0, 1), .25)*pow(media_mix, 3)\n    );\n  }\n  return c;\n}\n\nvec4 initialCondition(in vec2 p){\n  return vec4(tanh(vec3(1-length(_uvc))), sin(2*pi*_uv.y))*.5+.5;\n}\n\nvec4 renderMain () {\n  if (FRAMECOUNT<=2){\n    return initialCondition(_xy);\n  }\n  if (PASSINDEX == 0.0){\n    return fbMain(fb1, _uv);\n  }\n  else if (PASSINDEX == 1.0){\n    return secondaryMain(fb0);\n  }\n  else if (PASSINDEX == 2.0){\n    return postMain(fb0, _uv);\n  }\n\n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Milk, Honey, Smoke, Bile","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Turn ON for a brighter flashing effect, instead of the contour lines.","MAX":1,"MIN":0,"NAME":"flashing_mode","TYPE":"toggle","UI_GROUP":"mode"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for shimmering triangles instead of flashing or contour lines.","MAX":1,"MIN":0,"NAME":"triangle_mode","TYPE":"toggle","UI_GROUP":"mode"},{"DEFAULT":0,"DESCRIPTION":"Turn ON while other modes are OFF for circular contours instead of angular contours.","MAX":1,"MIN":0,"NAME":"circular_mode","TYPE":"toggle","UI_GROUP":"mode"},{"DEFAULT":0,"DESCRIPTION":"A bright pulse of light that comes out from the center.","MAX":1,"MIN":0,"NAME":"center_pulse","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Change how noisy the scene is.","MAX":1,"MIN":0,"NAME":"noise","TYPE":"slider","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Cut the media source into a mosaic of triangles, if a media source is selected.","MAX":1,"MIN":0,"NAME":"fragment_media","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Zoom out and fly back in on the media, if media is selected.","MAX":1,"MIN":0,"NAME":"media_pulse","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"media"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"Speed of the white painting action.","MAX":0.25,"MIN":0,"NAME":"speed","TYPE":"slider","UI_GROUP":"speed"},{"DEFAULT":0,"DESCRIPTION":"Rapidly cycle through triangles and hexagons. BOOM.","MAX":1,"MIN":0,"NAME":"EXPLODE","TYPE":"toggle","UI_GROUP":"boom"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\min_max_hex.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"mask_type","VALUES":[0,1,2,3,4]}],"HEIGHT":1080,"ID":"Min Max Hex","IMAGES":null,"IMAGE_PATH":"min_max_hex.synScene\\min_max_hex.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Min Max Hex\",\n \"IMAGE_PATH\": \"min_max_hex.png\",\n \"HARD_TRANSITIONS\": [\n {\n \"UNIFORM\": \"mask_type\",\n \"VALUES\":[0.0, 1.0, 2.0, 3.0, 4.0]\n }],\n \"IMAGES\": [],\n \"PASSES\": [ {\"TARGET\": \"firstBuffer\"}, {\"TARGET\": \"secondBuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"flashing_mode\",\n    \"MIN\" : 0.0,\n    \"MAX\" : 1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON for a brighter flashing effect, instead of the contour lines.\",\n    \"UI_GROUP\":\"mode\"\n  },{\n    \"NAME\": \"triangle_mode\",\n    \"MIN\" : 0.0,\n    \"MAX\" : 1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON for shimmering triangles instead of flashing or contour lines.\",\n    \"UI_GROUP\":\"mode\"\n  },{\n    \"NAME\": \"circular_mode\",\n    \"MIN\" : 0.0,\n    \"MAX\" : 1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Turn ON while other modes are OFF for circular contours instead of angular contours.\",\n    \"UI_GROUP\":\"mode\"\n  },{\n    \"NAME\": \"center_pulse\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.2,\n    \"TYPE\": \"bang smooth\",\n    \"DESCRIPTION\": \"A bright pulse of light that comes out from the center.\",\n    \"UI_GROUP\":\"effects\"\n  },{\n    \"NAME\": \"noise\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Change how noisy the scene is.\",\n    \"UI_GROUP\":\"effects\"\n  },{\n    \"NAME\": \"fragment_media\",\n    \"MIN\" : 0.0,\n    \"MAX\" : 1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Cut the media source into a mosaic of triangles, if a media source is selected.\",\n    \"UI_GROUP\":\"media\"\n  },{\n    \"NAME\": \"media_pulse\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.2,\n    \"TYPE\": \"bang smooth\",\n    \"DESCRIPTION\": \"Zoom out and fly back in on the media, if media is selected.\",\n    \"UI_GROUP\":\"media\"\n  },{\n    \"NAME\": \"speed\",\n    \"MAX\" : 0.25,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.1,\n    \"TYPE\": \"slider\",\n    \"DESCRIPTION\": \"Speed of the white painting action.\",\n    \"UI_GROUP\":\"speed\"\n  },{\n    \"NAME\": \"EXPLODE\",\n    \"MIN\" : 0.0,\n    \"MAX\" : 1.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Rapidly cycle through triangles and hexagons. BOOM.\",\n    \"UI_GROUP\":\"boom\"\n  }]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuffer","WIDTH":0}],"SCRIPT_CODE":"function TimeVar () {\n  this.rate = 0.0;\n  this.time = 0.0;\n}\n\nTimeVar.prototype.updateTime = function(val, dt) {\n  this.time = this.time+val*this.rate*dt*60;\n}\n\n\nfunction Accumulator () {\n  this.value = 0.0;\n  this.decay = 0.9;\n}\n\nAccumulator.prototype.update = function(val, dt){\n  this.value += (val - this.value) * (this.decay * dt * 60.0);\n  if (this.value > 1.0){\n    this.value = 1.0;\n  } else if (this.value<0.0){\n    this.value = 0.0;\n  }\n}\n\nvar timevar = new TimeVar();\nvar accum = new Accumulator();\n\n\nfunction update(dt) {\n\ttimevar.rate = inputs.speed*5.0;\n\t\n\taccum.update(Math.pow(inputs.syn_Hits,3.0), dt);\n\tuniforms.script_accum = accum.value;\n\n  timevar.updateTime(Math.pow(inputs.syn_Hits,3.0)*1.3+inputs.syn_Presence*0.02, dt);\n\tuniforms.script_time = timevar.time;\n\n\t// inputs.syn_CurvedTime*0.5*inputs.speed;\n\n}\nfunction transition() {\n\n}\n","SHADER_CODE":"\n#line 0\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n//\n// Finds the closest triangle center on a 2D plane \n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2tri = mat2(1, 0, i3, 2. * i3);\nconst mat2 tri2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvec2 closestTri(vec2 p) {\n    p = cart2tri * p;\n    vec2 pf = fract(p+syn_BPMTwitcher*EXPLODE);\n    vec2 v = vec2(1./3., 2./3.)+tan(TIME*3.7)*EXPLODE;\n    vec2 tri = mix(v, v.yx+tan(-syn_BPMTwitcher+syn_BPMSin2)*EXPLODE, step(pf.y, pf.x));\n    tri += floor(p);\n    tri = tri2cart * tri;\n    return tri;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0f;\n    x /= w;\n    return 1.0f - x*x*(3.0f-2.0f*x);\n}\n\nfloat triWave(float var, float period){\n    float up = (abs(mod(var,period))-period/2)/period;\n    float down = (abs(mod(-var,period))-period/2)/period;\n    if (mod(var, period)<period/2){\n        return up;\n    } else {\n        return down;\n    }\n}\n\nvoid spin(inout vec3 p) {\n    float r = script_time*0.5 + syn_BPMSin2*0.1;\n\n    mat2 rot = mat2(triWave(r+PI/2.0, PI*2), -triWave(r, 2*PI), triWave(r, 2*PI), triWave(r+PI/2.0, 2*PI))*2.0;\n    p.xz *= rot;\n    p.x -= triWave(r+PI, PI*13)*2.0;\n    p.y += triWave(r+PI, PI*7)*2.0;\n\n    p.zy *= rot;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat getMasker(){\n    vec2 triPos = closestTri(abs(_uvc)*4.0);\n    vec2 smallTris = closestTri(_uvc*10.0);\n    float retVal = 0.0;\n    if (mask_type < 1.0){\n        if ((length(triPos)<1.0)||((length(triPos)>2.0)&&(length(triPos)<2.8))){\n            retVal = 1.0;\n        }\n    } else if (mask_type < 2.0){\n        if (length(triPos)<2.0){\n            retVal = 1.0;\n        }\n    } else if (mask_type < 3.0){\n        if ((triPos.x-triPos.y<2.0)&&(triPos.y < 2.0)){\n            retVal = 1.0;\n        }\n    } else if (mask_type < 4.0){\n        if ((triPos.y<2.0)&&(triPos.y>1.0)||(triPos.y-triPos.x>1.5)){\n            retVal = 1.0;\n        }\n    } else if (mask_type < 5.0){\n        if ((triPos.y-triPos.x>1.3)||(length(triPos*vec2(0.0,1.2))<0.7)){\n            retVal = 1.0;\n        }\n    } \n\n    // if ((length(triPos)>size_mask)&&((length(triPos)<size_mask*1.8)||outer_ring<0.5)){\n    //     retVal = 0.0;\n    // }\n    return retVal;\n}\n\nvec4 renderMain()\n{\n    if (PASSINDEX == 0){\n        vec2 pos = _uvc*2.0;\n\n        vec2 triPos = closestTri(abs(pos));\n        vec2 smallTris = closestTri(_uvc*10.0);\n        // pos += normalize(smallTris)*(syn_HighHits*auto_twitcher+twitcher)*0.1;\n\n        if (triangle_mode > 0.5){\n            pos = closestTri(abs(_uvc*6.0)-smallTris);\n        }\n\n\n        if (flashing_mode > 0.5){\n            pos *= smallTris*step(syn_HighHits,0.7)*0.1;\n        }\n\n        vec3 pos3D = vec3(0.0);\n        if (flashing_mode > 0.5){\n            pos3D = vec3(pos+triPos, triPos.y*triPos.x*1.0);\n            spin(pos3D);\n        } else {\n            pos3D = vec3(pos+triPos, triPos.y*pos.x);\n            spin(pos3D);\n        }\n\n        float hex = fract(sdHexPrism(pos3D, vec2(0.5+syn_Presence*0.1-length(triPos)*0.5, 0.5))*10.0);\n        // hex = cubicPulse(0.1, 0.02+clamp(1.0-pow(length(_uvc*2)*3.0,3.0),0.0,1.0)*0.1, hex-dot(abs(smallTris), vec2(1.0))*center_pulse);\n\n        if (circular_mode > 0.5){\n            hex = fract(sdTorus(pos3D, vec2(0.5+syn_Presence*0.1, 0.5+(-1+syn_BPMSin2*2.0)*0.01))*10.0);\n        }\n\n        if (flashing_mode > 0.5){\n            hex = cubicPulse(0.1+syn_BassLevel*0.1, 0.02+clamp(1.0-pow(length(_uvc*2)*3.0,3.0),0.0,1.0)*0.1+center_pulse*2.0, hex-dot(abs(smallTris), vec2(1.0))*center_pulse);\n            hex += step(_rand(pos3D.xy),0.5)*step(0.7,syn_HighHits);\n        } else {\n            hex = cubicPulse(0.1, 0.02+clamp(1.0-pow(length(_uvc*2)*3.0,3.0),0.0,1.0)*0.1+center_pulse, hex-dot(abs(smallTris), vec2(1.0))*center_pulse);\n        }\n\n        vec3 color = vec3(hex);\n        return vec4(color,1.0);\n    } else if (PASSINDEX == 1){\n        vec2 triPos = closestTri(abs(_uvc)*4.0);\n        vec2 smallTris = closestTri(_uvc*10.0);\n\n        vec4 newBuff = texture(firstBuffer, _uv);\n        vec4 oldBuff = texture(secondBuffer, _uv);\n        newBuff += step(rand(_uvc*100.0+TIME),pow(dot(oldBuff, vec4(1.0))/4.0-0.2,3.0)*0.7+noise*0.4)*(syn_HighPresence+noise);\n        newBuff -= step(rand(_uvc*100.0-TIME),0.02);\n\n        float blackener = 1.0;\n        \n        blackener = getMasker();\n\n        newBuff = clamp(newBuff, 0.0, 10.0);\n\n        return mix(newBuff, oldBuff, 0.75)*blackener;\n    } else if (PASSINDEX == 2){\n\n        vec2 triPos = closestTri(abs(_uvc)*4.0);\n        vec2 smallTris = closestTri(_uvc*10.0);\n        vec4 newBuff = vec4(0.0);\n        vec2 offset = smallTris*media_pulse*abs(_uvc);\n        vec2 triPosOffset = fragment_media*triPos;\n\n        if (syn_MediaType != 0){\n            if (syn_MediaType == 1){\n                offset += -(0.25+syn_OnBeat*0.004)*_uv+vec2(triWave(syn_BassTime*0.017, 1.0), triWave(syn_Time*0.0073, 1.0))*0.5;\n            }\n\n            newBuff += pow(_loadUserImage(triPosOffset+offset),vec4(2.0));\n        }\n\n        float blackener = 1.0;\n        blackener = getMasker();\n\n        return clamp(texture(secondBuffer, _uv)*((1.0+EXPLODE+triangle_mode)*3.0)+newBuff*blackener,0.0,1.0);\n    }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Min Max Hex","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Race over the surface of the planet when on. Otherwise, dance around the surface based on the music.","MAX":1,"MIN":0,"NAME":"racer","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"OFF to stay close to the surface. ON to zoom out and view the whole planet.","MAX":1,"MIN":0,"NAME":"zoom_out","PARAMS":0.025000000372529,"TYPE":"toggle smooth","UI_GROUP":"camera"},{"DEFAULT":0.5,"DESCRIPTION":"racer MUST BE ON. Change the angle of the camera while in 'racer' mode. Careful, you can point the camera to places that are entirely black if zoomed out.","MAX":6.28000020980835,"MIN":0,"NAME":"racer_look","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":0.0299999993294477,"DESCRIPTION":"racer MUST BE ON. Adjust how fast the 'racer' camera moves over the surface.","MAX":0.0500000007450581,"MIN":0,"NAME":"racer_speed","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":0.800000011920929,"DESCRIPTION":"Change from small cracks in the surface to magenta protrusions. Default is to look like 'lava' towards the top.","MAX":1,"MIN":-0.5,"NAME":"inside_out","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Change color scheme to a more alien looking world with lighter colors.","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Turn on to insert a mirror that *does not* mirror the UserImage, so you can preserve your image.","MAX":1,"MIN":0,"NAME":"Mirror","TYPE":"toggle","UI_GROUP":"mirror"}],"CREDIT":"Meebs ft. Flexi","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\molten.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Molten","IMAGES":[{"NAME":"colornoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"molten.synScene\\molten.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs ft. Flexi\",\n \"TITLE\": \"Molten\",\n \"IMAGE_PATH\": \"molten.png\",\n \"IMAGES\": [{\n    \"PATH\": \"images/colornoise.jpg\",\n    \"NAME\": \"colornoise\"\n  }],\n  \"CONTROLS\": [{\n\t\t\t\"NAME\": \"racer\",\n\t\t\t\"MAX\" : 1.0,\n\t\t\t\"MIN\" : 0.0,\n\t\t\t\"DEFAULT\":0.0,\n\t\t\t\"TYPE\": \"toggle\",\n\t\t\t\"DESCRIPTION\": \"Race over the surface of the planet when on. Otherwise, dance around the surface based on the music.\",\n      \"UI_GROUP\":\"camera\"\n\t\t},{\n\t\t\t\"NAME\": \"zoom_out\",\n\t\t\t\"MAX\" : 1.0,\n\t\t\t\"MIN\" : 0.0,\n\t\t\t\"DEFAULT\":0.0,\n\t\t\t\"TYPE\": \"toggle smooth\",\n\t\t\t\"PARAMS\": 0.025,\n\t\t\t\"DESCRIPTION\": \"OFF to stay close to the surface. ON to zoom out and view the whole planet.\",\n      \"UI_GROUP\":\"camera\"\n\t\t},{\n\t\t\t\"NAME\": \"racer_look\",\n\t\t\t\"MAX\" : 6.28,\n\t\t\t\"MIN\" : 0.0,\n\t\t\t\"DEFAULT\":0.5,\n\t\t\t\"TYPE\": \"slider smooth\",\n\t\t\t\"PARAMS\": 0.05,\n\t\t\t\"DESCRIPTION\": \"racer MUST BE ON. Change the angle of the camera while in 'racer' mode. Careful, you can point the camera to places that are entirely black if zoomed out.\",\n      \"UI_GROUP\":\"camera\"\n\t\t},{\n\t\t\t\"NAME\": \"racer_speed\",\n\t\t\t\"MAX\" : 0.05,\n\t\t\t\"MIN\" : 0.0,\n\t\t\t\"DEFAULT\":0.03,\n\t\t\t\"TYPE\": \"slider smooth\",\n\t\t\t\"PARAMS\": 0.05,\n\t\t\t\"DESCRIPTION\": \"racer MUST BE ON. Adjust how fast the 'racer' camera moves over the surface.\",\n      \"UI_GROUP\":\"camera\"\n\t\t},{\n\t\t\t\"NAME\": \"inside_out\",\n\t\t\t\"MAX\" : 1.0,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"DEFAULT\":0.8,\n\t\t\t\"TYPE\": \"slider smooth\",\n\t\t\t\"DESCRIPTION\": \"Change from small cracks in the surface to magenta protrusions. Default is to look like 'lava' towards the top.\",\n      \"UI_GROUP\":\"color\"\n\t\t},{\n\t\t\t\"NAME\": \"invert\",\n\t\t\t\"MAX\" : 1.0,\n\t\t\t\"MIN\" : 0.0,\n\t\t\t\"DEFAULT\":0.00,\n\t\t\t\"TYPE\": \"toggle\",\n\t\t\t\"DESCRIPTION\": \"Change color scheme to a more alien looking world with lighter colors.\",\n      \"UI_GROUP\":\"color\"\n\t\t},{\n\t\t\t\"NAME\": \"Mirror\",\n\t\t\t\"MAX\" : 1.0,\n\t\t\t\"MIN\" : 0.0,\n\t\t\t\"DEFAULT\":0.00,\n\t\t\t\"TYPE\": \"toggle\",\n\t\t\t\"DESCRIPTION\": \"Turn on to insert a mirror that *does not* mirror the UserImage, so you can preserve your image.\",\n      \"UI_GROUP\":\"mirror\"\n\t\t}],\n \"PASSES\": [ {\"TARGET\":\"buffA\", \"WIDTH\":889, \"HEIGHT\":500, \"FLOAT\": true},\n {\"TARGET\":\"buffC\", \"WIDTH\":889, \"HEIGHT\":500, \"FLOAT\": true},\n {\"TARGET\":\"buffD\", \"WIDTH\":889, \"HEIGHT\":500, \"FLOAT\": true} ]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":500,"TARGET":"buffA","WIDTH":889},{"FLOAT":true,"HEIGHT":500,"TARGET":"buffC","WIDTH":889},{"FLOAT":true,"HEIGHT":500,"TARGET":"buffD","WIDTH":889}],"SCRIPT_CODE":"function Camera () {\n  this.rad = 26.0;\n  this.x = 0.2;\n  this.y = 0.2;\n  this.z = 0.2;\n  this.unitX = 0.2;\n  this.unitY = 0.2;\n  this.unitZ = 0.2;\n  this.dx = 0.0;\n  this.dy = 0.0;\n  this.dz = 0.0;\n\n  this.lookX = 0.0;\n  this.lookY = 0.0;\n  this.lookZ = 0.0;\n}\n\nfunction Looker () {\n  this.x = 0;\n  this.y = 0;\n  this.z = 0;\n}\n\nCamera.prototype.getUnit = function() {\n  var magnitude = Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2));\n  this.unitX = this.x/magnitude;\n  this.unitY = this.y/magnitude;\n  this.unitZ = this.z/magnitude;\n}\n\nCamera.prototype.confineToSphere = function () {\n  this.getUnit();\n  this.x = this.unitX*this.rad;\n  this.y = this.unitY*this.rad;\n  this.z = this.unitZ*this.rad;\n}\n\nCamera.prototype.move = function (dt, speed) {\n  this.x += this.dx * dt * speed;\n  this.y += this.dy * dt * speed;\n  this.z += this.dz * dt * speed;\n\n  this.confineToSphere();\n}\n\nCamera.prototype.updateVelocity = function() {\n  this.dx = (-0.5+inputs.syn_BassPresence)*10.0;\n  this.dy = (-0.5+inputs.syn_MidPresence)*10.0;\n  this.dz = (-0.5+inputs.syn_HighPresence)*10.0;\n}\n\nCamera.prototype.calculateLookDirection = function (speed) {\n  var base1x = 1;\n  var base1y = 1;\n  var base1z = 0;\n  base1z = (-base1x*this.x-base1y*this.y)/this.z; //Dot product to find arbitrary othogonal vector\n\n  var base2x = 0;\n  var base2y = 0;\n  var base2z = 0;\n  base2x = base1y*this.z-base1z*this.y;\n  base2y = base1z*this.x-base1x*this.z;\n  base2z = base1x*this.y-base1y*this.x;//Cross product to find the third and last orthogonal vector\n\n  var magnitude1 = Math.sqrt(Math.pow(base1x,2)+Math.pow(base1y,2)+Math.pow(base1z,2));\n  var magnitude2 = Math.sqrt(Math.pow(base2x,2)+Math.pow(base2y,2)+Math.pow(base2z,2));\n\n  base1x/=magnitude1;\n  base1y/=magnitude1; \n  base1z/=magnitude1;\n  base2x/=magnitude2;\n  base2y/=magnitude2; \n  base2z/=magnitude2; //Make them unit vectors\n \n  var lookTime = (inputs.syn_HighTime*0.2+inputs.syn_BassTime*0.1+inputs.syn_Time*0.05)*0.25*speed;\n  var lookTime2 = lookTime*0.77777;\n\n  this.lookX = this.x+base1x*Math.sin(lookTime)+base2x*Math.cos(lookTime2);\n  this.lookY = this.y+base1y*Math.sin(lookTime)+base2y*Math.cos(lookTime2);\n  this.lookZ = this.z+base1z*Math.sin(lookTime)+base2z*Math.cos(lookTime2);\n\n}\n\n\nvar camera = new Camera();\nvar looker = new Looker();\nvar time = 0;\nuniforms.camera = camera;\nuniforms.rad = camera.rad;\nuniforms.camLookAtJS = looker;\nvar decimator = 0;\nfunction update(dt) {\n  camera.rad = 26.0+inputs.zoom_out*15.0;\n  time += inputs.racer_speed;\n  decimator++;\n  if (inputs.racer > 0.5){\n    camera.x = Math.sin(time*0.5)/Math.sqrt(1+0.1*0.1)*camera.rad*0.9;\n    camera.y = Math.cos(time*0.5)/Math.sqrt(1+0.1*0.1)*camera.rad*0.9;\n    camera.z = 0.1/Math.sqrt(1+0.1*0.1)*camera.rad*0.9;\n    looker.x = Math.sin(time*0.5+inputs.racer_look)/Math.sqrt(1+0.1*0.1+0.1)*camera.rad*0.86;\n    looker.y = Math.cos(time*0.5+inputs.racer_look)/Math.sqrt(1+0.1*0.1+0.1)*camera.rad*0.86;\n    looker.z = 0.1/Math.sqrt(1+0.1*0.1)*camera.rad*0.86;\n  } else {\n    camera.updateVelocity();\n    camera.move(dt, inputs.syn_BPMSin4*2.5+inputs.zoom_out*5.0);\n    camera.calculateLookDirection(1.0);\n    looker.x = camera.lookX*0.96*(1.0-inputs.zoom_out*0.1);\n    looker.y = camera.lookY*0.96*(1.0-inputs.zoom_out*0.1);\n    looker.z = camera.lookZ*0.96*(1.0-inputs.zoom_out*0.1);\n  }\n\n  if(decimator%50==0){\n    // console.log(looker.x, \"x\");\n\n    // console.log(looker.y, \"y\");\n\n    // console.log(looker.z, \"z\");\n\n  }\n\n}\nfunction transition() {\n}","SHADER_CODE":"\nvec3 iResolution = vec3(RENDERSIZE.x, RENDERSIZE.y, 0.0);\nvec3 iChannelResolution = iResolution;\nfloat iGlobalTime = TIME*1.0;\nint iFrame = int(FRAMECOUNT);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\nvec4 iMouse = vec4(0.5);\nfloat planetRad = 20.25;\n\n\n// ****************** PASS 0 ***********************\n#define pi 3.141592653589793238462643383279\n#define pi_inv 0.318309886183790671537767526745\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(buffA, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(buffD, uv);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float f1lter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, f1lter);\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 noise = texture(colornoise, _uv*3.0 + fract(vec2(42,56)*iGlobalTime));\n\n    if(TIME<0.2)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    vec2 mouseV = vec2(0.5);\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 pixelSize = 1. / iResolution.xy;\n    // vec2 warpPos = vortex_warp(_uv, vec2(0.5), 0.1, 0.1, vec2(0.5));\n\n    vec2 d = pixelSize*3.5;\n    vec2 gx;\n    gx.x = BlurA(uv-vec2(1.,0.)*d, 3).r - BlurA(uv+vec2(1.,0.)*d, 3).r;\n    gx.y = BlurA(uv-vec2(0.,1.)*d, 3).r - BlurA(uv+vec2(0.,1.)*d, 3).r;\n\n    vec2 uvr = uv + gx*7.*pixelSize;\n\n    float r = BlurA(uvr, 0).r;\n    r += (BlurA(uvr, 1).r - BlurA(uv, 4).r) * 22.5/256.; // \"reaction-diffusion\"\n\n    if(TIME>2.0){\n        r += 2.25*(1.0+syn_BassLevel*2) / 256.;\n    }\n\n    fragColor.r = r;\n\n    vec2 gradGreen;\n    gradGreen.x = BlurA(uv-vec2(1.,0.)*d, 3).g - BlurA(uv+vec2(1.,0.)*d, 3).g;\n    gradGreen.y = BlurA(uv-vec2(0.,1.)*d, 3).g - BlurA(uv+vec2(0.,1.)*d, 3).g;\n    fragColor.gb = BlurA(_uv, 0).gb;\n    fragColor.gb += (BlurA(_uv+gradGreen, 1).gb - BlurA(_uv, 2).gb) * 200.5/256.; // \"reaction-diffusion\"\n    \n    fragColor = clamp(fragColor, 0., 1.);\n\n    //fragColor = noise; // reset\n}\n\n// *************** PASS 1 *****************\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffD, uv1) * 0.05;\n    sum += texture(buffD, uv2) * 0.09;\n    sum += texture(buffD, uv3) * 0.12;\n    sum += texture(buffD, uv4) * 0.15;\n    sum += texture(buffD, uv5) * 0.16;\n    sum += texture(buffD, uv6) * 0.15;\n    sum += texture(buffD, uv7) * 0.12;\n    sum += texture(buffD, uv8) * 0.09;\n    sum += texture(buffD, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid horizontalBlur( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(buffA, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(buffA, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}\n\n\n// *************** PASS 2 *****************\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffC, uv1) * 0.05;\n    sum += texture(buffC, uv2) * 0.09;\n    sum += texture(buffC, uv3) * 0.12;\n    sum += texture(buffC, uv4) * 0.15;\n    sum += texture(buffC, uv5) * 0.16;\n    sum += texture(buffC, uv6) * 0.15;\n    sum += texture(buffC, uv7) * 0.12;\n    sum += texture(buffC, uv8) * 0.09;\n    sum += texture(buffC, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid verticalBlur( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(buffC, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(buffC, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n    uv = uv_orig;\n    float eighth = 1./8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    }\n}\n\n// *************** Main Image Pass *****************\n\n//Distance to any objects\nfloat distToSurface(vec3 pos){\n\n    vec2 planetCoords;\n    vec3 normalToSurface = normalize(pos);\n    planetCoords.x = 0.5 - atan(normalToSurface.z, normalToSurface.x) / (2*PI);\n    planetCoords.y = 0.5 - asin(-normalToSurface.y) / PI;\n\n\n    if ((planetCoords.y < 0.09)||(planetCoords.y > 0.91)){\n        // planetCoords.y = mix(planetCoords.y, 0.05-planetCoords*0.5, clamp(0.05-planetCoords.y,0.0,0.05)/0.05);\n        // planetCoords.x = (planetCoords.x, planetCoords.x*0.05, clamp(0.05-planetCoords.y,0.0,0.05)/0.05);\n        // planetCoords.x = mix(planetCoords.x, planetCoords.x*0.5, clamp(0.05-planetCoords.y,0.0,0.05)/0.05);\n        planetCoords.x = planetCoords.x*0.2;\n        planetCoords.y = (1.0+normalToSurface.y)*2.0;\n\n    }\n\n    planetCoords *= vec2(5.0); //Vec2(0.63,1.0) is a magic number to make it seamless.\n\n    float mainLumps = texture(buffA, planetCoords).r*0.5;\n    vec2 temp = BlurA(fract(planetCoords*4.0), 2).gb;\n    float wires = pow(clamp(temp.r,0.0,0.8),3.0)*36.0;\n    float pattern = temp.g;\n\n    float sphere = length(pos) - planetRad + inside_out*clamp(mainLumps + inside_out*wires*2.0*(syn_HighHits*1.3+syn_HighPresence*0.5)*pattern,0.0,0.5);\n\n    return sphere;\n}\n\nfloat distanceToObj(vec3 pos){\n    return distToSurface(pos);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n  vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n  vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n  return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec3 col;\n\nvec3 rayMarch() {\n  vec2 vPos = _uvc;\n  vec2 ndcPos = _uv;\n  if (Mirror > 0.5){\n    if (vPos.x > 0.0){\n        vPos.x = -vPos.x;\n    }\n    if (ndcPos.x < 0.5){\n        ndcPos.x = 1.0-ndcPos.x;\n    }\n  }\n\n  vec3 camOrigin = camera;\n  vec3 camLookAt = camLookAtJS;\n\n  if(camera.z < 0.0){\n      camOrigin = -camOrigin;\n      camLookAt = -camLookAt;\n  }\n\n  vec3 camUpVector = vec3(0.0,1.0,0.0);\n\n  if (racer>0.5){\n    camUpVector = normalize(camOrigin);\n  }\n\n  vec3 vpn = normalize(camLookAt-camOrigin);\n  vec3 u = normalize(cross(camUpVector,vpn));\n  vec3 v = cross(vpn,u);\n  vec3 vcv = (camOrigin+vpn);\n  vec3 scrCoord = vcv+vPos.x*u*0.8+vPos.y*v*0.8;\n  vec3 scp = normalize(scrCoord-camOrigin);\n  \n  //Raymarching\n  float e = 0.05;\n  const float maxd = 30.0; //Max Depth\n  float dist = 0.5;\n  vec3 c, rayPos, N;\n  \n  float depth=1.0;\n  float numSteps = 0;\n  for(int i=0; i<20; i++){\n    if ((abs(dist) < 0.01)|| (depth > maxd)) {\n      break;\n    }\n    \n    depth += dist;\n    rayPos = camOrigin+scp*depth;\n    dist = distanceToObj(rayPos);\n    numSteps++;\n  }\n\n  if (depth < maxd){\n    \n    vec4 c1 = vec4(0.7, 0.3, 0.5, 0.0);\n    vec4 c2 = vec4(0.2, 0.0, 0.0, 0.2);\n    vec4 c3 = vec4(1.0, 0.3, 0.1, 0.60);\n    vec4 c4 = vec4(0.9, 0.6, 0.25, 0.85);\n    vec4 c5 = vec4(0.6, 0.3, 1.2, 1.0);\n\n    float colorPicker = 1.0-clamp((length(rayPos)-planetRad+0.75)*1.0, 0.0, 1.0);\n\n    col = vec3(0.0);\n    if (colorPicker < c2.w){\n        col = mix(c1.rgb, c2.rgb, colorPicker/c2.w);\n    } else if (colorPicker < c3.w){\n        col = mix(c2.rgb, c3.rgb, (colorPicker-c2.w)/(c3.w-c2.w));\n    } else if (colorPicker < c3.w){\n        col = mix(c3.rgb, c4.rgb, (colorPicker-c3.w)/(c4.w-c3.w));\n    } else if (colorPicker < c4.w){\n        col = mix(c4.rgb, c5.rgb, (colorPicker-c4.w)/(c5.w-c4.w));\n    }\n\n  }\n  else {\n    col = vec3(0.0,0.0,0.0);\n  }\n\n  // col -= vec3(1.0,1.0,1.0)*(-rayPos.z*0.00001);\n  vec4 noise = vec4(_rand(_uv+TIME))*0.5;\n  col -= vec3(1.0)*depth*(0.045-(zoom_out)*0.025);\n  col += noise.xyz*0.3;\n  if(invert > 0.5){\n    col = pow(col, 1.0-vec3(-0.5001));\n  }\n\n  // col = mix(col, col*vec3(1.0,0.8,0.0)/step(10.0,numSteps)*(numSteps-10.0)/20.0 , 0.5);\n\n  return col;\n}\n\nvoid mainImage4( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayMarchCol = rayMarch();\n    if (_exists(syn_UserImage)){\n        rayMarchCol = _loadUserImage().rgb*rayMarchCol;\n    }\n    fragColor = vec4(rayMarchCol, 1.0);\n}\n\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    //buffA\n    vec4 fragColor;\n    mainImage0(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 1.0){\n    //buffC\n    vec4 fragColor;\n    horizontalBlur(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 2.0){\n    //Image\n    vec4 fragColor;\n    verticalBlur(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 3.0){\n    //Image\n    vec4 fragColor;\n    mainImage4(fragColor, gl_FragCoord.xy);\n    // fragColor = texture(buffA, _uv);\n    return fragColor;\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Molten","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Reduces the color space, resulting contour lines instead of smooth shading. 100% is all colors, 0% is only 2 or 3.","MAX":1,"MIN":0.100000001490116,"NAME":"levels","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"OFF is normal. ON is grainy and inverse.","MAX":1,"MIN":0,"NAME":"color_mode","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Zoom in and out.","MAX":12,"MIN":1,"NAME":"zoom","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"cells"},{"DEFAULT":0,"DESCRIPTION":"Arrange the spheres randomly (OFF) or on a grid (ON).","MAX":1,"MIN":0,"NAME":"arranged","TYPE":"toggle","UI_GROUP":"cells"},{"DEFAULT":0.5,"DESCRIPTION":"Define a rotation direction and amount.","MAX":1,"MIN":-1,"NAME":"rotation","PARAMS":0.5,"TYPE":"knob traveler","UI_GROUP":"motion"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"Define a direction for the spheres to move.","MAX":[1,1],"MIN":[-1,-1],"NAME":"xyPos","PARAMS":0.5,"TYPE":"xy traveler","UI_GROUP":"motion"},{"DEFAULT":1,"DESCRIPTION":"Add a motion blur effect. 100% will freeze the scene. 0% is no blur.","MAX":0,"MIN":1,"NAME":"feedback","TYPE":"slider","UI_GROUP":"feedback"}],"CREDIT":"Alex Rowe","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\myoplasm.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Myoplasm","IMAGES":null,"IMAGE_PATH":"myoplasm.synScene\\myoplasm.png","JSON_CODE":"{\n\"CREDIT\":\"Alex Rowe\",\n\"TITLE\":\"Myoplasm\",\n\"IMAGE_PATH\":\"myoplasm.png\",\n\"SMOOTH_TRANSITIONS\":[{\n  \"UNIFORMS\":[\"r0\",\"r1\",\"r2\",\"r3\", \"r4\"]\n  },{\n  \"UNIFORMS\":[\"n0\",\"n1\",\"n2\",\"n3\"]\n  },{\n  \"UNIFORMS\":[\"c0\",\"c1\",\"c2\",\"c3\", \"c4\"]\n}],\n\"CONTROLS\":[{\n\t\"NAME\": \"levels\",\n\t\"TYPE\": \"slider\",\n\t\"MIN\": 0.1,\n\t\"DEFAULT\": 1.0,\n\t\"DESCRIPTION\": \"Reduces the color space, resulting contour lines instead of smooth shading. 100% is all colors, 0% is only 2 or 3.\",\n  \"UI_GROUP\":\"color\"\n\t},{\n\t\"NAME\": \"color_mode\",\n\t\"TYPE\": \"toggle\",\n\t\"DEFAULT\": 0.0,\n\t\"MIN\": 0.0,\n\t\"MAX\": 1.0,\n\t\"DESCRIPTION\": \"OFF is normal. ON is grainy and inverse.\",\n  \"UI_GROUP\":\"color\"\n\t},{\n\t\"NAME\": \"zoom\",\n\t\"TYPE\": \"slider smooth\",\n\t\"DEFAULT\": 1.0,\n\t\"MIN\": 1.0,\n\t\"MAX\": 12.0,\n\t\"PARAMS\": 0.1,\n\t\"DESCRIPTION\": \"Zoom in and out.\",\n  \"UI_GROUP\":\"cells\"\n\t},{\n\t\"NAME\": \"arranged\",\n\t\"TYPE\": \"toggle\",\n\t\"DEFAULT\": 0.0,\n\t\"MIN\": 0.0,\n\t\"MAX\": 1.0,\n\t\"DESCRIPTION\": \"Arrange the spheres randomly (OFF) or on a grid (ON).\",\n  \"UI_GROUP\":\"cells\"\n\t},{\n\t\"NAME\": \"rotation\",\n\t\"TYPE\": \"knob traveler\",\n\t\"DEFAULT\": 0.5,\n\t\"MIN\": -1.0,\n\t\"MAX\": 1.0,\n\t\"PARAMS\": 0.5,\n\t\"DESCRIPTION\": \"Define a rotation direction and amount.\",\n  \"UI_GROUP\":\"motion\"\n\t},{\n\t\"NAME\": \"xyPos\",\n\t\"TYPE\": \"xy traveler\",\n\t\"DEFAULT\": 0.5,\n\t\"MIN\": -1.0,\n\t\"MAX\": 1.0,\n\t\"PARAMS\": 0.5,\n\t\"DESCRIPTION\": \"Define a direction for the spheres to move.\",\n  \"UI_GROUP\":\"motion\"\n\t},{\n\t\"NAME\": \"feedback\",\n\t\"TYPE\": \"slider\",\n\t\"DEFAULT\": 1.0,\n\t\"MIN\": 1.0,\n\t\"MAX\": 0.0,\n\t\"DESCRIPTION\": \"Add a motion blur effect. 100% will freeze the scene. 0% is no blur.\",\n  \"UI_GROUP\":\"feedback\"\n\t}]\n}\n","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"float time = syn_HighTime * 0.6;\nfloat cameratime = syn_Time * 0.25;\nfloat shake = syn_BassLevel+syn_BassHits;\nfloat darken = syn_BassPresence;\nfloat size = syn_BassLevel;\nfloat fade = syn_FadeInOut;\n\nvec3 palette(float i){\n\n    float T = 1400. + 1300.*i;\n    vec3 spec =  vec3(7.4, 5.6, 4.4);\n    vec3 spec1 = vec3(4.4, 5.6, 7.4);\n    vec3 spec2 = vec3(7.4, 4.6, 5.4);\n    vec3 spec3 = vec3(9, 10, 6);\n    vec3 spec4 = vec3(6.0, 5.5, 5.0);\n    spec = mix(spec, spec1, r1);\n    spec = mix(spec, spec2, r2);\n    spec = mix(spec, spec3, r3);\n    spec = mix(spec, spec4, r4);\n    // spec += spec*vec3(-0.0, 0.4, 0.0)*volume*c4;\n    spec = pow(spec,vec3(5.0 - darken)) * (exp(1.43e5/(T*spec))-1.0);\n    return 1.0-exp(-5e8/spec);\n}\n\nvec3 hash(vec3 n) {\n  float p = sin(dot(n, vec3(7, 157, 113)));\n  return fract(vec3(2097152, 262144, 32768)*p);\n}\n\nfloat voronoi(vec3 p){\n  p.z += time - TIME;\n  p*=zoom;\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\n\t// Maximum value\n\tfloat d = 1;\n\n  float levelsFixed = 1000000;\n  if (levels<0.99){\n    levelsFixed = pow(levels,2.0)*100;\n  } \n\n\tfor(float j = -1.; j < 1.01; j++) {\n\t    for(float i = -1.; i < 1.01; i++) {\n\n\t\t    b = vec3(i, j, -1.);\n\t\t    r = b - p + hash(g+b)*(1.0-arranged);\n\t\t    d = min(d, dot(r,r));\n\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash(g+b)*(1.0-arranged);\n\t\t    d = min(d, dot(r,r));\n\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash(g+b)*(1.0-arranged);\n\t\t    d = min(d, dot(r,r));\n\n        d = _pixelate(d, levelsFixed);\n\t    }\n\t}\n\n  d += (c3+c1)*d*5*(1-size);\n  d = pow(d, 0.5 + size/2);\n\n\treturn d;\n}\n\nvec2 shakeUV (vec2 uv) {\n  float amount = smoothstep(0.8, 1.0, shake);\n  vec2 shaker= vec2(\n                    _noise(      time) - 0.5,\n                    _noise(100 + time) - 0.5\n                    ) * 0.1;\n\n  return uv + shaker * amount;\n}\n\nvec4 renderMain() {\n  if (PASSINDEX == 0){\n  \tvec2 uv = _uvc;\n    uv = mix(uv, uv*1.7, r3);\n  \t// uv += (vec2(sin(cameratime), cos(cameratime+1000)) - 0.5)*0.25;\n    uv = shakeUV(uv);\n\n  \tvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.0));\n\n    // rd.xy = _rotate(rd.xy, (1-round(c2))*mod(time*0.25,2*PI));\n    rd.xy = _rotate(rd.xy, -rotation);\n    rd.xy-=xyPos*0.1;\n\n  \tfloat c = voronoi(rd*2);\n\n  \tc = max(c + dot(hash(rd)*2.-1., vec3(0.015)), 0.);\n\n    c *= sqrt(c)*(1.5 + r3);\n    vec3 col = palette(c);\n\n    col = mix(1 - col, col, round(n3 + n2));\n\n    if (color_mode > 0.5){\n      col = 1.0-(col-(dFdx(col)+dFdy(col))*10.0);\n    }\n\n    if (_exists(syn_UserImage)){\n      col = mix(col, 1.0-(col-(dFdx(col)+dFdy(col))*10.0), _loadUserImageAsMask().r);\n    }\n\n  \treturn mix(texture(syn_FinalPass, _uv), vec4(clamp(col * fade, 0., 1.), 1.), pow(feedback,2.0));\n  }\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":0.5,"UNIFORMS":["r0","r1","r2","r3","r4"]},{"DURATION":0.5,"UNIFORMS":["n0","n1","n2","n3"]},{"DURATION":0.5,"UNIFORMS":["c0","c1","c2","c3","c4"]}],"TAGS":[],"TITLE":"Myoplasm","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Replicate the entire system at different zoom levels","MAX":1,"MIN":0,"NAME":"multiplexer_on","TYPE":"toggle","UI_GROUP":"multiplexer"},{"DEFAULT":5,"DESCRIPTION":"Number of layers in the multiplexer","MAX":8,"MIN":2,"NAME":"multiplexer_layers","TYPE":"slider","UI_GROUP":"multiplexer"},{"DEFAULT":0,"DESCRIPTION":"Randomize each layer so they don't align","MAX":1,"MIN":0,"NAME":"randomize_layers","PARAMS":0.0500000007450581,"TYPE":"toggle smooth","UI_GROUP":"multiplexer"},{"DEFAULT":0.5,"DESCRIPTION":"Amount of zoom between each layer","MAX":1,"MIN":0,"NAME":"zoom_power","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"multiplexer"},{"DEFAULT":0.5,"DESCRIPTION":"How fast the layers zoom - negative reverses the direction","MAX":3,"MIN":-3,"NAME":"rate_zoom","TYPE":"knob","UI_GROUP":"multiplexer"},{"DEFAULT":0.0750000029802322,"DESCRIPTION":"Overall speed of particles","MAX":0.200000002980232,"MIN":0,"NAME":"particle_speed","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Particles get new direction to travel every beat hit","MAX":1,"MIN":0,"NAME":"beat_randomizer","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":1,"DESCRIPTION":"Speed controlled by audio or constant","MAX":1,"MIN":0,"NAME":"audio_motion","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Turn up to add in flow","MAX":1,"MIN":0,"NAME":"flow_amount","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"flow"},{"DEFAULT":0,"DESCRIPTION":"Flow direction, up or down","MAX":1,"MIN":-1,"NAME":"vertical_flow","TYPE":"knob","UI_GROUP":"flow"},{"DEFAULT":0,"DESCRIPTION":"Flow zooming in or out","MAX":1,"MIN":-1,"NAME":"flow_in_out","TYPE":"knob","UI_GROUP":"flow"},{"DEFAULT":1,"DESCRIPTION":"Audio reactive flow or constant","MAX":1,"MIN":0,"NAME":"reactive_flow","TYPE":"toggle","UI_GROUP":"flow"},{"DEFAULT":0,"DESCRIPTION":"Use media to choose particle colors","MAX":1,"MIN":0,"NAME":"particle_col","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Use media in a simple multiply blend","MAX":1,"MIN":0,"NAME":"simple_multiply","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Use media as a mask for the flow effect","MAX":1,"MIN":0,"NAME":"feedback_mask","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Audio reactive flashing of the lines between particles","MAX":1,"MIN":0,"NAME":"flashing_lines","TYPE":"toggle","UI_GROUP":"modes"},{"DEFAULT":0,"DESCRIPTION":"Totally different look, monochrome thin connections between all particles","MAX":1,"MIN":0,"NAME":"minimal_mode","TYPE":"toggle","UI_GROUP":"modes"},{"DEFAULT":0,"DESCRIPTION":"TURN THIS ON TO FIX BAD FPS - Reduces particle number which can also give unique looks","MAX":1,"MIN":0,"NAME":"FPS_fewer_particles","TYPE":"toggle","UI_GROUP":"fps_fix"}],"CREDIT":"patu x Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\neuron_proximitors.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Neuron Proximitors","IMAGES":null,"IMAGE_PATH":"neuron_proximitors.synScene\\neuron_proximitors.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Replicate the entire system at different zoom levels\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"multiplexer_on\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"multiplexer\"\n      },{\n         \"DEFAULT\" : 5,\n         \"DESCRIPTION\" : \"Number of layers in the multiplexer\",\n         \"MAX\" : 8,\n         \"MIN\" : 2,\n         \"NAME\" : \"multiplexer_layers\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"multiplexer\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Randomize each layer so they don't align\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"randomize_layers\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"multiplexer\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Amount of zoom between each layer\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"zoom_power\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"multiplexer\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"How fast the layers zoom - negative reverses the direction\",\n         \"MAX\" : 3,\n         \"MIN\" : -3,\n         \"NAME\" : \"rate_zoom\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"multiplexer\"\n      },{\n         \"DEFAULT\" : 0.075,\n         \"DESCRIPTION\" : \"Overall speed of particles\",\n         \"MAX\" : 0.2,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"particle_speed\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"motion\"\n      },{\n         \"DEFAULT\" : 0.00,\n         \"DESCRIPTION\" : \"Particles get new direction to travel every beat hit\",\n         \"MAX\" : 1,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"beat_randomizer\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"motion\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Speed controlled by audio or constant\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"audio_motion\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"motion\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Turn up to add in flow\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flow_amount\",\n         \"PARAMS\":0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"flow\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Flow direction, up or down\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"vertical_flow\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"flow\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Flow zooming in or out\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"flow_in_out\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"flow\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Audio reactive flow or constant\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"reactive_flow\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"flow\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Use media to choose particle colors\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"particle_col\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Use media in a simple multiply blend\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"simple_multiply\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Use media as a mask for the flow effect\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"feedback_mask\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Audio reactive flashing of the lines between particles\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flashing_lines\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"modes\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Totally different look, monochrome thin connections between all particles\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"minimal_mode\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"modes\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"TURN THIS ON TO FIX BAD FPS - Reduces particle number which can also give unique looks\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"FPS_fewer_particles\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"fps_fix\"\n      }\n   ],\n   \"CREDIT\" : \"patu x Meebs\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"neuron_proximitors.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 512,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 5\n      },{\n         \"FLOAT\" : true,\n         \"TARGET\" : \"BuffB\",\n         \"WIDTH\" : 1920,\n         \"HEIGHT\" : 1080\n      },{\n         \"FLOAT\" : true,\n         \"TARGET\" : \"BuffC\",\n         \"WIDTH\" : 1920,\n         \"HEIGHT\" : 1080\n      }\n   ],\n   \"TITLE\" : \"Neuron Proximitors\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":512,"TARGET":"BuffA","WIDTH":5},{"FLOAT":true,"HEIGHT":1080,"TARGET":"BuffB","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"BuffC","WIDTH":1920}],"SCRIPT_CODE":"\nvar time = 0;\n\nfunction update(dt) {\n  time += dt*(-inputs.rate_zoom);\n  uniforms.scr_time = time;\n}\n\nfunction transition() {\n}","SHADER_CODE":"\t\t\t//******** BuffA Code Begins ********\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p , vec2(127.1,311.7));\t\n  return fract(abs(sin(h)*43758.5453123));\n}\n\nvec4 posUpdate(vec4 posVel){\n  vec4 posVelOut = posVel;\n  posVelOut.zw -= 0.5;\n  // posVelOut.zw = _rotate(posVelOut.zw, syn_OnBeat*0.1*beat_randomizer);\n  //Update the velocities to new random velocities for 1/3 of the particles.\n  if ((syn_OnBeat == 1.0)&&(beat_randomizer>0.5)){\n    posVelOut.z = (hash12(posVel.xy + TIME * 47.) / 2. - .5) * 2.;\n    posVelOut.w = (hash12(posVel.xy * 1000.+ TIME * 100.) / 2. - .5) * 4.;\n  }\n  posVelOut.xy += (posVelOut.zw)*particle_speed*particle_speed*mix(1.0, \n  (0.05+pow(syn_Level, 3.0)*0.5+pow(syn_Hits, 3.0)*0.45), audio_motion);\n\n  posVelOut.zw += 0.5;\n  posVelOut.x = mod(posVelOut.x, 16.0/9.0);\n  posVelOut.y = mod(posVelOut.y, 1.0);\n  posVelOut.zw = fract(posVelOut.zw);\n  return posVelOut;\n}\n\n#define NUMPOINTS 72\n\nvec4 renderPassA() {\n\tvec4 C = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    C = vec4(-.5);\n    \n    // buffer texure\n    \n    if (int(fragCoord.y) < NUMPOINTS) {        \n        // float vol = texelFetch(syn_UserImage, ivec2(clamp(fragCoord.y * 2., 0, 768), 0), 0).r;\n        // vol = syn_Hits*0.75;\n        // first column -- position\n        if (int(fragCoord.x) == 0) {        \n            if (FRAMECOUNT < 4) {            \n                // initial position\n                C.x = (hash12(fragCoord.xy) / 2. - .5) * 4.0;\n                C.y = (hash12(fragCoord.yx) / 2. - .5) * 2.;\n\t\t\t\t\n                // initial speed vector\n                C.z = (hash12(fragCoord.xy * C.xy) / 2. - .5) * 2.;\n                C.w = (hash12(C.xy * 1000.+ TIME * 100.) / 2. - .5) * 4.;\n            } else {\n\t\t\t    \t\t// previous frame\n              C = texelFetch(BuffA, ivec2(fragCoord.xy), 0);  \n              C = posUpdate(C);\n            }\n        }\t\n\n        // second column -- nearest point position\n        if (int(fragCoord.x) == 1) {\n            float minDist = 2.;\n            \n            // 1st column \n            vec4 pos = texelFetch(BuffA, ivec2(0, fragCoord.y), 0);\n            pos = posUpdate(pos);\n\n            // test all values stored in 1st column.\n            for (int i = 0; i < NUMPOINTS-48*int(FPS_fewer_particles); i++) {\n            \tvec4 testPos = texelFetch(BuffA, ivec2(0, i), 0);\n              testPos = posUpdate(testPos);\n\n              float d = distance(pos.xy, testPos.xy);\n              if (int(fragCoord.y) == i){\n              \tcontinue;\n              }\n              if (d < minDist) {\n                minDist = d;\n                C.xy = testPos.xy;   \n              }\n\n              \n              // if (d < minDist) {\n              //   if (d < 1. - vol) {\n              //     C.xy = H.xy;\n              //     minDist = d;\n              //     if (dot(G.xy, C.xy) > .5) {\n              //       C.w = 1.;   \n              //     }\n              //     break;\n              //   } else {\n              //     C.xy = G.xy;   \n              //   }\n              // }\n            }\n            \n            C.w -= 0.1;\n            C.w = max(C.w, 0.);\n        }\n        \n        // // third column - copy of sound texture \n        // if (int(fragCoord.x) == 2) {\n        //     C.r = vol;\n        // }\n    }\n    \n    \n\treturn C; \n } \n\n// Fork of \"Buffer computed points.\" by patu. https://shadertoy.com/view/XllBRj\n// http://bit.ly/shadertoy-plugin\n\nfloat SqDistancePtSegment( vec2 a, vec2 b, vec2 p )\n{\n    vec2 \n        pa = p - a, \n        ba = b - a,\n    \td = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    \n    return dot(d, d);\n}\n\nvec4 renderParticles() {\n  vec4 media = _loadUserImage();\n\n\tvec3 col = vec3(0.0);\n\tvec2 fragCoord = _xy;\n\tvec2 uv = fragCoord.xy / RENDERSIZE.xy;\n    \n  uv.x *= RENDERSIZE.x / RENDERSIZE.y;\n    \n  vec2 u = uv;\n  vec3 tex = _loadUserImage().rgb;\n  int numToDraw = NUMPOINTS - 48*int(FPS_fewer_particles);\n  for (int y = 0; y < numToDraw; y++) {\n\n    vec4 c1 = texelFetch(BuffA, ivec2(0, y), 0); // data from bufA 1st column\n    vec4 c2 = texelFetch(BuffA, ivec2(1, y), 0); // data from bufA 2nd column \n\n    int rand1 = y%(numToDraw/2);\n    int rand2 = int(clamp(y+y%3-3, 0, numToDraw));\n    // int rand3 = numToDraw-y;\n    vec4 cr1 = texelFetch(BuffA, ivec2(0, rand1), 0); // data from bufA 2nd column \n    vec4 cr2 = texelFetch(BuffA, ivec2(0, rand2), 0); // data from bufA 2nd column \n    // vec4 cr3 = texelFetch(BuffA, ivec2(0, rand3), 0); // data from bufA 2nd column \n\n    // F += step(distance(_uv, c1.xy), 0.004);\n\n    // c1.x *= RENDERSIZE.x/RENDERSIZE.y;\n    // c2.x *= RENDERSIZE.x/RENDERSIZE.y;\n\n    // float seg = floor(y*6.0/NUMPOINTS);\n    // seg = mod(y+syn_BeatTime, floor(numLines));\n    // float volc = 0.0;\n    // volc += ind0*step(seg, 1);\n    // volc += ind1*step(seg, 2);\n    // volc += 0.5;\n    // volc += ind2*_pulse(float(y), 10.0, 2.0);\n\n    // F = mix(F, vec4(1.0,0.0,0.0,0.0) * 1.1 * volc, smoothstep(0., 1., 1. / length(uv - c1.xy) * .004))*10.0;\n    // F += vec4(0.0,0.0,1.0,0.0) * 1.1 * volc*smoothstep(0., 1., 1. / length(uv - c2.xy) * .0025)*10.0;\n\n    float volc = syn_BassLevel;\n    float pSel = y/float(numToDraw);\n    float pSelNext = (y+1)/float(numToDraw);\n    // vec3 segCol = vec4(_hsv2rgb(vec3(c1.x*0.125 + syn_Time*0.005, syn_HighHits, syn_Hits)),0.0);       \n    // vec4 pCol = vec4(_hsv2rgb(vec3(c1.x*0.2 + syn_Time*0.005, 1.0, 1.0)),0.0);\n    vec3 pCol = mix(vec3(0.0, 1.0, 0.8), vec3(0.0, 0.3, 1.0), 0.5+0.5*sin(pSel*2*PI+syn_BPMTwitcher));\n    vec3 pCol2 = mix(vec3(0.0, 1.0, 0.8), vec3(0.0, 0.3, 1.0), 0.5+0.5*sin((1.0-pSel)*2*PI+syn_BPMTwitcher));\n\n    // segment\n    vec3 segCol = vec3(1.0);\n\n    //Add in Media Colors\n    if (particle_col > 0.5){\n      vec3 col = texture(syn_UserImage, vec2(1.0)*pSel).rgb;\n      pCol = col*2.0;\n      segCol = col*2.0;\n    }\n\n    if (simple_multiply > 0.5){\n      pCol = tex*2.0;\n      segCol = tex*2.0;\n    }\n\n    float thicknessSegments = .000003;\n    if ( minimal_mode < 0.5){\n      float closestSegment = SqDistancePtSegment(c1.xy, c2.xy, uv);\n      float progress = distance(c1.xy, uv)/distance(c1.xy, c2.xy);\n      segCol = mix(pCol, pCol2, progress);\n      // segCol *= pow(_pulse(progress, 0.5, 0.495), 0.5);\n\n      //Give the segments some audio reactivity\n      segCol.rgb = _rgb2hsv(segCol.rgb);\n      segCol.g -= pow(syn_OnBeat, 0.25);\n      segCol.g = clamp(segCol.g, 0.0, 1.0);\n      // segCol.b += syn_Hits*syn_Presence;\n      segCol.rgb = _hsv2rgb(segCol.rgb);\n      col += pCol * 2.5 * smoothstep(0., 1., 1./length(uv - c1.xy)*(0.002));\n      col += segCol * (1. - smoothstep(0.0, thicknessSegments, closestSegment))*mix(1.0, syn_HighHits, flashing_lines); \n    } else {\n      float segR1 = SqDistancePtSegment(c1.xy, cr1.xy, uv);\n      float pR1 = distance(c1.xy, uv)/distance(c1.xy, cr1.xy);\n      float segR2 = SqDistancePtSegment(c1.xy, cr2.xy, uv);\n      float pR2 = distance(c1.xy, uv)/distance(c1.xy, cr2.xy);\n      // segCol = mix(pCol, vec3(1.0), particle_col);\n\n      thicknessSegments = .0000015;\n      float dWall1 = min(min(c1.x,c1.y), min(RENDERSIZE.x/RENDERSIZE.y-c1.x,1.0-c1.y));\n      float dWall2 = min(min(cr1.x,cr1.y), min(RENDERSIZE.x/RENDERSIZE.y-cr1.x,1.0-cr1.y));\n      float dWall3 = min(min(c2.x,c2.y), min(RENDERSIZE.x/RENDERSIZE.y-c2.x,1.0-c2.y));\n      float dWall4 = min(min(cr2.x,cr2.y), min(RENDERSIZE.x/RENDERSIZE.y-cr2.x,1.0-cr2.y));\n      float distWall = pow(min(min(dWall1, dWall2), min(dWall3, dWall4)), 2.0)*16.0;\n      col += mix(vec3(1.0), pCol, particle_col)*2.5 * smoothstep(0., 1., 1./length(uv - c1.xy)*(0.00075+0.0005*sin(_uv.x+cos(_uv.y+syn_HighTime*0.1))))*pow(distWall, 0.5);\n      col += segCol * (1. - smoothstep(0.0, thicknessSegments, segR1))*distWall; \n      col += segCol * (1. - smoothstep(0.0, thicknessSegments, segR2))*distWall; \n      // col += pulse1 * (1. - smoothstep(0.0, thicknessSegments*7.0, segR1)); \n      // col += pulse2 * (1. - smoothstep(0.0, thicknessSegments*7.0, segR2)); \n    }\n  }    \n\n  //midglow\n  // F += vec4(1.0,0.8,0.0,0.0)*(1. - smoothstep(0.0, .00001*syn_Hits, SqDistancePtSegment(c1.xy, c2.xy, uv)));\n\n\n  vec2 offset = vec2(0.0, 0.0);\n  vec2 upVector = vec2(0.0, 1.0);\n  // float noiseVal = snoise(vec3(_uvc*5.0, 0.0));\n  offset -= upVector*0.02*sign(vertical_flow)*vertical_flow*vertical_flow*mix(1.0, syn_BassLevel, reactive_flow);\n  offset += (_uvc+vec2(0.0,-pow(mix(0.0, syn_BassLevel, reactive_flow), 2.0)*0.5))*0.1*flow_in_out;\n\n\n\n  vec4 last = texture(BuffC, _uv+offset);\n  // last.rgb = clamp(_pixelate(last.rgb, 10)-0.1, 0.0, 1.0);\n\n\n  // for (int i = 0; i < 4; i ++){\n  //   last.rgb = _pixelate(last.rgb, 10);\n  // }\n  // last.rgb = _rgb2hsv(last.rgb);\n  // last.g -= 0.01;\n  // last.rgb = _hsv2rgb(last.rgb);\n  col = clamp(col, 0.0, 1.0);\n  vec4 finalCol = vec4(col, 1.0);\n  float mask = mix(1.0, 1.0-step(dot(media.rgb, vec3(1.0))/3.0, 0.5), feedback_mask);\n  finalCol = mix(finalCol, finalCol + last*0.9, 0.99*pow(flow_amount, 0.1)*mask);\n  // F = texelFetch(BuffA, ivec2(_xy*0.08), 0);\n\treturn finalCol; \n } \n\nvec4 renderFeedback(){\n  return texture(BuffB, _uv);\n}\nvec2 _rotateAboutCenter(vec2 uvIn, float amt){\n  vec2 uvNew = uvIn;\n  _uv2uvc(uvNew);\n  uvNew = _rotate(uvNew, amt);\n  _uvc2uv(uvNew);\n  return uvNew;\n}\nvec4 renderMultiLayer(){\n  vec2 mirPos = _uv*2.0;\n\n  if (mirPos.x>1.0){\n    mirPos.x = 1.0-mirPos.x;\n  }\n  if (mirPos.y>1.0){\n    mirPos.y = 1.0-mirPos.y;\n  }\n  int iter = int(multiplexer_layers);\n  vec4 allLayers = vec4(0.0);\n  if (multiplexer_on > 0.5){\n      for (int i = 1; i<iter; i++){\n        float iF = float(i);\n        float lowest = 1.0-step(2.0, iF);\n        float highest = step(iter-1, iF);\n\n        // float layerNum = 4.0/pow(iF, 0.75);\n        // float nextLayerNum = 4.0/pow((iF+1), 0.75);\n        float layerNum = pow(iF, 0.75);\n        float nextLayerNum = pow((iF+1), 0.75);\n        float amtToNext = fract(scr_time);\n        float lowestMix = amtToNext;\n        float highestMix = 1.0-amtToNext;\n        float mixVal = mix(1.0, lowestMix, lowest);\n        mixVal = mix(mixVal, highestMix, highest);\n        // float layerNum = pow(i+1, 2.0);\n        float zoomAmt = mix(1.0, mix(layerNum, nextLayerNum, amtToNext),zoom_power);\n        vec2 randomSpot = vec2(_rand(i-floor(scr_time)),_rand(i+77-floor(scr_time)));\n        vec2 zoomPos = _uv;\n        zoomPos *= zoomAmt;\n        zoomPos += vec2(1.0-zoomAmt)*0.5;\n\n        vec4 layer = texture(BuffC, zoomPos+randomSpot*randomize_layers);\n        allLayers += layer*mixVal;\n      }\n    } else {\n      allLayers = texture(BuffC, _uv);\n    }\n  return allLayers;\n}\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0) {\n\t\treturn renderPassA();\n\t} else if(PASSINDEX == 1) {\n\t\treturn renderParticles();\n\t} else if(PASSINDEX == 2) {\n    return renderFeedback();\n  } else if(PASSINDEX == 3) {\n    return renderMultiLayer();\n  }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Neuron Proximitors","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Turn up to simplify the scene into a few splotches of color.","MAX":1,"MIN":0,"NAME":"simplify","PARAMS":0.25,"TYPE":"slider smooth","UI_GROUP":"zoom"},{"DEFAULT":0,"DESCRIPTION":"'Zooms Out' when turned up, causing a grainy effect like a sandstorm.","MAX":1,"MIN":0,"NAME":"sandstorm","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"zoom"},{"DEFAULT":0,"DESCRIPTION":"Cause the slopes of the texture to highlight on high percussive hits.","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"While ON, pulses emanate outwards synced to the BPM of the song.","MAX":1,"MIN":0,"NAME":"pulsate","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"A radial grid effect that emanates out from the center like rays of energy.","MAX":1,"MIN":0,"NAME":"radial_grid","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Rotates the main texture on the beat when set to ON. Standard slow rotation when set to OFF.","MAX":1,"MIN":0,"NAME":"beat_rotate","TYPE":"toggle","UI_GROUP":"action"}],"CREDIT":"Felix Woitzel","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\nova.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Nova","IMAGES":null,"IMAGE_PATH":"nova.synScene\\nova.png","JSON_CODE":"{\n  \"CREDIT\": \"Felix Woitzel\",\n  \"TITLE\": \"Nova\",\n  \"IMAGE_PATH\": \"nova.jpg\",\n  \"SMOOTH_TRANSITIONS\":[{\n  \"UNIFORMS\":[\"light\", \"dark\"],\n  \"DURATION\": 3\n},{\n  \"UNIFORMS\":[\"cReg1\", \"cReg0\", \"cReg2\", \"cReg3\"],\n  \"DURATION\": 3\n  }],\n  \"PASSES\": [ {\"TARGET\":\"buffA\", \"WIDTH\":960, \"HEIGHT\":540, \"FLOAT\": true},\n  {\"TARGET\":\"buffC\", \"WIDTH\":960, \"HEIGHT\":540, \"FLOAT\": true},\n  {\"TARGET\":\"buffD\", \"WIDTH\":960, \"HEIGHT\":540, \"FLOAT\": true}\n  ],\n  \"CONTROLS\":[\n  {\n    \"NAME\":\"simplify\",\n    \"TYPE\": \"slider smooth\",\n    \"DEFAULT\":0,\n    \"MAX\":1.0,\n    \"MIN\":0.0,\n    \"PARAMS\":0.25,\n    \"DESCRIPTION\": \"Turn up to simplify the scene into a few splotches of color.\",\n    \"UI_GROUP\":\"zoom\"\n  },\n    {\n    \"NAME\":\"sandstorm\",\n    \"TYPE\": \"slider smooth\",\n    \"DEFAULT\":0,\n    \"MIN\":0.0,\n    \"MAX\":1.0,\n    \"PARAMS\":0.4,\n    \"DESCRIPTION\": \"'Zooms Out' when turned up, causing a grainy effect like a sandstorm.\",\n    \"UI_GROUP\":\"zoom\"\n  },\n  {\n    \"NAME\":\"flashing\",\n    \"UI_GROUP\": \"action\",\n    \"TYPE\": \"toggle\",\n    \"DEFAULT\":0,\n    \"DESCRIPTION\": \"Cause the slopes of the texture to highlight on high percussive hits.\"\n  },\n  {\n    \"NAME\":\"pulsate\",\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"action\",\n    \"DEFAULT\":0,\n    \"DESCRIPTION\": \"While ON, pulses emanate outwards synced to the BPM of the song.\"\n  },{\n    \"NAME\":\"radial_grid\",\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"action\",\n    \"DEFAULT\":0,\n    \"DESCRIPTION\": \"A radial grid effect that emanates out from the center like rays of energy.\"\n  },{\n    \"NAME\":\"beat_rotate\",\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"action\",\n    \"DEFAULT\":0,\n    \"DESCRIPTION\": \"Rotates the main texture on the beat when set to ON. Standard slow rotation when set to OFF.\"\n  }\n  ]\n}\n\n","PASSES":[{"FLOAT":true,"HEIGHT":540,"TARGET":"buffA","WIDTH":960},{"FLOAT":true,"HEIGHT":540,"TARGET":"buffC","WIDTH":960},{"FLOAT":true,"HEIGHT":540,"TARGET":"buffD","WIDTH":960}],"SCRIPT_CODE":"","SHADER_CODE":"float bassHits = syn_BassHits;\nfloat highHits = syn_HighHits;\nfloat vuTimeUncorrected = syn_Time;\nfloat bassTimeUncorrected = syn_BassTime;\nfloat randomizerBeat = syn_RandomOnBeat;\nfloat midsAccum = syn_MidLevel;\nfloat beatTimeUncorrected = syn_BeatTime;\nfloat onBeat = syn_OnBeat;\nfloat switchOnBeat = syn_ToggleOnBeat;\nfloat highsAccum = syn_HighLevel;\nfloat bassAccum = syn_BassLevel;\n\nvec3 iResolution = vec3(RENDERSIZE.x, RENDERSIZE.y, 0.0);\nfloat iGlobalTime = TIME*1.0;\nint iFrame = int(TIME*60.0);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\nfloat vuTime = vuTimeUncorrected*6*0.01 + time * 0.05;\nfloat bassTime = syn_BassTime*0.09;\nfloat beatTime = beatTimeUncorrected*6;\n\nvec2 lightPos = vec2(resolution.x*(0.5+0.5*sin(bassTime*2*PI*0.18)),resolution.y*(0.5+0.5*cos(bassTime*2*PI*0.224)));\n\nvec4 iMouse = vec4(lightPos,bassAccum*2.0,1.1);\n\n//General Functions\n\n#define pi2_inv 0.159154943091895335768883763372\n\nfloat sdRoundBox(vec2 p, vec2 b, float r)\n{\n  vec2 q = abs(p) - b;\n  vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n  float d = (m.x > 0.0) ? length(q) : m.y;\n  return d - r;\n}\n\nvec2 lower_left(vec2 uv)\n{\n  return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n  return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n  return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n  return fract((uv - 1.) * 0.5);\n}\n\nvec2 mouseDelta(){\n  vec2 pixelSize = 1. / iResolution.xy;\n  float eighth = 1./8.;\n  vec4 oldMouse = texture(buffD, vec2(7.5 * eighth, 2.5 * eighth));\n  vec4 nowMouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n  if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y &&\n     nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n  {\n    return nowMouse.xy - oldMouse.xy;\n  }\n  return vec2(0.);\n}\n\nfloat border(vec2 domain, float thickness){\n  vec2 uv = fract(domain-vec2(0.5));\n  uv = min(uv,1.-uv)*2.;\n  return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\nvec2 rot90(vec2 vector){\n  return vector.yx*vec2(1,-1);\n}\n\nvec2 wrap_flip(vec2 uv){\n  return vec2(1.)-abs(fract(uv*(.5-simplify*0.4))*2.-1.);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n  return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n  vec2 rot = vec2(cos(ang), sin(ang))*zoom;\n  return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n  vec2 uv = domain - center;\n  float d = length(uv);\n  return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n  return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n              numerator.y*denominator.x - numerator.x*denominator.y)/\n  vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n  return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n  return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n  return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n  return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpf1lter(vec2 uv, vec2 pos, float size, float ramp)\n{\n  return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n  vec2 pos_correct = 0.5 + (pos - 0.5);\n  vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n  float f1lter = warpf1lter(uv, pos_correct, size, ramp);\n  return mix(uv, rot_uv, f1lter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n  float ramp = 4.;\n\n  float d = 0.125;\n\n  float l = length(vel);\n  vec2 p1 = pos;\n  vec2 p2 = pos;\n\n  if(l > 0.){\n    vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n    p1 = pos - normal * d / 2.;\n    p2 = pos + normal * d / 2.;\n  }\n\n  float w = l / d * 2.;\n\n  // two overlapping rotations that would annihilate when they were not displaced.\n  vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n  vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n  return (circle1 + circle2) / 2.;\n}\n\n  vec4 loadUserImageZoomed(vec2 offset, float zoom) {\n    vec2 uv = _correctImageCoords(textureSize(syn_UserImage, 0));\n    uv *= zoom;\n    uv -= 1/zoom;\n    \n    vec4 tempCol = _invertImage(_imageToMask(texture(syn_UserImage, uv+offset)));\n\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.y > 1.0 || uv.x > 1.0) {\n      return _invertImage(vec4(0.0));\n    }\n    \n    return tempCol;\n  }\n\n\n// ****************** PASS 0 ***********************\nvec4 BlurA(vec2 uv, int level)\n{\n  if(level <= 0)\n  {\n    return texture(buffA, fract(uv));\n  }\n\n  uv = upper_left(uv);\n  for(int depth = 1; depth < 8; depth++)\n  {\n    if(depth >= level)\n    {\n      break;\n    }\n    uv = lower_right(uv);\n  }\n\n  return texture(buffD, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n  vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n  vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n  return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n  vec2 pixelSize = 1. / iResolution.xy;\n\n  float center_f1lter = smoothcircle(uv, aspect, 0.1, 32.*(1.4-syn_HighPresence*0.4-0.4*syn_MidPresence));\n\n  float ang = (bassTime*0.06+syn_BPMTwitcher*0.06*beat_rotate)/pi2_inv;\n  float scale = mix(3., 18., center_f1lter);\n\n  vec2 rot = vec2(cos(ang), sin(ang));\n  vec2 offset = vec2(pow(sandstorm,3.0)*1000);\n\n  vec2 uv_carpet = 0.5 + complex_mul((uv - 0.5)*aspect, rot*scale)/aspect;\n  uv_carpet = wrap_flip(uv_carpet + vec2(1.0)-_uvc*offset*0.1);\n\n\n  float carpet_circle = circle(uv_carpet, aspect, 4.);\n\n\n  // blue is fed by a carpet-mirrored circle and a carpet-transformed texture feedback of itself\n  fragColor.b = BlurA(uv_carpet, 0).b * mix(0.75, 1., center_f1lter) + mix(0., 0.5, center_f1lter*highHits);\n  fragColor.b = mix(fragColor.z, 1., carpet_circle);\n\n  // green is pretty much like blue but with a steeper fall-off, and heavier zoom\n\n  scale = mix(4., 64., center_f1lter);\n  vec2 uv_galaxies = 0.5 + complex_mul((uv - 0.5)*aspect, rot*scale)/aspect;\n  uv_galaxies = wrap_flip(uv_galaxies + offset);\n\n  float bleedAmt = 0.5;\n  fragColor.g = pow(texture(buffA, _uv).g*(0.5+highHits*0.8)+BlurA(uv_galaxies, 0).b*bleedAmt,2.0);\n\n  fragColor.g = mix(fragColor.g, 0.2, center_f1lter);\n\n  // red is fed by green\n  vec2 uv_zoom_mix = 0.5 + (uv - 0.5)* mix(0.985, 1.0, center_f1lter);\n\n  fragColor.r = BlurA(uv_zoom_mix, 0).x*mix(0.925, 0.0, center_f1lter) - mix(0.02, 0.35, center_f1lter);\n  fragColor.r = mix(fragColor.x, 1.,(1.-center_f1lter) * fragColor.y*(1.0-highHits));\n\n  if (_exists(syn_UserImage)){\n    vec4 tempCol = loadUserImageZoomed(vec2(0.0),2.0);\n    tempCol *= pow(center_f1lter,2.0);\n    // fragColor = mix(fragColor+tempCol, fragColor*tempCol, syn_BassLevel);\n    fragColor += tempCol*(syn_BassLevel*0.2+0.4*syn_BassPresence+0.3);\n  }\n\n  fragColor = clamp(fragColor, 0., 1.);\n\n}\n\n\n// *************** PASS 1 *****************\n//NOT USED, placeholder because shadertoy had it\n\n\n// *************** PASS 2 *****************\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n  float h = scale / iResolution.x;\n  vec4 sum = vec4(0.0);\n\n  sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n  sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n  sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n  sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n  sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n  sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n  sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n  sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n  sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n  return sum/0.98; // normalize\n}\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 uv_half = fract(uv*2.);\n  fragColor = blur_horizontal(buffA, uv_half, 1.);\n}\n\n\n// *************** PASS 3 *****************\n// vertical blur (second pass)\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n  float v = 1. / iResolution.y;\n  vec4 sum = vec4(0.0);\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n  sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n  return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n  float v = 1. / iResolution.y;\n  vec4 sum = vec4(0.0);\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n  sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n  return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n  float v = pow(2., float(depth)) / iResolution.y;\n\n  vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n  uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n  uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n  uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n  uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n  uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n  uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n  uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n  uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n  uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n  if(uv.y > 0.5)\n  {\n    uv1 = upper_left(uv1);\n    uv2 = upper_left(uv2);\n    uv3 = upper_left(uv3);\n    uv4 = upper_left(uv4);\n    uv5 = upper_left(uv5);\n    uv6 = upper_left(uv6);\n    uv7 = upper_left(uv7);\n    uv8 = upper_left(uv8);\n    uv9 = upper_left(uv9);\n  }\n  else{\n    uv1 = lower_left(uv1);\n    uv2 = lower_left(uv2);\n    uv3 = lower_left(uv3);\n    uv4 = lower_left(uv4);\n    uv5 = lower_left(uv5);\n    uv6 = lower_left(uv6);\n    uv7 = lower_left(uv7);\n    uv8 = lower_left(uv8);\n    uv9 = lower_left(uv9);\n  }\n\n  for(int level = 0; level < 8; level++)\n  {\n    if(level > depth)\n    {\n      break;\n    }\n\n    uv1 = lower_right(uv1);\n    uv2 = lower_right(uv2);\n    uv3 = lower_right(uv3);\n    uv4 = lower_right(uv4);\n    uv5 = lower_right(uv5);\n    uv6 = lower_right(uv6);\n    uv7 = lower_right(uv7);\n    uv8 = lower_right(uv8);\n    uv9 = lower_right(uv9);\n  }\n\n  vec4 sum = vec4(0.0);\n\n  sum += texture(buffC, uv1) * 0.05;\n  sum += texture(buffC, uv2) * 0.09;\n  sum += texture(buffC, uv3) * 0.12;\n  sum += texture(buffC, uv4) * 0.15;\n  sum += texture(buffC, uv5) * 0.16;\n  sum += texture(buffC, uv6) * 0.15;\n  sum += texture(buffC, uv7) * 0.12;\n  sum += texture(buffC, uv8) * 0.09;\n  sum += texture(buffC, uv9) * 0.05;\n\n  return sum/0.98; // normalize\n}\n\nvoid mainImage3( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 uv_orig = uv;\n  vec2 uv_half = fract(uv*2.);\n  if(uv.x < 0.5)\n  {\n    if(uv.y > 0.5)\n    {\n      fragColor = blur_vertical_upper_left(buffC, uv_half);\n    }\n    else\n    {\n      fragColor = blur_vertical_lower_left(buffC, uv_half);\n    }\n  }\n  else\n  {\n    for(int level = 0; level < 8; level++)\n    {\n      if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n      {\n        break;\n      }\n      vec2 uv_half = fract(uv*2.);\n      fragColor = blur_vertical_left_column(uv_half, level);\n      uv = uv_half;\n    }\n  }\n  uv = uv_orig;\n  float eighth = 1./8.;\n  if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n  {\n    fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n  }\n}\n\n\nvec2 pattern(vec2 p)\n{\n  p = fract(p);\n  float r = 10.123;\n  float v = 0.0, g = 0.0;\n  r = fract(r * 9184.928);\n  float cp, d;\n\n  d = p.x;\n  g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n  d = p.y;\n  g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n  d = p.x - 1.0;\n  g += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n  d = p.y - 1.0;\n  g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\n  const int iter = 12;\n  for(int i = 0; i < iter; i ++)\n  {\n    cp = 0.5 + (r - 0.5) * 0.9;\n    d = p.x - cp;\n    g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n    if(d > 0.0) {\n      r = fract(r * 4829.013);\n      p.x = (p.x - cp) / (1.0 - cp);\n      v += 1.0;\n    }\n    else {\n      r = fract(r * 1239.528);\n      p.x = p.x / cp;\n    }\n    p = p.yx;\n  }\n  v /= float(iter);\n  return vec2(g, v);\n}\n\n// *************** PASS 4 *****************\nvoid mainImage4(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 pixelSize = 1. / iResolution.xy;\n  vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n\n  float flowVel = 0.01;\n  vec2 flowVector = vec2(sin((onBeat)*PI*2.0+beatTime), cos((onBeat)*PI*2.0+beatTime))*flowVel;\n\n  vec2 grad1_z = GradientA(uv, pixelSize*2., vec4(0,0,0.15,0), 1);\n  float center_f1lter = smoothcircle(uv-grad1_z*10.0, aspect, 0.1, 32.);\n\n  vec2 tempVec2 = wrap_flip(uv+grad1_z*highHits);\n  vec2 grad0_z = GradientA(tempVec2, pixelSize, vec4(0,0,8,0), 0);\n\n\n  // float cReg0 = -0.001;\n  // float cReg1 = 1.0;\n  // float cReg2 = -0.001;\n  // float cReg3 = -0.001;\n  // float dark = 0.0;\n  // float light = 1.0;\n\n  vec3 baseCol = vec3(1.4,1.2,0.2);\n  vec3 galaxyCol = vec3(0.0, 0.85, 0.85);\n  vec3 subAddColor = vec3(0.50,0.70,0.75);\n  vec3 bleed = vec3(0.6,0.8,0.8);\n  vec3 fineStructure = vec3(0.282, 0.380, 0.209);\n  vec3 depthGalaxies = vec3(0.9);\n\n  // *** Color Regime 1 ***\n  baseCol = mix(baseCol, vec3(0.45,0.75,1.0), cReg1);\n  galaxyCol = mix(galaxyCol, vec3(1.0,0.7,0.2), cReg1);\n  subAddColor = mix(subAddColor, vec3(0.0,0.0,0), cReg1);\n  bleed = mix(bleed, vec3(1,1,0), cReg1);\n  fineStructure = mix(fineStructure, vec3(0.0,0.0,0.0), cReg1);\n  depthGalaxies = mix(depthGalaxies, vec3(0.2,0.2,0.8), cReg1);\n\n  // *** Color Regime 2 ***\n  baseCol = mix(baseCol, vec3(0.0), cReg2);\n  galaxyCol = mix(galaxyCol, vec3(0.45,0.1,1.0), cReg2);\n  subAddColor = mix(subAddColor, vec3(0.25,0.55,1.0), cReg2);\n  bleed = mix(bleed, vec3(0.25,0.55,1.0), cReg2);\n  fineStructure = mix(fineStructure, vec3(1.0,1.0,1.0), cReg2);\n  depthGalaxies = mix(depthGalaxies, vec3(0.0,0.3,0.8), cReg2);\n\n  // *** Color Regime 3 ***\n  baseCol = mix(baseCol, vec3(0.0,0.0,0.0), cReg3);\n  galaxyCol = mix(galaxyCol, vec3(0.9,0.5,0.0), cReg3);\n  subAddColor = mix(subAddColor, vec3(0.0,0.5,0.0), cReg3);\n  bleed = mix(bleed, vec3(1.0,0.8,0.0), cReg3);\n  fineStructure = mix(fineStructure, vec3(1.0,1.0,1.0), cReg3);\n  depthGalaxies = mix(depthGalaxies, vec3(1.0,0.7,0.00), cReg3);\n\n  galaxyCol *= (0.5+0.5*syn_BassPresence);\n  // bleed *= center_f1lter;\n\n  vec3 finalColor = vec3(0.0);\n\n  finalColor = mix(finalColor, baseCol, 1.-BlurA(uv + grad0_z*0., 0).x*10.0); //General base background\n\n  finalColor = mix(finalColor, galaxyCol, BlurA(uv - grad1_z*highHits, 0).b); // Galaxies/Neurons\n\n  finalColor = finalColor+mix(vec3(-1), vec3(0.5,0.2,0.5), dark)*subAddColor*length(grad0_z); //Subtract or Add\n\n  finalColor -= dot(grad0_z,vec2(1.0))*syn_HighHits*flashing;\n\n  finalColor = mix(finalColor, bleed, BlurA(uv + grad1_z*5.0, 0).x); // Darkness bleeding away from teal\n\n  vec3 backPat = vec3(1.) * BlurA(uv - GradientA(uv, pixelSize*2., vec4(0,0,2,0), 1), 0).z*(1.-center_f1lter);\n  \n\n  vec2 sqPat = pattern(_toPolar((uv-0.5)*1.0*vec2(resolution.x/resolution.y,1.0))+backPat.x*0.05+ flowVector);\n  float pulseTime = fract(length(_uvc)-syn_BPMTri2/syn_BPMConfidence + sqPat.x*0.01)*0.5;\n  float pulse = smoothstep(0.0,0.2,pulseTime)-smoothstep(0.2,0.3,pulseTime);\n\n  float floatSqPat = step(1.4, sqPat.x)*(1.-center_f1lter)*pulse*radial_grid;\n  finalColor = mix(finalColor, fineStructure*floatSqPat,  BlurA(uv, 0).g*floatSqPat - clamp(center_f1lter*1.15-0.25, 0., 1.)); //Fine Structure\n\n  finalColor += floatSqPat*syn_Presence*1.0;\n\n  finalColor = mix(finalColor, depthGalaxies, BlurA(uv - GradientA(uv, pixelSize*2.5, vec4(0,0,3.5,0), 1), 0).z*(1.-center_f1lter)*(1.25-center_f1lter*1.)-0.5); // Depth to Galaxies\n\n  // finalColor = mix(finalColor*0.9, finalColor, center_f1lter*bassAccum);\n\n  float vignetteMod = sdRoundBox(2*(_uv-0.5), vec2(0.6), 0.1);//Magic num 0.2 for nice edges\n  finalColor = finalColor*smoothstep(0.5,1.0,1.0-vignetteMod);//Generate Vignette Modifier\n\n  float pulseTime2 = fract(length(_uvc)-syn_BPMTri2/syn_BPMConfidence + pow(length(clamp(finalColor,0.0,1.0)),10.0)*0.01)*0.5;\n  float pulse2 = smoothstep(0.0,0.2,pulseTime2)-smoothstep(0.2,0.28,pulseTime2);\n\n  finalColor = mix(finalColor, finalColor*pulse2, pulsate);\n\n  fragColor = vec4(finalColor, 1.0);\n\n}\n\n\n\nvec2 getNormPos() {\n  return vec2(-1+2*(gl_FragCoord.x/resolution.x),-1+2*(gl_FragCoord.y/resolution.y));\n}\nvec2 getNormPosBotLeft() {\n  return vec2(gl_FragCoord.xy/resolution.xy);\n}\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    //buffA\n    vec4 fragColor;\n    mainImage0(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  // else if (PASSINDEX == 1.0){\n  //   //buffB\n  //   vec4 fragColor;\n  //   mainImage1(fragColor, gl_FragCoord.xy);\n  //   return fragColor;\n  // }\n  else if (PASSINDEX == 1.0){\n    //buffC\n    vec4 fragColor;\n    mainImage2(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 2.0){\n    //buffD\n    vec4 fragColor;\n    mainImage3(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 3.0){\n    //Image\n    vec4 fragColor;\n    mainImage4(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":3,"UNIFORMS":["light","dark"]},{"DURATION":3,"UNIFORMS":["cReg1","cReg0","cReg2","cReg3"]}],"TAGS":[],"TITLE":"Nova","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.00999999977648258,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00999999977648258,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"rot","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\opartexp1.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"OpArtExp1","IMAGES":null,"IMAGE_PATH":"opartexp1.synScene\\opartexp1.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.01,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.01,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"rot\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"opartexp1.png\",\n\t\"TITLE\" : \"OpArtExp1\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n\nvec2 bipolar(vec2 p,float a, float b){\n     \n    float alpha = a*a - dot(p,p);\n    float beta = a*a + dot(p,p);\n    float gamma = sqrt(alpha*alpha - 4.0*p.y*p.y*a*a);\n    float sigma = atan( 2.0*a*p.y ,alpha + b*gamma );\n    float tau = 0.5*log((beta + 2.0*a*p.x)/(beta - 2.0*a*p.x));\n    \n    return vec2(sigma,tau);\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tfloat time = TIME*rate;\n    vec2 p = (_xy.xy - 0.5*RENDERSIZE.xy) / RENDERSIZE.y;\n\t\n    //rotate\n   float rotationRate = rot;\n   float s = sin(rotationRate*time);\n   float c = cos(rotationRate*time);\n   p = mat2(c,s,-s,c)*p;\n    \n    vec2 bp = bipolar(p,0.3, 1.0 + sin(time));\n    float osc = bp.x + bp.y;\n\t\n    vec3 color = vec3(sin(15.0*osc + 10.0*time));\n   \n \tout_FragColor  = vec4(color,1.0);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"OpArtExp1","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"x_mod","TYPE":"slider","UI_GROUP":"xy"},{"DEFAULT":1,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"y_mod","TYPE":"slider","UI_GROUP":"xy"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"pop","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"action"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\PLUS.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"type","VALUES":[0,1,2]},{"UNIFORM":"resoMod","VALUES":[0,10,20,30]}],"HEIGHT":1080,"ID":"PLUS","IMAGES":null,"IMAGE_PATH":"PLUS.synScene\\PLUS.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"PLUS\",\n \"IMAGE_PATH\": \"PLUS.png\",\n \"HARD_TRANSITIONS\": [\n {\"UNIFORM\": \"type\", \"VALUES\":[0.0, 1.0, 2.0]},\n {\"UNIFORM\": \"resoMod\", \"VALUES\":[0.0,10.0,20.0,30.0]}],\n \"IMAGES\": [],\n \"PASSES\": [],\n \"CONTROLS\": [{\n    \"NAME\": \"x_mod\",\n    \"MAX\" : 3.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"xy\"\n  },{\n    \"NAME\": \"y_mod\",\n    \"MAX\" : 3.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"xy\"\n  },{\n    \"NAME\": \"pop\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.2,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"action\"\n  }]\n }","PASSES":null,"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nvar bpmcount = new BPMCounter();\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM;\n  bpmcount.updateTime(bpm, dt);\n\n  if (bpmcount.didIncrement == 1.0){\n    tAtLast0 = t;\n  }\n  t = tAtLast0;\n  t += (1. - Math.exp(-bpmcount.timeWithinBeat*9.))*inputs.syn_Presence;\n  uniforms.script_time = t;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"\n#line 0\n\nfloat reso = 30+resoMod;\n\n\nvec3 quadTree()\n{\n    vec2 pos = _xy;\n    float H = RENDERSIZE.y;\n    pos /= H;\n    pos.x -= 0.5*RENDERSIZE.x/RENDERSIZE.y;\n    pos *= reso*0.05;\n    pos = abs(pos);\n\n    vec4 retCol = vec4(0.0);\n    float r = 0.1; \n    float t = TIME;\n    vec2 objPos = (0.5+0.5*vec2(cos(t),sin(t)));\n    vec2 fU;\n\n    pos *= 0.5;\n    objPos *= 0.5;                         // unzoom for the whole domain falls within [0,1]^n\n    \n    float cellWarmth = 0.0;\n    \n    for (int i=0; i<7; i++) {             // to the infinity, and beyond ! :-)\n        fU = min(pos,1.-pos); \n        if (min(fU.x,fU.y) < 20.*r/H) { //cell border thickness\n            retCol--; \n            break; // cell border\n        } \n        if (length(objPos-.5) - r > .7){\n            break; // cell is out of the shape\n        }\n\n        // --- iterate to child cell\n        fU = step(.5,pos);                 // select child\n        pos    = (2.0)*pos - fU;              // go to new local frame\n        objPos = (2.0)*objPos - fU;  \n        r *= (2.0);\n        \n        cellWarmth += .1;                         // getting closer, getting hotter\n        pos -= abs((-1.0+i*2.0)*pos*0.1);\n    }\n               \n    float objDraw = smoothstep(.3,1.,length(objPos-pos)/r); // draw object\n    return vec3(cellWarmth,0.0, 1.0-objDraw);\n}\n\n\nvec4 firstPass(){\n    // vec2 crossPos = abs(_uvc*20)+1/20.0;\n    vec2 crossPos = abs(_uvc*reso);\n    crossPos = abs(-1+mod(crossPos,2));\n    if (type>0.5){\n        crossPos *= vec2(1.0 - length(_uvc));\n    } else if (type>1.5){\n        crossPos *= vec2(1.0 - fract(length(_uvc)*10.0));\n    } else {\n        //normal\n    }\n\n    crossPos *= vec2(x_mod,y_mod);\n\n    vec2 uvc = _uvc;\n    uvc.x = abs(uvc.x);\n    // if (_uv.x > 0.5){\n    //     uvc.x = 0.5-(-uvc.x+0.5);\n    // }\n\n    vec2 rotPos = _rotate(crossPos, PI/4);\n    float sizeMod = mix(pow(-0.5+_fbm(vec3(_pixelate(uvc,reso),syn_Time*0.15)),1.0),1.0+length(_uvc),pop);\n    float growMod = pow(-0.5+_fbm(vec3(_pixelate(uvc,reso),syn_Time)),1.0);\n\n    float crossGrow = syn_HighHits*0.5+growMod;\n    float crossPattern = step(crossPos.x,0.3+crossGrow)*step(crossPos.y,0.3+crossGrow);\n\n    crossPattern = ((crossPos.y > (1.2+sizeMod*20.0)/reso)&&(crossPos.x > (1.2+sizeMod*20.0)/reso)) ? 0.0 : crossPattern;\n\n    vec3 crosses = vec3(crossPattern);\n\n    if (syn_MediaType > 0.5){\n        crosses *= _loadUserImage().rgb;\n    }\n\n    return vec4(crosses, 0.0);\n}\n\nvec4 renderMain()\n{\n    return firstPass();\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"PLUS","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Toggle this on the beat to set the BPM of the animation","MAX":1,"MIN":0,"NAME":"TOGGLE_ON_BEAT","TYPE":"toggle","UI_GROUP":"BPM_TAP"},{"DEFAULT":1,"DESCRIPTION":"Rotates the dispersion direction with the Bass","MAX":1,"MIN":0,"NAME":"bass_rotate","TYPE":"toggle","UI_GROUP":"dispersion"},{"DEFAULT":1,"DESCRIPTION":"Adds an extra fuzz to the dispersion","MAX":1,"MIN":0,"NAME":"extra_noise","TYPE":"toggle","UI_GROUP":"dispersion"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Power of the dispersion","MAX":0.400000005960464,"MIN":-0.400000005960464,"NAME":"dispersion_amount","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"dispersion"},{"DEFAULT":0.5,"DESCRIPTION":"Contrast applied during the dispersion effect","MAX":1,"MIN":0,"NAME":"dispersion_contrast","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"dispersion"},{"DEFAULT":0,"DESCRIPTION":"Adds in extra brightness if the scene is too dark","MAX":2,"MIN":0,"NAME":"extra_brightness","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"dispersion"},{"DEFAULT":0,"DESCRIPTION":"Adds some twitchy motion when the bass hits","MAX":1,"MIN":0,"NAME":"bass_twitcher","PARAMS":0.400000005960464,"TYPE":"knob smooth","UI_GROUP":"shape"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"Thickness of the lines in the shape","MAX":1,"MIN":0,"NAME":"stroke_thickness","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":1.39999997615814,"DESCRIPTION":"Overall size of the shape","MAX":2,"MIN":0,"NAME":"radius","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"Adds more fuzz to the shape","MAX":1,"MIN":0,"NAME":"fuzz_shape","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"fuzz"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"Adds audio reactive fuzz to the shape","MAX":1,"MIN":0,"NAME":"fuzz_high_hits","PARAMS":0.400000005960464,"TYPE":"slider smooth","UI_GROUP":"fuzz"},{"DEFAULT":1,"DESCRIPTION":"Adds media color into the scene","MAX":1,"MIN":0,"NAME":"media_on","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0.5,"DESCRIPTION":"Allow the shape to mask the media","MAX":1,"MIN":0,"NAME":"mask_shape","TYPE":"slider","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Allow the shape to affect the media's dispersion","MAX":1,"MIN":0,"NAME":"shape_affect_media","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Allow the media to affect its own dispersion","MAX":1,"MIN":0,"NAME":"media_affect_dispersion","TYPE":"toggle","UI_GROUP":"media"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\primitiv_logik.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"PRIMITIV_logik","IMAGES":null,"IMAGE_PATH":"primitiv_logik.synScene\\primitiv_logik.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.0,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"TOGGLE_ON_BEAT\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"BPM_TAP\",\n         \"DESCRIPTION\":\"Toggle this on the beat to set the BPM of the animation\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"bass_rotate\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"dispersion\",\n         \"DESCRIPTION\":\"Rotates the dispersion direction with the Bass\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"extra_noise\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"dispersion\",\n         \"DESCRIPTION\":\"Adds an extra fuzz to the dispersion\"\n      },{\n         \"DEFAULT\" : 0.2,\n         \"MAX\" : 0.4,\n         \"MIN\" : -0.4,\n         \"NAME\" : \"dispersion_amount\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"dispersion\",\n         \"DESCRIPTION\":\"Power of the dispersion\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"dispersion_contrast\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"dispersion\",\n         \"DESCRIPTION\":\"Contrast applied during the dispersion effect\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"extra_brightness\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"dispersion\",\n         \"DESCRIPTION\":\"Adds in extra brightness if the scene is too dark\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"bass_twitcher\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"shape\",\n         \"DESCRIPTION\":\"Adds some twitchy motion when the bass hits\"\n      },{\n         \"DEFAULT\" : 0.4,\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"stroke_thickness\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"shape\",\n         \"DESCRIPTION\":\"Thickness of the lines in the shape\"\n      },{\n         \"DEFAULT\" : 1.4,\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"radius\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"shape\",\n         \"DESCRIPTION\":\"Overall size of the shape\"\n      },{\n         \"DEFAULT\" : 0.3,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"fuzz_shape\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"fuzz\",\n         \"DESCRIPTION\":\"Adds more fuzz to the shape\"\n      },{\n         \"DEFAULT\" : 0.3,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"fuzz_high_hits\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.4,\n         \"UI_GROUP\" : \"fuzz\",\n         \"DESCRIPTION\":\"Adds audio reactive fuzz to the shape\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_on\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\",\n         \"DESCRIPTION\":\"Adds media color into the scene\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"mask_shape\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"media\",\n         \"DESCRIPTION\":\"Allow the shape to mask the media\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"shape_affect_media\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\",\n         \"DESCRIPTION\":\"Allow the shape to affect the media's dispersion\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_affect_dispersion\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\",\n         \"DESCRIPTION\":\"Allow the media to affect its own dispersion\"\n      }\n   ],\n   \"PASSES\":[{\"TARGET\":\"mainRender\"}],\n   \"CREDIT\" : \"Meebs\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"primitiv_logik.png\",\n   \"TITLE\" : \"PRIMITIV_logik\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"mainRender","WIDTH":0}],"SCRIPT_CODE":"\nfunction SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n}\nvar smCount = new SmoothCounter();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar iters = 0;\nvar bassT = 0.0;\n\nfunction syncBouncer () {\n  this.x = 0.0;\n  this.y = 0.0;\n  this.absTime = 0.0;\n  this.intTime = 0.0;\n  this.lastPressAbsTime = 0.0;\n  this.currentFreq = 1.0;\n}\n\nsyncBouncer.prototype.updateBouncer = function(didBounce, dt) {\n  this.absTime += dt;\n  if (didBounce>0.1){\n    this.intTime = 0.0;\n    this.currentFreq = (this.absTime - this.lastPressAbsTime)*0.5;\n    this.lastPressAbsTime = this.absTime;\n  }\n  this.intTime += dt;\n  this.x = 0.5+0.5*Math.sin(this.intTime*3.1415*(1/this.currentFreq));\n  this.y = this.intTime*(1/this.currentFreq);\n\n}\n\nvar myBouncer = new syncBouncer();\nvar changer = 0.0;\nvar lastVal = 0.0;\nvar bouncerTime = 0.0;\nvar decimator = 0;\nfunction update(dt) {\n\n  if (inputs.TOGGLE_ON_BEAT == 1.0 && lastVal == 0.0){\n      changer = 1.0;\n      lastVal = 1.0;\n    } else if (inputs.TOGGLE_ON_BEAT == 0.0 && lastVal == 1.0){\n      changer = 1.0;\n      lastVal = 0.0;\n    }\n    myBouncer.updateBouncer(changer, dt);\n    changer = 0.0;\n    // bouncerTime += myBouncer.x;\n  uniforms.beatTime = myBouncer.y;\n  // decimator++;\n  // if (decimator == 10.0){\n  //   decimator = 0;\n  //   print(myBouncer.y);\n  // }\n  // this.uniforms.bouncerTime = bouncerTime;\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n    return min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n\nfloat pie(vec2 p, float angle)\n{\n    angle = radians(angle) / 2.0;\n    vec2 n = vec2(cos(angle), sin(angle));\n    return abs(p).x * n.x + p.y*n.y;\n}\n\nfloat circleDist(vec2 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat triangleDist(vec2 p, float radius)\n{\n    return max( abs(p).x * 0.866025 + \n                p.y * 0.5, -p.y) \n                -radius * 0.5;\n}\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n    vec2 n = normalize(vec2(height, width / 2.0));\n    return max( abs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n    width /= 2.0;\n    radius -= width;\n    return substract(pie(p, angle), \n                     abs(circleDist(p, radius)) - width);\n}\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n    size -= vec2(radius);\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n    vec2 dir = start - end;\n    float lngth = length(dir);\n    dir /= lngth;\n    vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n    return length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat fuzzyShape(float dist, float fade){\n\tfloat shape = 1.0-pow(smoothstep(0.0, 0.0+fade, dist),6.0);\n\treturn shape;\n}\n\nfloat fuzzyStroke(float dist, float fade, float thickness){\n\tfloat shape = \n    smoothstep(0.0-thickness-fade*0.5, 0.0+fade*0.5, dist)-\n    smoothstep(0.0-fade*0.5, 0.0+thickness+fade*0.5, dist);\n\treturn shape;\n}\n\nfloat _mix3(float col1, float col2, float col3, float mixVal){\n    mixVal *= 2.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    return mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n}\n\nfloat _mix4(float col1, float col2, float col3, float col4, float mixVal){\n    mixVal *= 3.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    float firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    return mix(firstTwo, mix(col3, col4, mix3), step(2.0, mixVal));\n}\nfloat _mix5(float col1, float col2, float col3, float col4, float col5, float mixVal){\n    mixVal *= 4.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    float mix4 = clamp(mixVal-3.0, 0.0, 1.0);\n\n    float firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    float lastTwo = mix(mix(col3, col4, mix3), mix(col4, col5, mix4), step(3.0, mixVal));\n\n    return mix(firstTwo, lastTwo, step(2.0, mixVal));\n}\n\nvec3 renderAllShapes(){\n\tvec2 uv = _uvc;\n\tfloat fuzzer = -0.5+_rand(_uv+TIME);\n    //Fuzzify\n\tuv += fuzzer*_uvc*fuzz_shape*fuzz_shape*fuzz_shape*fuzz_shape*5.0+fuzzer*_uvc*fuzz_high_hits*fuzz_high_hits*syn_HighHits;\n\n    //Origin Twitching on OnBeat\n    vec2 shapeOrigin = uv;\n    vec2 ogOffset = vec2(_statelessContinuousChaotic(syn_BassTime*0.5), _statelessContinuousChaotic(syn_BassTime*0.7))*syn_OnBeat;\n    shapeOrigin += ogOffset*0.1*bass_twitcher*bass_twitcher;\n\n    //Shapes\n\tfloat distCirc = circleDist(shapeOrigin, 0.3*radius);\n\tfloat distTri = triangleDist(shapeOrigin+vec2(0.0,0.18)*radius, 0.5*radius*1.1, 0.4*radius*1.1);\n    float distBox = boxDist(shapeOrigin, vec2(0.25)*radius, 0.0);\n    float distHex = sdHexagon(shapeOrigin, 0.25*radius);\n    //TimeStepping\n    float timeVar = mod(TIME, 4.0);\n    timeVar = mod(beatTime, 4.0);\n    timeVar = floor(timeVar)+pow(fract(timeVar),40.0);\n\tfloat mixShape = _mix5(distCirc, distTri, distHex, distBox, distCirc, timeVar/4.0);\n    //Stroke along SDF\n\tfloat shape = fuzzyStroke(mixShape, 0.0, stroke_thickness*stroke_thickness*stroke_thickness)*(1.0);\n\n\tvec3 col = vec3(shape);\n\tcol += _rand(_uv+77.0-TIME)*0.1*extra_noise;\n\treturn col;\n}\n\n// chromatic dispersion samples\n#define SAMPLES 32\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-mix(4.5, 12.0, dispersion_contrast) * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec4 texMirror(sampler2D samplerIn, vec2 uvIn){\n  if (mod(uvIn.x, 2.0) > 1.0){\n    uvIn.x = 1.0-uvIn.x;\n  }\n  if (mod(uvIn.y, 2.0) > 1.0){\n    uvIn.y = 1.0-uvIn.y;\n  }\n  return texture(samplerIn, uvIn);\n}\n\n\nvec3 sampleDisp(sampler2D mySamp, vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texMirror(mySamp, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\n\nvec4 renderMain(void)\n{\n\tif (PASSINDEX == 0.0){\n\t\treturn vec4(renderAllShapes(), 1.0);\n\t} else if (PASSINDEX == 1.0){\n\t\tvec4 tex = texture(mainRender, _uv);\n        // return tex;\n\t\tfloat lum = clamp(tex.r, 0.0, 1.0);\n        vec2 norm = (_uvc)*vec2(RENDERSIZE.y/RENDERSIZE.x, 1.0);\n\n        float mediaLum = dot(_loadUserImage().rgb, vec3(1.0))/3.0;\n\n        if (shape_affect_media > 0.5){\n            norm += normalize(_rotate(vec2(0.0,1.0),2*PI*lum));\n        }\n        norm += normalize(_rotate(vec2(0.0,1.0),2*PI*mediaLum))*media_affect_dispersion;\n        norm = _rotate(norm, syn_BassTime*bass_rotate*0.25);\n        vec3 finalCol = vec3(0.0);\n        if ((media_on < 0.5)||(syn_MediaType<0.5)){\n            finalCol = sampleDisp(mainRender, _uv, norm, sign(dispersion_amount)*dispersion_amount*dispersion_amount);\n        } else {\n            finalCol = sampleDisp(syn_UserImage, _invertYAxisVideo(_correctImageCoords(textureSize(syn_UserImage, 0))), norm, sign(dispersion_amount)*dispersion_amount*dispersion_amount);\n\n        }\n        finalCol = contrast(finalCol);\n        finalCol *= 1.0+extra_brightness*extra_brightness;\n        finalCol *= _mix3(1.0, 1.0+lum, lum, mask_shape);\n\t\treturn vec4(finalCol, 1.0);\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"PRIMITIV_logik","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[45,45],"DESCRIPTION":"","MAX":[50,50],"MIN":[6,6],"NAME":"grid","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[6,6],"DESCRIPTION":"","MAX":[50,50],"MIN":[6,6],"NAME":"grid2","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[-1,-1],"NAME":"center","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"curve","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"shift","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":270,"DESCRIPTION":"","MAX":1800,"MIN":-900,"NAME":"density","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-0.0500000007450581,"DESCRIPTION":"","MAX":3,"MIN":-3,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":71.3399963378906,"DESCRIPTION":"","MAX":233,"MIN":8,"NAME":"seed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-0.0500000007450581,"DESCRIPTION":"","MAX":10,"MIN":-0.0509999990463257,"NAME":"offset","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"polar_on_bool","TYPE":"toggle","UI_GROUP":"ungrouped"}],"CREDIT":"AxiomCrux.net","DESCRIPTION":"Data Patterns","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\pattern_datablocks_03.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Pattern_DataBlocks_03","IMAGES":null,"IMAGE_PATH":"pattern_datablocks_03.synScene\\pattern_datablocks_03.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t45,\n\t\t\t\t45\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t50,\n\t\t\t\t50\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t6,\n\t\t\t\t6\n\t\t\t],\n\t\t\t\"NAME\" : \"grid\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t6,\n\t\t\t\t6\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t50,\n\t\t\t\t50\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t6,\n\t\t\t\t6\n\t\t\t],\n\t\t\t\"NAME\" : \"grid2\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t],\n\t\t\t\"NAME\" : \"center\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"curve\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"shift\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 270,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1800,\n\t\t\t\"MIN\" : -900,\n\t\t\t\"NAME\" : \"density\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -0.05,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : -3,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 71.34,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 233,\n\t\t\t\"MIN\" : 8,\n\t\t\t\"NAME\" : \"seed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -0.05,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : -0.051,\n\t\t\t\"NAME\" : \"offset\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"polar_on_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"AxiomCrux.net\",\n\t\"DESCRIPTION\" : \"Data Patterns\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"pattern_datablocks_03.png\",\n\t\"TITLE\" : \"Pattern_DataBlocks_03\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"bool polar_on = (polar_on_bool > 0.5); \n\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define TWO_PI 6.28318530718\n#define seed2 seed+218.0\n#define seed1 seed+3578.1\n#define seed3 seed+45378.0\n#define offset1 (offset<5.0)?offset*5.1:1.0\n#define offset2 (offset>5.0)?(offset-5.0)*0.01:0.0\n///////////////////////////////////////////\n// based on :www.patriciogonzalezvivo.com/2015/thebookofshaders/10/ikeda-03.frag from :thebookofshaders.com  by Patricio Gonzalez Vivo\n///////////////////////////////////////////\nfloat ranf(in float x) { return fract(sin(x)*1e4);}\nfloat rant(in vec2 st) { return fract(sin(dot(st.xy, vec2(seed1,seed2)))*seed3);}\nfloat random(in float x){ return fract(sin(x)*seed); } // original value was 43758.5453\nfloat random(in vec2 st){ return fract(sin(dot(st.xy,vec2(seed*0.5,seed*2.0))) * seed); }  // 12.9898,\t78.233,  & 43758.5453\nfloat pattern(vec2 st, vec2 v, float t) {    vec2 p = floor(st+v);    return step(t, rant(100.+p*.000001)+ranf(p.x)*0.5 );}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat randomChar(vec2 outer,vec2 inner){\n    //float grid = grid.x;\n    vec2 margin = grid2; //vec2(xScale,yScale);\n    vec2 borders = step(margin,inner)*step(margin,1.-inner);\n    vec2 ipos = floor(inner*grid.x);\n    vec2 fpos = fract(inner*grid.y);\n    return step(0.5,random(outer*64.+ipos)) * borders.x * borders.y * step(shift,fpos.x) * step(shift,fpos.y);\n}\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n    vec2 st = _xy.xy/RENDERSIZE.xy;\n    st.x *= RENDERSIZE.x/RENDERSIZE.y;\n    //st -= vec2(0.5 * RENDERSIZE.x/RENDERSIZE.y, 0.5);\n\tst -= center;\n \n    vec2 polar ;  \n\t//st -= 0.5;    \n    polar.x = atan(st.x - 0.5, st.y - 0.5) * 5.;\n    polar.y = length(st - 0.5);\n    st = polar_on?mix(st,polar,curve):st;\n    \n    st *= grid;  \n\n    vec2 ipos = floor(st);  \n    vec2 fpos = fract(st); \n                \n//    ipos -= vec2(0.,floor(TIME*rate*random(ipos.x+1.)));\n    \n    vec2 vel = vec2(TIME*rate*max(grid.x,grid.y)); \n    //st *= grid2;   \n    vel *= vec2(-1.,0.0) * ranf(1.0+ipos.y); \n    vel*= grid2;\n    vec2 off1 = vec2(offset1,0.);\n    vec2 off2 = vec2(offset2,0.);\n    \n    vec3 color = vec3(0.0);\n    color.r = pattern(st+off1,vel,0.5+density/RENDERSIZE.x);\n    color.g = pattern(st,vel,0.5+density/RENDERSIZE.x);\n    color.b = pattern(st-off2,vel,0.5+density/RENDERSIZE.x); \n    color *= step(shift,fpos.y);\n    out_FragColor = vec4(color,1.0);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Pattern_DataBlocks_03","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.75,"DESCRIPTION":"Affects the dither. Low will be fewer bright pixels, high will be no dithering at all.","MAX":2,"MIN":0.100000001490116,"NAME":"dither_mod","TYPE":"slider","UI_GROUP":"pixels"},{"DEFAULT":2.40000009536743,"DESCRIPTION":"Sets the size of the pixels for the dither effect.","MAX":8,"MIN":0.75,"NAME":"size","TYPE":"slider","UI_GROUP":"pixels"},{"DEFAULT":0,"DESCRIPTION":"Mixes between two patterns: low is the simple shapes, high is the smooth gradient shape with lots of motion.","MAX":1,"MIN":0,"NAME":"pattern_mixer","TYPE":"slider","UI_GROUP":"pattern"},{"DEFAULT":[0.300000011920929,0.600000023841858,0.800000011920929],"DESCRIPTION":"Define one of the two colors that make up the palette.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"color_1","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":[1,0.800000011920929,0.200000002980232],"DESCRIPTION":"Define the second color. Most colors will fall between these two, but will always be more heavily saturated.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"color_2","TYPE":"color","UI_GROUP":"color"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\pop.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"direction","VALUES":[-1,1]},{"UNIFORM":"sides","VALUES":[1,3,6]},{"UNIFORM":"colRegime","VALUES":[0,1]}],"HEIGHT":1080,"ID":"Pop","IMAGES":null,"IMAGE_PATH":"pop.synScene\\pop.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Pop\",\n \"IMAGE_PATH\": \"pop.jpg\",\n \"HARD_TRANSITIONS\": [\n {\n \"UNIFORM\": \"direction\",\n \"VALUES\":[-1.0,1.0]\n },\n {\n \"UNIFORM\": \"sides\",\n \"VALUES\":[1.0,3.0,6.0]\n },\n {\n \"UNIFORM\": \"colRegime\",\n \"VALUES\":[0.0,1.0]\n }\n ],\n \"PASSES\": [ {\"TARGET\": \"firstBuffer\"},{\"TARGET\": \"secondBuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"dither_mod\",\n    \"MAX\" : 2.0,\n    \"MIN\" : 0.1,\n    \"DEFAULT\":0.75,\n    \"DESCRIPTION\": \"Affects the dither. Low will be fewer bright pixels, high will be no dithering at all.\",\n    \"UI_GROUP\":\"pixels\"\n  },{\n    \"NAME\": \"size\",\n    \"MAX\" : 8.0,\n    \"MIN\" : 0.75,\n    \"DEFAULT\":2.4,\n    \"DESCRIPTION\": \"Sets the size of the pixels for the dither effect.\",\n    \"UI_GROUP\":\"pixels\"\n  },{\n    \"NAME\": \"pattern_mixer\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\":\"slider\",\n    \"DESCRIPTION\": \"Mixes between two patterns: low is the simple shapes, high is the smooth gradient shape with lots of motion.\",\n    \"UI_GROUP\":\"pattern\"\n  },{\n    \"NAME\": \"color_1\",\n    \"DEF_COLOR\":[0.3,0.6,0.8],\n    \"UI_GROUP\": \"color\",\n    \"TYPE\":\"color\",\n    \"DESCRIPTION\": \"Define one of the two colors that make up the palette.\"\n  },{\n    \"NAME\": \"color_2\",\n    \"DEF_COLOR\":[1.0,0.8,0.2],\n    \"UI_GROUP\": \"color\",\n    \"TYPE\":\"color\",\n    \"DESCRIPTION\": \"Define the second color. Most colors will fall between these two, but will always be more heavily saturated.\"\n  }]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuffer","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"float time = syn_Time*0.1;\nvec2 mouse = vec2(sin(syn_Time*0.07+syn_RandomOnBeat*0.5), cos(syn_Time*0.0729+syn_RandomOnBeat*0.7));\nvec2 resolution = RENDERSIZE.xy;\n\nfloat iGlobalTime;\nvec4 iMouse;\nvec3 iResolution;\n\n// by @301z\n\n// ****** SEXY HEXIES ******\n\nfloat npoly(float n, float theta) {\n  float u = mod(PI * time * 0.05 + theta / (2. * PI), 1.) * (n); \n  //float u = theta / (PI * 2.) + 0.1;\n  float a = PI / n;\n  float b = a * (PI * floor(u) + 1.);\n  float c = 2. * u - 2. * floor(u) - 1.;\n  float x = cos(a) * cos(b) - c * sin(a) * sin(b);\n  float y = cos(a) * sin(b) + c * sin(a) * cos(b);\n  return length(vec2(x, y));\n}\n\nvec3 hexies(void) {\n  const int num = 4;\n  vec4 layers[5];\n  layers[0] = vec4( 2, 3.0, 0.49, 0.4);\n  layers[1] = vec4( 3, 7.0, 0.59, 0.7 );\n  layers[2] = vec4( 8, 18.0, 0.69, 0.9 );\n  layers[3] = vec4( 16, 50.0, 0.9, 2.3 );\n  // layers[4] = vec4( 3.0, 14.0, 0.89, 0.9 );\n  \n  vec2 center = (gl_FragCoord.xy - resolution * 0.5) / min(resolution.x, resolution.y);\n\n  vec3 mixed = vec3(1., 1., 1.);\n  for (int i = 0; i < num; ++i) {\n    // vec2 scroll = center + vec2(mouse.x * 0.1 * float(i+1) + time * 0.1 * float(i), time * 0.1 * layers[i].w);\n    vec2 scroll = center + direction*vec2(0.0, syn_CurvedTime*0.1*layers[i].w);\n  \n    vec2 p = mod((1. + scroll) * layers[i].y, layers[i].x) - 1.;\n    vec2 q = floor((scroll) * layers[i].y) /2. / layers[i].y;\n  \n    p*=(1.1-syn_HighLevel/layers[i].y);\n\n    float r = length(p);\n    float angle = atan(p.x, p.y);\n    vec4 col = vec4(0., 0., 0., 0.);\n  \n    if (r < npoly(sides, angle) * 0.70){\n      col = vec4(mix(1.0-color_1, 1.0-color_2, (fract(q.x*4.0)+fract(q.y*4.0))*0.5), layers[i].z);\n    }\n    \n    mixed = mix(mixed, col.rgb, col.a);\n  }\n   \n  mixed = clamp(pow(mixed,vec3(2.0))*2.0,0.0,1.0);\n  return mixed;\n}\n\n\n// ******** BOX *********\nconst float pi = 3.14159;\n\nfloat rand(vec3 co){\n    return 0.9+0.1*fract(sin(co.z+dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 rotate(vec3 v,vec2 r) \n{\n  mat3 rxmat = mat3(1,   0    ,    0    ,\n        0,cos(r.y),-sin(r.y),\n        0,sin(r.y), cos(r.y));\n  mat3 rymat = mat3(cos(r.x), 0,-sin(r.x),\n           0    , 1,    0    ,\n        sin(r.x), 0,cos(r.x));\n  \n  \n  return (v*rxmat)*rymat;\n  \n}\n\nvec3 norm(vec3 v)\n{\n  //box made of 6 planes\n  float tp = dot(v,vec3(0,-1,0))*3.;\n  float bt = dot(v,vec3(0,1,0))*3.;\n  float lf = dot(v,vec3(1,0,0))*3.;\n  float rt = dot(v,vec3(-1,0,0))*3.;\n  float fr = dot(v,vec3(0,0,1))*3.;\n  float bk = dot(v,vec3(0,0,-1))*3.;\n  \n  return v/min(min(min(min(min(tp,bt),lf),rt),fr),bk);\n}\n\nfloat grid(vec3 v)\n{\n  float g;\n  \n  g = (length(v));\n  g = (1.0-(g*g)*2.0)*2.0*rand(v);\n  return g*g-0.125*cos(fract(time)*pi*2.0);\n}\n\nvec3 boxPattern( void ) {\n\n  vec2 res = vec2(resolution.x/resolution.y,1.0);\n  vec2 p = ( gl_FragCoord.xy / resolution.y ) -(res/2.0);\n  \n  p = mix(p,p * (1.0-dot(p,p)*1.5),length(p)*1.5);\n  \n  vec2 m = (mouse-0.5)*pi*vec2(2.,1.);\n  \n  vec3 color = vec3(0.0);\n  \n  vec3 pos = norm(rotate(vec3(p,0.5),vec2(m)));\n  \n  float c = grid(pos);\n  return pos;\n}\n\n\n\n//******* DITHER and POSTERIZE ********\n\n// float LEVELS = pow(0.8*syn_FadeInOut+levels,3.0);\nfloat LEVELS = pow(0.01+dither_mod,3.0);\n\n\nfloat posterize(float thresholdIn, float value)\n{\n  float threshold = thresholdIn*pow(_uv.y+0.9-syn_HighPresence*0.5,6);\n  float retVal;\n  if (mod(value * LEVELS, 1.0) >= threshold){\n    retVal = floor(value * LEVELS + 1.0) / LEVELS;\n  } else {\n    retVal = floor(value * LEVELS) / LEVELS;\n  }\n  // retVal = value;\n  return retVal;\n}\n\nvec4 dither(vec2 posIn, vec4 color)\n{\n  vec2 pos = posIn;\n  vec2 polarPos = _toPolar(_uvc);\n  float posBump = fract(polarPos.x+0.25-syn_BPMTri2)*0.5;\n  posBump = pow(posBump, 3.0);\n  float thickness = 0.3;\n  float bumpDist = (smoothstep(0.0,thickness,posBump)-smoothstep(thickness,thickness+0.01,posBump))*pow((syn_BassLevel+syn_BassPresence),2.0)*0.75;\n  // float bumpDistWhite = smoothstep(0.0,thickness,posBump)-smoothstep(thickness,thickness+0.2,posBump);\n  pos -= normalize(_uvc)*bumpDist*10.0;\n\tfloat threshold =\n\t\t  mod(floor(pos.x) + floor(pos.y), 2.0) / 2.0\n\t\t+ mod(floor(pos.x), 2.0) / 4.0\n\t\t+ mod(floor(pos.x / 2.0) + floor(pos.y / 2.0), 2.0) / 8.0\n\t\t+ mod(floor(pos.x / 2.0), 2.0) / 16.0\n\t\t+ mod(floor(pos.x / 4.0) + floor(pos.y / 4.0), 2.0) / 32.0\n\t\t+ mod(floor(pos.x / 4.0), 2.0) / 64.0\n\t\t+ 1.0 / 128.0;\n\treturn vec4(posterize(threshold, color.x), posterize(threshold, color.y), posterize(threshold, color.z), color.w);\n\t// return vec4(threshold);2\n}\n\nvec4 renderMain() {\n\t\n  vec3 boxData = boxPattern();\n  vec3 hexyCol = 1.0-hexies();\n\n  vec3 pattern1 = hexyCol*2.0;\n  vec3 boxColor = mix(color_1, color_2, boxData.z*4.0)*2.0;\n  vec3 pattern2 = clamp(vec3(pow(length(boxData),10.0)*(0.6+syn_Presence*0.4)*80.0)*boxColor,0.0,1.0)*1.6;\n  vec3 mixCol = mix(pattern1, max(pattern1,pattern2), clamp(pattern_mixer*2.0,0.0,1.0));\n  mixCol = mix(mixCol, pattern2, clamp((pattern_mixer*2.0-1.0),0.0,1.0));\n  mixCol = clamp(mixCol, 0.0, 1.0);\n\n  vec4 finalCol;\n    \n  finalCol = vec4(mixCol, 1.0);\n\n  vec2 posPix = _uvc*RENDERSIZE.x;\n\n  if (_exists(syn_UserImage)){\n    finalCol += _loadUserImage();\n  } \n\n\tfinalCol = dither(posPix.xy/(pow(2.0,size)), finalCol);\n\t// finalCol = vec4(posterize(s1, finalCol.x),posterize(0.5, finalCol.y), posterize(0.5, finalCol.z),1.0);\n\treturn finalCol;\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Pop","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":7,"DESCRIPTION":"","MAX":24,"MIN":1,"NAME":"K","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.75,"DESCRIPTION":"","MAX":2,"MIN":1,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":3,"DESCRIPTION":"","MAX":5,"MIN":0,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":[0.400000005960464,0.330000013113022,0.5],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"c1_color","TYPE":"color","UI_GROUP":"ungrouped"},{"DEFAULT":[0.899999976158142,0.899999976158142,0.899999976158142],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"c2_color","TYPE":"color","UI_GROUP":"ungrouped"},{"DEFAULT":[0.899999976158142,0.5,0.330000013113022],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"c3_color","TYPE":"color","UI_GROUP":"ungrouped"},{"DEFAULT":[0.800000011920929,0.600000023841858,0.899999976158142],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"c4_color","TYPE":"color","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"based on https://www.shadertoy.com/view/lljfDd by dlsym","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\quazicrystal.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"QuaziCrystal","IMAGES":null,"IMAGE_PATH":"quazicrystal.synScene\\quazicrystal.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 7,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 24,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"K\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.75,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.4,\n\t\t\t\t0.33,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"c1_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.9,\n\t\t\t\t0.9,\n\t\t\t\t0.9\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"c2_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.9,\n\t\t\t\t0.5,\n\t\t\t\t0.33\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"c3_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.8,\n\t\t\t\t0.6,\n\t\t\t\t0.9\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"c4_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"based on https://www.shadertoy.com/view/lljfDd by dlsym\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"quazicrystal.png\",\n\t\"TITLE\" : \"QuaziCrystal\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec4 c4 = vec4(c4_color, 1.0); \nvec4 c3 = vec4(c3_color, 1.0); \nvec4 c2 = vec4(c2_color, 1.0); \nvec4 c1 = vec4(c1_color, 1.0); \n\n\n\n////////////////////////////////////////////////////////////\n// QuaziCrystal  by mojovideotech\n//\n// based on :\n// shadertoy.com\\/lljfDd by dlsym\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n\n\n#define \tpi   \t3.141592653589793 \t// pi\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec4 colorize(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    vec3 col = 2.5 * a * b * (cos(0.4*pi*(c*t+d))); \n    return vec4(col, 1.0);\n}\n\nfloat v(vec2 coord, float k, float s, float rot) {\n    float cx = cos(rot), sy = sin(rot);\n    return 0.0 + 0.5 * cos((cx * coord.x + sy * coord.y) * k + s);\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n   \tfloat T = rate * TIME;\n    vec2 uv = _xy.xy - (0.5 * RENDERSIZE.xy); // center\n    float vt = 0.0, j = floor(K);\n    for(int i = 0; i < 24; i++) {\n    \tif (float(i) >= j) break;\n        float s = float(i) * pi / j;\n    \tfloat w = v(uv, 2.1-scale, T, s);\n        vt += w / 0.5;\n    }\n\tout_FragColor = colorize(vt, c1.rgb, c2.rgb, c3.rgb, c4.rgb);\n\nreturn out_FragColor; \n } \n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"QuaziCrystal","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"When ON, Percussive hits will cause the the simulation to 'burst'.","MAX":1,"MIN":0,"NAME":"pusher","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"When ON, the actiion is replaced with diagonal scrolling, oscillating on the beat. Leads to interesting contour lines and more 'echoes'.","MAX":1,"MIN":0,"NAME":"scroller","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":0,"DESCRIPTION":"Removes hard edges, resulting on a softer 'smokey' look.","MAX":1,"MIN":0,"NAME":"soften","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Turn on for a vertically scrolling stark black and white scene. Good for dramatic parts of the music. Try turning soften and scroller on and off while monochrome is ON.","MAX":1,"MIN":0,"NAME":"monochrome","PARAMS":0.0199999995529652,"TYPE":"toggle smooth","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Move the simulation twice as fast vertically when ON. Very subtle effect.","MAX":1,"MIN":0,"NAME":"vert_speed","TYPE":"toggle","UI_GROUP":"speed"},{"DEFAULT":0,"DESCRIPTION":"Move the simulation twice as fast horizontally when ON. Very subtle effect.","MAX":1,"MIN":0,"NAME":"hor_speed","TYPE":"toggle","UI_GROUP":"speed"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\quicksand.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"shape_type","VALUES":[1,0,2]},{"UNIFORM":"scanDirection","VALUES":[0,1]},{"UNIFORM":"colorMode","VALUES":[0,1]}],"HEIGHT":1080,"ID":"Quicksand","IMAGES":null,"IMAGE_PATH":"quicksand.synScene\\quicksand.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Quicksand\",\n \"IMAGE_PATH\": \"quicksand.png\",\n \"HARD_TRANSITIONS\": [\n        {\n            \"UNIFORM\": \"shape_type\", \n            \"VALUES\":[1.0,0.0,2.0]\n        },\n        {\n            \"UNIFORM\": \"scanDirection\", \n            \"VALUES\":[0.0,1.0]\n        },\n        {\n            \"UNIFORM\": \"colorMode\", \n            \"VALUES\":[0.0,1.0]\n        }\n    ],\n \"SMOOTH_TRANSITIONS\": [\n    {\"UNIFORMS\":[\"cReg0\", \"cReg1\", \"cReg2\"], \n    \"DURATION\": 5}\n    ],\n  \"CONTROLS\": [\n        {\n            \"NAME\": \"pusher\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"When ON, Percussive hits will cause the the simulation to 'burst'.\",\n            \"UI_GROUP\":\"action\"\n        },{\n            \"NAME\": \"scroller\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"When ON, the actiion is replaced with diagonal scrolling, oscillating on the beat. Leads to interesting contour lines and more 'echoes'.\",\n            \"UI_GROUP\":\"action\"\n        },{\n            \"NAME\": \"soften\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"Removes hard edges, resulting on a softer 'smokey' look.\",\n            \"UI_GROUP\":\"effects\"\n        },{\n            \"NAME\": \"monochrome\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle smooth\",\n            \"PARAMS\": 0.02,\n            \"DESCRIPTION\": \"Turn on for a vertically scrolling stark black and white scene. Good for dramatic parts of the music. Try turning soften and scroller on and off while monochrome is ON.\",\n            \"UI_GROUP\":\"effects\"\n        },\n        {\n            \"NAME\": \"vert_speed\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"Move the simulation twice as fast vertically when ON. Very subtle effect.\",\n            \"UI_GROUP\":\"speed\"\n        },{\n            \"NAME\": \"hor_speed\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"Move the simulation twice as fast horizontally when ON. Very subtle effect.\",\n            \"UI_GROUP\":\"speed\"\n        }\n    ],\n    \"PASSES\": [\n    {\n        \"TARGET\":\"firstBuff\",\n        \"FLOAT\": true\n    },\n    {\n        \"TARGET\":\"secondBuff\",\n        \"FLOAT\": true\n    }\n    ]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuff","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuff","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"\n#define tolerance 0.001;\n\nbool almostEqual(float num1, float num2, float tolIn){\n\treturn abs(num1-num2)<tolIn;\n}\n\nbool almostEqual(float num1, float num2){\n\treturn abs(num1-num2)<tolerance;\n}\n\nvec4 renderMain(void)\n{\n\tif (PASSINDEX == 0){\n\t\tif (FRAMECOUNT < 10){\n\t\t\treturn vec4(0.5,1.0,1.0,0.5);\n\t\t}\n\n\t\tvec2 pixelSize = 1/RENDERSIZE;\n\t\tif (soften > 0.5){\n\t\t\tpixelSize *= 0.75;\n\t\t}\n\n\t\tfloat horAmt = 1.0+hor_speed;\n\t\tfloat vertAmt = 1.0+vert_speed;\n\n\t\t// float vertDisp = (5.0-floor(_rand(_pixelate(_uv.x, 50.0)+floor(syn_BPMTwitcher))*10.0));\n\t\t// if (_rand(_pixelate(_uv.x, 50.0))>_uv.y){\n\t\t// \tvertDisp *= 0.0;\n\t\t// }\n\n\n\t\tvec2 disp = vec2(0.0);\n\n\t\tif (pusher>0.5){\n\t\t\tdisp = -_uvc*100.0*(clamp(syn_MidHighHits*syn_Presence,0.1,1.0)-0.1);\n\t\t}\n\n\t\tvec4 center;\n\t\tvec4 above;\n\t\tvec4 below;\n\t\tvec4 left;\n\t\tvec4 right;\n\n\t\tif (scroller<0.5){\n\t\t\tcenter = texture(firstBuff, _uv);\n\t\t\tabove = texture(firstBuff, _uv+(vec2(0.0,vertAmt)+disp)*pixelSize);\n\t\t\tbelow = texture(firstBuff, _uv+(vec2(0.0,-vertAmt)+disp)*pixelSize);\n\t\t\tleft = texture(firstBuff, _uv+(vec2(-horAmt,0.0)+disp)*pixelSize);\n\t\t\tright = texture(firstBuff, _uv+(vec2(horAmt,0.0)+disp)*pixelSize);\n\n\t\t\tif (_uv.x > 0.5){\n\t\t\t\tvec4 tempLeft = left;\n\t\t\t\tleft = right;\n\t\t\t\tright = tempLeft;\n\t\t\t}\n\n\t\t} else if (scroller>0.5){\n\t\t\tif (_uv.x>0.5){\n\t\t\t\thorAmt *= -1;\n\t\t\t}\n\t\t\tvertAmt *= -1+2*mod(floor(syn_BPMTwitcher),2);\n\t\t\tcenter = texture(firstBuff, _uv);\n\t\t\tabove = texture(firstBuff, _uv+(vec2(horAmt,vertAmt)+disp)*pixelSize);\n\t\t\tbelow = texture(firstBuff, _uv+(vec2(-horAmt,-vertAmt)+disp)*pixelSize);\n\t\t\tright = texture(firstBuff, _uv+(vec2(horAmt,vertAmt)+disp)*pixelSize);\n\t\t\tleft = right;\n\t\t}\n\n\t\tvec4 dataOut = vec4(0.0);\n\t\tbvec4 dataSet = bvec4(false);\n\n  \tbool testForShape = false;\n  \tif (shape_type < 0.5){\n  \t\tfloat cpPulseTime = fract(syn_OnBeat+_uv.y);\n  \t\tfloat cpPulse = sin(smoothstep(0.0,0.3,cpPulseTime)-smoothstep(0.3,0.6,cpPulseTime));\n  \t\ttestForShape = abs(_uvc.x)<0.0075+0.1*cpPulse*syn_OnBeat*syn_Presence;\n  \t} else if (shape_type < 1.5){\n  \t\tfloat cpPulseTime = fract(syn_OnBeat+sin(_toPolarTrue(_rotate(_uvc, -PI/2)).y*2*PI+cos(TIME*0.5))+TIME*0.5);\n  \t\tfloat cpPulse = sin(smoothstep(0.0,0.3,cpPulseTime)-smoothstep(0.3,0.6,cpPulseTime));\n  \t\ttestForShape = length(_uvc*vec2(1.0,0.5+_uv.y))<0.15+0.05*syn_OnBeat+0.1*cpPulse*syn_OnBeat*syn_Presence;\n  \t} else if (shape_type < 2.5){\n  \t\t// float cpPulseTime = fract(syn_OnBeat+cos(_uvc.x*4.0));\n  \t\t// float cpPulse = sin(smoothstep(0.0,0.3,cpPulseTime)-smoothstep(0.3,0.6,cpPulseTime))*3.0;\n  \t\t// testForShape = 0.5-abs(_uvc.y)<0.0075+0.1*cpPulse*syn_OnBeat*syn_Presence;\n  \t}\n\n  \tif (_exists(syn_UserImage)){\n  \t\tif (_loadUserImageAsMask().r>0.5){\n  \t\t\tdataOut.r = 0.5;\n  \t\t\tdataSet.r = true;\n  \t\t\tdataOut.g = 0.5;\n  \t\t\tdataSet.g = true;\n\n  \t\t\t// dataSet = bvec4(true);\n  \t\t} else if (dot(_loadUserImage().rgb,vec3(1.0))/3.0>0.55){\n  \t\t\tdataOut.b = 0.05;\n  \t\t\tdataSet.b = true;\n  \t\t}\n  \t} else if (testForShape){\n\t\t\tdataOut = vec4(1.0);\n\t\t\tdataSet = bvec4(true);\n\t\t} else {\n\t\t\tdataOut.a = 0.0;\n\t\t}\n\n\t\t// if (almostEqual(center.g, center.b)){\n\t\t\t// dataOut.r = 0.5;\n\t\t\t// dataSet.r = true;\n\t\t// }\n\n\t\tif (almostEqual(below.r,center.r)&&almostEqual(above.r,center.r)&&!dataSet.r){\n\t\t\tdataOut.r = _rand(_uvc+TIME);\n\t\t\tdataSet.r = true;\n\t\t}\n\n\t\tif (almostEqual(left.r,center.r)&&almostEqual(right.r,center.r)&&!dataSet.r){\n\t\t\tdataOut.r = _rand(_uvc+TIME);\n\t\t\tdataSet.r = true;\n\t\t}\n\n\t\tif (below.r > center.r && !dataSet.r){\n\t\t\tdataOut.r = right.r;\n\t\t\tdataSet.r = true;\n\t\t}\n\t\tif (above.r > center.r && !dataSet.r){\n\t\t\tdataOut.r = left.r;\n\t\t\tdataSet.r = true;\n\t\t}\n\t\tif (left.r < center.r && !dataSet.r){\n\t\t\tdataOut.r = above.r;\n\t\t\tdataSet.r = true;\n\t\t}\n\t\tif (right.r < center.r && !dataSet.r){\n\t\t\tdataOut.r = below.r;\n\t\t\tdataSet.r = true;\n\t\t}\n\n\t\t\n\t\tif (almostEqual(1.0,center.g)&&!dataSet.g){\n\t\t\tdataOut.g = _rand(_uvc+TIME);\n\t\t\tdataSet.g = true;\n\t\t}\n\n\t\tif (below.g > center.g && !dataSet.g){\n\t\t\tdataOut.g = right.g;\n\t\t\tdataSet.g = true;\n\t\t}\n\t\tif (above.g > center.g && !dataSet.g){\n\t\t\tdataOut.g = left.g;\n\t\t\tdataSet.g = true;\n\t\t}\n\t\tif (left.g < center.g && !dataSet.g){\n\t\t\tdataOut.g = above.g;\n\t\t\tdataSet.g = true;\n\t\t}\n\t\tif (right.g < center.g && !dataSet.g){\n\t\t\tdataOut.g = below.g;\n\t\t\tdataSet.g = true;\n\t\t}\n\n\t\tif (almostEqual(center.b,1.0)&&!dataSet.b){\n\t\t\tdataOut.b = _rand(_uvc+TIME)*0.1;\n\t\t\tdataSet.b = true;\n\t\t}\n\n\t\tif (center.b < below.b && !dataSet.b){\n\t\t\tdataOut.b = below.b;\n\t\t\tdataSet.b = true;\n\t\t}\n\t\tif (above.b > center.b && !dataSet.b){\n\t\t\tdataOut.b = left.b;\n\t\t\tdataSet.b = true;\n\t\t}\n\t\tif (left.b < center.b && !dataSet.b){\n\t\t\tdataOut.b = above.b;\n\t\t\tdataSet.b = true;\n\t\t}\n\t\tif (right.b > center.b && !dataSet.b){\n\t\t\tdataOut.b = 1.0-below.b;\n\t\t\tdataSet.b = true;\n\t\t}\n\t\t// if (almostEqual(left.b, right.b)&&almostEqual(above.b,below.b)){\n\t\t// \tdataOut.b = center.b;\n\t\t// \tdataSet.b = true;\n\t\t// }\n\n\t\tdataOut = clamp(dataOut, 0.0, 1.0);\n\n\t\treturn dataOut*vec4(dataSet)+center*vec4(not(dataSet));\n\n\t} else if (PASSINDEX == 1){\n\t\tfloat xPos = _uv.x;\n\t\t// float xPos = abs(-0.5-_uv.x);\n\t\t// if (_uv.x>0.5){\n\t\t// \txPos = -_uv.x+0.5;\n\t\t// }\n\t\t// float xPos = _uv.x;\n\n\t\tvec4 dataTex = texture(firstBuff, vec2(xPos, _uv.y));\n\n\n\t\tvec4 monoColor = vec4(dataTex.b);\n\n\t\tvec4 finalCol = vec4(0.0);\n\n\t\tvec4 briCol = vec4(0.5,0.8,0.0,0.0);\n\t\tvec4 centerCol = vec4(0.7,0.1,0.1,0.0);\n\t\tvec4 outsideCol = vec4(0.1,0.1,0.4,0.0);\n\n\n\t\tbriCol = mix(briCol, -vec4(0.9,0.9,0.9,0.0), cReg1);\n\t\tcenterCol = mix(centerCol, vec4(0.7,0.5,0.5,0.0), cReg1);\n\t\toutsideCol = mix(outsideCol, vec4(0.7,0.1,0.0,0.0), cReg1);\n\n\t\tbriCol = mix(briCol, -vec4(0.2,0.8,0.4,0.0), cReg2);\n\t\tcenterCol = mix(centerCol, vec4(0.2,0.8,0.7,0.0), cReg2);\n\t\toutsideCol = mix(outsideCol, vec4(0.2,0.9,0.5,0.0), cReg2);\n\n\n\t\tfinalCol += mix(briCol, vec4(1.0), clamp(abs(_uvc.x)*2.0,0.0,1.0))*dataTex.r;\n\t\tfinalCol += mix(centerCol*2.0,outsideCol,abs(_uvc.x)*2.0)*(1.0-dataTex.g);\n\t\t//finalCol += vec4(1.0,1.0,1.0,0.0)*syn_MidLevel*pow(1.0-abs(_uvc.x),3.0)*dataTex.b*dataTex.a;\n\n\t\t\n\t\tfloat percolating = step(0.01,dataTex.r);\n\t\tvec4 percVal = vec4(1.0)*(1.0-percolating)*pow(1.0-abs(_uvc.x),3.0)*syn_BPMSin2*6.0;\n\n\t\tfinalCol -= percVal;\n\t\tmonoColor -= percVal;\n\n\t\tfloat highPulseTime = fract(-syn_HighHits+dataTex.r*2.0+abs(scanDirection<0.5 ? _uvc.x : _uvc.y));\n  \tfloat highPulse = sin(smoothstep(0.0,0.1,highPulseTime)-smoothstep(0.1,0.2,highPulseTime));\n\n    finalCol += (1.0-finalCol)*highPulse*syn_Intensity*pow(syn_HighHits,0.25)*pow(length(_uvc),3.0)*2.0;\n\n\t\t// finalCol = mix(monoColor, finalCol, syn_Presence);\n\n\t\tfloat monoPulseTime = fract(-monochrome+dataTex.r*2.0+abs(scanDirection<0.5 ? _uvc.y : _uvc.x));\n  \tfloat monoPulse = smoothstep(0.0,0.4,monoPulseTime)-smoothstep(0.4,0.8,monoPulseTime);\n\t\tfinalCol = mix(finalCol, 1.0-monoColor, monochrome);\n\n\t\treturn finalCol;\n\n\t} else if (PASSINDEX == 2){\n\t\tvec2 pos = _uv*0.5+vec2(sin(floor(syn_BPMTwitcher/4.0)),cos(floor(syn_BPMTwitcher/4.0)));\n\t\tpos = _pixelate(pos, RENDERSIZE.x);\n\t\tpos = _uv;\n\t\tvec4 finalCol = texture(secondBuff, pos);\n\t\tvec4 dataTex = texture(firstBuff, _uv);\n\n\t\t// float gridLineX = mod(_uv.x*0.3,1/RENDERSIZE.x);\n\t\t// float gridLineY = mod(_uv.y*0.3,1/RENDERSIZE.y);\n\n\t\t// if(almostEqual(gridLineX,0.0,0.0001)||almostEqual(gridLineY,0.0,0.0001)){\n\t\t// \tfinalCol = vec4(0.0);\n\t\t// }\n\n\t\tif(_exists(syn_UserImage)&&_loadUserImageAsMask().r>0.5){\n\t\t\tfinalCol = vec4(1.0-dataTex.b);\n\t\t}\n\n\t\treturn finalCol;\n\n\t}\n\n\treturn vec4(1.0,0.0,1.0,0.0);\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":5,"UNIFORMS":["cReg0","cReg1","cReg2"]}],"TAGS":[],"TITLE":"Quicksand","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Turn OFF auto splatter and use this button to trigger splatters instead. Every time you click, another one dies. You monster.","MAX":1,"MIN":0,"NAME":"manual_splatter","PARAMS":0.400000005960464,"TYPE":"bang smooth","UI_GROUP":"splatter"},{"DEFAULT":1,"DESCRIPTION":"Turn ON for automatic blood splatters on the beat, turn off if you want to use the manual splatter button.","MAX":1,"MIN":0,"NAME":"auto_splatter","TYPE":"toggle","UI_GROUP":"splatter"},{"DEFAULT":1,"DESCRIPTION":"Choose whether the extra, slow drips are included in each splatter.","MAX":1,"MIN":0,"NAME":"extra_drips","TYPE":"toggle","UI_GROUP":"splatter"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for automatic slices on the beat, turn off you want to use the manual slice button.","MAX":1,"MIN":0,"NAME":"auto_slicer","TYPE":"toggle","UI_GROUP":"slicer"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for high-contrast slices instead of red.","MAX":1,"MIN":0,"NAME":"constrast_slices","TYPE":"toggle","UI_GROUP":"slicer"},{"DEFAULT":0,"DESCRIPTION":"Turn OFF auto slicer and use this button to trigger slices instead. Splatter wasn't enough? Do you have an insatiable thirst for blood?","MAX":1,"MIN":0,"NAME":"manual_slice","TYPE":"bang counter","UI_GROUP":"slicer"},{"DEFAULT":0.349999994039536,"DESCRIPTION":"Intensity of the shake effect.","MAX":1,"MIN":0,"NAME":"shake","TYPE":"slider","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for a glitch effect when the highs hit.","MAX":1,"MIN":0,"NAME":"highs_glitch","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":1,"DESCRIPTION":"Turn this up to increase the intensity of the blood.","MAX":2,"MIN":1,"NAME":"more_blood","TYPE":"slider","UI_GROUP":"blood"},{"DEFAULT":1,"DESCRIPTION":"Turn this up to decrease the intensity of the blood.","MAX":0,"MIN":1,"NAME":"less_blood","TYPE":"slider","UI_GROUP":"blood"},{"DEFAULT":0,"DESCRIPTION":"Hit this to push the blood out radially.","MAX":1,"MIN":0,"NAME":"punch_out","PARAMS":0.600000023841858,"TYPE":"bang smooth","UI_GROUP":"puncher"},{"DEFAULT":0,"DESCRIPTION":"Hit this to pull the blood in towards the center.","MAX":1,"MIN":0,"NAME":"punch_in","PARAMS":0.600000023841858,"TYPE":"bang smooth","UI_GROUP":"puncher"},{"DEFAULT":0,"DESCRIPTION":"Turn this up to make the punch effect of the two buttons more intense. High values can turn the scene into a sort of tunnel.","MAX":1,"MIN":0,"NAME":"intensity_punch","TYPE":"slider","UI_GROUP":"puncher"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\redrum.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"REDRUM","IMAGES":[{"NAME":"wall1Tex","PATH":"images/wall1.jpg"},{"NAME":"wall2Tex","PATH":"images/wall2.jpg"},{"NAME":"wall3Tex","PATH":"images/wall3.jpg"}],"IMAGE_PATH":"redrum.synScene\\redrum.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn OFF auto splatter and use this button to trigger splatters instead. Every time you click, another one dies. You monster.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"manual_splatter\",\n         \"PARAMS\" : 0.4,\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"splatter\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Turn ON for automatic blood splatters on the beat, turn off if you want to use the manual splatter button.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_splatter\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"splatter\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Choose whether the extra, slow drips are included in each splatter.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"extra_drips\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"splatter\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn ON for automatic slices on the beat, turn off you want to use the manual slice button.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_slicer\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"slicer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn ON for high-contrast slices instead of red.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"constrast_slices\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"slicer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn OFF auto slicer and use this button to trigger slices instead. Splatter wasn't enough? Do you have an insatiable thirst for blood?\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"manual_slice\",\n         \"TYPE\" : \"bang counter\",\n         \"UI_GROUP\" : \"slicer\"\n      },\n      {\n         \"DEFAULT\" : 0.35,\n         \"DESCRIPTION\" : \"Intensity of the shake effect.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"shake\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"effects\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn ON for a glitch effect when the highs hit.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"highs_glitch\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"effects\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Turn this up to increase the intensity of the blood.\",\n         \"MAX\" : 2,\n         \"MIN\" : 1,\n         \"NAME\" : \"more_blood\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"blood\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Turn this up to decrease the intensity of the blood.\",\n         \"MAX\" : 0,\n         \"MIN\" : 1,\n         \"NAME\" : \"less_blood\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"blood\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Hit this to push the blood out radially.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"punch_out\",\n         \"PARAMS\" : 0.6,\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"puncher\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Hit this to pull the blood in towards the center.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"punch_in\",\n         \"PARAMS\" : 0.6,\n         \"TYPE\" : \"bang smooth\",\n         \"UI_GROUP\" : \"puncher\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn this up to make the punch effect of the two buttons more intense. High values can turn the scene into a sort of tunnel.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"intensity_punch\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"puncher\"\n      }\n   ],\n   \"CREDIT\" : \"Meebs\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"wall1Tex\",\n         \"PATH\" : \"images/wall1.jpg\"\n      },\n      {\n         \"NAME\" : \"wall2Tex\",\n         \"PATH\" : \"images/wall2.jpg\"\n      },\n      {\n         \"NAME\" : \"wall3Tex\",\n         \"PATH\" : \"images/wall3.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"redrum.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 0,\n         \"TARGET\" : \"dataPass\",\n         \"WIDTH\" : 0\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 0,\n         \"TARGET\" : \"simPass\",\n         \"WIDTH\" : 0\n      }\n   ],\n   \"TITLE\" : \"REDRUM\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"dataPass","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"simPass","WIDTH":0}],"SCRIPT_CODE":"function SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n}\n\nvar manslice = new SmoothCounter();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  manslice.update(dt, inputs.manual_slice, 0.2);\n\n  uniforms.manslice_scr = manslice.currentValue;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(manslice.currentValue);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"//Grit/flashing effect by jmpep from Shadertoy.\n\n// #define LINES_AND_FLICKER\n#define BLOTCHES\n#define GRAIN\n\n#define FREQUENCY 15.0\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float c){\n\treturn rand(vec2(c,1.0));\n}\n\nfloat distance_from_point_to_line(vec2 pt, vec2 l1, vec2 l2){\n  float returnMe = 0.0;\n  float a = (l2.y - l1.y);\n  float b = (l2.x - l1.x);\n  float c = 0.0;\n  \n  //  if b is zero, this is a vertical line!\n  //  in which case distance is based on x distance alone\n  if (b == 0.0) {\n    float minY = min(l1.y, l2.y);\n    float maxY = max(l1.y, l2.y);\n    \n    //  if we're between the two points distrance is straight up x diff\n    if ((pt.y > minY) && (pt.y < maxY)) {\n      returnMe = abs(pt.x-l1.x);\n    }\n    else  {\n      //returnMe = min(distance(pt, l1), distance(pt, l2));\n      returnMe = -1.0;\n    }\n  }\n  //  if a is zero, this is a horizontal line\n  else if (a == 0.0)  {\n    float minX = min(l1.x, l2.x);\n    float maxX = max(l1.x, l2.x);\n    \n    //  if we're between the two points distrance is straight up y diff\n    if ((pt.x > minX) && (pt.x < maxX)) {\n      returnMe = abs(pt.y - l1.y);\n    }\n    else  {\n      //returnMe = min(distance(pt, l1), distance(pt, l2));\n      returnMe = -1.0;\n    }\n  }\n  //  if b isn't 0, solve for c now that we know a, b, and either l1 or l2\n  else  {   \n    //  here's the tricky bit-\n    //  if pt is beyond l1 and l2, we should switch to distance from those points\n    //  in order to determine this we need to use the perpendicular lines to the segment l1|l2 that pass through l1 & l2\n    //  the slope of the perp line will be -1.0 / slope of original line\n    float m = a / b;\n    float perpm = -b / a;\n    vec2 left_line_pt = l1;\n    vec2 right_line_pt = l2;\n    if (l1.x > l2.x)  {\n      left_line_pt = l2;\n      right_line_pt = l1;\n    }\n    \n    float perp_intercept1 = left_line_pt.y - perpm * left_line_pt.x;\n    float perp_intercept2 = right_line_pt.y - perpm * right_line_pt.x;\n    \n    if (m > 0.0)  {\n      returnMe = abs(a * pt.x - b * pt.y + l2.x * l1.y - l2.y * l1.x) / sqrt(a*a + b*b);\n    }\n    else  {\n      returnMe = abs(a * pt.x - b * pt.y + l2.x * l1.y - l2.y * l1.x) / sqrt(a*a + b*b);\n    }\n  }\n   \n    return returnMe;\n}\n\nfloat randomLine(float seed)\n{\n\tfloat b = 0.01 * rand(seed);\n\tfloat a = rand(seed+1.0);\n\tfloat c = rand(seed+2.0) - 0.5;\n\tfloat mu = rand(seed+3.0);\n\t\n\tfloat l = 1.0;\n\t\n\tif ( mu > 0.2)\n\t\tl = pow(  abs(a * _uv.x + b * _uv.y + c ), 1.0/8.0 );\n\telse\n\t\tl = 2.0 - pow( abs(a * _uv.x + b * _uv.y + c), 1.0/8.0 );\t\t\t\t\n\t\n\treturn mix(0.5, 1.0, l);\n}\n\n// Generate some blotches.\nfloat randomBlotch(float seed)\n{\n\tfloat x = rand(seed);\n\tfloat y = rand(seed+1.0);\n\tfloat s = 0.01 * rand(seed+2.0);\n\t\n\tvec2 p = vec2(x,y) - _uv;\n\tp.x *= RENDERSIZE.x / RENDERSIZE.y;\n\tfloat a = atan(p.y,p.x);\n\tfloat v = 1.0;\n\tfloat ss = s*s * (sin(6.2831*a*x)*0.1 + 1.0);\n\t\n\tif ( dot(p,p) < ss ) v = 0.2;\n\telse\n\t\tv = pow(dot(p,p) - ss, 1.0/16.0);\n\t\n\treturn mix(0.3 + 0.2 * (1.0 - (s / 0.02)), 1.0, v);\n}\n\n\nvec4 addGrain(sampler2D tex)\n{\n\tvec4 fragColor = vec4(0.0);\n\t\t// Set frequency of global effect to 15 variations per second\n\t\tfloat t = float(int(TIME * FREQUENCY));\n\t\t\n\t\t// Get some image movement\n\t\tvec2 s_uv = _uv + 0.01*pow(shake,2.0) * vec2( rand(t), rand(t + 23.0));\n\t\tvec2 s_uv2 = _uv + 0.01*pow(shake,2.0) * vec2( _statelessContinuousChaotic(syn_CurvedTime*0.1), _statelessContinuousChaotic(syn_CurvedTime*0.1 + 23.0));\n\n\t\t// Get the image\n\t\tvec3 image = texture( tex, vec2(s_uv.x, s_uv.y) ).xyz;\n\t\tvec3 image2 = texture( tex, vec2(s_uv2.x, s_uv2.y) ).xyz;\n\t\timage = mix(image, image2, 0.5);\n\n\t\t// Convert it to B/W\n\t\tfloat luma = dot( vec3(0.2126, 0.7152, 0.0722), image );\n\t\tvec3 bwImage = luma * vec3(0.7, 0.7, 0.7);\n\t\tvec3 oldImage = mix(image, bwImage, syn_HighHits);\n\t\t// oldImage = image;\n\t\t// Create a time-varying vignetting effect\n\t\tfloat vI = 16.0 * (_uv.x * (1.0-_uv.x) * _uv.y * (1.0-_uv.y));\n\t\t// vI *= mix( 0.7, 1.0, rand(t + 0.5));\n\t\t\n\t\t// Add additive flicker\n\t\tvI += 1.0 + 0.4 * rand(t+8.);\n\t\t\n\t\t// Add a fixed vignetting (independent of the flicker)\n\t\t// vI *= mix(1.0, pow(16.0 * _uv.x * (1.0-_uv.x) * _uv.y * (1.0-_uv.y), 0.4), vignette);\n\t\t\n\t\t// Add some random lines (and some multiplicative flicker. Oh well.)\n\t\t// #ifdef LINES_AND_FLICKER\n\t\t// int l = int(8.0 * rand(t+7.0));\n\t\t\n\t\t// if ( 0 < l ) vI *= randomLine( t+6.0+17.* float(0));\n\t\t// if ( 1 < l ) vI *= randomLine( t+6.0+17.* float(1));\n\t\t// if ( 2 < l ) vI *= randomLine( t+6.0+17.* float(2));\t\t\n\t\t// if ( 3 < l ) vI *= randomLine( t+6.0+17.* float(3));\n\t\t// if ( 4 < l ) vI *= randomLine( t+6.0+17.* float(4));\n\t\t// if ( 5 < l ) vI *= randomLine( t+6.0+17.* float(5));\n\t\t// if ( 6 < l ) vI *= randomLine( t+6.0+17.* float(6));\n\t\t// if ( 7 < l ) vI *= randomLine( t+6.0+17.* float(7));\n\t\t\n\t\t// #endif\n\t\t\n\t\t// Add some random blotches.\n\t\t#ifdef BLOTCHES\n\t\tint s = int( max(8.0 * rand(t+18.0) -2.0, 0.0 ));\n\n\t\tif ( 0 < s ) vI *= randomBlotch( t+6.0+19.* float(0));\n\t\tif ( 1 < s ) vI *= randomBlotch( t+6.0+19.* float(1));\n\t\tif ( 2 < s ) vI *= randomBlotch( t+6.0+19.* float(2));\n\t\tif ( 3 < s ) vI *= randomBlotch( t+6.0+19.* float(3));\n\t\tif ( 4 < s ) vI *= randomBlotch( t+6.0+19.* float(4));\n\t\tif ( 5 < s ) vI *= randomBlotch( t+6.0+19.* float(5));\n\t\n\t\t#endif\n\t\n\t\t// Show the image modulated by the defects\n    fragColor.xyz = oldImage * vI;\n\t\t\n\t\t// Add some grain (thanks, Jose!)\n\t\t#ifdef GRAIN\n      fragColor.xyz *= (1.0+(rand(_uv+t*.01)-.2)*.15)*(1.0+syn_HighHits*5.0);\t\t\n    #endif\t\n\t\t// fragColor.rgb += vec3(1.0, 0.3, 0.0)*syn_BassPresence*vI*0.1;\n\t\treturn fragColor;\n\n}\n\n\nconst float MAGIC_BOX_MAGIC = 0.56;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float tot = 0.0;\n    float L = length(p), L2;\n    \n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n\n    \n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nvec4 renderMain(void)\n{\n\tif (PASSINDEX == 0.0){\n\t\tvec2 zoomIn = -_uvc*vec2(RENDERSIZE.y/RENDERSIZE.x, 1.0)*(punch_out-punch_in*2.0)*(0.1+0.7*intensity_punch)*_rand(_toPolarTrue(_uvc).y+TIME*0.1);\n\t\t// float dripAmt = _rand(_pixelate(_uv.x,50.0))*(0.5+0.5*sin(_uv.y*5.0+TIME));\n\t\tvec4 oldData = texture(dataPass, _uv+zoomIn);\n\n\t\tfloat dripAmt = pow(oldData.b, 2.0);\n\n\t\tvec4 oldDataA = texture(dataPass, _uv+vec2(0.0,dripAmt*50.0)/RENDERSIZE+zoomIn);\n\n\t\t//DRIP EFFECT\n\t\tfloat bloodVal = oldData.b;\n\t\tfloat aboveBlood = oldDataA.b;\n\n\t\tif (bloodVal < aboveBlood){\n\t\t\toldData.b = oldDataA.b; //make this pixel's data set to its above pixels data\n\t\t}\n\n\t\tbloodVal = oldData.b; //reset bloodVal to the new one\n\n\t\tfloat oldSlice = oldData.a;\n\n\t\t//FOR CIRCLE DRIPS\n\t\tfloat rotoAmt = -0.5+_fbm(vec3(_uvc*30.0,syn_HighTime*0.01));\n\t\tvec4 above4 = texture(dataPass, _uv+_rotate(vec2(0.0,0.001),rotoAmt)+zoomIn);\n\t\tvec4 below4 = texture(dataPass, clamp(_uv-_rotate(vec2(0.0,0.03+syn_BassLevel*0.06),rotoAmt)+zoomIn,0.0,1.0));\n\n\t\tfloat above = above4.r;\n\t\tfloat below = below4.r;\n\n\t\tif (above > oldData.r){\n\t\t\toldData.r = above;\n\t\t}\n\n\t\tfloat circleDrip = oldData.r;\n\t\tcircleDrip *= 0.9+abs(below-above)*0.1; //decrease timeVal, making blood older\n\t\tcircleDrip = clamp(circleDrip, 0.0, 1.0);\n\t\t//FADE EFFECT\n\t\t//subtract some amount from bloodVal alpha, letting us know it is old.\n\t\tbloodVal *= 0.98;\n\n\t\t//NEW SPLATS\n\t\tfloat mbox = magicBox(vec3(_uvc+sin(vec2(syn_BeatTime*23.7, TIME*3.0)*0.1)*20.0, sin(TIME)*20.0));\n    float a = smoothstep(14., 16., mbox);\n\n\t\tfloat pattern = a;\n\t\tif (syn_MediaType>0.5){\n\t\t\tpattern = (0.3*a+_loadUserImageAsMask().r*0.7);\n\t\t}\n\t\t// pattern = max(a*syn_HighHits, a2*syn_BassLevel);\n\t\t//limit pattern spatially\n\t\tpattern *= smoothstep(0.0, 9.0-1.5*syn_Presence, 1/distance(_uvc, vec2(sin(TIME*107.18), cos(TIME*103.7))*0.7));\n\n\t\tvec4 wall1 = _loadImage(wall1Tex, vec2(TIME*0.3));\n\t\tvec4 wall2 = _loadImage(wall2Tex, vec2(-TIME*0.3));\n\t\tvec4 wall3 = _loadImage(wall3Tex, vec2(-TIME*17.34,TIME*10.329));\n\t\tvec4 texMix = mix(min(wall1, wall2), wall3, 0.5+0.5*sin(TIME));\n\n\t\tfloat texMixFloat = dot(texMix.rgb, vec3(1.0))/3.0;\n\n\t\tpattern *= texMixFloat;\n\n\t\tfloat bloodBeat = mix(step(0.5,manual_splatter), max(step(0.98, syn_OnBeat),step(0.99, syn_HighHits)), auto_splatter);\n\t\t//timeVal and bloodVal need the new splats.\n\t\tfloat circlePat = step(100.0+40.0*sin(TIME*1074.43), 1/distance(_uvc, vec2(sin(TIME*107.18), cos(TIME*103.7))*0.7));\n\t\tcircleDrip += circlePat*bloodBeat*syn_Level*less_blood*extra_drips;\n\t\tbloodVal += pattern*bloodBeat*more_blood*less_blood;\n\n\t\tvec2 pointOnLine;\n\n// vec2(_rand(TIME), _rand(TIME*0.97)), vec2(_rand(TIME+0.43), _rand(TIME*0.97+0.29))\n\t\tfloat s = sin(mix(floor(manslice_scr)*0.5+PI*mod(floor(manslice_scr),2.0), syn_BeatTime*10.0+TIME*0.5, auto_slicer));\n\t\tfloat c = cos(mix(floor(manslice_scr)*0.5+PI*mod(floor(manslice_scr),2.0), syn_BeatTime*10.0+TIME*0.5, auto_slicer));\n\t\tmat2 m = mat2(c, -s, s, c);\n\n    float disty = distance_from_point_to_line(_uvc*10.0, vec2(-1.0,sin(TIME)-0.2)*m, vec2(cos(TIME*0.33)+0.2,1.0)*m);\n\t\t\n\t\toldSlice *= 0.9;\n\t\tfloat sliceBeat = mix(clamp(fract(1.0-manslice_scr),0.0,1.0), syn_OnBeat, auto_slicer);\n\t\tfloat slicePattern = _pulse(disty, 0.0+texMixFloat-0.5, 0.2+a)*sliceBeat*_pulse((_uvc*m).x, -1.0+sliceBeat*2.0, 0.4)*5.0;\n\t\toldSlice += slicePattern;\n\t\tbloodVal += slicePattern*0.15*less_blood;\n\t\tvec4 finalCol = vec4(circleDrip, pattern, bloodVal, oldSlice);\n\n\t\treturn finalCol;\n\t}\n\telse if (PASSINDEX == 1.0){\n\t\tvec4 data = texture(dataPass, _uv);\n\n\t\tfloat circleDrip = data.r;\n\t\tfloat bloodVal = data.b;\n\t\tfloat slice = data.a;\n\t\tslice = smoothstep(0.0,1.0,slice);\n\n\t\tvec4 finalBlood = pow(bloodVal,1.5)*2.0 * vec4(0.9,0.0,0.0,1.0);\n\n\t\tfinalBlood += circleDrip*vec4(0.9, 0.0, 0.0, 1.0);\n\t\tfinalBlood += slice*mix(vec4(-0.15, 1.0, 1.0, 1.0), vec4(0.9,0.0,0.0,1.0), 1.0-constrast_slices)*0.5;\n\n\t\tvec4 finalCol = finalBlood;\n\n\t\t// finalCol.a = clamp(lastA,0.0,1.0);\n\t\treturn vec4(finalCol.rgb,1.0);\n\t} else if (PASSINDEX == 2.0){\n\t\tvec4 passThru = texture(dataPass, _uv);\n\n\t\t// return vec4(passThru.a)*2.0;\n\n\t\t// return passThru;\n\t\tvec4 colOut = addGrain(simPass);\n\t\tfloat lum = dot(colOut.rgb, vec3(1.0))/3.0;\n\t\tcolOut = mix(colOut, (1.0-colOut)*(4.0-more_blood), pow((1.0-lum),5.0)*syn_HighHits*dot(passThru.rba, vec3(1.0))*highs_glitch);\n\n\t\treturn colOut;\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"REDRUM","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"","MAX":9,"MIN":0.100000001490116,"NAME":"R","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":5,"DESCRIPTION":"","MAX":1,"MIN":0.100000001490116,"NAME":"grid","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by crackhouse","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\rgbmandlish.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"RGBMandlish","IMAGES":null,"IMAGE_PATH":"rgbmandlish.synScene\\rgbmandlish.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 9,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"R\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"grid\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by crackhouse\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"rgbmandlish.png\",\n\t\"TITLE\" : \"RGBMandlish\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\nfloat iTime = TIME;\n\n// Anaglyph Structure\n// Framed for https://fanzine.cookie.paris/\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.10.24\n// Using code from Inigo Quilez\n\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat random (in vec2 st) { return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\n\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0.)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * .5 + right * anchor.x + up * anchor.y);\n}\n\n\nfloat map (vec3 pos) {\n    float scene = 10.0;\n    float r = R;\n    const float count = 8.0;\n    for (float index = count; index > 0.0; --index)\n    {\n        pos.xz = abs(pos.xz)-1.5*r;\n        pos.xz *= rot(0.4/r + iTime * 0.1)-sin(grid*0.03);\n        pos.yz *= rot(1.5/r + iTime * 0.05)-sin(grid*0.03);\n        pos.yx *= rot(.2/r + iTime * 0.05)+sin(grid*0.03);\n        scene = min(scene, length(pos.xy)-0.001);\n        scene = min(scene, length(pos)-.3*r)*cos(.2-grid*0.05);\n        r /= 1.8;\n    }\n    return scene;\n}\n\nvec4 raymarch (vec3 eye, vec3 ray) {\n    float dither = random(ray.xy+fract(iTime));\n    vec4 result = vec4(eye, 0);\n    float total = 0.0;\n    float maxt = 20.0;\n    const float count = 30.;\n    for (float index = count; index > 0.0; --index) {\n        result.xyz = eye + ray * total;\n        float dist = map(result.xyz);\n        if (dist < 0.001 + total * .002 || total > maxt) {\n            result.w = index / count;\n            break;\n        }\n        dist *= 0.9 + 0.1 * dither;\n        total += dist;\n    }\n    result.w *= step(total, maxt);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(1.,0.5,-4.5);\n    vec3 at = vec3(0);\n    vec3 ray = look(eye, at, uv);\n    vec3 eyeoffset = 0.02*normalize(cross(normalize(at-eye), vec3(0,1.*grid,0)));\n\n    vec4 resultLeft = raymarch(eye-eyeoffset, ray);\n    vec4 resultRight = raymarch(eye+eyeoffset, ray);\n    fragColor = vec4(resultLeft.w,vec2(resultRight.w),1);\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n    mainImage(out_FragColor, _xy.xy);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"RGBMandlish","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"","MAX":2,"MIN":0.100000001490116,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.75,"DESCRIPTION":"","MAX":2,"MIN":0.5,"NAME":"thickness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":5,"MIN":1,"NAME":"twists","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.454540014266968,"DESCRIPTION":"","MAX":1,"MIN":0.25,"NAME":"gamma","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\rainbowringcubictwist.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"RainbowRingCubicTwist","IMAGES":null,"IMAGE_PATH":"rainbowringcubictwist.synScene\\rainbowringcubictwist.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.75,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"thickness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"twists\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.45454,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.25,\n\t\t\t\"NAME\" : \"gamma\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"rainbowringcubictwist.png\",\n\t\"TITLE\" : \"RainbowRingCubicTwist\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n////////////////////////////////////////////////////////////\r\n// RainbowRingCubicTwist  by mojovideotech\r\n//\r\n// based on :\r\n// glslsandbox/e#58416.0\r\n//\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n////////////////////////////////////////////////////////////\r\n\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\n\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n    float T = sin(PI * syn_BassHits)0.5+syn_Time/2 * rate;\r\n    vec2 R = RENDERSIZE;  \r\n    vec2 P = (_xy.xy - 0.5*R)*(2.1 - scale);\r\n    vec4 S, E, F;\r\n    P = vec2(length(P) / R.y - 0.333, atan(P.y,P.x));  \r\n    P *= vec2(2.6 - thickness,floor(twists));                                                                                                             ;\r\n    S = 0.08*cos(1.5*vec4(0.0, 1.0, 2.0, 3.0) + T + P.y + sin(P.y)*cos(T));\r\n    E = S.yzwx; \r\n    F = max(P.x - S, E - P.x);\r\n    out_FragColor = pow(dot(clamp(F*R.y, 0.0, 1.0), 72.0*(S - E))*(S - 0.1), vec4(gamma));\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"RainbowRingCubicTwist","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\raw_video.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Raw Video","IMAGES":null,"IMAGE_PATH":"raw_video.synScene\\raw_video.png","JSON_CODE":"{\n  \"TITLE\": \"Raw Video\",\n  \"DESCRIPTION\": \"\",\n  \"IMAGE_PATH\": \"raw_video.png\",\n  \"CREDIT\": \"Synesthesia\"\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec4 renderMain(void)\n{\n    return _loadUserImage();\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Raw Video","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"auto_hue","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"darker","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.600000023841858,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"fov_mod","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"ridges_constant","TYPE":"toggle","UI_GROUP":"shape"},{"DEFAULT":1,"DESCRIPTION":"","MAX":-1,"MIN":1,"NAME":"flatten","PARAMS":0.025000000372529,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"highhits_ridges","TYPE":"toggle","UI_GROUP":"shape"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"spiral_ridges","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"shape"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"","MAX":0.400000005960464,"MIN":-0.400000005960464,"NAME":"speed_direction","PARAMS":0.00999999977648258,"TYPE":"knob traveler","UI_GROUP":"time"},{"DEFAULT":0.349999994039536,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"bass_time","TYPE":"knob","UI_GROUP":"time"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"media_scale","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"media_only","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"selector","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"media"}],"CREDIT":"aiekick","DESCRIPTION":" Ray Marching Experiment 62 with another lighting try :)","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\ray_marching_experiment_62.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Ray Marching Experiment 62","IMAGES":null,"IMAGE_PATH":"ray_marching_experiment_62.synScene\\ray_marching_experiment_62.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_hue\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"darker\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flashing\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.6,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 2,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"fov_mod\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"ridges_constant\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : -1,\n         \"MIN\" : 1,\n         \"NAME\" : \"flatten\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.025,\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"highhits_ridges\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"spiral_ridges\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"shape\"\n      },{\n         \"DEFAULT\" : 0.1,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.4,\n         \"MIN\" : -0.4,\n         \"NAME\" : \"speed_direction\",\n         \"TYPE\" : \"knob traveler\",\n         \"PARAMS\":0.01,\n         \"UI_GROUP\" : \"time\"\n      },{\n         \"DEFAULT\" : 0.35,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"bass_time\",\n         \"TYPE\" : \"knob\",\n         \"UI_GROUP\" : \"time\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"media_scale\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"media_only\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"selector\",\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"media\"\n      }\n   ],\n   \"CREDIT\" : \"aiekick\",\n   \"DESCRIPTION\" : \" Ray Marching Experiment 62 with another lighting try :)\",\n   \"HEIGHT\" : 720,\n   \"IMAGE_PATH\" : \"ray_marching_experiment_62.png\",\n   \"TITLE\" : \"Ray Marching Experiment 62\",\n   \"WIDTH\" : 1280\n}\n","PASSES":null,"SCRIPT_CODE":"function ApproachRandomSpot () {\n  this.goal = 0.0;\n  this.currentSpot = 0.0;\n}\n\nApproachRandomSpot.prototype.update = function(amt) {\n  this.currentSpot = this.currentSpot + (this.goal-this.currentSpot)*amt;\n}\n\nvar mover = new ApproachRandomSpot();\n\nvar decimator = 0;\nvar time = 0.0;\nvar rate = 0.0;\nfunction update(dt) {\n\n  time += 0.5*((inputs.syn_BassLevel*inputs.syn_BassLevel*0.1 + inputs.syn_BassPresence*0.2 + 0.01)*inputs.bass_time*1.5);\n\n  uniforms.script_time = time;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n}\n\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 rotx(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 roty(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rotz(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nfloat retreater_var = spiral_ridges*spiral_ridges;\nfloat rotTime = (script_time);\nvec4 fragColor = vec4(0.0);\n\n// vec3 getTexCol(vec3 p, vec4 alt){\n// \tvec2 lookupPos = vec2(p.x*xy_scale, p.z*xy_scale);\n// \treturn texture(syn_UserImage, lookupPos).rgb;\n// }\nvec4 df(vec3 p) // from https://www.shadertoy.com/view/ltcSDr\n{\n\tp *= rotz(p.z * 0.07 * flatten);\n\tvec2 uv = p.xz;\n\tfloat a = length(uv) - rotTime;\n\tuv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\tuv = abs(uv);\n\tuv = vec2(atan(uv.x-retreater_var*100.0, uv.y+retreater_var*50.0)/3.14159, length(uv));\n\tfloat b = sqrt(uv.x) + sqrt(uv.y) - sin(p.x*10.0-p.z*10.0+TIME)*highhits_ridges*0.025*syn_HighHits;\n\tfloat c = sqrt(uv.x + uv.y);\n\tfloat s = b-c;\n\tfloat d = 6. - abs(p.y)  - smoothstep(0.128,1.0-0.128, s*1.32*mix(syn_Presence,1.0,ridges_constant));\n\t// fragColor.rgb += getTexCol(p, vec4(b, c, s, d))*0.085;\n\treturn vec4(d);\n}\n\nvec3 nor( in vec3 p, float prec )\n{\n\tvec3 e = vec3( prec, 0., 0. );\n\tvec3 n = vec3(\n\t    df(p+e.xyy).x - df(p-e.xyy).x,\n\t    df(p+e.yxy).x - df(p-e.yxy).x,\n\t    df(p+e.yyx).x - df(p-e.yyx).x );\n\treturn normalize(n);\n}\n\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n    // return col;\n    \n    // thansk to public_int_i\n    float i1 = sin(TIME*0.45)*0.5+0.5,\n          i2 = cos(TIME*0.45)*0.5+0.5;\n   \treturn mix(col, col*max(0., 1.0-(i1+i2))+\n           col.zxy*i1+\n           col.yzx*i2, auto_hue);\n}\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (_pulse(selector, 0.00, 0.5)*texture(tex, p.yz)*n.x + _pulse(selector, 0.5, 0.5)*texture(tex, p.zx)*n.y + _pulse(selector, 1.0, 0.5)*texture(tex, p.xy)*n.z).xyz;\n}\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t\n\treturn df(p - n * s).x;\t\t\t\t\t\t\n}\n\nvec4 renderMainImage() {\n\tvec2 fragCoord = _xy;    \n  vec2 g = fragCoord.xy;\n\tvec2 si = RENDERSIZE.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\tfloat t = -speed_direction * 0.2;\n\tvec3 ro = vec3(cos(t),0., sin(t)) * 12.; \n  vec3 cv = vec3(0); \n\tvec3 cu = normalize(vec3(0,1,0));\n\tvec3 z = normalize(cv-ro);\n  vec3 x = normalize(cross(cu,z));\n\tvec3 y = cross(z,x);\n  float fov = .9*2.5*pow(fov_mod,2.0);\n\tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n    \n  float s = 1., d = 0., extraLight = 0.0;\n\tfor (int i=0; i<200; i++) \n\t{\n\t\tif (log(d*d/s/1e5)>0.) break;\n\t\td += (s=df(ro+rd*d).x)*.5;\n    extraLight += d/400.*(1.0-darker)+d/300.0*flashing*syn_Hits; // new lighting try system\n\t}\n\n\tfragColor.rgb += extraLight;\n  fragColor.rgb = mix(fragColor.rgb, vec3(d*d/400.), .5);\n    \n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n  float sss = df(p - n*0.001).x/0.1;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\tfloat sb = SubDensity(p, 1., 0.1);\t\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = clamp(blackbody(100. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 1. - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\t\n  fragColor.rgb *= (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe * 1.2;\n\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n  vec2 q = g/si;\n  fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n  if (syn_MediaType > 0.5){\n  \tvec3 texCol = tex3D(syn_UserImage, p*media_scale, n);\n  \tfragColor.rgb = mix(texCol, fragColor.rgb+texCol, 1.0-media_only);\n  }\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Ray Marching Experiment 62","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[-0.200000002980232,-0.200000002980232],"DESCRIPTION":"XY Position of the light source","MAX":[1,1],"MIN":[-1,-1],"NAME":"light_pos","PARAMS":0.100000001490116,"TYPE":"xy smooth","UI_GROUP":"light"},{"DEFAULT":1,"DESCRIPTION":"Z-axis position of the light source","MAX":3,"MIN":-5,"NAME":"light_z","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"light"},{"DEFAULT":0,"DESCRIPTION":"Jump one column right","MAX":1,"MIN":0,"NAME":"move_right","TYPE":"bang counter","UI_GROUP":"fast_motion"},{"DEFAULT":0,"DESCRIPTION":"Jump one row up","MAX":1,"MIN":0,"NAME":"move_up","TYPE":"bang counter","UI_GROUP":"fast_motion"},{"DEFAULT":0,"DESCRIPTION":"Rotate the camera view to the right","MAX":1,"MIN":0,"NAME":"rotate_right","TYPE":"bang counter","UI_GROUP":"fast_motion"},{"DEFAULT":0,"DESCRIPTION":"Rotate the camera view upwards","MAX":1,"MIN":0,"NAME":"rotate_up","TYPE":"bang counter","UI_GROUP":"fast_motion"},{"DEFAULT":0.5,"DESCRIPTION":"Smoothly blend between hyper cube, cube (at 0.0), or sphere","MAX":1,"MIN":-1,"NAME":"cube_sphere","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"A pulse that blends all the cubes together for a moment","MAX":-1,"MIN":1,"NAME":"pulse_pillars","PARAMS":0.0750000029802322,"TYPE":"bang smooth","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"Stretch or squash the objects along the Z-axis","MAX":2,"MIN":0,"NAME":"z_stretch","PARAMS":0.0500000007450581,"TYPE":"knob smooth","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Move each object within its cell some random direction","MAX":1,"MIN":-1,"NAME":"irregularity","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"Size of cuboids","MAX":2,"MIN":0,"NAME":"cube_size","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"Adds in a warm orange/pink glow","MAX":2,"MIN":0,"NAME":"glow_amt","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0.349999994039536,"DESCRIPTION":"How reflective the cuboids are","MAX":1,"MIN":0,"NAME":"reflectivity","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"Adds a dark black fog, good with glow","MAX":1,"MIN":0,"NAME":"fog_amt","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"How much the media will appear in the reflections","MAX":1,"MIN":0,"NAME":"media_reflect","PARAMS":0.100000001490116,"TYPE":"knob smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"How much the media will appear directly painted on the objects","MAX":1,"MIN":0,"NAME":"media_color","PARAMS":0.100000001490116,"TYPE":"knob smooth","UI_GROUP":"media"},{"DEFAULT":[0,0],"DESCRIPTION":"Move the camera around in XY","MAX":[1,1],"MIN":[-1,-1],"NAME":"camera","PARAMS":0.00499999988824129,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":0.5,"DESCRIPTION":"Field of View for the perspective of the camera","MAX":0,"MIN":1,"NAME":"FOV","PARAMS":0.0350000001490116,"TYPE":"knob smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Weird lensing effect that goes positive and negative","MAX":1,"MIN":-1,"NAME":"fisheye","PARAMS":0.0500000007450581,"TYPE":"knob smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Turn this up if for 4x anti-aliasing, but only if you've got a really good GPU!","MAX":1,"MIN":0,"NAME":"anti_aliasing_fps","TYPE":"toggle","UI_GROUP":"fps_warning"}],"CREDIT":"Shane","DESCRIPTION":"A very basic demonstration of raymarching a distance field with reflections and shadows. Definitely not cutting edge, but hopefully, interesting to anyone who isn't quite familiar with the process.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\raymarched_reflections.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Raymarched Reflections","IMAGES":null,"IMAGE_PATH":"raymarched_reflections.synScene\\raymarched_reflections.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : -0.2,\n         \"DESCRIPTION\" : \"XY Position of the light source\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"light_pos\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"light\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Z-axis position of the light source\",\n         \"MAX\" : 3.0,\n         \"MIN\" : -5.0,\n         \"NAME\" : \"light_z\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"light\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Jump one column right\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"move_right\",\n         \"TYPE\" : \"bang counter\",\n         \"UI_GROUP\" : \"fast_motion\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Jump one row up\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"move_up\",\n         \"TYPE\" : \"bang counter\",\n         \"UI_GROUP\" : \"fast_motion\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Rotate the camera view to the right\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"rotate_right\",\n         \"TYPE\" : \"bang counter\",\n         \"UI_GROUP\" : \"fast_motion\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Rotate the camera view upwards\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"rotate_up\",\n         \"TYPE\" : \"bang counter\",\n         \"UI_GROUP\" : \"fast_motion\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Smoothly blend between hyper cube, cube (at 0.0), or sphere\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"cube_sphere\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"geometry\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"A pulse that blends all the cubes together for a moment\",\n         \"MAX\" : -1.0,\n         \"MIN\" : 1.0,\n         \"NAME\" : \"pulse_pillars\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.075,\n         \"UI_GROUP\" : \"geometry\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"Stretch or squash the objects along the Z-axis\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"z_stretch\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"geometry\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Move each object within its cell some random direction\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"irregularity\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"geometry\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Size of cuboids\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"cube_size\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"geometry\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Adds in a warm orange/pink glow\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"glow_amt\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.35,\n         \"DESCRIPTION\" : \"How reflective the cuboids are\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"reflectivity\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0.3,\n         \"DESCRIPTION\" : \"Adds a dark black fog, good with glow\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"fog_amt\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"color\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"How much the media will appear in the reflections\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"media_reflect\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"How much the media will appear directly painted on the objects\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"media_color\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"media\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"Move the camera around in XY\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"camera\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.005,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Field of View for the perspective of the camera\",\n         \"MAX\" : 0.0,\n         \"MIN\" : 1.0,\n         \"NAME\" : \"FOV\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.035,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Weird lensing effect that goes positive and negative\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"fisheye\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn this up if for 4x anti-aliasing, but only if you've got a really good GPU!\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"anti_aliasing_fps\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"fps_warning\"\n      }\n   ],\n   \"CREDIT\" : \"Shane\",\n   \"DESCRIPTION\" : \"A very basic demonstration of raymarching a distance field with reflections and shadows. Definitely not cutting edge, but hopefully, interesting to anyone who isn't quite familiar with the process.\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"raymarched_reflections.png\",\n   \"TITLE\" : \"Raymarched Reflections\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"function Timer () {\n  this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function(rate, val, dt) {\n  this.time = this.time+rate*dt*val;\n}\n\nfunction SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\n\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n\n}\n\n\n\n// var bpmcount = new BPMCounter();\n\nvar moveRight = new SmoothCounter();\nvar moveUp = new SmoothCounter();\nvar rotateRight = new SmoothCounter();\nvar rotateUp = new SmoothCounter();\n\n\nvar timevar = new Timer();\n\n\n\nvar decimator = 0;\n\nvar t = 0;\n\n\n\nfunction update(dt) {\n\n\n\n  try {\n\n    timevar.updateTime(1, inputs.const_rate + inputs.syn_BassLevel*inputs.bass_rate, dt);\n\n    uniforms.script_time = timevar.time;\n\n    moveRight.update(dt, inputs.move_right, 0.2);\n    moveUp.update(dt, inputs.move_up, 0.2);\n    rotateRight.update(dt, inputs.rotate_right, 0.1);\n    rotateUp.update(dt, inputs.rotate_up, 0.1);\n\n    uniforms.moveRightScr = moveRight.currentValue;\n    uniforms.moveUpScr = moveUp.currentValue;\n    uniforms.rotateRightScr = rotateRight.currentValue;\n    uniforms.rotateUpScr = rotateUp.currentValue;\n  } \n\n\n\n    catch (e){\n\n    print(e);\n\n  }\n\n\n\n}","SHADER_CODE":"/*\n\tRaymarched Reflections\n\t----------------------\n\n\tA very basic demonstration of raymarching a distance field with reflections \n\tand reasonably passable shadows. Definitely not cutting edge, but hopefully, \n\tinteresting to anyone who isn't quite familiar with the process.\n\n\tReflections are pretty easy: Raymarch to the hit point, then obtain the color \n\tat that point. Continue on from the hit point in the direction of the reflected \n\tray until you reach a new hit point. Obtain the color at the new point, then\n\tadd a portion of it to your original color. Repeat the process.\n\n\tUnfortunately, the extra work can slow things down, especially when you apply\n\tshadows, which is probably why you don't see too many shadowed,\treflected \n\texamples. However, for relatively simple distance fields, it's pretty doable.\n\n\tIt was tempting to do this up, but I figured a simpler example would be more\n\thelpful. Take away the rambling comments, and there isn't a great deal of code.\n\tI'll post a more sophisticated one later.\n*/\n\nvec3 _grad3(vec3 col1, vec3 col2, vec3 col3, float mixVal){\n    mixVal *= 2.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    return mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n}\n\nvec3 _grad4(vec3 col1, vec3 col2, vec3 col3, vec3 col4, float mixVal){\n    mixVal *= 3.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    vec3 firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    return mix(firstTwo, mix(col3, col4, mix3), step(2.0, mixVal));\n}\n\nvec3 _grad5(vec3 col1, vec3 col2, vec3 col3, vec3 col4, vec3 col5, float mixVal){\n    mixVal *= 4.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    float mix4 = clamp(mixVal-3.0, 0.0, 1.0);\n\n    vec3 firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    vec3 lastTwo = mix(mix(col3, col4, mix3), mix(col4, col5, mix4), step(3.0, mixVal));\n\n    return mix(firstTwo, lastTwo, step(2.0, mixVal));\n}\n\nvec3 zTime = vec3(0., 0., syn_BassTime*0.2+TIME*0.25);\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    vec3 mirP = p;\n    vec3 modP = mod(p, vec3(2.0));\n    if (modP.x > 1.0){\n        mirP.x = 1.0-p.x;\n    }\n    if (modP.y > 1.0){\n        mirP.y = 1.0-p.y;\n    }\n    if (modP.z > 1.0){\n        mirP.z = 1.0-p.z;\n    }\n    vec3 tx = _contrast(_invertImage(vec4(texture(t, mirP.yz).xyz, 0.0)), _Media_Contrast).rgb;\n    vec3 ty = _contrast(_invertImage(vec4(texture(t, mirP.zx).xyz, 0.0)), _Media_Contrast).rgb;\n    vec3 tz = _contrast(_invertImage(vec4(texture(t, mirP.xy).xyz, 0.0)), _Media_Contrast).rgb;\n\n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n#define FAR 30.\n\n// Distance function. This one is pretty simple. I chose rounded\n// spherical boxes, because they're cheap and they display the \n// reflections reasonably well.\nfloat map(vec3 p)\n{\n    float scaleSpace = cube_size;\n    // p *= cube_size;\n    p += zTime;\n    // Positioning the rounded cubes a little off center, in order\n    // to break up the space a little.\n    //\n    // \"floor(p)\" represents a unique number (ID) for each cube \n    // (based on its unique position). Take that number and produce \n    // a randomized 3D offset, then add it to it's regular position. \n    // Simple.\n    float n = sin(dot(floor(p), vec3(27, 113, 57)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16 - .08;\n    \n    // Repeat factor. If irregularity isn't your thing, you can get \n    // rid of \"rnd\" to line things up again.\n    p = fract(p + rnd*irregularity*3.0) - .5;\n    p.z *= pulse_pillars;\n    p.z *= z_stretch;\n    // Rounded spherical boxes. The following is made up, but kind of\n    // makes sense. Box, minus a bit of sphericalness, gives you a \n    // rounded box.\n    p = abs(p); \n    float box = max(p.x, max(p.y, p.z))-0.25*scaleSpace;\n    float round = dot(p, p)*0.5-0.05*scaleSpace;\n    return mix(box, round, cube_sphere);\n    \n    //return length(p) - 0.225; // Just spheres.\n}\nvec3 g;\n\n// float iterReducer = (5.0-cube_size)*0.2;\nfloat iterReducer = (5.0)*0.2;\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 120; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.0005 || t>FAR) break;        \n        \n        t += d*.75;  // Using more accuracy, in the first pass.\n\n        g += vec3(.5, .5, .5) * .005 / (.01 + d*d);         //Glow\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 64; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>(FAR*1.5)) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0035;    \n    float end = max(length(rd), .001);\n\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(.0025, -.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n// Alternating the cube colors in a 3D checkered arrangement.\n// You could just return a single color, if you wanted, but I\n// thought I'd mix things up a bit.\n//\n// Color scheme mildly influenced by: Sound Experiment 3 - aiekick\n// https://www.shadertoy.com/view/Ml2XWt\nvec3 getObjectColor(vec3 p){\n    \n    // vec3 col = vec3(0.0,0.0,1.0);\n    // // \"floor(p)\" is analogous to a unique ID - based on position.\n    // // This could be stepped, but it's more intuitive this way.\n    // vec3 scaledP = p*scaleSpace;\n    // scaledP += zTime;\n    // if(fract(dot(floor(scaledP), vec3(0.5))) > .001){\n    //     col = vec3(1.0, 0.0, 0.0);\n    // }\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    col = _hsv2rgb(vec3(p.z*0.03+p.x*0.02, 1.0, 1.0));\n    return col;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    vec3 texCol = tex3D(syn_UserImage, sp+zTime, sn);\n    texCol = pow(texCol, vec3(2.0))*10.0;\n    objCol = mix(objCol, texCol, media_color);\n\n    // Combining the above terms to produce the final scene color.\n    vec3 lightCol = vec3(1.0,1.0, 1.0);\n    float tMod = _pulse(t, 0.0, 0.01);\n    // objCol = tMod*darker_edges*vec3(-10.0);\n    // objCol = mix(objCol, objCol+tMod*vec3(-10.0), darker_edges);\n    vec3 sceneCol = (objCol*(diff + (.15+media_color*0.2)) + lightCol*spec*4.) * atten;\n    // sceneCol = _palette(1.0-dot(normalize(sn), rd)*2.0, vec3(1.020, 0.520, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.240, 0.750), vec3(0.480, 0.090, 0.870));\n\n\n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n#define AA_ON\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n#ifdef AA_ON\nint AA = 1+int(anti_aliasing_fps);\nvec4 tot = vec4(0.0);\nfor( int m=0; m<AA; m++ )\nfor( int nm=0; nm<AA; nm++ )\n    {\n    vec2 o = vec2(float(m),float(nm)) / float(AA) - 0.5;\n    o /= RENDERSIZE.y;\n#else\n    vec2 o = vec2(0.0);\n#endif\n\n\n    vec2 screenPos = -1.0 + 2.0 * _uv;\n    screenPos.x *= RENDERSIZE.x / RENDERSIZE.y;\n    screenPos = screenPos + o;\n\n    vec2 n = vec2(_rand(_uvc+fract(TIME))) - 0.5;\n\n    float x = screenPos.x;\n    float y = screenPos.y;\n    float z = (length(vec3(1.0))-sqrt(abs(x)*abs(x)+ abs(y)*abs(y)));\n\n    vec3 normb = normalize(vec3(x,y,z+FOV));\n\n    normb = mix(normalize(vec3(x, y, mix(0.3, 10.0, FOV*FOV*FOV))), normb, fisheye);\n\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - RENDERSIZE.xy*.5) / RENDERSIZE.y;\n    \n    // Unit direction ray.\n    vec3 rd = normb;\n    \n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself, at this point. :)\n    // float cs = cos(camera.x * PI);\n    // float si = sin(camera.y * PI);\n    // rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    // rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    rd.xz = _rotate(rd.xz, camera.x*PI+rotateRightScr*(PI/3.5));\n\n    rd.yz = _rotate(rd.yz, camera.y*PI+rotateUpScr*(PI/3.5));\n\n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0.0)+vec3(moveRightScr, moveUpScr, 0.0);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(light_pos.x*5.0, light_pos.y*5.0, 5.0+light_z*5.0);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n   \n    vec3 sp = ro + rd*t;\n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! - Better call the shadow police. :)\n    float sh = softShadow(ro, lp, 16.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    float tSave = t;\n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    vec3 reflCol = doColor(ro, rd, sn, lp, t);\n    vec3 texRefCol = tex3D(syn_UserImage, ro, sn);\n    reflCol = mix(reflCol, texRefCol, media_reflect);\n    sceneColor = _grad3(sceneColor, reflCol+sceneColor, reflCol, reflectivity);\n    // Other combinations... depending what you're trying to achieve.\n    //sceneColor = sceneColor*.7 + doColor(ro, rd, sn, lp, t)*.5;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, tSave/mix(FAR, FAR*0.1, fog_amt));\n    fogF += smoothstep(0., .95, t/mix(FAR, FAR*0.1, fog_amt));\n    \n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneColor = mix(sceneColor, vec3(0), fogF); \n\n    //Add in Glow\n    vec3 glowCol = mix(vec3(.9, .2, .4), vec3(.3, cos(TIME)*.1, .2), 0.0);\n    glowCol.r *= (0.5+0.5*sin(TIME));\n    glowCol = _palette(1.0-sn.y, vec3(1.020, 0.520, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.240, 0.750), vec3(0.480, 0.090, 0.870));\n    float glowPow = clamp(glow_amt, 1.0, 2.0)-1.0;\n    float glowAmt = 1.0/pow(distance(sp, lp),3.0-glowPow*2.0);\n    float glowDim = clamp(glow_amt, 0.0, 1.0);\n    sceneColor += glowDim*glowAmt*glowCol * pow(g*4/(AA*AA),vec3(2.0))* .0009;\n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n    #ifdef AA_ON\n    tot += vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n  }\n    tot /= float(AA*AA);\n    // vec4 color = pow(tot, vec4(1.75));\n    vec4 color = tot;\n    #else\n    vec4 color = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n    color = pow(color, vec4(2.0));\n    #endif\n\treturn color; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Raymarched Reflections","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"When ON, the usually larger, static, colored grid of circles will be visible, when OFF, the circles won't appear.","MAX":1,"MIN":0,"NAME":"grid_1","TYPE":"toggle","UI_GROUP":"grid_1"},{"DEFAULT":0,"DESCRIPTION":"When ON, pulses of rings will propagate through the main grid's circles. When OFF, no rings will appear.","MAX":1,"MIN":0,"NAME":"pulser","TYPE":"toggle","UI_GROUP":"grid_1"},{"DEFAULT":1,"DESCRIPTION":"Controls the number and size of the circles on the main grid. Also affects the size of the pulser and mask. Higher is more, smaller pieces.","MAX":6,"MIN":0,"NAME":"resolution","TYPE":"slider","UI_GROUP":"grid_1"},{"DEFAULT":0,"DESCRIPTION":"When ON, a grid of smaller dots that react to an underlying shape (or UserImage) will be visible. Turn OFF for a simpler scene featuring only the main grid.","MAX":1,"MIN":0,"NAME":"grid_2","TYPE":"toggle","UI_GROUP":"grid_2"},{"DEFAULT":5,"DESCRIPTION":"grid 2 MUST BE ON. Controls the number and size of the active grid's circles.","MAX":7,"MIN":0,"NAME":"resolution_2","TYPE":"slider","UI_GROUP":"grid_2"},{"DEFAULT":1.20000004768372,"DESCRIPTION":"grid 2 MUST BE ON. Controls the size and intensity of the action in the active grid's motion.","MAX":3,"MIN":0,"NAME":"intensity","TYPE":"slider","UI_GROUP":"grid_2"},{"DEFAULT":1,"DESCRIPTION":"grid 2 MUST BE ON. Controls the color of the active grid's circles.","MAX":1,"MIN":0,"NAME":"black_or_white","TYPE":"toggle","UI_GROUP":"grid_2"},{"DEFAULT":0,"DESCRIPTION":"Make every color it's opposite, instead. Results in a nice blue color scheme when ON. Use alongside black or white to control color.","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Add some regular black shapes to the scene. The size and number are controlled by 'resolution'. The shape type is controlled by 'Transition'.","MAX":1,"MIN":0,"NAME":"mask","TYPE":"toggle","UI_GROUP":"effects"},{"DEFAULT":0,"DESCRIPTION":"Turn ON to start the whole scene rotating, or OFF to keep it rectilinear.","MAX":1,"MIN":0,"NAME":"rotating","TYPE":"toggle","UI_GROUP":"effects"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\rearranged.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"shape_type_1","VALUES":[0,1]},{"UNIFORM":"shape_type_2","VALUES":[0,1]},{"UNIFORM":"shape_angle","VALUES":[0,1]},{"UNIFORM":"scanDirection","VALUES":[0,1]},{"UNIFORM":"colorMode","VALUES":[0,1]}],"HEIGHT":1080,"ID":"Rearranged","IMAGES":null,"IMAGE_PATH":"rearranged.synScene\\rearranged.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Rearranged\",\n \"IMAGE_PATH\": \"rearranged.png\",\n \"HARD_TRANSITIONS\": [\n        {\n            \"UNIFORM\": \"shape_type_1\", \n            \"VALUES\":[0.0,1.0]\n        },{\n            \"UNIFORM\": \"shape_type_2\", \n            \"VALUES\":[0.0,1.0]\n        },{\n            \"UNIFORM\": \"shape_angle\", \n            \"VALUES\":[0.0,1.0]\n        },\n        {\n            \"UNIFORM\": \"scanDirection\", \n            \"VALUES\":[0.0,1.0]\n        },\n        {\n            \"UNIFORM\": \"colorMode\", \n            \"VALUES\":[0.0,1.0]\n        }\n    ],\n \"SMOOTH_TRANSITIONS\": [\n    {\"UNIFORMS\":[\"cReg0\", \"cReg1\", \"cReg2\"], \n    \"DURATION\": 5}\n    ],\n  \"CONTROLS\": [\n        {\n            \"NAME\": \"grid_1\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":1.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"When ON, the usually larger, static, colored grid of circles will be visible, when OFF, the circles won't appear.\",\n            \"UI_GROUP\":\"grid_1\"\n        },{\n            \"NAME\": \"pulser\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"When ON, pulses of rings will propagate through the main grid's circles. When OFF, no rings will appear.\",\n            \"UI_GROUP\":\"grid_1\"\n        },{\n            \"NAME\": \"resolution\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 6.0,\n            \"DEFAULT\":1.0,\n            \"TYPE\":\"slider\",\n            \"DESCRIPTION\": \"Controls the number and size of the circles on the main grid. Also affects the size of the pulser and mask. Higher is more, smaller pieces.\",\n            \"UI_GROUP\":\"grid_1\"\n        },{\n            \"NAME\": \"grid_2\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"When ON, a grid of smaller dots that react to an underlying shape (or UserImage) will be visible. Turn OFF for a simpler scene featuring only the main grid.\",\n            \"UI_GROUP\":\"grid_2\"\n        },{\n            \"NAME\": \"resolution_2\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 7.0,\n            \"DEFAULT\":5.0,\n            \"TYPE\":\"slider\",\n            \"DESCRIPTION\": \"grid 2 MUST BE ON. Controls the number and size of the active grid's circles.\",\n            \"UI_GROUP\":\"grid_2\"\n        },{\n            \"NAME\": \"intensity\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 3.0,\n            \"DEFAULT\":1.2,\n            \"TYPE\":\"slider\",\n            \"DESCRIPTION\": \"grid 2 MUST BE ON. Controls the size and intensity of the action in the active grid's motion.\",\n            \"UI_GROUP\":\"grid_2\"\n        },{\n            \"NAME\": \"black_or_white\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":1.0,\n            \"TYPE\":\"toggle\",\n            \"UI_GROUP\": \"grid_2\",\n            \"DESCRIPTION\": \"grid 2 MUST BE ON. Controls the color of the active grid's circles.\"\n        },{\n            \"NAME\": \"invert\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"Make every color it's opposite, instead. Results in a nice blue color scheme when ON. Use alongside black or white to control color.\",\n            \"UI_GROUP\":\"effects\"\n        },{\n            \"NAME\": \"mask\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"Add some regular black shapes to the scene. The size and number are controlled by 'resolution'. The shape type is controlled by 'Transition'.\",\n            \"UI_GROUP\":\"effects\"\n        },{\n            \"NAME\": \"rotating\",\n            \"MIN\" : 0.0,\n            \"MAX\" : 1.0,\n            \"DEFAULT\":0.0,\n            \"UI_GROUP\":\"effects\",\n            \"TYPE\":\"toggle\",\n            \"DESCRIPTION\": \"Turn ON to start the whole scene rotating, or OFF to keep it rectilinear.\"\n        }\n    ],\n    \"PASSES\": [\n    {\n        \"TARGET\":\"firstBuff\",\n        \"FLOAT\": true\n    },\n    {\n        \"TARGET\":\"secondBuff\",\n        \"FLOAT\": true\n    }\n    ]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuff","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuff","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"\n#line 0\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0f;\n    x /= w;\n    return 1.0f - x*x*(3.0f-2.0f*x);\n}\n\n// ******** BOX *********\nconst float pi = 3.14159;\n\nfloat time = TIME;\nvec2 mouse = vec2(0.5);\n\nfloat rand(vec3 co){\n    return 0.9+0.1*fract(sin(co.z+dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 rotate(vec3 v,vec2 r) \n{\n  mat3 rxmat = mat3(1,   0    ,    0    ,\n        0,cos(r.y),-sin(r.y),\n        0,sin(r.y), cos(r.y));\n  mat3 rymat = mat3(cos(r.x), 0,-sin(r.x),\n           0    , 1,    0    ,\n        sin(r.x), 0,cos(r.x));\n  \n  \n  return (v*rxmat)*rymat;\n  \n}\n\nvec3 norm(vec3 v)\n{\n  //box made of 6 planes\n  float tp = dot(v,vec3(0,-1,0))*3.;\n  float bt = dot(v,vec3(0,1,0))*3.;\n  float lf = dot(v,vec3(1,0,0))*3.;\n  float rt = dot(v,vec3(-1,0,0))*3.;\n  float fr = dot(v,vec3(0,0,1))*3.;\n  float bk = dot(v,vec3(0,0,-1))*3.;\n  \n  return v/min(min(min(min(min(tp,bt),lf),rt),fr),bk);\n}\n\nfloat grid(vec3 v)\n{\n  float g;\n  \n  g = (length(v));\n  g = (1.0-(g*g)*2.0)*2.0*rand(v);\n  return g*g-0.125*cos(fract(time)*pi*2.0);\n}\n\nvec3 boxPattern( void ) {\n\n  vec2 res = vec2(RENDERSIZE.x/RENDERSIZE.y,1.0);\n  vec2 p = ( gl_FragCoord.xy / RENDERSIZE.y ) -(res/2.0);\n  \n  p = mix(p,p * (1.0-dot(p,p)*1.5),length(p)*1.5);\n  \n  vec2 m = vec2(syn_Presence+syn_BassLevel*0.3+syn_Time*0.01, syn_BPMTwitcher*0.1)*pi*vec2(2.,1.);\n  \n  vec3 color = vec3(0.0);\n  \n  vec3 pos = norm(rotate(vec3(p,0.5),vec2(m)));\n  \n  float c = grid(pos);\n  return pos;\n}\n\n// ******** MAIN *********\n\nvec4 renderMain(void)\n{\n\tvec3 bkgGradient = mix(_normalizeRGB(251,131,104), _normalizeRGB(239, 109, 119), 1.0-_uv.x);\n\tvec3 bkgGradientInv = mix(_normalizeRGB(239, 109, 119), _normalizeRGB(251,131,104), 1.0-_uv.x);\n\n\tvec2 uv = _uv;\n\tvec2 uvc = _uvc;\n\tif (rotating > 0.5){\n\t\tuvc = _rotate(uvc, syn_CurvedTime*0.1);\n\t\tuv = _rotate(_uvc,syn_CurvedTime*0.1)*vec2(RENDERSIZE.y/RENDERSIZE.x, 1.0)+0.5;\n\t}\n\n\tvec2 gridSpace = mod(uvc*4.5*pow(2, ceil(resolution)), 2.0)-1.0;\n\n\tfloat xDivisor = 4.0*pow(2, ceil(resolution));\n\tfloat yDivisor = 2.25*pow(2, ceil(resolution));\n\tvec2 index = vec2(floor(uv.x*xDivisor), floor((uv.y-0.5)*yDivisor));\n\tfloat selectedOne = step(0.9, _rand(pow(2, index.x/xDivisor)*pow(2, index.y/yDivisor) + floor(syn_BPMTwitcher)));\n\tfloat selectedOthers = step(0.7, _rand(pow(2, index.x/xDivisor)*pow(2, index.y/yDivisor)*273.2 + floor(syn_BPMTwitcher)));\n\n\tfloat sizeMod = (ceil(resolution)/6.0)*0.2;\n\tfloat circ = 1.0-smoothstep(0.12+sizeMod, 0.22+sizeMod, \n\t\tlength(gridSpace)-\n\t\tselectedOne*pow(syn_OnBeat,0.4)*(0.4+sizeMod));\n\tvec3 circCol = mix(_normalizeRGB(72, 196, 201),vec3(1.0),selectedOne*syn_OnBeat)*(0.2+0.8*syn_Presence);\n\tcircCol = mix(circCol, bkgGradient, cubicPulse(uv.y+abs(uvc.x), 0.4, fract(TIME*0.2)*2.0-0.3)*selectedOthers);\n\tcircCol *= circ;\n\t// circCol -= circ*cubicPulse(uv.y+abs(uvc.x), 0.4, (syn_BPMTri2/syn_BPMConfidence)*2.0-0.3)*0.2;\n\n\tfloat noise = _rand(uv*10.0+_pixelate(TIME, 10.0))*0.1;\n\n\tfloat shading = length(gridSpace)*pow(syn_BassLevel,2.0)*2.5;\n\n\tvec3 finalCol = vec3(0.0);\n\n\tfinalCol += pulser*cubicPulse(0.8*index.y/yDivisor, 0.2+selectedOne*0.9, (-1.0+2.0*scanDirection)*(fract(syn_BPMTwitcher)*1.2-1.0+0.2*(1.0-scanDirection)))*cubicPulse(length(gridSpace*2.0),0.1,0.5+sizeMod*3.0);\n\n\tvec2 smallGridSpace = mod(uvc*4.5*pow(2, ceil(resolution_2)), 2.0)-1.0;\n\tfloat smallXDiv = 4.0*pow(2, ceil(resolution_2));\n\tfloat smallYDiv = 2.25*pow(2, ceil(resolution_2));\n\tvec2 smallIndex = vec2(floor(uv.x*smallXDiv), floor((uv.y-0.5)*smallYDiv));\n\n\tvec3 image = pow(boxPattern(),vec3(4.6))*200.0;\n\tif (_exists(syn_UserImage)){\n\t\timage = texture(syn_UserImage, vec2(smallIndex.x/smallXDiv, smallIndex.y/smallYDiv + 0.501)).rgb;\n\t}\n\tfloat imgBri = dot(image, vec3(1.0))/3.0;\n\n\tfloat circSmall = 1.0-smoothstep((0.0+imgBri*0.8*(0.5+syn_HighHits*0.5))*intensity, (0.05+imgBri*0.8*(0.5+syn_HighHits*0.5))*intensity, \n\tlength(smallGridSpace));\n\n\t// finalCol = vec3(index.x/xDivisor, index.y/yDivisor, 0.0)+selectedOne-circ - length(circSpace);\n\t// finalCol = vec3(step(gridSpace.x*gridSpace.y,0.7));\n\tvec3 userImageCol = vec3((-1.0+black_or_white*2.0)*circSmall);\n\n\tfinalCol += mix(bkgGradient, bkgGradientInv, shading)+userImageCol*grid_2-noise;\n\tvec2 angle = vec2(1.0);\n\tif (shape_angle>0.5){\n\t\tgridSpace.y = -gridSpace.y;\n\t}\n\tfloat modder = gridSpace.x*angle.x+gridSpace.y*angle.y;\n\tif (shape_type_2 > 0.5){\n\t\tmodder = gridSpace.x*gridSpace.y;\n\t}\n\tif (shape_type_1 > 0.5){\n\t\tmodder = abs(modder);\n\t}\n\tif (mask > 0.5){\n\t\tfinalCol -= smoothstep(0.45,0.5, pow(modder,3.0));\n\t}\n\t\n\tfinalCol *= (1.0-circ*grid_1);\n\tfinalCol += circCol*grid_1;\n\n\tfinalCol = mix(finalCol, 1.0-finalCol, invert);\n\n\t// finalCol = image;\n\n\treturn vec4(finalCol,0.0);\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":5,"UNIFORMS":["cReg0","cReg1","cReg2"]}],"TAGS":[],"TITLE":"Rearranged","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Rotate the fractal along the Z axis, turning it into a goopy mess.","MAX":1,"MIN":0,"NAME":"rot_on","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"psych"},{"DEFAULT":1,"DESCRIPTION":"Rotate to the right or left.","MAX":1,"MIN":-1,"NAME":"rot_direction","PARAMS":0.0500000007450581,"TYPE":"toggle smooth","UI_GROUP":"psych"},{"DEFAULT":1,"DESCRIPTION":"Changes from a short to long lens perspective.","MAX":10,"MIN":0,"NAME":"perspective","PARAMS":0.025000000372529,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Multiplier on the z-axis. Similar, but different from perspective.","MAX":1.5,"MIN":0,"NAME":"z_depth","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Rotate the camera downwards by 90 degrees.","MAX":1,"MIN":0,"NAME":"down_rot","TYPE":"bang counter","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Rotate the camera rightwards by 90 degrees.","MAX":1,"MIN":0,"NAME":"right_rot","TYPE":"bang counter","UI_GROUP":"camera"},{"DEFAULT":4.30000019073486,"DESCRIPTION":"Changes the number of iterations that create the scaffold. Only 4 options here. Heavily modifies how the rotation in psych behaves as well.","MAX":4.30000019073486,"MIN":1.00999999046326,"NAME":"iters","TYPE":"slider","UI_GROUP":"fractal"},{"DEFAULT":[1,1],"DESCRIPTION":"Stretches and distorts the fractal. Default is 50/50 right in the middle.","MAX":[2,2],"MIN":[0,0],"NAME":"scale_xy","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"fractal"},{"DEFAULT":[1,1,1],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"col1","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":[0,0.800000011920929,1],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"col2","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":[1,0.400000005960464,0],"DESCRIPTION":"","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"col3","TYPE":"color","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"bar_on","PARAMS":0.00999999977648258,"TYPE":"toggle smooth","UI_GROUP":"color"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\scaffold_fractal.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Scaffold Fractal","IMAGES":null,"IMAGE_PATH":"scaffold_fractal.synScene\\scaffold_fractal.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Scaffold Fractal\",\n \"IMAGE_PATH\": \"scaffold_fractal.png\",\n \"HARD_TRANSITIONS\": [],\n \"IMAGES\": [],\n \"PASSES\": [],\n \"HEIGHT\": 720,\n \"WIDTH\": 1280,\n \"CONTROLS\": [{\n    \"NAME\": \"rot_on\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\":0.1,\n    \"TYPE\": \"slider smooth\",\n    \"UI_GROUP\":\"psych\",\n    \"DESCRIPTION\": \"Rotate the fractal along the Z axis, turning it into a goopy mess.\"\n  },{\n    \"NAME\": \"rot_direction\",\n    \"MAX\" : 1.0,\n    \"MIN\" : -1.0,\n    \"DEFAULT\":1.0,\n    \"PARAMS\":0.05,\n    \"TYPE\": \"toggle smooth\",\n    \"UI_GROUP\":\"psych\",\n    \"DESCRIPTION\": \"Rotate to the right or left.\"\n  },{\n    \"NAME\": \"perspective\",\n    \"MAX\" : 10.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1,\n    \"PARAMS\":0.025,\n    \"TYPE\": \"slider smooth\",\n    \"UI_GROUP\":\"camera\",\n    \"DESCRIPTION\": \"Changes from a short to long lens perspective.\"\n  },{\n    \"NAME\": \"z_depth\",\n    \"MAX\" : 1.5,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"PARAMS\":0.05,\n    \"TYPE\": \"slider smooth\",\n    \"UI_GROUP\":\"camera\",\n    \"DESCRIPTION\":\"Multiplier on the z-axis. Similar, but different from perspective.\"\n  },{\n    \"NAME\": \"down_rot\",\n    \"TYPE\": \"bang counter\",\n    \"UI_GROUP\":\"camera\",\n    \"DESCRIPTION\": \"Rotate the camera downwards by 90 degrees.\"\n  },{\n    \"NAME\": \"right_rot\",\n    \"TYPE\": \"bang counter\",\n    \"UI_GROUP\":\"camera\",\n    \"DESCRIPTION\": \"Rotate the camera rightwards by 90 degrees.\"\n  },{\n    \"NAME\": \"iters\",\n    \"MAX\" : 4.3,\n    \"MIN\" : 1.01,\n    \"DEFAULT\":4.3,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\":\"fractal\",\n    \"DESCRIPTION\": \"Changes the number of iterations that create the scaffold. Only 4 options here. Heavily modifies how the rotation in psych behaves as well.\"\n  },{\n    \"NAME\": \"scale_xy\",\n    \"MAX\" : 2.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"PARAMS\":0.01,\n    \"TYPE\": \"xy smooth\",\n    \"UI_GROUP\":\"fractal\",\n    \"DESCRIPTION\":\"Stretches and distorts the fractal. Default is 50/50 right in the middle.\"\n  },{\n    \"NAME\": \"col1\",\n    \"TYPE\": \"color\",\n    \"DEF_COLOR\":[1.0,1.0,1.0],\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"col2\",\n    \"TYPE\": \"color\",\n    \"DEF_COLOR\":[0.0,0.8,1.0],\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"col3\",\n    \"TYPE\": \"color\",\n    \"DEF_COLOR\":[1.0,0.4,0.0],\n    \"UI_GROUP\":\"color\"\n  },{\n    \"NAME\": \"bar_on\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle smooth\",\n    \"UI_GROUP\":\"color\"\n  }]\n }","PASSES":null,"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = 0.25*bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nfunction SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n}\n\nvar bpmcount = new BPMCounter();\nvar downrot = new SmoothCounter();\nvar rightrot = new SmoothCounter();\n\nvar decimator = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM;\n  bpmcount.updateTime(bpm, dt);\n\n  uniforms.script_time = bpmcount.timeWithinBeat+bpmcount.count;\n\n  downrot.update(dt, inputs.down_rot, 0.1);\n  rightrot.update(dt, inputs.right_rot, 0.1);\n\n  uniforms.down_rot_scr = downrot.currentValue;\n  uniforms.right_rot_scr = rightrot.currentValue;\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"float time = TIME;\nvec2 mouse = vec2(0.5);\nvec2 resolution = RENDERSIZE;\n\n// a raymarching experiment by kabuto\n// dmt fork by s1e\n// controls, modifications, and audio reactivity by Meebs\n// found on glslsandbox.com\n\n\nconst int MAXITER = 25;\n\nvec3 field(vec3 p, float dime) {\n    p *= 0.09;\n    float f = 0.09;\n\n    for (int i = 0; i < int(iters); i++) {\n        p = p.yzx*mat3( .8*scale_xy.x,             .6*scale_xy.y,                             0,\n                      -0.6,                        0.8+0.01*sin(dime/120.0),       0, \n                       0.0 + 0.042*sin(dime/25.0), 0.0033 + 0.0012*cos(dime/75.0), 1);\n        p += vec3(0.2, cos(TIME/45.0)*0.1 + 0.3, cos(TIME/90.0)*0.1 + 0.3)*float(i);\n        p = abs(fract(p)-.5);\n        p *= 2.0;\n        f *= 2.0;\n    }\n    p *= p;\n    return sqrt(p+p.yzx)/f-.002;\n}\n\nfloat pulse(float variable, float center, float width, float bias){\n  return (smoothstep(center-width, center, variable)-(smoothstep(center+bias, center+width+bias, variable)));\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n  float ca = cos(angle); float sa = sin(angle);\n  return v*mat3(\n                +ca, +.0, -sa,\n                +.0,+1.0, +.0,\n                +sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n  float ca = cos(angle); float sa = sin(angle);\n  return v*mat3(\n                +1.0, +.0, +.0,\n                +.0, +ca, -sa,\n                +.0, +sa, +ca);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec4 renderMain( void ) {\n    float dime = syn_CurvedTime*10.0;\n    vec3 dir = normalize(vec3((_xy-resolution*.5)*(perspective+rot_on*4.0)/resolution.x,0.66));\n    dir *= vec3(1.0,1.0,z_depth);\n    dir = rotate_y(dir, PI*0.5*down_rot_scr);\n    dir = rotate_x(dir, PI*0.5*right_rot_scr);\n    // dir = mix(diry, dirx, 0.5);\n\n    vec3 pos = vec3(0.0, syn_Presence, dime/16.0);\n    vec3 color = vec3(0);\n    float hit = 0.0;\n    for (int i = 0; i < MAXITER; i++) {\n        vec3 f2 = field(pos, dime);\n        float f = min(min(f2.x,f2.y),f2.z);\n        if (f < 0.0002*100.0){\n            hit = 1.0;\n        }\n        pos += dir*f;\n        pos.xy = _rotate(pos.xy, (pos.z-dime/16.0)*pow(rot_on,2.0)*rot_direction);\n        color += float(MAXITER-i)/(f2+.000025);\n    }\n    // vec3 color3 = vec3(1.-1.0/(color*(0.00106)));\n    // color3 = color3 * color3 * color3 * color3;\n\n    color = _gamma(vec4(color,1.0), 1.0-pow(rot_on,0.25)*0.25).rgb;\n\n    vec3 posHit = pos*hit;\n\n    float divisor = 0.000106;\n    divisor *= 4.5-iters;\n\n    vec3 data = color*divisor;\n    vec3 barsData = pow(color*divisor,vec3(10.0));\n    vec3 fogData = clamp(data-barsData,0.0,1.0);\n\n    vec3 fogCol = vec3(0.0);\n    fogCol += clamp(fogData.r,0.0,1.0)*col3;\n    fogCol += fogData.g*col1;\n    fogCol += fogData.b*col2;\n\n    // float redPulse = pulse((pos.z-dime/16.0)*2.0, fract(1.0-syn_HighHits)*5.0, syn_HighPresence+0.1, 0.9);\n    // float barPulse = smoothstep(syn_BassLevel,0.0,1.0);\n\n    vec3 barCol = vec3(0.0);\n    barCol += clamp(barsData.r,0.0,1.0)*col3;\n    barCol += clamp(barsData.g,0.0,1.0)*col1;\n    barCol += clamp(barsData.b,0.0,1.0)*col2;\n\n    barCol *= bar_on;\n\n    // float barPulse = pulse(posHit.z-dime/16.0,syn_BassPresence+0.2,0.0,0.0);\n    // barCol += col3*hit*barPulse;\n\n    // float pulseAmt = _pulse(-0.5+mod(-dime/16.0+pos.z,modFreq)*(1.0/modFreq),fract(syn_BPMTri2/syn_BPMConfidence)*1.0, width);\n    float pulseAmt = pulse((posHit.z-dime/16.0), 3.0+fract(syn_HighTime*0.05)*15.0, 0.1, 0.9)*syn_HighHits;\n\n    vec3 finalCol = clamp((fogCol+barCol),0.0,1.0)*(1.0+pulseAmt*10.0);\n\n    // finalCol *= dot(_loadUserImage().rgb,vec3(1.0));\n\n    finalCol.rgb = _gamma(vec4(finalCol, 1.0), 0.5).rgb*(1.5+rot_on*2.0);\n\n\n    return vec4(finalCol, 1.0);\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Scaffold Fractal","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.0020000000949949,"DESCRIPTION":"","MAX":0.0500000007450581,"MIN":9.99999974737875e-05,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":10,"MIN":0.200000002980232,"NAME":"modVal","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"zAdder","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"cosinAdder","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"sinAdder","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"finalMulti","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\searchingforsomething.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"SearchingForSomething","IMAGES":null,"IMAGE_PATH":"searchingforsomething.synScene\\searchingforsomething.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.002,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.05,\n\t\t\t\"MIN\" : 0.0001,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0.2,\n\t\t\t\"NAME\" : \"modVal\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.7,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"zAdder\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.7,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"cosinAdder\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.7,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"sinAdder\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.7,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"finalMulti\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"searchingforsomething.png\",\n\t\"TITLE\" : \"SearchingForSomething\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec4 c;\n\tfloat l = TIME;\n\tfloat z=TIME;\n\t\n\tfor(int i=0;i<4;i++) {\n\t\tvec2 uv;\n\t\tvec2 p=_xy.xy/RENDERSIZE;\n\t\tuv=p;\n\t\tp-=0.5;\n\t\tp.x*=RENDERSIZE.x/RENDERSIZE.y;\n\t\tz+=zAdder;\n\t\tl=length(p);\n\t\tuv+=p/l*(cos(z)+cosinAdder)*(sin(l*9.-z*2.)+sinAdder);\n\t\tc[i]=scale/length(abs(mod(uv,modVal)-modVal/2.));\n\t}\n\tout_FragColor=vec4(c/l*finalMulti);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"SearchingForSomething","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Send a colorful shimmer through the fluid. Careful, too much shimmering can kill the simulation.","MAX":-10,"MIN":1,"NAME":"shimmer","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"surface"},{"DEFAULT":0,"DESCRIPTION":"Send a vertical shock through the fluid, pulsing the color as well. Careful, too many shocks can kill it.","MAX":-1,"MIN":0,"NAME":"shock","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"surface"},{"DEFAULT":0,"DESCRIPTION":"Feeds the center of the scene. Push if your simulation dies, or the screen is all black.","MAX":0.150000005960464,"MIN":0,"NAME":"reset_center","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"surface"},{"DEFAULT":0,"DESCRIPTION":"Change the motion of the fluid. When OFF, it will be more constant. When ON it will move back and forth with the BPM of the song.","MAX":1,"MIN":0,"NAME":"bpm_oscillate","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":2,"DESCRIPTION":"UserImage MUST BE SELECTED to see effects. Changes the paint color of the user selected texture.","MAX":2,"MIN":0,"NAME":"media_color","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":[0,0],"DESCRIPTION":"Bottom Left is OFF. Moving this causes a 'tunneling' effect. Can be great with bpm oscillate ON.","MAX":[1,1],"MIN":[0,0],"NAME":"tunnel","PARAMS":0.25,"TYPE":"xy smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Apply some triangularly arranged mirrors to the scene.","MAX":1,"MIN":0,"NAME":"pyramid","TYPE":"toggle","UI_GROUP":"mirrors"},{"DEFAULT":1,"DESCRIPTION":"Mirror the scene (including UserImage).","MAX":1,"MIN":0,"NAME":"mirror","TYPE":"toggle","UI_GROUP":"mirrors"}],"CREDIT":"Felix Woitzel ft. Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\shrouded.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Shrouded","IMAGES":[{"NAME":"colornoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"shrouded.synScene\\shrouded.png","JSON_CODE":"{\n \"CREDIT\": \"Felix Woitzel ft. Meebs\",\n \"TITLE\": \"Shrouded\",\n \"IMAGE_PATH\": \"shrouded.png\",\n    \"HARD_TRANSITIONS\": [\n    ],\n \"SMOOTH_TRANSITIONS\":[{\n \"UNIFORMS\":[\"cReg0\", \"cReg1\", \"cReg2\", \"cReg3\", \"cReg4\"],\n \"DURATION\": 10\n }],\n \"IMAGES\": [{\n    \"PATH\": \"images/colornoise.jpg\",\n    \"NAME\": \"colornoise\"\n  }],\n \"PASSES\": [ {\"TARGET\":\"buffA\", \"WIDTH\":1600, \"HEIGHT\":800, \"FLOAT\": true},\n {\"TARGET\":\"buffC\", \"WIDTH\":1600, \"HEIGHT\":800, \"FLOAT\": true},\n {\"TARGET\":\"buffD\", \"WIDTH\":1600, \"HEIGHT\":800, \"FLOAT\": true} ],\n \"CONTROLS\": [\n {\n \t\"NAME\":\"shimmer\", \"TYPE\": \"bang smooth\", \"PARAMS\": 0.05,\n\t\"DEFAULT\": 1.0, \"MIN\": 1.0,\t\"MAX\": -10.0,\n\t\"DESCRIPTION\": \"Send a colorful shimmer through the fluid. Careful, too much shimmering can kill the simulation.\",\n  \"UI_GROUP\":\"surface\"\n },{\n \t\"NAME\":\"shock\", \"TYPE\": \"bang smooth\", \"PARAMS\": 0.05,\n\t\"DEFAULT\": 0.0, \"MIN\": 0.0,\t\"MAX\": -1.0,\n\t\"DESCRIPTION\": \"Send a vertical shock through the fluid, pulsing the color as well. Careful, too many shocks can kill it.\",\n  \"UI_GROUP\":\"surface\"\n },{\n \t\"NAME\":\"reset_center\", \"TYPE\": \"bang smooth\", \"PARAMS\": 0.05,\n\t\"DEFAULT\": 0.0, \"MIN\": 0.0,\t\"MAX\": 0.15,\n\t\"DESCRIPTION\": \"Feeds the center of the scene. Push if your simulation dies, or the screen is all black.\",\n  \"UI_GROUP\":\"surface\"\n },{\n \t\"NAME\":\"bpm_oscillate\", \"TYPE\": \"toggle\",\n\t\"DEFAULT\": 0.0, \"MIN\": 0.0,\t\"MAX\": 1.0,\n\t\"DESCRIPTION\": \"Change the motion of the fluid. When OFF, it will be more constant. When ON it will move back and forth with the BPM of the song.\",\n  \"UI_GROUP\":\"motion\"\n },{\n \t\"NAME\":\"media_color\", \"TYPE\": \"toggle\",\n\t\"DEFAULT\": 2.0, \"MIN\": 0.0,\t\"MAX\": 2.0,\n\t\"DESCRIPTION\": \"UserImage MUST BE SELECTED to see effects. Changes the paint color of the user selected texture.\",\n  \"UI_GROUP\":\"motion\"\n },{\n \t\"NAME\":\"tunnel\", \"TYPE\": \"xy smooth\", \"PARAMS\": 0.25,\n\t\"DEFAULT\": 0.0, \"MIN\": 0.0,\t\"MAX\": 1.0,\n\t\"UI_GROUP\": \"motion\",\n\t\"DESCRIPTION\": \"Bottom Left is OFF. Moving this causes a 'tunneling' effect. Can be great with bpm oscillate ON.\"\n },{\n \t\"NAME\":\"pyramid\", \"TYPE\": \"toggle\",\n\t\"DEFAULT\": 0.0, \"MIN\": 0.0,\t\"MAX\": 1.0,\n\t\"DESCRIPTION\": \"Apply some triangularly arranged mirrors to the scene.\",\n  \"UI_GROUP\":\"mirrors\"\n },{\n \t\"NAME\":\"mirror\", \"TYPE\": \"toggle\",\n\t\"DEFAULT\": 1.0, \"MIN\": 0.0,\t\"MAX\": 1.0,\n\t\"DESCRIPTION\": \"Mirror the scene (including UserImage).\",\n  \"UI_GROUP\":\"mirrors\"\n }\n ]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":800,"TARGET":"buffA","WIDTH":1600},{"FLOAT":true,"HEIGHT":800,"TARGET":"buffC","WIDTH":1600},{"FLOAT":true,"HEIGHT":800,"TARGET":"buffD","WIDTH":1600}],"SCRIPT_CODE":"","SHADER_CODE":"vec3 iResolution = vec3(RENDERSIZE.x, RENDERSIZE.y, 0.0);\nvec3 iChannelResolution = iResolution;\nfloat iGlobalTime = TIME*1.0;\nint iFrame = int(FRAMECOUNT);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\nvec4 iMouse = vec4(0.5);\n\n\n// ****************** PASS 0 ***********************\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(buffA, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(buffD, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n    dY += shock;\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float f1lter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, f1lter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.425;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 noise = (texture(colornoise, _uv*4.0 + fract(vec2(42,56)*iGlobalTime))-0.5)*2.;\n    uv += _uvc*pow(tunnel,vec2(4.0));\n\n    if ((pyramid>0.5)&&(uv.x > uv.y*0.5)){\n        uv.y = 0.5-uv.y;\n    }\n\n\n    if(iFrame<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    float intensity = pow(syn_Presence,5.0);\n    vec2 flowVel = vec2(0.00,mix(-0.0001, -0.002, intensity));\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 pixelSize = 1. / iResolution.xy;\n\n    uv = vortex_pair_warp(uv, vec2(0.5, 0.5), flowVel*aspect*1.4);\n\n    // expansion\n    vec2 gradientLookupDistance = pixelSize*3.;\n    float expansionFactor = mix(0.3, 1.5, syn_Presence);\n    // bool jumpyExpoRegime = false;\n    // if (jumpyExpoRegime == true){\n    //     expansionFactor = 1.*syn_OnBeat*4.0;\n    // }\n\n\n    // reaction-diffusion\n    float differentialFactor = 12./256.;\n    float increment = -3./256.;\n    float noiseFactor = 2./256.;\n\n    // rock-paper-scissor\n    float feedBack = shimmer*6./256.;\n    float feedForward = shimmer*6./256.;\n\n    float motion = clamp(-syn_HighHits+syn_BassLevel,-0.35,1.0)*0.01;\n    if (bpm_oscillate > 0.5){\n        // expansionFactor = syn_BPMSin2;\n        motion = clamp(syn_BPMSin2*2-1.0,-1.0,1.0)*0.01+0.002*syn_HighHits;\n    }\n\n    uv += GradientA(uv, gradientLookupDistance, vec4(0., 0., 0., 1.), 1)*motion;\n\n    fragColor.r = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(4.,0.,-2.,0.), 1)*pixelSize*expansionFactor, 0).r;\n    fragColor.g = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(0.,4.,0.,-2.), 1)*pixelSize*expansionFactor, 0).g;\n    fragColor.b = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(-2.,0.,4.,0.), 1)*pixelSize*expansionFactor, 0).b;\n    fragColor.a = BlurA(uv + GradientA(uv, gradientLookupDistance, vec4(0.,-2.,0.,4.), 1)*pixelSize*expansionFactor, 0).a;\n\n    if (_exists(syn_UserImage)){\n        float userImg = _loadUserImageAsMask().r;\n        if (media_color<1.0){\n            fragColor.r += userImg;\n        } else if (media_color<2.0){\n            fragColor.g += userImg;\n        } else if (media_color<3.0){\n            fragColor.b += userImg;\n        } else if (media_color<4.0){\n            fragColor.a += userImg;\n        }\n    }\n\n    fragColor += (BlurA(uv, 1) - BlurA(uv, 2))*differentialFactor;\n\n    fragColor += increment + noise * noiseFactor;\n\n    fragColor = fragColor + (1.0-smoothstep(0.1,0.4,length(_uvc)))*reset_center*(0.8+0.2*noise*0.5);\n\n    if (length(_uv)<0.01){\n        fragColor = vec4(1.0);\n    }\n\n    fragColor -= fragColor.argb * feedBack;\n    fragColor += fragColor.gbar * feedForward;\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n//    fragColor = noise; // reset\n}\n\n// *************** PASS 2 *****************\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffD, uv1) * 0.05;\n    sum += texture(buffD, uv2) * 0.09;\n    sum += texture(buffD, uv3) * 0.12;\n    sum += texture(buffD, uv4) * 0.15;\n    sum += texture(buffD, uv5) * 0.16;\n    sum += texture(buffD, uv6) * 0.15;\n    sum += texture(buffD, uv7) * 0.12;\n    sum += texture(buffD, uv8) * 0.09;\n    sum += texture(buffD, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(buffA, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(buffA, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}\n\n\n// *************** PASS 4 *****************\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(buffC, uv1) * 0.05;\n    sum += texture(buffC, uv2) * 0.09;\n    sum += texture(buffC, uv3) * 0.12;\n    sum += texture(buffC, uv4) * 0.15;\n    sum += texture(buffC, uv5) * 0.16;\n    sum += texture(buffC, uv6) * 0.15;\n    sum += texture(buffC, uv7) * 0.12;\n    sum += texture(buffC, uv8) * 0.09;\n    sum += texture(buffC, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage3( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(buffC, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(buffC, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n    uv = uv_orig;\n    float eighth = 1./8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    }\n}\n\n// *************** Main Image Pass *****************\n\nvoid mainImage4( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = _uv;\n\n    // if (uv.x*mod(syn_BeatTime*5.0+syn_RandomOnBeat*2.0,8.0)*0.5+uv.y*mod(syn_BeatTime*13.0+syn_RandomOnBeat*1.7,8.0)*0.5 > 1.0){\n    //     uv = 1.0-uv;\n    // }\n    if ((uv.x > 0.5)&&(mirror>0.5)){\n        uv.x = 1.0-uv.x;\n    }\n\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 d = pixelSize*2.;\n    vec4 dx = (BlurA(uv + vec2(1,0)*d, 1) - BlurA(uv - vec2(1,0)*d, 1))*0.5;\n    vec4 dy = (BlurA(uv + vec2(0,1)*d, 1) - BlurA(uv - vec2(0,1)*d, 1))*0.5;\n\n    d = pixelSize*1.;\n    dx += BlurA(uv + vec2(1,0)*d, 0) - BlurA(uv - vec2(1,0)*d, 0);\n    dy += BlurA(uv + vec2(0,1)*d, 0) - BlurA(uv - vec2(0,1)*d, 0);\n    vec2 lightSize=vec2(0.5);\n\n    //for B\n    //midHighCol is general color?\n    //bassCol1 is a color in between coral\n    //highCol1 does almost nothing. creeps in on the edges.\n    //bassCol2 is general color \"on\" the life spots\n    //highCol2 does almost nothing when sim is running. creeps in from edges.\n    //midCol is squiggles layer... Its red and white tho.\n\n    //for A\n    //midHighCol is sheen near the wavefronts. like \"newSpawn\"\n    //bassCol1 is big wavefronts and smooth shading\n    //highCol1 is wavefronts\n    //bassCol2 crisp wavefronts and smooth wavefronts, of a diff color probably.\n    //highCol2 sort of ghostly messy wavefronts\n    //midCol sort of a networky layer. Looks brainular.\n\n\n    vec3 midHighCol = vec3(0.7,1.66,2.0);\n    vec3 bassCol1 = vec3(8.0,6.,2.);\n    vec3 highCol1 = vec3(0.1,0.,0.4);\n    vec3 bassCol2 = vec3(1.25,1.35,1.4);\n    vec3 highCol2 = vec3(0.25,0.75,1.);\n    vec3 midCol = vec3(1.,1.25,1.5);\n\n\n    // float cReg1 = 0.0;\n    // float cReg2 = 0.0;\n    // float cReg3 = 0.0;\n    // float cReg4 = 0.0;\n\n\n    // *** Color Regime 1 ***\n    midHighCol = mix(midHighCol, _normalizeRGB(252, 255, 245)*2.0, cReg1);\n    bassCol1 = mix(bassCol1, _normalizeRGB(0, 38, 28)*2.0, cReg1);\n    highCol1 = mix(highCol1, _normalizeRGB(4, 76, 41)*2.0, cReg1);\n    bassCol2 = mix(bassCol2, _normalizeRGB(22, 127, 57)*2.0, cReg1);\n    highCol2 = mix(highCol2, _normalizeRGB(150, 237, 137)*2.0, cReg1);\n    midCol = mix(midCol, _normalizeRGB(4, 76, 41)*2.0, cReg1);\n    // highCol2 = mix(highCol2, vec3(0.3,0.4,0.22), cReg1);\n\n    // *** Color Regime 2 ***\n    midHighCol = mix(midHighCol, _normalizeRGB(70, 137, 102)*2.0, cReg2);\n    bassCol1 = mix(bassCol1, _normalizeRGB(255, 240, 165)*2.0, cReg2);\n    highCol1 = mix(highCol1, _normalizeRGB(255, 176, 59)*2.0, cReg2);\n    bassCol2 = mix(bassCol2, _normalizeRGB(182, 73, 38)*2.0, cReg2);\n    highCol2 = mix(highCol2, _normalizeRGB(142, 40, 0)*2.0, cReg2);\n    midCol = mix(midCol, _normalizeRGB(142, 40, 0)*2.0, cReg2);\n\n    // *** Color Regime 3 ***\n    midHighCol = mix(midHighCol, _normalizeRGB(28, 24, 34)*3.0, cReg3);\n    bassCol1 = mix(bassCol1, _normalizeRGB(64, 21, 42)*3.0, cReg3);\n    highCol1 = mix(highCol1, _normalizeRGB(115, 22, 48)*2.0, cReg3);\n    bassCol2 = mix(bassCol2, _normalizeRGB(255, 84, 52)*2.0, cReg3);\n    highCol2 = mix(highCol2, _normalizeRGB(204, 30, 44)*2.0, cReg3);\n    midCol = mix(midCol, _normalizeRGB(64, 21, 42)*2.0, cReg3);\n\n    // *** Color Regime 4 ***\n    midHighCol = mix(midHighCol, _normalizeRGB(46, 9, 39)*4.0, cReg4);\n    bassCol1 = mix(bassCol1, _normalizeRGB(217, 0, 0)*2.0, cReg4);\n    highCol1 = mix(highCol1, _normalizeRGB(4, 117, 111)*2.0, cReg4);\n    bassCol2 = mix(bassCol2, _normalizeRGB(255, 45, 0)*2.0, cReg4);\n    highCol2 = mix(highCol2, _normalizeRGB(255, 140, 0)*2.0, cReg4);\n    midCol = mix(midCol, _normalizeRGB(4, 117, 111)*2.0, cReg4);\n\n\n    vec2 zoneMids = vec2(sin(syn_MidTime*0.23), cos(syn_MidTime*0.17));\n    vec2 zoneMidHighs = vec2(sin(syn_MidHighTime*0.23), cos(syn_MidHighTime*0.17));\n    vec2 zoneHighs = vec2(sin(syn_HighTime*0.23), cos(syn_HighTime*0.17));\n\n    midHighCol *= (0.05+0.95*syn_MidHighPresence*distance(zoneMidHighs, _uvc)*0.8);\n    bassCol1 *= (0.05+0.95*(sqrt(syn_BassPresence))*1.25);\n    highCol1 *= (0.05+0.95*sqrt(syn_HighPresence));\n    bassCol2 *= (0.05+0.95*sqrt(syn_BassPresence)*1.5);\n    highCol2 *= (0.05+0.95*syn_HighHits*(0.5+syn_Presence*0.5)*distance(zoneHighs, _uvc));\n    midCol *= (0.05+0.95*distance(zoneMids, _uvc)*sqrt(syn_MidPresence));\n\n    float lowIntensity = 1.0-syn_Presence;\n\n    vec3 finalColor = vec3(0.0);\n\n    finalColor += BlurA(uv+vec2(dx.x,dy.x)*pixelSize*8., 0).x * midHighCol;\n    finalColor = mix(finalColor, bassCol1, BlurA(uv + vec2(dx.x,dy.x)*lightSize, 3).y*0.4*0.75*vec3(1.-BlurA(uv+vec2(dx.x,dy.x)*pixelSize*8., 0).x));\n    finalColor = mix(finalColor, highCol1, BlurA(uv, 1).a*length(GradientA(uv, pixelSize*2., vec4(0.,0.,0., 1.), 0))*5.);\n    finalColor = mix(finalColor, bassCol2, BlurA(uv, 0).x*BlurA(uv + GradientA(uv, pixelSize*2.5, vec4(-256.,32.,-128.,32.), 1)*pixelSize, 2).y);\n    finalColor = mix(finalColor, highCol2, BlurA(uv, 1).x*length(GradientA(uv+GradientA(uv, pixelSize*2., vec4(0.,0.,128.,0.), 1)*pixelSize, pixelSize*2., vec4(0.,0.,0.,1.), 0))*5.);\n    finalColor = mix(finalColor, midCol, 0.5*(1.-BlurA(uv, 0)*1.).g*length(GradientA(uv+GradientA(uv, pixelSize*2., vec4(0.,128.,0.,0.), 1)*pixelSize, pixelSize*1.5, vec4(0.,0.,16.,0.), 0)));\n\n    finalColor *= 0.5+(sin(_uvc.x*5.0+TIME*0.1)*_uv.y+cos(_uvc.x*4.7-TIME*0.47)+cos(_uvc.x*11.0+TIME*0.89)*(1.0-_uv.y))/6.0;\n\n\n    fragColor = vec4(finalColor, 1.0);\n\n    //    fragColor = BlurA(uv, 0); // simple bypass\n    //    fragColor = BlurB(uv, 0); // simple bypass\n       // fragColor = texture(buffD, _uv); // raw Gaussian pyramid\n\n}\n\n\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    //buffA\n    vec4 fragColor;\n    mainImage0(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 1.0){\n    //buffC\n    vec4 fragColor;\n    mainImage2(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 2.0){\n    //Image\n    vec4 fragColor;\n    mainImage3(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n  else if (PASSINDEX == 3.0){\n    //Image\n    vec4 fragColor;\n    mainImage4(fragColor, gl_FragCoord.xy);\n    return fragColor;\n  }\n}\n","SMOOTH_TRANSITIONS":[{"DURATION":10,"UNIFORMS":["cReg0","cReg1","cReg2","cReg3","cReg4"]}],"TAGS":[],"TITLE":"Shrouded","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.25,"DESCRIPTION":"Rate of the effect.","MAX":1,"MIN":0,"NAME":"rate","TYPE":"knob","UI_GROUP":"effect"},{"DEFAULT":4,"DESCRIPTION":"Warpiness of the effect.","MAX":8,"MIN":1,"NAME":"warp","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"effect"},{"DEFAULT":1,"DESCRIPTION":"How dramatically the effect modifies the input media.","MAX":1,"MIN":0,"NAME":"intensity","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"effect"},{"DEFAULT":[0,0],"DESCRIPTION":"Nudge effect in any direction.","MAX":[-1,-1],"MIN":[1,1],"NAME":"direction","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"effect"},{"DEFAULT":0.25,"DESCRIPTION":"Amount of refraction of the input media.","MAX":1,"MIN":0,"NAME":"refraction","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"effect"},{"DEFAULT":0.5,"DESCRIPTION":"Brightness of lighting and density of shadows.","MAX":1,"MIN":0,"NAME":"brightness","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"effect"},{"DEFAULT":[0,0],"DESCRIPTION":"Pan input media in any direction.","MAX":[1,1],"MIN":[-1,-1],"NAME":"media_xy","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"media"}],"CREDIT":"Shady Headstash","DESCRIPTION":"Sinusoidal warp.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\sinusoidal_warp.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Sinusoidal Warp","IMAGES":null,"IMAGE_PATH":"sinusoidal_warp.synScene\\sinusoidal_warp.png","JSON_CODE":"{\n    \"CONTROLS\": [\n        {\n            \"DEFAULT\": 0.25,\n            \"DESCRIPTION\": \"Rate of the effect.\",\n            \"IS_META\": false,\n            \"MAX\": 1.0,\n            \"MIN\": 0.0,\n            \"NAME\": \"rate\",\n            \"TYPE\": \"knob\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 4.0,\n            \"DESCRIPTION\": \"Warpiness of the effect.\",\n            \"IS_META\": false,\n            \"MAX\": 8.0,\n            \"MIN\": 1.0,\n            \"NAME\": \"warp\",\n            \"TYPE\": \"slider smooth\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 1.0,\n            \"DESCRIPTION\": \"How dramatically the effect modifies the input media.\",\n            \"IS_META\": false,\n            \"MAX\": 1,\n            \"MIN\": 0,\n            \"NAME\": \"intensity\",\n            \"TYPE\": \"slider smooth\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0.0,\n            \"DESCRIPTION\": \"Nudge effect in any direction.\",\n            \"IS_META\": false,\n            \"MAX\": -1.0,\n            \"MIN\": 1.0,\n            \"NAME\": \"direction\",\n            \"TYPE\": \"xy smooth\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0,\n            \"DESCRIPTION\": \"Pan input media in any direction.\",\n            \"IS_META\": false,\n            \"MAX\": 1,\n            \"MIN\": -1.0,\n            \"NAME\": \"media_xy\",\n            \"TYPE\": \"xy smooth\",\n            \"UI_GROUP\": \"media\"\n        },\n        {\n            \"DEFAULT\": 0.25,\n            \"DESCRIPTION\": \"Amount of refraction of the input media.\",\n            \"IS_META\": false,\n            \"MAX\": 1.0,\n            \"MIN\": 0,\n            \"NAME\": \"refraction\",\n            \"TYPE\": \"slider smooth\",\n            \"PARAMS\":0.1,\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0.5,\n            \"DESCRIPTION\": \"Brightness of lighting and density of shadows.\",\n            \"IS_META\": false,\n            \"MAX\": 1.0,\n            \"MIN\": 0.0,\n            \"NAME\": \"brightness\",\n            \"TYPE\": \"slider smooth\",\n            \"UI_GROUP\": \"effect\"\n        }\n    ],\n    \"CREDIT\": \"Shady Headstash\",\n    \"DESCRIPTION\": \"Sinusoidal warp.\",\n    \"HEIGHT\": 1080,\n    \"IMAGE_PATH\": \"sinusoidal_warp.png\",\n    \"TITLE\": \"Sinusoidal Warp\",\n    \"WIDTH\": 1920\n}\n","PASSES":null,"SCRIPT_CODE":"function Timer() {\n    this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function (rate, val, dt) {\n    this.time = this.time + rate * dt * val;\n};\n\nvar bassTimevar = new Timer();\nvar timevar = new Timer();\n\nfunction update(dt) {\n\n    try {\n        bassTimevar.updateTime(1.0, inputs.rate + inputs.rate * (inputs.syn_Level * inputs.syn_Hits + inputs.syn_BassPresence), dt);\n        timevar.updateTime(1.0, inputs.rate, dt);\n\n        uniforms.script_time = timevar.time;\n        uniforms.bass_time = bassTimevar.time;\n\n    } catch (e) {\n        print(e);\n    }\n\n}\n","SHADER_CODE":"// --- Original \"Bumped Sinusoidal Warp\" shader by Shane from https://www.shadertoy.com/view/4l2XWK\n// Modified by Mikael Ems (Shady Headstash)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define HPI 1.570796326795\n#define TWPI 6.283185307179586  \t// two pi, 2*pi\n\nvec4 texMirror(sampler2D samplerIn, vec2 uvIn){\n    if (mod(uvIn.x, 2.0) > 1.0){\n        uvIn.x = 1.0-uvIn.x;\n    }\n    if (mod(uvIn.y, 2.0) > 1.0){\n        uvIn.y = 1.0-uvIn.y;\n    }\n    return _contrast(_invertImage(texture(samplerIn, _invertYAxisVideo(uvIn))),_Media_Contrast);\n}\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n\n    float t = bass_time;\n\n    p += _uvc*10.0*mix(0.3, 0.1, (warp-1.0)/7.0);\n\n    // Planar sine distortion.\n    for (int i=0; i<3.; i++)\n    p += cos(p.yx*warp + vec2(t, PI*(direction.x*2.0)))/3.*intensity,\n    p += cos(p.yx + vec2(0, -PI*(direction.y*2.0)) + t)/2.*intensity,\n    p *= 1.3;\n\n    // Domain repetition.\n    return mod(p, 2.)-1.;\n}\n\nvec4 renderMainImage() {\n\tvec4 o = vec4(0.0);\n\tvec2 u = _xy / RENDERSIZE.xy;\n\n    // Texture lookup.\n    vec2 tu = W(u);\n\n    u += media_xy.xy * 0.25;\n    o.w = length(W(u));\n    //o = texture(syn_UserImage, u + tu*refraction);\n    //o = (vec4(.7, .4, .1, 1) * pow(max((o.w-length(W(u - .01))), 0.)*8. + 1., 4.)*.1 + .5)*o.w;\n\n    // Shading.\n    float c = (1.0-length(tu));\n    c *= sqrt(c);\n    c = pow(c, 1.1-brightness);\n\n    if (_exists(syn_UserImage)) {\n        // Texture color.\n        o = vec4(c) * texMirror(syn_UserImage, u + tu*(refraction*0.1));\n        //o = smoothstep(.05, .5, o*o);\n    } else {\n        float d = max(c - length (W(u*5. + vec2(.025, .015))), 0.)*5. + .3;\n        d *= d*d*.5; // Ramp it up a bit for extra shine.\n        // Textureless.\n        o = sqrt((d + vec4(1.0))*c);\n    }\n\treturn o;\n }\n\n/*\n// Smaller version, sans texture.\nvoid mainImage( inout vec4 o,  vec2 u ) {\n    u /= RENDERSIZE.y/5.;\n    o.w = length(W(u));\n    o = texture(syn_UserImage, u + tu*refraction);\n    o = (vec4(.7, .4, .1, 1) * pow(max((o.w-length(W(u - .01))), 0.)*8. + 1., 4.)*.1 + .5)*o.w;\n}\n*/\n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Sinusoidal Warp","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[0.990000009536743,0.990000009536743],"MIN":[0.00999999977648258,0.00999999977648258],"NAME":"O","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[0.100000001490116,0.100000001490116],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"C","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":9,"DESCRIPTION":"","MAX":36,"MIN":0,"NAME":"R1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":17,"DESCRIPTION":"","MAX":54,"MIN":0,"NAME":"R2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":5,"MIN":1.10000002384186,"NAME":"zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":3,"MIN":-3,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":64,"DESCRIPTION":"","MAX":72,"MIN":24,"NAME":"depth","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.550000011920929,"DESCRIPTION":"","MAX":1.25,"MIN":0.25,"NAME":"gamma","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\spacespore.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"SpaceSpore","IMAGES":null,"IMAGE_PATH":"spacespore.synScene\\spacespore.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t0.99,\n\t\t\t\t0.99\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0.01,\n\t\t\t\t0.01\n\t\t\t],\n\t\t\t\"NAME\" : \"O\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.1,\n\t\t\t\t0.1\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"C\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 9,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 36,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"R1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 17,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 54,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"R2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 1.1,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : -3,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 64,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 72,\n\t\t\t\"MIN\" : 24,\n\t\t\t\"NAME\" : \"depth\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.55,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1.25,\n\t\t\t\"MIN\" : 0.25,\n\t\t\t\"NAME\" : \"gamma\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"spacespore.png\",\n\t\"TITLE\" : \"SpaceSpore\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n////////////////////////////////////////////////////////////////////\n// SpaceSpore  by mojovideotech\n// v2.0 5/2020 ; optimized code, added uniforms\n//\n// based on :\n// shadertoy.com/lslcWj   by LukeRissacher\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////////////\n\n\n#define \ttwpi  \t6.283185307179586  \t\n#define \tR(p, a) p = p * cos(a) + vec2(-p.y, p.x) * sin(a)\n\nfloat Swave(float w) { return 0.5 + 0.5 * sin(twpi * w); }\n\nfloat Sdef(vec3 p) { return 1.0 - abs(sin(p.x) + sin(p.y) + sin(p.z)) * 0.333; }\n\nfloat Smap(vec3 p, float s) {\n    float dSphere = length(p) - 1.0;\n    return max(dSphere, (0.95 - Sdef(s * p)) / s);\n}\n\nvec3 Scol(vec3 p) {\n    float a = clamp((2.0 - length(p)) * 0.5, 0.0, 1.0);\n    vec3 c = 0.5 + 0.5 * cos(twpi * cross(vec3(1.0, C.x, C.y), vec3(Swave(-a) * vec3(0.5, 1.0, 1.0))));\n    return c * a;\n}\n\nvec3 rgb(vec3 c) { return c*c*c*(c*(c*6.0-15.0)+10.0); }\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tfloat TT = TIME * rate; \n\tvec3 rd = normalize(vec3(2.0 * _xy.xy - RENDERSIZE.xy, -min(RENDERSIZE.x,RENDERSIZE.y)));\n    vec3 ro = vec3(0.0, 0.0, zoom); \n    R(rd.xz, O.x * -TT);\n    R(ro.xz, O.x * -TT);\n    R(rd.yz, O.y * TT);\n    R(ro.yz, O.y * TT);\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float S = mix(R1, R2, Swave(0.05 * TT));\n    for (int i = 0; i < 90; i++) {\n    \tif (float(i) >= floor(depth)) { break; }\n        vec3 p = ro + t * rd;\n        float d = Smap(p, S);\n        if (t > 5.0 || d < 0.001) {\n            break;\n        }\n        t += 0.8 * d;\n        col += 0.05 * Scol(p);\n    }\n    out_FragColor = vec4(pow(rgb(col),vec3(gamma)),1.0);\n\nreturn out_FragColor; \n } \n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"SpaceSpore","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"mouse","TYPE":"xy","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"Automatically converted from http://glslsandbox.com/e#1613.0","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\spiralsurface1.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"SpiralSurface1","IMAGES":null,"IMAGE_PATH":"spiralsurface1.synScene\\spiralsurface1.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"mouse\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"Automatically converted from http://glslsandbox.com/e#1613.0\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"spiralsurface1.png\",\n\t\"TITLE\" : \"SpiralSurface1\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n//Archimedes spiral, antialiased\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\nconst float EPSILON = 0.1;\n\nvec2 perspective(vec2 scaled) {\n\tfloat z = 1.2-scaled.y+cos((scaled.x)*scaled.y*6.)*.1;\n\treturn vec2((scaled.x-.5)/z,sin((scaled.x-.5)*10./z)*.2+1./z)*.5;\n}\n\nfloat getval(vec2 car) {\n\tfloat r = sqrt(car.x * car.x + car.y * car.y);\n\tfloat theta = atan(car.y, car.x);\n\t\n\treturn fract(TIME) * 2. + theta / (2. * PI) - r * 16.;\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 mousepersp = perspective(mouse);\n\tvec2 vec = perspective(_xy.xy / RENDERSIZE.xy) - mousepersp;\n\tfloat val = getval(vec);\n\tfloat valx = getval(perspective((_xy.xy + vec2(.01,0)) / RENDERSIZE.xy) - mousepersp)-val;\n\tfloat valy = getval(perspective((_xy.xy + vec2(0,.01)) / RENDERSIZE.xy) - mousepersp)-val;\n\tfloat aa = sqrt(valx*valx+valy*valy)*250.;\n\taa = aa > 100. ? 0. : tan(min(aa,PI*.4999))*.3;\n\t\n\tvec3 color = vec3(sqrt((1.-smoothstep(EPSILON-aa, EPSILON+aa, abs(fract(val)-.5)))/(1.+dot(vec,vec)*20.)));\n\t\n\tout_FragColor = vec4(color, 1.0);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"SpiralSurface1","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"scale","TYPE":"slider","UI_GROUP":"simulation"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"pulse_out","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"feed"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"auto_feed","TYPE":"toggle","UI_GROUP":"feed"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"black_pulse","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"erase"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"full_erase","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"erase"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"grow","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"twitch"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"pulse_ripple","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"twitch"}],"CREDIT":"sheltron ft. Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\sprinkles.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Sprinkles","IMAGES":null,"IMAGE_PATH":"sprinkles.synScene\\sprinkles.png","JSON_CODE":"{\n \"CREDIT\": \"sheltron ft. Meebs\",\n \"TITLE\": \"Sprinkles\",\n \"IMAGE_PATH\": \"sprinkles.png\",\n\"IMAGES\": [],\n\n \"PASSES\": [\n {\"TARGET\":\"buffA\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true},\n {\"TARGET\":\"buffA2\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true},\n {\"TARGET\":\"buffB\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true},\n {\"TARGET\":\"buffB2\", \"WIDTH\":1920, \"HEIGHT\":1080, \"FLOAT\": true}],\n\n\"CONTROLS\":[{\"NAME\": \"scale\", \"MIN\": -2.0, \"MAX\": 2.0, \"DEFAULT\": 0.0, \"UI_GROUP\":\"simulation\"},\n\n{\"NAME\":\"pulse_out\", \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"feed\", \"MAX\": 1.0, \"DEFAULT\": 0.0},\n{\"NAME\":\"auto_feed\", \"TYPE\": \"toggle\", \"UI_GROUP\": \"feed\", \"MAX\": 1.0, \"DEFAULT\": 1.0},\n\n{\"NAME\":\"black_pulse\", \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"erase\", \"MAX\": 1.0, \"DEFAULT\": 0.0},\n{\"NAME\":\"full_erase\", \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"erase\", \"MAX\": 1.0, \"DEFAULT\": 0.0, \"PARAMS\":0.2},\n\n{\"NAME\":\"grow\", \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"twitch\", \"MAX\": 1.0, \"DEFAULT\": 0.0, \"PARAMS\": 0.2},\n{\"NAME\":\"pulse_ripple\", \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"twitch\", \"MAX\": 1.0, \"DEFAULT\": 0.0, \"PARAMS\": 0.2}\n\n  ]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"buffA","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"buffA2","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"buffB","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"buffB2","WIDTH":1920}],"SCRIPT_CODE":"","SHADER_CODE":"vec2 resolution = RENDERSIZE; // the rendering resolution (in pixels)\nfloat time = TIME;\nvec2 uv = _uv;\n\nvec2 toPolar(vec2 cart) {\n    return vec2(length(cart), atan(cart.x, cart.y));\n}\n\nvec2 toCart(vec2 polar) {\n    return vec2(polar.x * cos(polar.y), polar.x * sin(polar.y));\n}\n\nfloat uvrand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat arc(vec2 coord)\n{\n    const float pi = 3.1415926;\n    float t = floor(time * 1.1) * 7.3962;\n\n    vec2 sc = coord;\n    float phi = atan(sc.y, sc.x + 1e-6);\n    vec2 pc = vec2(fract(phi / (pi * 2) + syn_BassTime*0.01), length(sc));\n\n    vec2 org = vec2(0.5, 0.5);\n    vec2 wid = vec2(0.5, 0.5);\n\n    for (int i = 0; i < 4; i++)\n    {\n        if (uvrand(org + t) < 0.04 * i) break;\n        wid *= 0.5;\n        org += wid * (step(org, pc) * 2 - 1);\n    }\n\n    return uvrand(org);\n}\n\nfloat arcGridPattern()\n{\n    vec4 delta = vec4(-1, -1, 1, 1) * 0.5;\n    delta *= (1/resolution.y);\n\n    // neightbor four samples\n    float c1 = arc(abs(_uvc)*0.4 + delta.xy);\n    float c2 = arc(abs(_uvc)*0.4 + delta.zy);\n    float c3 = arc(abs(_uvc)*0.4 + delta.xw);\n    float c4 = arc(abs(_uvc)*0.4 + delta.zw);\n\n    // roberts cross operator\n    float gx = c1 - c4;\n    float gy = c2 - c3;\n    float g = sqrt(gx * gx + gy * gy);\n\n    return g*4;\n}\n\n\nvec2 getLap(sampler2D tex, vec2 pos, vec2 dx, vec2 dy, vec4 c){\n  // return  texture(tex, fract(pos + dx)).xy * 0.2 +\n  //         texture(tex, fract(pos + dx + dy)).xy * 0.05 +\n  //         texture(tex, fract(pos - dx)).xy * 0.2 +\n  //         texture(tex, fract(pos - dx - dy)).xy * 0.05 +\n  //         texture(tex, fract(pos + dy)).xy * 0.2 +\n  //         texture(tex, fract(pos + dx - dy)).xy * 0.05 +\n  //         texture(tex, fract(pos - dy)).xy * 0.2 +\n  //         texture(tex, fract(pos - dx + dy)).xy * 0.05 -\n  //         c.xy;\n\n  return  texture(tex, fract(pos + dx)).xy * 0.25 +\n        texture(tex, fract(pos - dx)).xy * 0.25 +\n        texture(tex, fract(pos + dy)).xy * 0.25 +\n        texture(tex, fract(pos - dy)).xy * 0.25 -\n        c.xy;\n}\n\nvec4 doReacDiff(void)\n{\n  vec2 uvn = (uv-0.5) * vec2(resolution.x/resolution.y, 1.0);\n\n  vec2 dx = vec2(1. / resolution.x, 0.0)*(2.5+scale)*(1.0+pulse_ripple*10.0);\n  vec2 dy = vec2(0.0, 1. / resolution.y)*(2.5+scale)*(1.0+pulse_ripple*10.0);\n\n  vec4 c = vec4(0.0);\n  vec2 laplacian = vec2(0.0);\n\n  if (PASSINDEX < 1.0){\n    c = texture(buffB2, uv);\n    laplacian = getLap(buffB2, uv, dx, dy, c);\n  } else if (PASSINDEX < 3.0) {\n    c = texture(buffA2, uv);\n    laplacian = getLap(buffA2, uv, dx, dy, c);\n  }\n\n  float reaction = c.r * c.g * c.g;\n\n  float dt = 1.0;\n\n  // THESE ARE THE MAGIC NUMBERS\n  float f = 0.018;\n  float k = 0.048;\n\n  // equation\n  c.r += dt * (0.6 * laplacian.r - reaction + f * (1. - c.r))*(1.0+grow*50.0*_pulse(length(_uvc)*0.85 + 0.1, (1.0-grow)*1.0, 0.3));\n  c.g += dt * (0.3 * laplacian.g + reaction - (k + f) * c.g )*(1.0+grow*50.0*_pulse(length(_uvc)*0.85 + 0.1, (1.0-grow)*1.0, 0.3));\n\n\n  float briSim = 1.0-clamp(pow(1.0-dot(abs(c.rg), vec2(1.0, 1.0)),0.25)*2.0,0.0,1.0);\n\n  vec3 fft = vec3(_sqPulse(fract(length(_uvc)*3.3), fract(TIME*0.1), 0.03))*syn_HighHits;\n  if (syn_MediaType > 0.5){\n    fft = _loadUserImage().rgb*(_pulse(dot(_uvc, _uvc)*0.75 + 0.1, pow(1.0-pulse_out,2.0), 0.1)+auto_feed*briSim*pow(syn_HighHits,2.0)*10.0);\n  } else {\n    fft = vec3(1.0)*arcGridPattern()*(_pulse(dot(_uvc, _uvc)*0.75 + 0.1, pow(1.0-pulse_out,2.0), 0.1)+auto_feed*briSim*pow(syn_HighHits,2.0)*20.0)*0.5;\n  }\n\n  // fft = _loadUserImage().rgb*(_pulse(dot(_uvc, _uvc)*0.75 + 0.1, pow(1.0-pulse_out,2.0), 0.1)+auto_feed*briSim*syn_HighHits*3.0)*0.5;\n\n  float fftF = pow(dot(fft, vec3(1.0))/3.0,1.0);\n\n  // FFT MODIFICATION\n  c.r += fftF*0.1;\n  c.g += fftF*0.01;\n\n  c *= 1.0-_pulse(length(_uvc)*0.85 + 0.1, (1.0-black_pulse)*2.0, 0.15)*0.01;\n  c *= 1.0-full_erase*0.05;\n\n\n  if( length(uvn) < 0.001) {\n      c.r = 0.0; c.g = 100.0 *length(uvn);\n  }\n\n  return min(max(vec4(0.), c), vec4(1.));\n}\n\n//END REACTION DIFFUSION\n\n//BEING WORLD TEX COLORING\n\nfloat getSim(vec2 uv, vec2 d) {\n    float result = texture(buffB2, uv + d ).y;\n    return result;\n}\n\nvec4 renderPass1(void)\n{\n  const int iters = 5;\n  vec3 finalCol = vec3(0.0);\n\n    vec2 uvn = (uv - 0.5) * vec2(resolution.x/resolution.y, 1.0);\n\n\n    vec2 px = vec2(1. / resolution.x, 0.0);\n    vec2 py = vec2(0.0, 1. / resolution.y);\n\n    vec2 g_uv = uv;\n\n    float p = getSim(g_uv, vec2(0.));\n    float u = p - getSim(g_uv, - py);\n    float r = p - getSim(g_uv, - px);\n\n    vec3 dy = normalize(vec3(0.0, py.y, u/7.0));\n    vec3 dx = normalize(vec3(px.x ,0.0, r/7.0));\n\n    vec3 n = cross(dy,dx);\n\n    // n *= (1.0+scale+2.0);\n\n    float shade = 0.1 + dot(n, normalize(vec3(0., 0., -1.)));\n\n    vec3 color =  (1. - n ) * shade * vec3(p * 3.0);\n\n    color = _rgb2hsv(clamp(color,0.0,1.0));\n    color.r = sin(color.r*10.0);\n    color.g = color.g*2.0;\n    // color.b -= dot(_loadUserImage().rgb, vec3(1.0))/3.0;\n    color = _hsv2rgb(color);\n    if (color.g > color.r+color.b){\n      color += vec3(color.r, -color.g, color.b);\n    }\n\n    // color = vec3(1.0-clamp(pow(1.0-dot(abs(texture(buffB2, g_uv).rg), vec2(1.0, 1.0)),0.25)*2.0,0.0,1.0));\n\n  return vec4(color, 1.);\n}\n\nvec4 renderMain(void){\n  if (FRAMECOUNT < 2){\n    if (syn_MediaType>0.5){\n      return _loadUserImage()*0.5;\n    } else {\n      return vec4(step(abs(_uvc), vec2(0.01)), 0.0, 1.0);\n    }\n  }\n  if (PASSINDEX == 0.0){\n    return doReacDiff();\n  } else if (PASSINDEX == 1.0){\n    return texture(buffA, _uv);\n  } else if (PASSINDEX == 2.0){\n    return doReacDiff();\n  } else if (PASSINDEX == 3.0){\n    return texture(buffB, _uv);\n  } else if (PASSINDEX == 4.0){\n    return renderPass1();\n  }\n\n}\n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Sprinkles","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.025000000372529,"DESCRIPTION":"","MAX":0.200000002980232,"MIN":0.00999999977648258,"NAME":"rot_speed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"rot_offset","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by joshpbatty","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\square_tunnel.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Square Tunnel","IMAGES":null,"IMAGE_PATH":"square_tunnel.synScene\\square_tunnel.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.025,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.2,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"rot_speed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rot_offset\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by joshpbatty\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"square_tunnel.png\",\n\t\"TITLE\" : \"Square Tunnel\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\t\n\tvec2 R = RENDERSIZE.xy;\n\tvec2 U = _xy.xy;\n    U = (U+U-R)/R.x;\n    float t = rot_speed*(TIME-(rot_offset * 100.)), r = 1.0, c,s;\n    \n    vec4 O;\n    //O -= O;\n    for( int i=0; i< 49; i++){\n\t    U *= mat2(c=cos(t),s=sin(t),-s,c),\n        r /= abs(c) + abs(s),\n        O = smoothstep(3./R.y, 0., max(abs(U.x),abs(U.y)) - r) - O;\n    }\n    \n\tout_FragColor = O;\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Square Tunnel","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"by mojovideotech","DESCRIPTION":"Automatically converted from http://glslsandbox.com/e#21290.5","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\squarecellstructurescan.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"SquareCellStructureScan","IMAGES":null,"IMAGE_PATH":"squarecellstructurescan.synScene\\squarecellstructurescan.png","JSON_CODE":"{\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"Automatically converted from http://glslsandbox.com/e#21290.5\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"squarecellstructurescan.png\",\n\t\"TITLE\" : \"SquareCellStructureScan\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897932384626433832795\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n\nfloat2 circuit(float2 p)\n{\n\tp = fract(p);\n\tfloat r = 0.123;\n\tfloat v = 0.0, g = 0.0;\n\tr = fract(r * 9184.928);\n\tfloat cp, d;\n\t\n\td = p.x;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.x - 1.0;\n\tg += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\t\n\tconst int iter = 12;\n\tfor(int i = 0; i < iter; i ++)\n\t{\n\t\tcp = 0.5 + (r - 0.5) * 0.9;\n\t\td = p.x - cp;\n\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n\t\tif(d > 0.0) {\n\t\t\tr = fract(r * 4829.013);\n\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\tv += 1.0;\n\t\t}\n\t\telse {\n\t\t\tr = fract(r * 1239.528);\n\t\t\tp.x = p.x / cp;\n\t\t}\n\t\tp = p.yx;\n\t}\n\tv /= float(iter);\n\treturn float2(g, v);\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tfloat scale = 0.5;\n\n\tfloat2 uv = _xy.xy;\n\tuv /= RENDERSIZE.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= RENDERSIZE.x / RENDERSIZE.y;\n\tuv= uv * scale + float2(0.0, TIME*0.1);\n\tfloat2 cid2 = floor(uv);\n\tfloat cid = (cid2.y*10.0+cid2.x)*0.1;\n\n\tfloat2 dg = circuit(uv);\n\tfloat d = dg.x;\n\tfloat3 col1 = (0.2-float3(max(min(d, 2.0)-1.0, 0.0)*2.0*0.25)) * float3(1.0, 1.1, 1.3);\n\tfloat3 col2 = float3(max(d-1.0, 0.0)*2.0*0.5) * float3(1.0, 1.2, 1.6);\n\n\tfloat f = max(0.5-mod(uv.y-uv.x*0.3+(TIME*0.4)+(dg.y*0.4), 2.5), 0.0)*5.0;\n\tcol2 *= f;\n\t\n\tout_FragColor = vec4(col1+col2, 1.0);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"SquareCellStructureScan","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"When off, the waves will stand still. Could be toggled on the beat to add pulsing to the scene.","MAX":0,"MIN":-0.200000002980232,"NAME":"WAVE_SPEED","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Add some smooth distortion to the waves.","MAX":1,"MIN":0,"NAME":"DISTORTION","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Add a rotational drift to the waves. Must be reset to perfectly center to get normal waves back.","MAX":0.150000005960464,"MIN":-0.150000005960464,"NAME":"ROTATE","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Add a directional drift to the waves. Must be reset to perfectly center to get normal waves back.","MAX":2,"MIN":-2,"NAME":"DRIFT","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":1,"DESCRIPTION":"When ON, cycles through many different shapes that disturb the wave simulation. When OFF, take manual control using paint position.","MAX":1,"MIN":0,"NAME":"auto_painter","TYPE":"toggle","UI_GROUP":"painter"},{"DEFAULT":[0,0],"DESCRIPTION":"auto painter MUST BE OFF. Manually move a small, pulsing paintbrush around the scene, creating a wake as it travels.","MAX":[1,1],"MIN":[-1,-1],"NAME":"paint_position","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"painter"},{"DEFAULT":1,"DESCRIPTION":"UserImage MUST BE SELECTED. This changes the way the scene treats a user defined image or video. Turn on for flashing, turn off for more subtle masking.","MAX":0,"MIN":1,"NAME":"logo_type","TYPE":"toggle","UI_GROUP":"media"}],"CREDIT":"Alex Rowe","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\square_shoals.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"config","VALUES":[1,0,2,3,4,5]},{"UNIFORM":"bassconfig","VALUES":[0,4,3,2,1,5]},{"UNIFORM":"colRegimeSelector","VALUES":[2,1,0,3,4]}],"HEIGHT":1080,"ID":"SquareShoals","IMAGES":null,"IMAGE_PATH":"square_shoals.synScene\\square_shoals.png","JSON_CODE":"{\n  \"TITLE\": \"SquareShoals\",\n  \"CREDIT\": \"Alex Rowe\",\n  \"IMAGE_PATH\": \"square_shoals.jpg\",\n  \"PASSES\": [\n  { \"TARGET\":\"backbuffer\", \n    \"HEIGHT\":500, \n    \"WIDTH\":888, \n    \"FLOAT\":true\n  }],\n  \"IMAGES\": [],\n  \"HARD_TRANSITIONS\": [{\n  \"UNIFORM\": \"config\",\n  \"VALUES\": [1, 0, 2, 3, 4, 5]\n },{\n  \"UNIFORM\": \"bassconfig\",\n  \"VALUES\": [0, 4, 3, 2, 1, 5]\n },{\n  \"UNIFORM\": \"colRegimeSelector\",\n  \"VALUES\": [2, 1, 0, 3, 4]\n}],\n  \"CONTROLS\":  [{\n    \"NAME\": \"WAVE_SPEED\",\n    \"MIN\": -0.2,\n    \"MAX\":  0.0,\n    \"DEFAULT\": 0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"When off, the waves will stand still. Could be toggled on the beat to add pulsing to the scene.\",\n    \"UI_GROUP\":\"motion\"\n  },{\n    \"NAME\": \"DISTORTION\",\n    \"MIN\": 0,\n    \"MAX\": 1,\n    \"DEFAULT\": 0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"Add some smooth distortion to the waves.\",\n    \"UI_GROUP\":\"motion\"\n  },{\n    \"NAME\": \"ROTATE\",\n    \"MIN\": -0.15,\n    \"MAX\":  0.15,\n    \"DEFAULT\": 0,\n    \"DESCRIPTION\": \"Add a rotational drift to the waves. Must be reset to perfectly center to get normal waves back.\",\n    \"UI_GROUP\":\"motion\"\n  },{\n    \"NAME\": \"DRIFT\",\n    \"MIN\": -2,\n    \"MAX\":  2,\n    \"DEFAULT\": 0,\n    \"DESCRIPTION\": \"Add a directional drift to the waves. Must be reset to perfectly center to get normal waves back.\",\n    \"UI_GROUP\":\"motion\"\n  },{\n    \"NAME\": \"auto_painter\",\n    \"MIN\": 0,\n    \"MAX\": 1,\n    \"DEFAULT\": 1,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"When ON, cycles through many different shapes that disturb the wave simulation. When OFF, take manual control using paint position.\",\n    \"UI_GROUP\":\"painter\"\n  },{\n    \"NAME\": \"paint_position\",\n    \"MIN\": -1.0,\n    \"MAX\":  1.0,\n    \"DEFAULT\": 0.0,\n    \"TYPE\": \"xy smooth\",\n    \"PARAMS\": 0.05,\n    \"DESCRIPTION\": \"auto painter MUST BE OFF. Manually move a small, pulsing paintbrush around the scene, creating a wake as it travels.\",\n    \"UI_GROUP\":\"painter\"\n  },{\n    \"NAME\": \"logo_type\",\n    \"DEFAULT\":1.0,\n    \"MIN\":1.0,\n    \"MAX\":0.0,\n    \"TYPE\": \"toggle\",\n    \"DESCRIPTION\": \"UserImage MUST BE SELECTED. This changes the way the scene treats a user defined image or video. Turn on for flashing, turn off for more subtle masking.\",\n    \"UI_GROUP\":\"media\"\n  }]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":500,"TARGET":"backbuffer","WIDTH":888}],"SCRIPT_CODE":"","SHADER_CODE":"float time = syn_Time*0.5;\n\nfloat volume = syn_Hits;\nfloat brightness = syn_HighHits;\nfloat onBeat = syn_OnBeat;\nfloat bassAccum = syn_BassLevel;\nfloat speedTime = syn_Time * 0.3;\nfloat bassTime = syn_BassTime * 0.3;\nfloat randomizerBeat = syn_ToggleOnBeat;\n\nvec2 resolution = RENDERSIZE;\nfloat WIDTH = 888;\nfloat HEIGHT = 500;\n\nstruct ColorRegime\n{\n  vec3 col1;\n  vec3 col2;\n};\n\nColorRegime reg1 = ColorRegime(vec3(1.0,0.7,0.25), vec3(0.8, 0.8, 1.0));\nColorRegime reg2 = ColorRegime(vec3(0.9,0.1,0.45), vec3(0.3,0.02,0.15));\nColorRegime reg3 = ColorRegime(vec3(0.0,0.3,0.7), vec3(0.7, 0.7, 1.0));\nColorRegime reg4 = ColorRegime(vec3(0.5,0.2,0.0), vec3(0.9, 0.8, 0.65));\nColorRegime reg5 = ColorRegime(vec3(0.0,0.7,0.0), vec3(0.2, 0.6, 1.0));\n\n// Gets the pixel in the backbuffer at (X,Y)\nfloat current(float x, float y) {\n return texture(backbuffer, vec2(x,y)).x;\n}\n\n// Gets the previous pixel in the backbuffer at (X,Y)\nfloat past(float x, float y) {\n return texture(backbuffer, vec2(x,y)).y;\n}\n\n// Gets normal to surface based on scenedist\nvec2 getNormal(vec2 pos){\n  float x = pos.x;\n  float y = pos.y;\n  float eps = 1.0/WIDTH/2;\n  return normalize(vec2(\n    IMG_NORM_PIXEL(backbuffer, vec2(x + eps, y)).x - IMG_NORM_PIXEL(backbuffer, vec2(x - eps, y)).x,\n    IMG_NORM_PIXEL(backbuffer, vec2(x, y + eps)).x - IMG_NORM_PIXEL(backbuffer, vec2(x, y - eps)).x));\n  }\n\n// Supplies a configuration for 'source' pixels generating waves\nfloat configuration(float i) {\n  float width = WIDTH;\n  float height = HEIGHT;\n  float xp = floor(gl_FragCoord.x) - (width/2.0);\n  float yp = floor(gl_FragCoord.y) - (height/2.0);\n  vec2 pos = vec2(xp,yp);\n  \n  if (_exists(syn_UserImage)){\n    if (logo_type < 0.5){\n      float logoFloat = _loadUserImageAsMask().r;\n      return volume*volume*1.0*logoFloat;\n    }\n  }\n  \n  // Concentric Circle\n  if (i == 0.0) {\n    vec2 mirrorPos = abs(pos);\n    float disty = length(pos-vec2(height*0.2*sin(speedTime*2*PI*0.08+randomizerBeat),height*0.2*cos(speedTime*2*PI*0.124+randomizerBeat)));\n    if(disty < 40.0) {\n      return volume*volume*1.5*pow(disty/40.0,4.0);\n    }\n  // Big Concentric Circles\n  } else if (i == 1.0) {\n    if (mod(length(pos),height/2.0) <= 5.0) {\n      return volume*volume*1.5;\n    }\n  // Random dots\n  } else if (i == 2.0) {\n    if(_rand(vec2(xp, yp)) < 0.001) {\n      return volume*volume*(3+3*volume);\n    }\n  // Square\n  } else if (i == 3.0) {\n    if((abs(xp) == 100 && abs(yp) <= 100 )||( abs(xp) <= 100 && abs(yp) == 100)) {\n      return volume*volume;\n    }\n  // Blotches\n  } else if (i == 4.0) {\n    float noise = _noise(vec3(_uv*20.0, speedTime));\n      if (noise*noise - 0.9 > 0.0) {\n        return volume*volume * noise*noise * 10.0;\n      }\n  // Motor boat in ocean\n  } else if (i == 5.0) {\n    float retVal = 0.0;\n    for (int k=-2; k<=2; k++){\n      if(xp == k*140 && abs(_uv.y-mod(-abs(k*1.5)+speedTime*0.5,10.0)/10.0) < .01) {\n         retVal += 0.5;\n      }\n    }\n    return retVal;\n  }\n  return 0.0;\n}\n\n// Supplies a configuration for putting \"dead zones\" in when bass hits\nfloat bassConfiguration(float i) {\n  float width = WIDTH;\n  float height = HEIGHT;\n  float xp = floor(gl_FragCoord.x) - (width/2.0);\n  float yp = floor(gl_FragCoord.y) - (height/2.0);\n  vec2 pos = vec2(xp, yp);\n\n  if (_exists(syn_UserImage)){\n    if (logo_type > 0.5){\n      float logoFloat = _loadUserImageAsMask().r;\n      return 1.0*logoFloat;\n    }  \n  }\n\n    // Concentric Circles\n  if (i == 0) {\n    if (mod(length(pos),height/5.0) <= 5.0) {\n      return 1.0;\n    }\n    // Concentric Squares\n  } else if (i == 2) {\n    if (mod(max(abs(pos.x),abs(pos.y)),height/10.0) <= 2.0) {\n      return 1.0;\n    }\n    // Random pixels\n  } else if (i == 3) {\n    if(_rand(floor(pos/20.0)*20.0) < 0.3) {\n      return 1.0;\n    }\n    // Motor boat in ocean\n  } else if (i == 4) {\n    float retVal = 0.0;\n    for (int k=-2; k<=2; k++){\n      if(length(pos-vec2(160*k,-height/2+height*fract((TIME*0.02+bassTime*0.04-abs(0.1*k))))) < 50.0) {\n        retVal += 1.0;\n      }\n    }\n    return retVal;\n    //big pixels\n  } else if (i == 5) {\n    if(_rand(100.243+floor(vec2(0.0,TIME)+pos/50.0)*50.0) < 0.2) {\n      return 1.0;\n    }\n  }\n//  } else if (i < 0.6) {\n//    return 0.0;\n//  }\n  return 0.0;\n}\n\nfloat WAVESPEED = 0.2+0.05*cos((1.0-volume)*PI) + WAVE_SPEED;\n// float WAVESPEED = 0.2;\n\n// float config = 1;\n// float bassconfig = 1;\n// float colRegimeSelector = 2;\n\n\n// Provides the actual wave simulation\nvec3 passOne() {\n  float pos;\n\n  // vec2 coord = _rotate(gl_FragCoord.xy - RENDERSIZE/2, ROTATE) + RENDERSIZE/2;\n  float rot_mod = ROTATE;\n  if (abs(ROTATE)<0.015){\n    rot_mod = 0;\n  }\n  float drift_mod = DRIFT;\n  if (abs(DRIFT)<0.2){\n    drift_mod = 0;\n  }\n  vec2 coord = _rotate(_uv - 0.5*vec2(1.0, RENDERSIZE.x/RENDERSIZE.y), rot_mod * abs(rot_mod)) + 0.5*vec2(1.0, RENDERSIZE.x/RENDERSIZE.y);\n  coord += vec2(sin(TIME/10), cos(TIME/10)) * drift_mod / RENDERSIZE.y;\n\n  coord += (vec2(\n    _fbm(vec3(coord * 10, TIME)),\n    _fbm(vec3(coord * 10, TIME + 100))\n    )  - 0.5) * DISTORTION / 100;\n\n  float x = coord.x;\n  float y = coord.y;\n\n  // Initlialize pixel if it hasnet been yet\n  if(texture(backbuffer,vec2(x,y)).z != 0.25) {\n    return vec3(0.0, 0.0, 0.25);\n  }\n\n  float r = WAVESPEED;\n\n  // Calculate next positon based on diffrential equation\n  float constDamping = 0.01;\n\n  pos = r*r*(\n    current(x-1/RENDERSIZE.x,y) + current(x+1/RENDERSIZE.x,y) +\n    current(x,y-1/RENDERSIZE.y) + current(x,y+1/RENDERSIZE.y) -\n    4 * current(x,y)) + \n    2 * current(x,y) - past(x,y) -\n    - constDamping*(current(x,y) - past(x,y));\n\n  // Alter position of pixel if it is one of the source pixels\n  if (auto_painter >= 0.5){\n    float configData = configuration(config);\n    if (configData > 0) {\n      pos = configData;\n    }\n  } else {\n    float disty = length(_uvc-vec2(paint_position.x, paint_position.y)*vec2(1.0, RENDERSIZE.y/RENDERSIZE.x)*0.9);\n    if(disty < 0.075) {\n      pos = volume*volume*1.5*pow(disty+1.0,4.0);\n    }\n  }\n\n//  pos = 1.0;\n  float bassConfigData = bassConfiguration(bassconfig);\n  if (bassConfigData > 0) {\n    pos = pos*pow((1.0-bassAccum),0.2);\n  }\n\n  // fade out based on decay (DIFFERENT from damping)\n  float decay = _scale(syn_FadeInOut, 0.90, 0.999);\n  pos *= decay;\n\n  // clamp position to make sure things dont get too wild\n  pos = clamp(pos, -2.0, 2.0);\n\n  // Return position, the last position\n  return vec3(pos, current(x,y), 0.25);\n}\n\n// Renders the pixels to screen\nvec3 passTwo() {\n  vec2 uv = _uv - 0.5;\n  vec3 data = IMG_NORM_PIXEL(backbuffer,_uv).rgb;\n  //Height reaches 2.0, divide by half and then pow it.\n  float height = pow(clamp(data.x/2.0,0.0,1.0),0.5);\n//  float height = data.x;\n\n\n  // Provide noise based coloring function\n // vec3 col = vec3(\n //     _fbm(vec3(_uv.x,_uv.y, TIME/30.0)),\n //     _fbm(vec3(_uv.x+10,_uv.y, TIME/30.0)),\n //     _fbm(vec3(_uv.x+20,_uv.y, TIME/30.0))\n //   );\n // col = mix(col, vec3(0.8, 0.8, 1.0), brightness * height);\n\n  // mix gold with silver\n\n  vec3 col1, col2, bkgCol;\n  if (colRegimeSelector == 0){\n    col1 = reg1.col1;\n    col2 = reg1.col2;\n  } else if (colRegimeSelector == 1){\n    col1 = reg2.col1;\n    col2 = reg2.col2;\n  } else if (colRegimeSelector == 2){\n    col1 = reg3.col1;\n    col2 = reg3.col2;\n  } else if (colRegimeSelector == 3){\n    col1 = reg4.col1;\n    col2 = reg4.col2;\n  } else if (colRegimeSelector == 4){\n    col1 = reg5.col1;\n    col2 = reg5.col2;\n  }\n\n  bkgCol = vec3(0.0);\n  vec2 norm = getNormal(_uv);\n  vec2 light = vec2(sin(brightness+TIME/5.0), cos(brightness+TIME/5.0)*2.0);\n\n  float ref = dot(norm, uv - light)/2.0;\n\n  // uncomment to debug lighting\n//   return vec3(ref);\n\n  float colorMixer = clamp((1.0+0.5*sin(uv.x*3.973+speedTime*0.35) + 0.5*sin(uv.y*2.315+speedTime*0.4))/2.0,0.0,1.0);\n//  colorMixer = mix(colorMixer, 1.0-colorMixer, brightness);\n\n  vec3 col = mix(col1, col2, colorMixer);\n  col = col*(1.0+5.0*pow(clamp(ref, 0.0, 0.9),3.0));\n\n  // Mix to bkg, brightness based on wave height\n  vec3 finalCol =  mix(bkgCol, col, height);\n\n  if ((bassconfig >= 0.2&&bassconfig <0.3)||((bassconfig >=0.4)&&bassconfig == 0.5)){\n    finalCol *= 2.5;\n  }\n\n  return finalCol * 2;\n}\n\nvec4 renderMain () {\n    if (PASSINDEX == 0) {\n      return vec4(passOne(),1.0);\n    } else if (PASSINDEX == 1) {\n      return vec4(passTwo()*(1-dot(_uv - 0.5,_uv -0.5)*2.3),1.0);\n    } \nreturn vec4(0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"SquareShoals","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Choose from one of four different patterns for the scene.","MAX":3,"MIN":0,"NAME":"pattern","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"pattern"},{"DEFAULT":[0,0],"DESCRIPTION":"Relocate the camera position to be off-center.","MAX":[300,300],"MIN":[-300,-300],"NAME":"move_xy","PARAMS":0.0399999991059303,"TYPE":"xy smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Reverse direction of zoom, to be traveling in or out.","MAX":1,"MIN":-1,"NAME":"reverse","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0.800000011920929,"DESCRIPTION":"How fast to zoom in or out.","MAX":2,"MIN":0,"NAME":"zoom_speed","TYPE":"slider","UI_GROUP":"motion"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Really intense spin effect. Default: 50%.","MAX":2,"MIN":0,"NAME":"spin","PARAMS":0.0199999995529652,"TYPE":"slider traveler","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Barrel distortion in or out.","MAX":1,"MIN":-1,"NAME":"distortion","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":4,"DESCRIPTION":"Number of axes of symmetry. Careful, increasing this can lower FPS.","MAX":7,"MIN":0,"NAME":"stacked_layers","TYPE":"slider","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"pearlescence","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"colorize"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\stained_glass.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Stained Glass","IMAGES":[{"NAME":"colorNoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"stained_glass.synScene\\stainedglass.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Stained Glass\",\n \"IMAGE_PATH\": \"stainedglass.png\",\n \"IMAGES\": [{\"NAME\": \"colorNoise\", \"PATH\":\"images/colornoise.jpg\"}],\n \"PASSES\": [{\"TARGET\":\"firstBuff\", \"WIDTH\": 1280, \"HEIGHT\":720}],\n \"CONTROLS\": [\n  {\n \t\"NAME\":\"pattern\", \"TYPE\": \"slider smooth\", \"PARAMS\": 0.05,\n \t\"MIN\": 0.0, \"MAX\": 3.0, \"DEFAULT\": 0.0,\n \t\"UI_GROUP\": \"pattern\",\n \t\"DESCRIPTION\": \"Choose from one of four different patterns for the scene.\"\n \t},{\n \t\"NAME\":\"move_xy\", \"TYPE\": \"xy smooth\", \"PARAMS\": 0.04,\n \t\"MIN\": -300.0, \"MAX\": 300.0, \"DEFAULT\": 0.0,\n \t\"UI_GROUP\": \"motion\",\n \t\"DESCRIPTION\":\"Relocate the camera position to be off-center.\"\n \t},{\n \t\"NAME\":\"reverse\", \"TYPE\": \"toggle\",\n \t\"MIN\": -1.0, \"MAX\": 1.0, \"DEFAULT\": 0.0,\n \t\"UI_GROUP\": \"motion\",\n \t\"DESCRIPTION\": \"Reverse direction of zoom, to be traveling in or out.\"\n \t},{\n \t\"NAME\":\"zoom_speed\", \"TYPE\": \"slider\",\n \t\"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 0.8,\n \t\"UI_GROUP\": \"motion\",\n \t\"DESCRIPTION\": \"How fast to zoom in or out.\"\n \t},{\n \t\"NAME\":\"spin\", \"TYPE\": \"slider traveler\",\n \t\"MIN\": 0.0, \"MAX\": 2.0, \"DEFAULT\": 0.2, \"PARAMS\": 0.02,\n \t\"UI_GROUP\": \"motion\",\n \t\"DESCRIPTION\": \"Really intense spin effect. Default: 50%.\"\n \t},{\n \t\"NAME\":\"distortion\", \"TYPE\": \"slider smooth\", \"PARAMS\": 0.05,\n \t\"MIN\": -1.0, \"MAX\": 1.0, \"DEFAULT\": 0.0,\n \t\"UI_GROUP\": \"geometry\",\n\t\"DESCRIPTION\": \"Barrel distortion in or out.\"\n \t},{\n \t\"NAME\":\"stacked_layers\", \"TYPE\": \"slider\",\n\t\"DEFAULT\": 4.0, \"MIN\": 0.0,\t\"MAX\": 7.0,\n\t\"UI_GROUP\": \"geometry\",\n\t\"DESCRIPTION\": \"Number of axes of symmetry. Careful, increasing this can lower FPS.\"\n },{\n \t\"NAME\":\"pearlescence\", \"TYPE\": \"slider smooth\",\n\t\"DEFAULT\": 0.0, \"MIN\": 0.0,\t\"MAX\": 1.0,\n\t\"UI_GROUP\": \"colorize\"\n }\n ]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"firstBuff","WIDTH":1280}],"SCRIPT_CODE":"function ApproachRandomSpot () {\n  this.goal = 0.0;\n  this.currentSpot = 0.0;\n}\n\nApproachRandomSpot.prototype.update = function(amt) {\n  this.currentSpot = this.currentSpot + (this.goal-this.currentSpot)*amt;\n}\n\nvar mover = new ApproachRandomSpot();\n\nvar decimator = 0;\nvar time = 0;\n\nfunction update(dt) {\n\n  if (inputs.syn_OnBeat > 0.9){\n    mover.goal = Math.random();\n  }\n  // mover.goal = 0.5+0.5*Math.sin(inputs.TIME);\n  mover.update(0.02);\n  uniforms.random_spot = mover.currentSpot;\n\n  time = time+Math.pow(inputs.syn_BassLevel,2.0)*0.1*inputs.reverse*inputs.zoom_speed;\n\n  uniforms.script_bass_time = time;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n}\n\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"vec3 iResolution = vec3(RENDERSIZE.x, RENDERSIZE.y, 0.0);\nvec3 iChannelResolution = iResolution;\nfloat iGlobalTime = TIME*1.0;\nint iFrame = int(FRAMECOUNT);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\nvec4 iMouse = vec4(0.5);\n\nvec3 hsv(float h,float s,float v) {\n  return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\nfloat circle(vec2 p, float r) {\n  return smoothstep(0.1+syn_Presence*0.3, 0.0, abs(length(p)-r)); // try changing the 0.1 to 0.3\n}\nfloat r3 = sqrt(3.0);\nvec4 pulseCircles(vec2 uv) {\n  // vec2 uv = -1.0 + 2.0*_xy.xy / RENDERSIZE.xy;\n  // uv.x *= RENDERSIZE.x/RENDERSIZE.y;\n  uv *= 10.0;\n  float r = smoothstep(-0.7, 0.7, sin(random_spot*2.57-length(uv)*0.1))+1.0;\n  vec2 rep = vec2(4.0,r3*4.0);\n  vec2 p1 = mod(uv, rep)-rep*0.5;\n  vec2 p2 = mod(uv+vec2(2.0,0.0), rep)-rep*0.5;\n  vec2 p3 = mod(uv+vec2(1.0,r3), rep)-rep*0.5;\n  vec2 p4 = mod(uv+vec2(3.0,r3), rep)-rep*0.5;\n  vec2 p5 = mod(uv+vec2(0.0,r3*2.0), rep)-rep*0.5;\n  vec2 p6 = mod(uv+vec2(2.0,r3*2.0), rep)-rep*0.5;\n  vec2 p7 = mod(uv+vec2(1.0,r3*3.0), rep)-rep*0.5;\n  vec2 p8 = mod(uv+vec2(3.0,r3*3.0), rep)-rep*0.5;\n  \n  float c = 0.0;\n  c += circle(p1, r);\n  c += circle(p2, r);\n  c += circle(p3, r);\n  c += circle(p4, r);\n  c += circle(p5, r);\n  c += circle(p6, r);\n  c += circle(p7, r);\n  c += circle(p8 , r);\n  return vec4(hsv(r+0.7, 1.0, c), 1.0);\n}\n\nvec4 renderPass()\n{\n    vec4 fragColor = vec4(0.0);\n    float zoom = 0.5;\n    vec2 uv = zoom * (_xy - RENDERSIZE.xy / 2.0);\n        \n    float time = syn_HighTime * 3.1415 * 0.05;\n    \n    // uv += move_in;\n    \n    float pi = acos(-1.);\n   \n    float m = 1.;\n    float n = 8.;\n    float p = 1.;\n    \n    float img = 0.0;\n\n    if (syn_MediaType > 0.5){\n      img = dot(_loadUserImage().rgb, vec3(1.0))/3.0;   \n    }\n    \n    int points = 2+int(stacked_layers);\n    const int iters = 8;\n    float value = 0.;\n    float value2 = 0.;\n    float value3 = 0.;\n    vec3 value4 = vec3(1.0,0.0,syn_BassLevel);\n\n    vec2 uv2 = uv;\n\n    vec2 oldVal = vec2(0.0);\n\n\n    for(int j = 0; j < iters; j++){\n      // time = mix(time, -time, mod(j, 2));\n      // uv2 = _rotate(uv2, syn_Time*0.01*j);\n      uv = _rotate(uv, 100.0*j+spin)*(1.0+length(uv)*0.0005*distortion);\n      uv += move_xy;\n      uv2 = _rotate(uv2, 100.0*j+spin)*(1.0+length(uv2)*0.0005*distortion);\n      uv2 += move_xy*0.1;\n      uv.y += img*10.0;\n\n      for(int i = 0; i < points ; i++){\n              uv.y += img*1.0;\n\n        float zoom = mod(script_bass_time*0.2+j,iters);\n        // zoom -= img.r;\n\n        float angle = pi / float(points) * float(i);\n        float w = uv.x * sin(angle) + uv.y * cos(angle);\n        float w2 = uv2.x * sin(angle) + uv2.y * cos(angle);\n\n        // w /= random_spot;\n\n        float divisor = 1.0+pow(zoom,3.0);\n        float mixer = (1.0-smoothstep(iters-2, iters-1, zoom))*smoothstep(0, 1, zoom);\n\n        w /= divisor;\n        w2 /= divisor;\n\n        // w /= ((-0.5+random_spot)*4.0+_uvc.y*2.0);\n\n        float sinHolder = sin(w + time + syn_BassPresence);\n        float sinHolder2 = sin(w2 + time + random_spot*i);\n\n        // sinHolder = -1.0+2.0*step(sinHolder, 0.0);\n        // sinHolder = sinHolder;\n\n        value += sinHolder*mixer;\n        value2 += smoothstep(sinHolder2, 0.0, 0.1)*mixer;\n        // value3 += pow(oldVal.x, 2.0);\n        value3 += _pulse(value, 0.1+syn_Presence, 0.1);\n        value4 = mix(value4, cross(value4+syn_Presence*0.2, vec3(sinHolder, sinHolder2, 0.5)), mixer);\n      };\n\n      oldVal = vec2(value, value3);\n    }\n       \n    value /= iters;\n    value2 /= iters;\n    // value3 /= iters;\n\n    // value2 = step(1.0-value2, 0.0);\n    \n    float geometry = (sin(value * pi / 2.) + 1.) * 0.5;\n    float goop = (sin(value2 * pi / 2.) + 1.) * 0.5;\n    // float fractal = (sin(value3 * pi / 2.) + 1.) * 0.5;\n    float fractal = value3;\n    // goop = value2;\n\n    goop = clamp(goop, 0.0, 1.0);\n    fractal = clamp(fractal, 0.0, 1.0);\n\n\n    fragColor = vec4(geometry, fractal, 0.5+0.5*cos(value*10.0+uv2.y*0.01), goop);\n\n\n    fragColor = mix(fragColor, vec4(abs(min(value4,2.0)),1.0), pearlescence);\n    // fragColor = vec4(abs(value4), 1.0);\n    // fragColor.a = goop;\n    return fragColor;\n\n}\n\n\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){\n    return renderPass();\n  } else if (PASSINDEX == 1.0){\n    vec4 data = texture(firstBuff, _uv);\n    \n    float v = 0.0;\n    float patSel = pattern;\n    float patMix = smoothstep(0.25, 0.75, clamp(patSel, 0.0, 1.0));\n    v = mix(data.r, data.b, patMix);\n    patSel -= 1.0;\n    patMix = smoothstep(0.25, 0.75, clamp(patSel, 0.0, 1.0));\n    v = mix(v, clamp(data.a,0.0,1.0), patMix);\n    patSel -= 1.0;\n    patMix = smoothstep(0.25, 0.75, clamp(patSel, 0.0, 1.0));\n    v = mix(v, clamp(data.g,0.0,1.0), patMix);\n\n    // finalCol += data.g*vec4(1.0);\n    // finalCol += clamp(data.b,0.0,1.0)*vec4(1.0,0.0,0.0,1.0);\n    // v += clamp(data.a,0.0,1.0);\n\n    // slight vignetting\n    v *= exp(-0.6 * length(_uvc)) * 1.2;\n    \n    vec2 colPos = _uv + vec2(sin(TIME*0.1), cos(TIME*0.2))*10.0;\n\n    // use texture channel0 for color? why not.\n    vec3 cexp = texture(colorNoise, colPos * 0.001).xyz * 3.0 + texture(colorNoise, colPos * 0.01).xyz;//vec3(1.0, 2.0, 4.0);\n    cexp *= 1.4;\n    \n    vec3 finalCol = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n\n    // finalCol.rgb = _rgb2hsv(finalCol.rgb);\n    // // finalCol.r += data.g;\n    // finalCol.r += clamp(data.b,0.0,1.0);\n    // finalCol.g += clamp(data.b,0.0,1.0);\n    // finalCol.b -= clamp(data.b,0.0,1.0);\n\n    finalCol *= (0.5+0.5*pulseCircles(_uvc*1.5 + v).rgb);\n\n    finalCol = mix(finalCol, data.rgb, pearlescence);\n    return vec4(finalCol,1.0);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Stained Glass","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"freq1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.25,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"freq2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":5,"DESCRIPTION":"","MAX":7,"MIN":3,"NAME":"loop1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":16,"DESCRIPTION":"","MAX":25,"MIN":6,"NAME":"loop2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1.5,"MIN":-0.5,"NAME":"radius1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":2.5,"MIN":0.5,"NAME":"radius2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":3,"MIN":0.25,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00100000004749745,"DESCRIPTION":"","MAX":0.00499999988824129,"MIN":9.99999974737875e-05,"NAME":"thickness","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"based on http://glslsandbox.com/e#42256.0","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\stringart.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"StringArt","IMAGES":null,"IMAGE_PATH":"stringart.synScene\\stringart.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"freq1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.25,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"freq2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 7,\n\t\t\t\"MIN\" : 3,\n\t\t\t\"NAME\" : \"loop1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 16,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 25,\n\t\t\t\"MIN\" : 6,\n\t\t\t\"NAME\" : \"loop2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"radius1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2.5,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"radius2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0.25,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.001,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.005,\n\t\t\t\"MIN\" : 0.0001,\n\t\t\t\"NAME\" : \"thickness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"based on http://glslsandbox.com/e#42256.0\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"stringart.png\",\n\t\"TITLE\" : \"StringArt\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n////////////////////////////////////////////////////////////\n// StringArt  by mojovideotech\n//\n// based on :\n// glslsandbox.com\\/e#42256.0\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n\n\n#define \tpi   \t3.141592653589793 \t// pi\n#define \ttwpi  \t6.283185307179586  \t// two pi, 2*pi\n\nfloat T = 0.01*(TIME*rate);\n\nfloat cyc(float a) { \n\tfloat c = cos(a), s = sin(a);\n\tvec2 g = vec2(c,s), h = vec2(s,-c); \n\treturn dot(g,h); \n}\n\nvec2 rotate(vec2 st, float a) {\n\tfloat b = cyc(a);\n\ta = cyc(mix(a,b,freq1));\n\tst *= mat2( cos(a) , -sin(a), sin(a), cos(a) ) ;\n\treturn st ;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a, ap = p - a;\n    float rb = radius1, rp = radius2;\n    vec2 rr = rotate(vec2(rb,rp),T*pi);\n    float k = clamp(dot(ap, ab)/dot(ab, ab), rr.x, rr.y);\n    return smoothstep(0.0, 5.0/RENDERSIZE.y, length(ap - k*ab) - thickness);\n}\n\nfloat shape(float u,vec2 p, float angle) {\n    float d = 1.0;\n    vec2 a = vec2(scale, 0.0), b;\n    vec2 rot = vec2(cos(angle), sin(angle)*u);\n    for (int i = 0; i < 7; ++i) {\n        b = a;\n        for (int j = 0; j < 25; ++j) {\n        \tb = vec2(b.x*rot.x - b.y*rot.y, b.x*rot.y + b.y*rot.x);\n        \td = min(d, segment(p,  a, b));\n        \tif (float(j)>floor(loop2)) break;\n        }\n        a = vec2(a.x*rot.x - a.y*rot.y, a.x*rot.y + a.y*rot.x);\n        if (float(i)>floor(loop1)) break;\n    }\n    return d;\n}\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 uv = _xy.xy / RENDERSIZE.xy;\n    vec2 cc = (-RENDERSIZE.xy + 2.0*_xy.xy) / RENDERSIZE.y;\n    float col = shape(freq2,abs(cc),freq1+cos(T)*twpi);\n   \n\tout_FragColor = vec4(vec3(pow(1.0-col, 2.0)),1.0);\n\nreturn out_FragColor; \n } \n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"StringArt","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Send a bright pulse through the scene (inverted if invert is on).","MAX":1,"MIN":0,"NAME":"bright","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"flash"},{"DEFAULT":1,"DESCRIPTION":"Send a dark pulse through the scene (inverted if invert is on).","MAX":1,"MIN":0,"NAME":"dark","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"flash"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"Change the hue of the entire scene.","MAX":1,"MIN":0,"NAME":"hue","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Reduces the color space, resulting in less saturated colors and more abstract shapes. 100% is all colors, 0% is only 2 or 3.","MAX":1,"MIN":0.0900000035762787,"NAME":"levels","PARAMS":0.25,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"Amount of 'fire', or glow leaking up from the bottom.","MAX":-1,"MIN":2,"NAME":"fire","TYPE":"slider","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Change all colors to their opposite colors. Makes the scene much brighter.","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.699999988079071,"DESCRIPTION":"Feedback, or 'upward fading'. 0% is no blurring with very crisp lines. 100% will be no action, just upward scrolling.","MAX":0,"MIN":1,"NAME":"feedback","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"subtle"},{"DEFAULT":0,"DESCRIPTION":"On press, a sun-like orb appears in the center, and echoes through the scene.","MAX":1,"MIN":0,"NAME":"sun_pierce","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"subtle"},{"DEFAULT":10,"DESCRIPTION":"Low frame rate is responsible for a lot of the dramatic visual patterns in this scene. Make it stutter even more (lower frame rate) by moving this slider up. Or make it smoother and less dramatic by moving this down.","MAX":25,"MIN":1,"NAME":"stutter","TYPE":"slider","UI_GROUP":"subtle"},{"DEFAULT":1,"DESCRIPTION":"Reset the feedback by flashing 'mountains' on bass hits.","MAX":1,"MIN":0,"NAME":"auto_reset","TYPE":"toggle","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Manually reset the feedback by flashing to the 'mountains' screen.","MAX":1,"MIN":0,"NAME":"manual_reset","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"feedback"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\sun_set.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"direction","VALUES":[-1,1]}],"HEIGHT":1080,"ID":"Sun_Set","IMAGES":null,"IMAGE_PATH":"sun_set.synScene\\sun_set.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Sun_Set\",\n \"IMAGE_PATH\": \"sun_set.png\",\n \"HARD_TRANSITIONS\": [\n {\n \"UNIFORM\": \"direction\",\n \"VALUES\":[-1.0,1.0]\n }],\n \"IMAGES\": [],\n \"PASSES\": [{\"TARGET\": \"firstBuffer\"},{\"TARGET\": \"secondBuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"bright\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\": 0.05,\n    \"UI_GROUP\": \"flash\",\n    \"DESCRIPTION\": \"Send a bright pulse through the scene (inverted if invert is on).\"\n  },{\n    \"NAME\": \"dark\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\": 0.05,\n    \"UI_GROUP\": \"flash\",\n    \"DESCRIPTION\": \"Send a dark pulse through the scene (inverted if invert is on).\"\n  },{\n    \"NAME\": \"hue\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.1,\n    \"UI_GROUP\": \"color\",\n    \"DESCRIPTION\": \"Change the hue of the entire scene.\"\n  },{\n    \"NAME\": \"levels\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.09,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"slider smooth\",\n    \"PARAMS\": 0.25,\n    \"UI_GROUP\": \"color\",\n    \"DESCRIPTION\": \"Reduces the color space, resulting in less saturated colors and more abstract shapes. 100% is all colors, 0% is only 2 or 3.\"\n  },{\n    \"NAME\": \"fire\",\n    \"MAX\" : -1.0,\n    \"MIN\" : 2.0,\n    \"DEFAULT\":1.0,\n    \"UI_GROUP\": \"color\",\n    \"DESCRIPTION\": \"Amount of 'fire', or glow leaking up from the bottom.\"\n  },{\n    \"NAME\": \"invert\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"color\",\n    \"DESCRIPTION\": \"Change all colors to their opposite colors. Makes the scene much brighter.\"\n  },{\n    \"NAME\": \"feedback\",\n    \"MAX\" : 0.0,\n    \"MIN\" : 1.0,\n    \"DEFAULT\":0.7,\n    \"TYPE\": \"slider smooth\",\n    \"PARAMS\": 0.05,\n    \"UI_GROUP\": \"subtle\",\n    \"DESCRIPTION\": \"Feedback, or 'upward fading'. 0% is no blurring with very crisp lines. 100% will be no action, just upward scrolling.\"\n  },{\n    \"NAME\": \"sun_pierce\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"bang smooth\",\n    \"PARAMS\":0.1,\n    \"UI_GROUP\": \"subtle\",\n    \"DESCRIPTION\": \"On press, a sun-like orb appears in the center, and echoes through the scene.\"\n  },{\n    \"NAME\": \"stutter\",\n    \"MAX\" : 25.0,\n    \"MIN\" : 1.0,\n    \"DEFAULT\":10.0,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"subtle\",\n    \"DESCRIPTION\": \"Low frame rate is responsible for a lot of the dramatic visual patterns in this scene. Make it stutter even more (lower frame rate) by moving this slider up. Or make it smoother and less dramatic by moving this down.\"\n  },{\n    \"NAME\": \"auto_reset\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"feedback\",\n    \"DESCRIPTION\": \"Reset the feedback by flashing 'mountains' on bass hits.\"\n  },{\n    \"NAME\": \"manual_reset\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.2,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"feedback\",\n    \"DESCRIPTION\": \"Manually reset the feedback by flashing to the 'mountains' screen.\"\n  }]\n }","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0},{"FLOAT":true,"HEIGHT":0,"TARGET":"secondBuffer","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"\nvec4 sigmoid(vec4 x){\n  return x/(1.+abs(x));\n}\n\nfloat sigmoid(float x){\n  return x/(1.+abs(x));\n}\n\nvoid fromCentToUV(out vec2 posIn){\n  posIn *= 0.5;\n  posIn += 0.5;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 firstPass()\n{\n  vec2 pos = _uvc;\n  vec2 polarPos = _toPolar(_uvc);\n  vec3 dataCol = texture(firstBuffer, _uv).xyz;\n\n  float s2 = syn_Presence*0.4;\n\n  fromCentToUV(pos);\n  pos = pos + dataCol.xy*(3.0+8.0*syn_MidPresence);\n  pos = pos;\n  vec3 oldCol = texture(firstBuffer, pos).xyz;\n  float greenModder = fire;\n  float redModder = 1.0;\n  if (fire > 1.0){\n    greenModder = (fire-1.0)*20.0;\n  }\n  if (_exists(syn_UserImage)){\n    vec4 logoCol = _loadUserImageAsMask();\n    redModder = 0.3+length(logoCol)*(0.2+syn_HighHits)*0.9;\n  } else {\n    redModder = 1.0-fract(polarPos.x*s2*10.0+polarPos.x*(-3.0*_uv.y))*s2;\n  }\n    \n\n  vec3 col = vec3(redModder, pow(_uv.y,greenModder)*0.6, 0.5);\n  col += vec3(5.0)*step(length(_uvc-vec2(0.0,0.0+sun_pierce*0.2)),0.1+sun_pierce*0.1)*sun_pierce;\n\n\n  col *= 1.5-polarPos.x;\n  col += vec3(0.7*syn_HighHits*(smoothstep(fract(polarPos.y*10.0), 0.1, 0.2))*clamp((1.0-_uv.y*2.0),0.0,1.0), syn_HighLevel*abs(_uvc.y)*polarPos.x, 0.0);\n  col += vec3(0.0,0.0,-0.5*syn_OnBeat*_uvc.y);\n  col.z = mix(dataCol.z, col.z, 0.5-sun_pierce);\n\n  bool frameRefresh = false;\n  if ((manual_reset > 0.05)||((syn_BassHits > 0.5)&&(auto_reset>0.5))){\n    frameRefresh = true;\n    col = col;\n    float mountainMotion = _uv.x+direction*TIME;\n    oldCol = vec3(step(_uv.y+_fbm(mountainMotion), syn_BassPresence));\n    // oldCol = vec3(tan(length(_uvc)));\n  }\n\n  vec3 finalCol = dataCol;\n  if (mod(FRAMECOUNT,ceil(stutter))==0){\n    finalCol = mix(col, oldCol, 0.5);\n  }\n\n\n  finalCol += step(dot(abs(_uvc), vec2(cos(bright*PI-0.1),sin(bright*PI))),0.00)*sqrt(bright);\n  finalCol -= step(dot(abs(_uvc), vec2(cos(dark*PI-0.1),sin(dark*PI))),0.00)*sqrt(dark);\n\n  // finalCol = mix(finalCol, 1.0-finalCol, data.g);\n\n  // if (syn_HighHits>0.5){\n  //   finalCol = mix(col, oldCol, 0.5);\n  // }\n\n  return finalCol;\n}\n\n\n//Second\nvec3 secondPass()\n{\n\n  vec3 col = texture(firstBuffer, _uv).xyz*0.8;\n               // + texture(secondFB, uv+d*vec2(1.,0.))\n               // + texture(secondFB, uv+d*vec2(-1.,0.))\n               // + texture(secondFB, uv+d*vec2(0.,-1.))\n               // + texture(secondFB, uv+d*vec2(0.,1.))\n               // );\n\n  float intensity = 1.0-syn_Presence;\n  col = col*intensity + pow(col, vec3(3.0))*(1.0-intensity);\n\n  col += vec3(0.0,0.0,texture(firstBuffer, _uv+_fbm(_uv+TIME)*0.01).r)*syn_MidLevel*0.5;\n\n  return col;\n}\n\nvec4 renderMain () {\n  if (PASSINDEX == 0.0){\n    vec3 col = firstPass();\n    return vec4(col, 1.0);\n  }\n  else if (PASSINDEX == 1.0){\n    vec3 col = secondPass();\n    col = col*feedback+texture(secondBuffer, _uv-vec2(0.0,syn_BassLevel)*0.01).rgb*(1.0-feedback);\n    return vec4(col, col.b);\n  } else if (PASSINDEX == 2.0){\n    vec3 col = texture(secondBuffer, _uv).rgb;\n    if (invert >= 0.5){\n      col = 1.0-col;\n    }\n    vec3 hsv = rgb2hsv(col);\n    hsv.r += fract(hue);\n    float actualLevels = smoothstep(0.0,0.25,levels)*10.0+smoothstep(0.25,0.5,levels)*50.0+smoothstep(0.5,0.75,levels)*500.0+smoothstep(0.75,1.0,levels)*10000.0;\n    col = hsv2rgb(_pixelate(hsv,pow(actualLevels,0.5)));\n\n    return vec4(col, 1.0);\n  }\n\n  return vec4(1.0, 0.0, 0.0, 1.0);\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Sun_Set","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"The point they'll run from, if fear is set to ON.","MAX":[1.20000004768372,1.20000004768372],"MIN":[0,0],"NAME":"run_away","TYPE":"xy","UI_GROUP":"fear"},{"DEFAULT":0,"DESCRIPTION":"","MAX":2,"MIN":0,"NAME":"fear_on","TYPE":"toggle","UI_GROUP":"fear"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"frantic","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"energize_center","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"calm_collect","TYPE":"toggle","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"Higher excitement just means more exaggerated motion.","MAX":3,"MIN":0,"NAME":"excitement","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"motion"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"color_pop","PARAMS":0.5,"TYPE":"bang smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"color_palette","TYPE":"bang counter","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"invert_col","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":0.600000023841858,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"size","TYPE":"slider","UI_GROUP":"color"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\swarm.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"twitcherType","VALUES":[0,1,2]},{"UNIFORM":"twitchForceSupplier","VALUES":[0,1]}],"HEIGHT":1080,"ID":"Swarm","IMAGES":null,"IMAGE_PATH":"swarm.synScene\\swarm.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"Swarm\",\n \"IMAGE_PATH\": \"swarm.png\",\n \"HARD_TRANSITIONS\": [\n {\"UNIFORM\": \"twitcherType\", \"VALUES\":[0.0,1.0,2.0]},\n {\"UNIFORM\": \"twitchForceSupplier\", \"VALUES\":[0.0,1.0]}],\n \"IMAGES\": [],\n \"PASSES\": [ {\"TARGET\": \"firstBuffer\", \"HEIGHT\":2, \"WIDTH\": 100, \"FLOAT\": true},{\"TARGET\": \"secondBuffer\", \"HEIGHT\":720, \"WIDTH\": 1200}],\n \"CONTROLS\": [{\n    \"NAME\": \"run_away\",\n    \"MAX\" : 1.2,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"xy\",\n    \"UI_GROUP\": \"fear\",\n    \"DESCRIPTION\": \"The point they'll run from, if fear is set to ON.\"\n  },{\n    \"NAME\": \"fear_on\",\n    \"MAX\" : 2.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"fear\"\n  },{\n    \"NAME\": \"frantic\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"motion\"\n  },{\n    \"NAME\": \"energize_center\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"motion\"\n  },{\n    \"NAME\": \"calm_collect\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"motion\"\n  },{\n    \"NAME\": \"excitement\",\n    \"MAX\" : 3.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"PARAMS\":0.1,\n    \"TYPE\": \"slider smooth\",\n    \"UI_GROUP\": \"motion\",\n    \"DESCRIPTION\": \"Higher excitement just means more exaggerated motion.\"\n  },{\n    \"NAME\": \"color_pop\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.5,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"color\"\n  },{\n    \"NAME\": \"color_palette\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"bang counter\",\n    \"UI_GROUP\": \"color\"\n  },{\n    \"NAME\": \"invert_col\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"color\"\n  },{\n    \"NAME\": \"size\",\n    \"MAX\" : 3.0,\n    \"MIN\" : 0.00,\n    \"DEFAULT\":0.6,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"color\"\n  }]\n }","PASSES":[{"FLOAT":true,"HEIGHT":2,"TARGET":"firstBuffer","WIDTH":100},{"FLOAT":true,"HEIGHT":720,"TARGET":"secondBuffer","WIDTH":1200}],"SCRIPT_CODE":"","SHADER_CODE":"\n#define NUM_PARTICLES 40.\n#define MAX_ACC 3.\n#define MAX_VEL 1.5\n#define RESIST .2\n\nfloat colRegime = mod(color_palette, 10);\n\n\n\nvec2 RES = RENDERSIZE.xy;\nvec2 hash(float n) { return fract(sin(vec2(n,n*7.))*43758.5); }\nvec4 getParticle(float i) { return texelFetch(firstBuffer, ivec2(i,0),0);}\n\nvec4 firstPass() { \n    vec2 fragCoord = _xy;  \n    if( fragCoord.x > NUM_PARTICLES) discard;\n    vec2  w, vel, acc, sumF, res = vec2(1200.0, 720.0) / 720.0;\n    float d, a, v, dt = .03, id = floor(fragCoord.x);  \n    vec4 finalCol;\n        \n    if (FRAMECOUNT < 5)   \n        finalCol = vec4(.1+.8*hash(id)*res,0,0);         \n    else { \n\n    vec4 particle = getParticle(id);\n        \n// ====== Forces\n        \n    // Borders action\n    sumF = .8*(1./abs(particle.xy) - 1./abs(res-particle.xy));         \n    // // Bass action        \n    //     w = particle.xy;\n    //     // sumF += pow(normalize(w),vec2(4.0))*pop/dot(w,w);\n\n    // // Move left to right\n  // w = particle.xy - vec2(0.5, 0.5)*res;\n  // sumF += vec2((-1.0+mod(id,2)*2.0)*syn_HighHits,0.0)*3.0;\n\n\n    // float bassForce = syn_BassLevel*3.0*sin(TIME*1000.0);\n\n    // sumF += vec2(-0.5+particle.x,-bassForce*2.0*(-0.5+particle.y));\n\n    // sumF += _rotate(vec2(1.0, 0.0),floor(syn_BPMTwitcher*0.25))*syn_HighHits*3.0;\n\n\n    // if(floor(mod(id, 3))==0){\n    //     particle.xy = mix(particle.xy, hash(id+syn_BeatTime)*vec2(1.6,1.0), floor(syn_OnBeat*syn_HighHits*1.3));\n    // }\n\n    // Calculate repulsion force with other particles\n    for(float i=0.;i<NUM_PARTICLES;i++) {\n        if(i != id) {\n            d = length(w = particle.xy - getParticle(i).xy);\n            if (calm_collect > 0.5){\n                d *= 10.0;\n            }\n            sumF -= d > 0. ? w*(6.3+log(d*d*(0.022-syn_HighHits*0.011*syn_Presence)))/exp(d*d*2.4)/d  :  .01*hash(id); // if same pos : ramdom force\n            // sumF -= d > 0. ? w*(6.3+log(d*d*0.02))/exp(d*d*2.4)/d  :  .01*hash(id); // if same pos : ramdom force\n        }\n    }\n\n    //Rotational Force\n    vec2 polarPos = _toPolarTrue(2.0*particle.xy-1.0);\n\n    vec2 rotoVec = _rotate(mix(vec2(0.0,-1.0), vec2(0.0,1.0), sin(syn_Time*0.05)*0.5+0.5), -polarPos.y*2*PI);\n\n    sumF += polarPos.x*rotoVec*syn_Presence*2.0;\n\n    w = particle.xy - vec2(0.5, 0.5)*res;\n\n    float twitchForce = fract(1.0-syn_BPMTwitcher);\n    if (twitchForceSupplier > 0.5){\n        twitchForce = syn_BPMSin2;\n    }\n    twitchForce *= 1.0;\n\n    float twitchMod = twitchForce*(-1.0+mod(id,2)*2.0);\n    if (twitcherType > 0.5){\n        twitchMod = twitchForce*(-1.0+mod(id,3));\n    } else if (twitcherType > 1.5){\n        twitchMod = twitchForce*(-1.0+mod(id,5)*0.5);\n    }\n\n    sumF += vec2(twitchMod,0.0)*10.0;\n\n    if (frantic>0.5) sumF += vec2(-0.5+_rand(particle.xy*100.0+TIME),-0.5+_rand(particle.xy*133.0+TIME))*10.0;\n\n    sumF *= (1.0+excitement);\n\n    sumF -= (1/pow(distance(particle.xy, run_away),2.0))*fear_on*(run_away-particle.xy);\n\n    // Friction    \n    sumF -= particle.zw*RESIST/dt;\n\n// - Dynamic calculation ---------------------     \n        \n    // Calculate acceleration A = (1/m * sumF) [cool m=1. here!]\n    a = length(acc = sumF); \n    acc *= a>MAX_ACC ? MAX_ACC/a : 1.; // limit acceleration\n    // Calculate speed\n    v = length(vel = particle.zw + acc*dt);\n    vel *= v>MAX_VEL ? MAX_VEL/v : 1.; // limit velocity\n        \n    vel -= vec2(-0.888889+particle.x, -0.5+particle.y)*2.0*energize_center;\n\n\n// - Save ------------------------------------   \n        \n    // Save position and velocity of particle (xy = position, zw = velocity) \n        finalCol = vec4(particle.xy + vel*dt, vel);\n        \n    }\n    return finalCol;\n}\n\n\n// Draw a particle\nfloat signedDist(float i, vec2 p, float rot, float scale) {\n    float ds, c = cos(rot), s = sin(rot);\n    // Rotate ad rescale\n    p *= scale;\n\n    p.y = abs(p.y)+.13*p.x;\n\n    // scale *= \n\n    float shape = max(length(p)-0.3, -ds)/scale;\n\n    return shape;    \n}\n\nvec4 cell(vec2 fragCoord, vec2 pixel)\n{\n    vec2 uv = (fragCoord-pixel) / RENDERSIZE.xy;\n    return texture(secondBuffer, uv);\n}\n\nvec4 secondPass() {\n    vec2 p = 1./RENDERSIZE.xy;\n    vec2 fragCoord = _xy;\n    float d, m = 1e6;\n    float halo = 0;\n    vec4 c, ct, particle;\n    vec3 fragColor;\n\n    for(float i=0.;i<NUM_PARTICLES;i++) {     \n        // Get particle in Buf A (xy = position, zw = velocity) \n        //    from iq shader Brick [https://www.shadertoy.com/view/MddGzf]\n        particle = getParticle(i);\n        // Draw particle according to its direction\n        d = signedDist(i, particle.xy-fragCoord.xy*p.y, atan(particle.w,particle.z), 50-(pow(size,0.2)+color_pop)*40.0);\n        // min use to draw particle\n        m = min(m, d);\n        // Background color sum based on particle velocity (blue => red)\n        // c = mix(vec4(0,0,1,1), vec4(1,0,0,1), length(particle.zw)/MAX_VEL);\n        // Halo - simple version: c*smoothstep(.5,0.,d);\n        halo += length(particle.zw)/MAX_VEL*(smoothstep(0.25,0.25-0.2,d)-smoothstep(0.25-0.2,0.25-0.2*2,d)); \n    }\n    // Mix particle color (white) and Halo\n    fragColor = mix(vec3(1),vec3(0.0), smoothstep(0.,p.y*1.2, m));\n\n    float lookupDist = 1.0+(1.0-syn_FadeInOut)*5.0;\n\n    float l = cell(_xy, vec2(-1,0)*lookupDist).r; // left cell\n    float r = cell(_xy, vec2(1,0)*lookupDist).r; // rigt cell\n    float t = cell(_xy, vec2(0,1)*lookupDist).r; // top cell\n    float b = cell(_xy, vec2(0,-1)*lookupDist).r; // bottom cell\n\n    float minnedCol = min(min(min(l, r),t),b);\n    minnedCol -= _rand(_uvc*1000.0+TIME*10000.0)*0.1;\n\n\n    // fragColor = mix(fragColor, texture(secondBuffer, _uv), 0.6);\n    fragColor = vec3(minnedCol)+fragColor;\n    return vec4(clamp(fragColor,0.0,8.0),halo);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n  // finalCol *= palette(fract(redAmt + grnAmt + bluAmt), vec3(0.420, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.600, 0.250, 1.200), vec3(0.500, 0.450, 0.500));\n\n\nvec3 colorPaletteChooser(float colReg, float var){\n  vec3 paletteCol = vec3(0.5);\n  if (colReg < 1.0){\n    paletteCol = palette(var, vec3(0.500, 0.500, 0.520), vec3(0.500, 0.500, 0.500), vec3(0.780, 0.765, 0.750), vec3(0.360, 0.570, 0.680));\n  } else if (colReg < 2.0){\n    paletteCol = palette(var, vec3(0.500, 0.580, 0.500), vec3(0.190, 0.460, 0.500), vec3(0.760, 0.740, 0.580), vec3(1.000, 0.300, 0.490));\n  } else if (colReg < 3.0){\n    paletteCol = palette(1.0-var,vec3(0.500, 0.940, 0.900), vec3(0.600, 0.640, 0.350), vec3(0.680, 1.020, 0.405), vec3(0.380, 0.440, 0.095));\n  } else if (colReg < 4.0){\n    paletteCol = palette(var,vec3(0.500, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.825, 0.750), vec3(0.500, 0.500, 0.500));\n  } else if (colReg < 5.0){\n    paletteCol = palette(1.0-var,vec3(0.000, 0.580, 0.453), vec3(0.848, 0.703, 0.110), vec3(0.700, 0.175, 0.542), vec3(0.000, 0.182, 0.915));\n  } else if (colReg < 6.0){\n    paletteCol = palette(var,vec3(0.129, 0.359, 0.072), vec3(0.933, 0.561, 0.616), vec3(0.334, 1.013, 0.882), vec3(0.597, 0.050, 0.885));\n  } else if (colReg < 7.0){\n    paletteCol = palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.7191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 8.0){\n    paletteCol = palette(var,  vec3(-0.060, -0.340, 0.100), vec3(0.940, 0.840, 0.713), vec3(0.600, 0.735, 0.2191), vec3(0.500, 0.260, 0.335));\n  } else if (colReg < 9.0){\n    paletteCol = palette(var,vec3(0.000, 0.040, 0.073), vec3(0.000, 0.530, 0.420), vec3(0.485, 0.930, 0.931), vec3(0.400, 0.599, 0.520));\n  } else if (colReg < 10.0){\n    paletteCol = palette(1.0-var,vec3(1.040, 0.180, 0.260), vec3(0.053, 0.775, 0.330), vec3(0.142, 0.523, 0.800), vec3(0.242, 0.887, 0.000));\n  }\n  return paletteCol;\n}\n\nvec4 renderMain () {\n  if (PASSINDEX == 0.0){\n    return firstPass();\n  }\n  else if (PASSINDEX == 1.0){\n    return secondPass();\n  }\n  else if (PASSINDEX == 2.0){\n    vec4 data = texture(secondBuffer, _uv);\n    float colSel = data.r/8.0;\n    if (syn_MediaType > 0.5){\n        colSel = mix(colSel, 1.0-colSel, dot(_loadUserImage().rgb,vec3(1.0))/3.0);\n    }\n\n    if (invert_col >0.5){\n        colSel = 1.0-colSel;\n    }\n\n    float halo = data.a/10.0;\n    vec3 palCol = palette(colSel, vec3(0.500, 0.500, 0.520), vec3(0.500, 0.500, 0.500), vec3(0.780, 0.765, 0.750), vec3(0.360, 0.570, 0.680));\n    palCol = colorPaletteChooser(colRegime, colSel);\n    palCol *= pow(colSel,0.1); //brightness\n    \n    return vec4(palCol+halo, 1.0);\n\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Swarm","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.300000011920929,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"k","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"h","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"j","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.632000029087067,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"c","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.130999997258186,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"s","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"e","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.170000001788139,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"u","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"m","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"ungrouped"}],"CREDIT":"by echophons","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\tapestry_fract_+.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Tapestry Fract +","IMAGES":null,"IMAGE_PATH":"tapestry_fract_+.synScene\\tapestry_fract_+.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"k\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"h\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"j\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.632,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"c\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.131,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"s\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"e\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.17,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"u\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"m\",\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by echophons\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"tapestry_fract_+.png\",\n\t\"TITLE\" : \"Tapestry Fract +\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n// edit of http://glslsandbox.com/e#18752.0\r\n// additional iputs added by Doctor Mojo\r\nuniform vec2 mouse;\r\n\r\nvec3   iResolution = vec3(RENDERSIZE, 1.0);\r\nfloat  iGlobalTime = syn_Time*.25;\r\n\r\nfloat gTime = iGlobalTime*0.5;\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tfloat f = 1.0;\r\n\tfloat g = 1.0;\r\n\tvec2 res = iResolution.xy;\r\n\tvec2 mou = mouse.xy;\r\n\t\r\n\t//if (mouse.x < 0.5)\r\n\t//{\r\n\tmou.x = sin(gTime * e)*sin(gTime * u) * 1. + sin(gTime * m);\r\n\tmou.y = (1.0-cos(gTime * c))*sin(gTime * s)*1.0+cos(gTime * k);\r\n\tmou = (mou+1.0) * res;\r\n\t//}\r\n\tvec2 z = ((-res+2.0 * _xy.xy) / res.y);\r\n\tvec2 p = ((-res+2.0+mou) / res.y) * j;\r\n\tfor( int i = 0; i < 24; i++) \r\n\t{\r\n\t\tfloat d = dot(z,z);\r\n\t\tz = (vec2( z.x, -z.y ) / d) + p * h; \r\n\t\tz.x =  1.0-abs(z.x);\r\n\t\tf = max( f-d, (dot(z-p* syn_BassHits,z-p) ));\r\n\t\tg = min( g*d, sin(dot(z+p,z+p))+1.0);\r\n\t}\r\n\tf = abs(-log(f) / 3.5);\r\n\tg = abs(-log(g) / 8.0);\r\n\tout_FragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Tapestry Fract +","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Turn horizontal segments on or off.","MAX":1,"MIN":0,"NAME":"hori_sg","TYPE":"toggle","UI_GROUP":"tubes"},{"DEFAULT":0,"DESCRIPTION":"Turn vertical segments on or off.","MAX":1,"MIN":0,"NAME":"vert_sg","TYPE":"toggle","UI_GROUP":"tubes"},{"DEFAULT":0,"DESCRIPTION":"Turn diagonal segments on or off.","MAX":1,"MIN":0,"NAME":"diag_sg","TYPE":"toggle","UI_GROUP":"tubes"},{"DEFAULT":1,"DESCRIPTION":"Turn stick segments on or off.","MAX":1,"MIN":0,"NAME":"stick_sg","TYPE":"toggle","UI_GROUP":"tubes"},{"DEFAULT":0,"DESCRIPTION":"Turn sphere segments on or off.","MAX":1,"MIN":0,"NAME":"sphere_sg","TYPE":"toggle","UI_GROUP":"tubes"},{"DEFAULT":1,"DESCRIPTION":"When this is ON, the tubes will bump with drum hits, when OFF, they'll keep a constant thickness.","MAX":1,"MIN":0,"NAME":"auto_thickness","TYPE":"toggle","UI_GROUP":"tubes"},{"DEFAULT":0.25,"DESCRIPTION":"Thickness of the tubes and spheres. Default 25%.","MAX":1,"MIN":0,"NAME":"thickness","TYPE":"slider","UI_GROUP":"tubes"},{"DEFAULT":1,"DESCRIPTION":"0% is fully flat. 100% is high pointed peaks. Default is 25%.","MAX":4,"MIN":0,"NAME":"perturbation","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"floor"},{"DEFAULT":0,"DESCRIPTION":"Floor will automatically change from flat to perturbed slowly as the music energy rises and falls.","MAX":1,"MIN":0,"NAME":"auto_perturb","TYPE":"toggle","UI_GROUP":"floor"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for audio-reactive blinking floor. You'll need to choose a floor color that is non-black as well.","MAX":1,"MIN":0,"NAME":"blinking_floor","TYPE":"toggle","UI_GROUP":"floor"},{"DEFAULT":0,"DESCRIPTION":"ON to make the 3D lighting overblown and sharp.","MAX":0.200000002980232,"MIN":0,"NAME":"overblown","TYPE":"toggle","UI_GROUP":"floor"},{"DEFAULT":0,"DESCRIPTION":"ON make the 3D lighting flat and blurred.","MAX":0.800000011920929,"MIN":0,"NAME":"flat_blurred","TYPE":"toggle","UI_GROUP":"floor"},{"DEFAULT":0,"DESCRIPTION":"ON for a smooth, glossy floor, or OFF for the low-poly triangle floor.","MAX":1,"MIN":0,"NAME":"glossy","TYPE":"toggle","UI_GROUP":"floor"},{"DEFAULT":1,"DESCRIPTION":"How much of the floor the media covers. Default 50%, up to make it small and tiled, down to make it huge.","MAX":2,"MIN":0,"NAME":"media_scale","TYPE":"slider","UI_GROUP":"look"},{"DEFAULT":1.5,"DESCRIPTION":"Defines the scale of the space. Down to zoom in, up to zoom out. Best to just click a new spot, not use smoothly.","MAX":4,"MIN":0,"NAME":"zoom","TYPE":"slider","UI_GROUP":"look"},{"DEFAULT":[1,1,1],"DESCRIPTION":"Color of the pipes.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"pipe_col","TYPE":"color","UI_GROUP":"look"},{"DEFAULT":[0,0,0],"DESCRIPTION":"The color of the floor. Make this non-black to use the blinking floor effect. If you have media selected, this is ignored.","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"floor_col","TYPE":"color","UI_GROUP":"look"},{"DEFAULT":1,"DESCRIPTION":"Turn ON for red/cyan split when the bass hits, or OFF for a constant split controlled by the slider.","MAX":1,"MIN":0,"NAME":"auto_split","TYPE":"toggle","UI_GROUP":"redcyan_split"},{"DEFAULT":0,"DESCRIPTION":"Turn ON to splits the red and cyan color channels, but also keep the unchanged original colors, or OFF for just red/cyan.","MAX":1,"MIN":0,"NAME":"incl_original","TYPE":"toggle","UI_GROUP":"redcyan_split"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for a noisier split efect, or off for the standard split.","MAX":1,"MIN":0,"NAME":"noisy_split","TYPE":"toggle","UI_GROUP":"redcyan_split"},{"DEFAULT":0,"DESCRIPTION":"Default: 0%, meaning split effect is off. Turn up to increase the intensity of the red/cyan split effect.","MAX":2,"MIN":0,"NAME":"split_amt","TYPE":"slider","UI_GROUP":"redcyan_split"}],"CREDIT":"Shane","DESCRIPTION":"A hybrid point-lit, flat-shaded terrain with a mesh structure on it.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\terrain_lattice.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Terrain Lattice","IMAGES":[{"NAME":"image3","PATH":"images/3.jpg"}],"IMAGE_PATH":"terrain_lattice.synScene\\terrain_lattice.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"hori_sg\",\n         \"DESCRIPTION\":\"Turn horizontal segments on or off.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tubes\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"vert_sg\",\n         \"DESCRIPTION\":\"Turn vertical segments on or off.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tubes\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"diag_sg\",\n         \"DESCRIPTION\":\"Turn diagonal segments on or off.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tubes\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"stick_sg\",\n         \"DESCRIPTION\":\"Turn stick segments on or off.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tubes\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"sphere_sg\",\n         \"DESCRIPTION\":\"Turn sphere segments on or off.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tubes\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_thickness\",\n         \"DESCRIPTION\":\"When this is ON, the tubes will bump with drum hits, when OFF, they'll keep a constant thickness.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tubes\"\n      },{\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"thickness\",\n         \"DESCRIPTION\":\"Thickness of the tubes and spheres. Default 25%.\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"tubes\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 4.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"perturbation\",\n         \"TYPE\" : \"slider smooth\",\n         \"DESCRIPTION\":\"0% is fully flat. 100% is high pointed peaks. Default is 25%.\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"floor\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"auto_perturb\",\n         \"DESCRIPTION\":\"Floor will automatically change from flat to perturbed slowly as the music energy rises and falls.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"floor\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"blinking_floor\",\n         \"DESCRIPTION\":\"Turn ON for audio-reactive blinking floor. You'll need to choose a floor color that is non-black as well.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"floor\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.2,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"overblown\",\n         \"TYPE\" : \"toggle\",\n         \"DESCRIPTION\":\"ON to make the 3D lighting overblown and sharp.\",\n         \"UI_GROUP\" : \"floor\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.8,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"flat_blurred\",\n         \"TYPE\" : \"toggle\",\n         \"DESCRIPTION\":\"ON make the 3D lighting flat and blurred.\",\n         \"UI_GROUP\" : \"floor\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"glossy\",\n         \"DESCRIPTION\":\"ON for a smooth, glossy floor, or OFF for the low-poly triangle floor.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"floor\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_scale\",\n         \"TYPE\" : \"slider\",\n         \"DESCRIPTION\":\"How much of the floor the media covers. Default 50%, up to make it small and tiled, down to make it huge.\",\n         \"UI_GROUP\" : \"look\"\n      },{\n         \"DEFAULT\" : 1.5,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 4.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"zoom\",\n         \"DESCRIPTION\":\"Defines the scale of the space. Down to zoom in, up to zoom out. Best to just click a new spot, not use smoothly.\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"look\"\n      },{\n         \"DESCRIPTION\" : \"\",\n         \"NAME\" : \"pipe_col\",\n         \"TYPE\" : \"color\",\n         \"DEF_COLOR\":[1.0,1.0,1.0],\n         \"DESCRIPTION\":\"Color of the pipes.\",\n         \"UI_GROUP\" : \"look\"\n      },{\n         \"DESCRIPTION\" : \"\",\n         \"NAME\" : \"floor_col\",\n         \"TYPE\" : \"color\",\n         \"DEF_COLOR\":[0.0,0.0,0.0],\n         \"DESCRIPTION\":\"The color of the floor. Make this non-black to use the blinking floor effect. If you have media selected, this is ignored.\",\n         \"UI_GROUP\" : \"look\"\n      },{\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_split\",\n         \"DESCRIPTION\":\"Turn ON for red/cyan split when the bass hits, or OFF for a constant split controlled by the slider.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"redcyan_split\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"incl_original\",\n         \"DESCRIPTION\":\"Turn ON to splits the red and cyan color channels, but also keep the unchanged original colors, or OFF for just red/cyan.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"redcyan_split\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"noisy_split\",\n         \"TYPE\" : \"toggle\",\n         \"DESCRIPTION\":\"Turn ON for a noisier split efect, or off for the standard split.\",\n         \"UI_GROUP\" : \"redcyan_split\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 2.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"split_amt\",\n         \"TYPE\" : \"slider\",\n         \"DESCRIPTION\":\"Default: 0%, meaning split effect is off. Turn up to increase the intensity of the red/cyan split effect.\",\n         \"UI_GROUP\" : \"redcyan_split\"\n      }\n   ],\n   \"CREDIT\" : \"Shane\",\n   \"DESCRIPTION\" : \"A hybrid point-lit, flat-shaded terrain with a mesh structure on it.\",\n   \"PASSES\":[{\"TARGET\":\"meshPass\", \"HEIGHT\":432, \"WIDTH\":768}],\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image3\",\n         \"PATH\" : \"images/3.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"terrain_lattice.png\",\n   \"TITLE\" : \"Terrain Lattice\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":432,"TARGET":"meshPass","WIDTH":768}],"SCRIPT_CODE":"","SHADER_CODE":"/*\n\n    Terrain Lattice\n    ---------------\n\n\tThis is a raymarched heightmap subdivided into grid squares, which are each subdivided\n\tinto two triangles to emulate the flat shaded look. It's been done before, so just to \n\tbe different, I put a mesh on top... It seemed like a good idea at the time. :)\n\n    There are two ways to render flat grid squares. One is to linearly interpolate between\n\tthe height values of all four vertices to produce a quad that looks flat on account of\n    its straight edge joins. The other is to split the quad into two triangles and linearly \n\tinterpolate between the three verticies of each of those. I tried both methods, but \n\tliked the look of the genuinely flat-planed triangles more.\n\n    A flat shaded triangle render usually requires a barycentric approach, but since the\n\tgrid triangles are essentially half squares, it's possible to use, vector \n\tperpendicularity, symmetry, etc, to cut down on the calculations considerably.\n\n\tThe extra cycles were used to render the mesh. I originally rendered the diagonal rods \n\talso, but it made things look a little too busy, so I've left them out. Rendering straight \n\tcapsule-like tubes along grid seams can also be expensive, but it was possible to cut \n\tcorners there as well, so to speak.\n\n\tAnyway, this was just a practice run for a more ambitious example I have in mind. By\n\tthe way, I have a simplex grid version as well that I'll put up later.\n    \n\n\tOther examples:\n    \n\t// Simple, and really nicely lit.\n    Triangulator - nimitz\n\thttps://www.shadertoy.com/view/lllGRr   \n\t\n\n\t// Nice example that takes an intuitive vectorized approach.\n\tRay Marched Mesh Terrain - Flyguy\n\thttps://www.shadertoy.com/view/ltjSRD\n\n*/\n\n// Max ray distance.\n#define FAR 40.\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n// Glow on the bars, returned from map function\n// float glow;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Height map values. Just a couple of animated sinusoidal layers, but you could put anything\n// here... so long as it's cheap. :)\nfloat hm(in vec2 p){\n    \n    // Scaling, plus some movement.\n    p = p/2. + syn_Time*0.15/4.;\n    \n    // Layer one.\n    float n = dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.66;\n    p = p*1.5;  // Increase frequency.\n  \n    p.xy = mat2(.866025, .5, -.5, .866025)*p.xy; // Rotate.\n    \n    // Add another layer.\n    n += dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.34;\n    \n    return n; // Range [0, 1]... hopefully. :)\n\n}\n\n// Used to scale the grid without having to move the camera.\nfloat scale = zoom;\nvec3 hVal; // Global variable to hold the three height values for reuse.\n\n// The terrain - tesselated in a flat-grid triangle-pair fashion... Needs rewording. :D\nfloat triTerrain(vec2 p){ \n\n    \n    p *= scale; // Scaling.\n    \n    vec2 ip = floor(p); // Integer value. Used for the unique corner height values.\n    p -= ip; // Fractional grid value.\n \n    \n    if (glossy > 0.5){\n        p *= p*(3.-2.*p); // Weird Gouraud-looking triangles, or smooth quad.\n    }\n     \n    \n    // The barycentric coordinates, so to speak, and the corresponding height value.\n    // For those of you familiar with the process, you may note that there are far \n    // fewer operations than usual.\n   \n    float s = step(1., p.x + p.y); // Determines which side of the diagonal we're on.\n    \n    // Storing the heights at the three triangle vertices. Normally, it wouldn't be\n    // necessary, but we're reusing them to render the mesh.\n    hVal = vec3(hm(ip+s), hm(ip + vec2(1, 0)), hm(ip+vec2(0, 1)));\n    \n    // A simple, interpolated quad. It's not really flat, but the edge-joins are straight,\n    // so it looks that way. Because the mesh is set up on triangle logic, there two\n    // extra height values. Normally, you'd only need one extra.\n    //return mix(mix(hm(ip), hVal.y, p.x), mix(hVal.z, hm(ip+1.), p.x), p.y);\n\n    // Barycentric setup: This is a very trimmed down version of the generalized barycentric\n    // calculations that involve cross-products, and so forth. Without going into detail, I'm\n    // sure you could imagine that three points in space can be used to generate a plane \n    // equation via cross products and such, and the fractional grid points could be used in\n    // unison with the vertice coordinates to determine the exact coordinate on the plane, or\n    // the height value at that coordinate.\n    //\n    // Anyway, the grid triangles are shaped in such a way that a lot of the operations cancel \n    // out, and the lines below are the result. You could just use them. However, if you require\n    // more information, look up a few barycentric coordinate examples.\n    //\n    vec3 b = abs(vec3(1.0 - p.x - p.y, p.x - (p.x - p.y + 1.)*s, p.y - (p.y - p.x + 1.)*s));\n    \n    // The linearly interpolated triangle height.\n    return dot(b, hVal);\n    \n/* \n\n    // Triangulating across the other diagonal. Handy, if you want to make patterns.\n    float s = step(p.x, p.y);\n    hVal = vec3(hm(ip), hm(ip + vec2(1. - s, s)), hm(ip+1.));\n\n    //return mix(mix(hVal.x, hm(ip+vec2(1, 0)), f.x), mix(hm(ip+vec2(0, 1)), hVal.z, f.x),f.y);\n\n    vec3 b = abs(vec3(1. - (1. - s)*p.x - p.y*s, (1.-2.*s)*(p.x - p.y), p.x*s + p.y*(1. - s)));\n    \n    return dot(b, hVal);\n*/\n   \n \n}\n    float thickVar = 2.0*thickness*(1.0+abs(sin(sin(TIME)+_uv.x*2.0+_uv.y*2.0+0.5))*pow(syn_OnBeat,0.5)*auto_thickness);\n\n\n// The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    // float thickVar = thickness+(1.0+thickness*2.0)*abs(sin(sin(TIME)+p.z))*syn_HighHits*auto_thickness;\n\n    \n    float ter = triTerrain(p.xz); // The terrain.\n \n    float hPert = .125*perturbation; // Terrain height perturbation.\n    if (auto_perturb > 0.5){\n        hPert *= syn_Presence;\n    }\n    float fl = p.y  + (.5-ter)*hPert;//*.25; // Adding it to a flat plane.\n\n\n    hVal = hVal*hPert - .025; // Rescaling the height values to match the terrain perturbation.\n    \n    // The grid boundary railings. As usual, the code looks more complicated than it is. Basically, we're\n    // positioning four tubes around the grid boundaries. The Y-value is just a height interpolation\n    // from one vertice to the adjoining one. The \"abs\" business is just a cheap trick to stack the \n    // railings on top of one another without having to render another four tubes. \n    vec3 q = p;\n    q.xz = fract(q.xz*scale); // Break space into squares along the XZ plane.\n        \n    float ln = 1000.0;\n    if(hori_sg>0.5){\n        // Tubes on the left and right boundaries.\n        ln = min(ln, length(vec2(q.x, abs(q.y - hVal.x -(hVal.z - hVal.x)*q.z - .125) -.125)*vec2(1./scale, 1)));\n        ln = min(ln, length(vec2(q.x - 1., abs(q.y - hVal.y - (hVal.x - hVal.y)*q.z - .125) - .125)*vec2(1./scale, 1))); \n    }\n    \n    if(vert_sg>0.5){\n        // Tubes on the bottom and top boundaries.\n        ln = min(ln, length(vec2(abs(q.y - hVal.x - (hVal.y - hVal.x)*q.x - .125) -.125, q.z)*vec2(1, 1./scale)));\n        ln = min(ln, length(vec2(abs(q.y - hVal.z - (hVal.x - hVal.z)*q.x - .125) -.125, q.z - 1.)*vec2(1, 1./scale)));\n    }\n\n    if (diag_sg>0.5){\n        // The diagonal tube lines. Makes things look too busy, but comment them out, if you feel like it.\n        vec2 diag = vec2(q.x + q.z - 1., abs(q.y - hVal.z - (hVal.y - hVal.z)*q.x- .125) -.125);//*.7071;\n        ln = min(ln, length((diag)*vec2(1./scale, 1)));\n    }\n        \n    \n/*    \n    \n    // If you wanted to use the reverse diagonal on the triangulation. See the comments in the \n    // \"triTerrain\" function first.\n    \n    ln =   length(vec2(q.x, abs(q.y - hVal.x - (hVal.y - hVal.x)*q.z - .125) -.125)*vec2(1./scale, 1));\n    ln = min(ln, length(vec2(q.x - 1., abs(q.y - hVal.y - (hVal.z - hVal.y)*q.z - .125) -.125)*vec2(1./scale, 1)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.x - (hVal.y - hVal.x)*q.x - .125) -.125, q.z)*vec2(1, 1./scale)));\n    ln = min(ln, length(vec2(abs(q.y - hVal.y - (hVal.z - hVal.y)*q.x - .125) -.125, q.z - 1.)*vec2(1, 1./scale)));\n\n\n    vec2 diag = vec2(q.x - q.z, abs(q.y - hVal.x - (hVal.z - hVal.x)*q.z- .125) -.125);//*.7071;\n    ln = min(ln, length((diag)*vec2(1./scale, 1)));\n*/         \n   \n    \n    \n    // Vertical column and the balls. We've calculated another height value offset by half the grid in \n    // order to draw just one each - instead of four. It's a little hard to explain why but it has to\n    // do with repetitive cell boundaries.\n    float hgt = hm(floor(p.xz*scale + .5))*hPert - .025;\n    //float hgtZ = hm(floor(p.xz*scale + .5) + vec2(0, 1))*pert - .025;\n    vec2 offXZ = fract(p.xz*scale + .5) - .5;\n    if (stick_sg>0.5){\n        ln = min(ln, max(length(offXZ/scale), abs(q.y - hgt) - .25));\n    }\n\n    // The metallic balls. Stacked two high using the \"abs\" trick.\n    if (sphere_sg>0.5){\n        float sp = length(vec3(offXZ.x, abs(abs(q.y - hgt - .125) - .125), offXZ.y)*vec3(1./scale, 1, 1./scale));\n    \n        // ln -= .04/scale; // Line thickness.\n        sp -= .125*thickVar/scale; // Ball thickness.\n        ln = min(ln, sp);\n    }\n    \n    ln -= 0.04*thickVar/scale; // Line thickness.\n\n \n    // Object ID.\n    objID = step(fl, ln);\n    // if (ln > 0.0035){\n    //     glow += 1/ln;\n    // }\n    \n    // Combining the mesh with the terrain.\n    return min(fl, ln); //smin(fl, ln, .025);\n \n}\n\n \n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.; //fract(sin(dot(rd, vec3(7, 157, 113)))*45758.5453)*.1;\n   \n    for (int i=0; i<48; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d*.83;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 getNormal(in vec3 p, float t)\n{  \n    vec2 e = vec2(-1., 1.)*0.001*min(1. + t, 5.);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\n// vec3 getNormal(in vec3 p, float t) {\n// \tconst vec2 e = vec2(0.002, 0); //vec2(0.002*min(1. + t*.5, 2.), 0);\n// \treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n// }\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 10; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, .5);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.15, 1.0); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += TIME*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c, c*sqrt(c), c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.\n\n}\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n \n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - RENDERSIZE.xy*.5)/RENDERSIZE.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, -.5, TIME + 1.);  // \"Look At\" position.\n    // lk.yz = _rotate(lk.yz, TIME);\n\tvec3 ro = lk + vec3(0, 2.5, -2.); // Camera position, doubling as the ray origin.\n    // ro -= vec3(0.0, 0.0, TIME*(1.5-zoom));\n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, .75, 2);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= r2( path(lk.z).x/128. );\n\n    \n       \n //    // Mouse controls.   \n\t// vec2 ms = vec2(0);\n //    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - RENDERSIZE.xy)/RENDERSIZE.xy;\n //    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n //    mat2 rM = mat2(a, -a.y, a.x);\n //    rd.xz = rd.xz*rM; \n //    a = sin(vec2(1.5707963, 0) - ms.y); \n //    rM = mat2(a, -a.y, a.x);\n //    rd.yz = rd.yz*rM;\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    float svObjID = objID;\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n        // Edge and edge-factor.\n        //float edge, crv = 1., ef = 4.; // Curvature variable not used.\n        \n        // Texture scale factor.\n        float tSize0 = pow(media_scale,2.0)*0.125;\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t)*(1.0+overblown-flat_blurred);\n        \n        // Texture-based bump mapping. I've left it out for this.\n        // if(svObjID>0.5) sn = texBump(image3, sp*tSize0, sn, .003);\n\t    \n        \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(0.0);   \n\n        \n        if(svObjID>0.5) { // Terrain texturing.\n            texCol = vec3(floor_col);\n            if (syn_MediaType>0.5){\n                texCol = tex3D(syn_UserImage, sp*tSize0, sn);\n            }\n\n            //texCol = texture(image3, sp.xz*tSize0).xyz;\n            //texCol *= texCol;\n            texCol = smoothstep(0.0, .5, texCol);//*vec3(1, .9, .8);//\n            //texCol *= triTerrain(sp.xz)*.25 + .75; // Adds more definition to the squares.\n \n            // Color some of the squares brown.\n            // if(mod(dot(floor(sp.xz*scale), vec2(1, -1)), 5.)>=2.) texCol *= vec3(1, .5, .25);\n            \n                        \n            \n            // Blinking lights. Too much, I think.\n            if (blinking_floor > 0.5){\n                float rnd = fract(sin(dot(floor(sp.xz*scale), vec2(141.13, 289.97)))*43758.5453);\n                rnd = sin(rnd*6.283 + syn_BeatTime)*.5 + .5;\n                if(rnd>0.7){\n                    texCol *= 1.0;\n                } else { \n                    texCol *= 0.0;  \n                }\n            }\n            // texCol *= mix(vec3(2.), vec3(1, .5, .25), rnd); // Alternative: Random mix.\n\n            \n        }\n        else { // The chrome lattice.\n            // texCol += pow(glow*0.001,glow_amt*5.0);\n            texCol = vec3(pipe_col);\n            if (syn_MediaType > 0.5){\n                texCol = tex3D(syn_UserImage, sp*tSize0, sn);\n            }\n\n        }\n        // texCol += pow(glow*0.001,5.0)*glow_amt;\n\n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp-sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, 8.);\n    \t// float ao = cAO(sp, sn); // Ambient occlusion.\n\t    // ao = 1.0;\n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.)*2.0; \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*2.;\n        if(svObjID>.5) { // Lowering the terrain settings a bit.\n            env *= .25;\n            spec *= .5;            \n            fre *= .5;\n        }\n        \n\n        // Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff + 0.25 + vec3(1, .9, .7)*fre) + env + vec3(1, .95, .8)*spec);\n        \n\n        // Shading.\n        sceneCol *= atten*sh;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    // the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(.6, .5, 1), vec3(.025, .05, .1), clamp(rd.y + .75, 0., 1.));//vec3(1, .9, .8);//\n    sceneCol = mix(sceneCol, bg, smoothstep(0., .95, t/FAR));\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t} else if (PASSINDEX == 1){\n        vec3 colC = texture(meshPass, _uv).rgb;\n        vec3 finalCol = colC;\n        float splitAmt = 0.025*pow(split_amt,2.0);\n        if (auto_split > 0.5){\n            splitAmt *= pow(syn_BassLevel,3.0)*0.5;\n        } else {\n            splitAmt *= 0.5;\n        }\n        float posMod = mix(1.0, _rand(_pixelate(_uv.y, 500.0)*137)*1.0, noisy_split)*splitAmt;\n        vec3 colU = texture(meshPass, _uv-posMod).rgb;\n        vec3 colD = texture(meshPass, _uv+posMod).rgb;\n        vec3 cyan = vec3(0.0, 1.0, 1.0);\n        vec3 red =  vec3(1.0, 0.0, 0.0);\n\n        finalCol = colC*incl_original*0.6 + colU*cyan + colD*red;\n\n        return vec4(finalCol,1.0);\n    }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Terrain Lattice","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"Keijiro Takahashi","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\test_card.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Test Card","IMAGES":null,"IMAGE_PATH":"test_card.synScene\\test_card.png","JSON_CODE":"{\n  \"TITLE\": \"Test Card\",\n  \"DESCRIPTION\": \"\",\n  \"IMAGE_PATH\": \"test_card.png\",\n  \"CREDIT\": \"Keijiro Takahashi\"\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec2 resolution = RENDERSIZE;\nvec4 fragColor = vec4(0.0);\n\nfloat saturate(float x) { return clamp(x, 0, 1); }\nvec3 saturate(vec3 x) { return clamp(x, 0, 1); }\n\nvec3 hue2rgb(float h)\n{\n    h = fract(saturate(h)) * 6 - 2;\n    return saturate(vec3(abs(h - 1) - 1, 2 - abs(h), 2 - abs(h - 2)));\n}\n\nvec4 renderMain(void)\n{\n    float scale = 27.0 / resolution.y;                             // grid scale\n    vec2 area = vec2(floor(13 / resolution.y * resolution.x), 13); // size of inner area\n\n    vec2 p0 = gl_FragCoord.xy - resolution / 2; // position (pixel)\n    vec2 p1 = p0 * scale;                       // position (grid)\n\n    // gray background with crosshair\n    float c1 = 1 - step(2, min(abs(p0.x), abs(p0.y))) * 0.5;\n\n    // grid lines\n    vec2 grid = step(scale, abs(0.5 - fract(p1 * 0.5)));\n    c1 = saturate(c1 + 2 - grid.x - grid.y);\n\n    // outer area checker\n    vec2 checker = step(0.49999, fract(floor(p1 * 0.5 + 0.5) * 0.5));\n    if (any(greaterThan(abs(p1), area))) c1 = abs(checker.x - checker.y);\n\n    float corner = sqrt(8) - length(abs(p1) - area + 4); // corner circles\n    float circle = 12 - length(p1);                      // big center circle\n    float mask = saturate(circle / scale);               // center circls mask\n\n    // grayscale bars\n    float bar1 = saturate(p1.y < 5 ? floor(p1.x / 4 + 3) / 5 : p1.x / 16 + 0.5);\n    c1 = mix(c1, bar1, mask * saturate(ceil(4 - abs(5 - p1.y))));\n\n    // basic color bars\n    vec3 bar2 = hue2rgb((p1.y > -5 ? floor(p1.x / 4) / 6 : p1.x / 16) + 0.5);\n    vec3 c2 = mix(vec3(c1), bar2, mask * saturate(ceil(4 - abs(-5 - p1.y))));\n\n    // big circle line\n    c2 = mix(c2, vec3(1), saturate(2 - abs(max(circle, corner)) / scale));\n\n    fragColor = vec4(c2, 1);\n    corner *= 0.5;\n    if ((_uv.x < 0.5)&&(_uv.y > 0.5)){\n        fragColor += (step(1.0-syn_BassLevel, corner)-step(1.2-syn_BassLevel, corner));\n    } else if ((_uv.x < 0.5)&&(_uv.y < 0.5)){\n        fragColor += (step(1.0-syn_HighLevel, corner)-step(1.2-syn_HighLevel, corner));\n    }\n    else if ((_uv.x > 0.5)&&(_uv.y < 0.5)){\n        fragColor += (step(1.0-syn_Presence, corner)-step(1.2-syn_Presence, corner));\n    } \n    else if ((_uv.x > 0.5)&&(_uv.y > 0.5)){\n        fragColor += (step(1.0-syn_BPMTri2, corner)-step(1.2-syn_BPMTri2, corner));\n    }\n\n    return fragColor;\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Test Card","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"up for more media, down for more feedback","MAX":1.10000002384186,"MIN":0,"NAME":"THRESHOLD","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback threshold"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"volume increases threshold","MAX":1,"MIN":0,"NAME":"threshold_vol","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback threshold"},{"DEFAULT":[0.800000011920929,0.100000001490116,0.100000001490116],"DESCRIPTION":"this color will be the middle of the threshold range","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"keep_color","TYPE":"color","UI_GROUP":"feedback threshold"},{"DEFAULT":0,"DESCRIPTION":"randomize color","MAX":1,"MIN":0,"NAME":"random_keep_color","TYPE":"toggle","UI_GROUP":"feedback threshold"},{"DEFAULT":0.00400000018998981,"DESCRIPTION":"tone effects movements","MAX":0.00999999977648258,"MIN":0,"NAME":"tone_movement","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback motion"},{"DEFAULT":0.00300000002607703,"DESCRIPTION":"zoom on the beat","MAX":0.0199999995529652,"MIN":0,"NAME":"zoom_to_volume","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback motion"},{"DEFAULT":0,"DESCRIPTION":"introduces literal glitches. great for prolonged feedback","MAX":1,"MIN":0,"NAME":"bufferglitch","TYPE":"toggle","UI_GROUP":"feedback motion"},{"DEFAULT":0,"DESCRIPTION":"brightness/value adjustment","MAX":0.0020000000949949,"MIN":-0.0020000000949949,"NAME":"bright_adjust","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback hsv"},{"DEFAULT":0.00499999988824129,"DESCRIPTION":"hue adjustment","MAX":0.0299999993294477,"MIN":0.00100000004749745,"NAME":"color_spin","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback hsv"},{"DEFAULT":0,"DESCRIPTION":"saturation adjustment","MAX":0.0020000000949949,"MIN":-0.0020000000949949,"NAME":"saturate_adjust","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback hsv"},{"DEFAULT":0,"DESCRIPTION":"adjusts brightness based on current keep color. may strobe wildly","MAX":1,"MIN":0,"NAME":"bright_adjust_auto","TYPE":"toggle","UI_GROUP":"feedback hsv"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"palletize_after","TYPE":"toggle","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"palletize_before","TYPE":"toggle","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"random","MAX":1,"MIN":0,"NAME":"random_palette","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"audioreactive 1. DEFAULT","MAX":1,"MIN":0,"NAME":"palette1","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"audioreactive 2","MAX":1,"MIN":0,"NAME":"palette2","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"+","MAX":1,"MIN":0,"NAME":"palette3","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"color bands","MAX":1,"MIN":0,"NAME":"palette4","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"rainbow blast. requires sound","MAX":1,"MIN":0,"NAME":"palette5","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"snags a single frame of media or videosynth","MAX":1,"MIN":0,"NAME":"get_frame","TYPE":"bang","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"plays incoming media or videosynth","MAX":1,"MIN":0,"NAME":"play_media","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"snags frames on the beat","MAX":1,"MIN":0,"NAME":"auto_get_frame","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0.25,"DESCRIPTION":"scale of video synth","MAX":1,"MIN":0,"NAME":"synthScale","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"videosynth"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"scales the videosynths RGB channels","MAX":1,"MIN":0,"NAME":"synthMacro","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"videosynth"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"synth speed","MAX":1,"MIN":0,"NAME":"synthSpeed","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"videosynth"}],"CREDIT":"Kyle Grover","DESCRIPTION":"Behold the threshold on hold","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\thresholder.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"movementDir","VALUES":[-1,1]}],"HEIGHT":1080,"ID":"Thresholder","IMAGES":null,"IMAGE_PATH":"thresholder.synScene\\thresholder.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"up for more media, down for more feedback\",\n         \"MAX\" : 1.1,\n         \"MIN\" : 0,\n         \"NAME\" : \"THRESHOLD\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback threshold\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"volume increases threshold\",\n         \"NAME\" : \"threshold_vol\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback threshold\"\n      },{\n         \"DEF_COLOR\" : [ 0.8, 0.1, 0.1 ],\n         \"DESCRIPTION\" : \"this color will be the middle of the threshold range\",\n         \"NAME\" : \"keep_color\",\n         \"TYPE\" : \"color\",\n         \"UI_GROUP\" : \"feedback threshold\"\n      },\n      {\n         \"DESCRIPTION\" : \"randomize color\",\n         \"NAME\" : \"random_keep_color\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"feedback threshold\"\n      },\n      {\n         \"DEFAULT\" : 0.004,\n         \"DESCRIPTION\" : \"tone effects movements\",\n         \"MAX\" : 0.01,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"tone_movement\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback motion\"\n      },{\n         \"DEFAULT\" : 0.003,\n         \"DESCRIPTION\" : \"zoom on the beat\",\n         \"MAX\" : 0.02,\n         \"MIN\" : 0,\n         \"NAME\" : \"zoom_to_volume\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback motion\"\n      },\n      {\n         \"DESCRIPTION\" : \"introduces literal glitches. great for prolonged feedback\",\n         \"NAME\" : \"bufferglitch\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"feedback motion\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"brightness/value adjustment\",\n         \"MAX\" : 0.002,\n         \"MIN\" : -0.002,\n         \"NAME\" : \"bright_adjust\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback hsv\"\n      },\n      {\n         \"DEFAULT\" : 0.005,\n         \"DESCRIPTION\" : \"hue adjustment\",\n         \"MAX\" : 0.03,\n         \"MIN\" : 0.001,\n         \"NAME\" : \"color_spin\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback hsv\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"saturation adjustment\",\n         \"MAX\" : 0.002,\n         \"MIN\" : -0.002,\n         \"NAME\" : \"saturate_adjust\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback hsv\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"adjusts brightness based on current keep color. may strobe wildly\",\n         \"NAME\" : \"bright_adjust_auto\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"feedback hsv\"\n      },{\n         \"NAME\": \"palletize_after\",\n         \"TYPE\": \"toggle\",\n         \"DEFAULT\": 1.0,\n         \"UI_GROUP\" : \"palettes\"\n      },{\n         \"NAME\": \"palletize_before\",\n         \"TYPE\": \"toggle\",\n         \"UI_GROUP\" : \"palettes\"\n      },{\n         \"NAME\" : \"random_palette\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"palettes\",\n         \"DESCRIPTION\" : \"random\"\n      },{\n         \"NAME\" : \"palette1\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"palettes\",\n         \"DESCRIPTION\" : \"audioreactive 1. DEFAULT\"\n      },{\n         \"NAME\" : \"palette2\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"palettes\",\n         \"DESCRIPTION\" : \"audioreactive 2\"\n      },{\n         \"NAME\" : \"palette3\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"palettes\",\n         \"DESCRIPTION\" : \"+\"\n      },{\n         \"NAME\" : \"palette4\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"palettes\",\n         \"DESCRIPTION\" : \"color bands\"\n      },{\n         \"NAME\" : \"palette5\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"palettes\",\n         \"DESCRIPTION\" : \"rainbow blast. requires sound\"\n      },{\n         \"DESCRIPTION\" : \"snags a single frame of media or videosynth\",\n         \"NAME\" : \"get_frame\",\n         \"TYPE\" : \"bang\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"plays incoming media or videosynth\",\n         \"NAME\" : \"play_media\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"snags frames on the beat\",\n         \"NAME\" : \"auto_get_frame\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0.25,\n         \"DESCRIPTION\" : \"scale of video synth\",\n         \"NAME\" : \"synthScale\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"videosynth\"\n      },\n      {\n         \"DEFAULT\" : 0.4,\n         \"DESCRIPTION\" : \"scales the videosynths RGB channels\",\n         \"NAME\" : \"synthMacro\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"videosynth\"\n      },\n      {\n         \"DEFAULT\" : 0.1,\n         \"DESCRIPTION\" : \"synth speed\",\n         \"NAME\" : \"synthSpeed\",\n         \"PARAMS\" : 0.1,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"videosynth\"\n      }\n   ],\n   \"HARD_TRANSITIONS\":[{\"UNIFORM\":\"movementDir\", \"VALUES\":[-1.0,1.0]}],\n   \"TITLE\" : \"Thresholder\",\n   \"CREDIT\" : \"Kyle Grover\",\n   \"DESCRIPTION\" : \"Behold the threshold on hold\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"fkry\",\n         \"WIDTH\" : 1920\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"buffA\",\n         \"WIDTH\" : 1920\n      }\n   ],\n   \"HEIGHT\" : 1080,\n   \"WIDTH\" : 1920,\n   \"IMAGE_PATH\" : \"thresholder.png\"\n}","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"fkry","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"buffA","WIDTH":1920}],"SCRIPT_CODE":"function SynthTime() {\n    this.x = Math.random() * 10000;\n    this.y = Math.random() * 10000;\n    this.z = Math.random() * 10000;\n}\nSynthTime.prototype.tick = function() {\n    noiseTime = {\n        r: Math.sin(inputs.synthMacro * 15.01), \n        g: Math.sin(inputs.synthMacro * 11.54), \n        b: Math.sin(inputs.synthMacro * 6.02)\n    };\n    noiseTimeExp = {\n        r: noiseTime.r * noiseTime.r * noiseTime.r * 5,\n        g: noiseTime.g * noiseTime.g * noiseTime.g * 5,\n        b: noiseTime.b * noiseTime.b * noiseTime.b * 5\n    }\n    synthTimeDelta = {\n        r: inputs.syn_HighLevel * noiseTimeExp.b * inputs.synthScale * inputs.synthSpeed,\n        g: inputs.syn_MidLevel * noiseTimeExp.b * inputs.synthScale * inputs.synthSpeed,\n        b: inputs.syn_BassLevel * noiseTimeExp.b * inputs.synthScale * inputs.synthSpeed\n    };\n    this.x += synthTimeDelta.r;\n    this.y += synthTimeDelta.g;\n    this.z += synthTimeDelta.b;\n}\n\nfunction Freezes() {\n    this.hits = [];\n}\nFreezes.prototype.addhit = function() {\n    this.hits.push(1);\n}\nFreezes.prototype.tick = function() {\n    for (var index = 0; index < this.hits.length; index++) {\n        this.hits[index] -= 0.01;\n        if (this.hits[index] < 0.01) this.hits.splice(index,1);        \n    }\n}\n\nvar synthTime = new SynthTime();\nuniforms.synthTime = synthTime;\nvar freezes = new Freezes();\nuniforms.freezes = freezes\nuniforms.randomR = Math.random();\nuniforms.randomG = Math.random();\nuniforms.randomB = Math.random();\n\n\nuniforms.current_pallete = 1;\nfunction randomizeAllColors() {\n    uniforms.randomR1 = Math.random();\n    uniforms.randomG1 = Math.random();\n    uniforms.randomB1 = Math.random();        \n    uniforms.randomR2 = Math.random();\n    uniforms.randomG2 = Math.random();\n    uniforms.randomB2 = Math.random();        \n    uniforms.randomR3 = Math.random();\n    uniforms.randomG3 = Math.random();\n    uniforms.randomB3 = Math.random();        \n    uniforms.randomR4 = Math.random();\n    uniforms.randomG4 = Math.random();\n    uniforms.randomB4 = Math.random();\n}\nrandomizeAllColors();\n\n\nfunction update(data) {\n    synthTime.tick();\n    if (inputs.syn_Hits > 0.9) {\n        uniforms.randomR = Math.random();\n        uniforms.randomG = Math.random();\n        uniforms.randomB = Math.random();\n    }\n    freezes.addhit();\n    freezes.tick();\n    \n    if (inputs.random_palette > 0.5) {\n        randomizeAllColors();\n        uniforms.current_pallete = 0;\n    }\n    if (inputs.palette1 > 0.5) uniforms.current_pallete = 1;\n    if (inputs.palette2 > 0.5) uniforms.current_pallete = 2;\n    if (inputs.palette3 > 0.5) uniforms.current_pallete = 3;\n    if (inputs.palette4 > 0.5) uniforms.current_pallete = 4;\n    if (inputs.palette5 > 0.5) uniforms.current_pallete = 5;\n}","SHADER_CODE":"const float twopies = 6.28318530718;\n//helper functions\nvec3 hsv_2_rgb( in vec3 c ){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb_2_hsv( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nfloat plot(vec2 st, float pct, float width){\n  return  smoothstep( pct-width, pct, st.x) -\n          smoothstep( pct, pct+width, st.x);\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec4 defaultSynth(in vec2 fragCoord ) {    \n    vec2 synthuv = _uv - 0.5;\n    synthuv *= (0.02 + (synthScale * synthScale * 8));\n\n    vec2 noisescaleR = vec2(\n        sin(synthMacro * 12.015), \n        sin(synthMacro * 12.522)\n    ) * 10.0;\n    vec2 noisescaleG = vec2(\n        sin(synthMacro * 13.04), \n        sin(synthMacro * 13.3)\n    ) * 10.0;\n    vec2 noisescaleB = vec2(\n        sin(synthMacro * 14.08), \n        sin(synthMacro * 14.55)\n    ) * 10.0; \n\n    vec3 synthTimeNow = synthTime;\n    float noiser = cnoise( vec3(\n        synthuv.x * noisescaleR.x, \n        synthuv.y * noisescaleR.y, \n        synthTimeNow.r\n    ));\n    float noiseg = cnoise( vec3(\n        synthuv.x * noisescaleG.x, \n        synthuv.y * noisescaleG.y, \n        synthTimeNow.g\n    ));\n    float noiseb = cnoise( vec3(\n        synthuv.x * noisescaleB.x, \n        synthuv.y * noisescaleB.y, \n        synthTimeNow.b\n    ));\n    vec3 noisecol = vec3(noiser, noiseg, noiseb);\n    vec3 noisecolhsv = rgb_2_hsv(noisecol);\n    noisecolhsv.r = sin(noisecol.r * 3);\n    noisecolhsv.g = sin(noisecol.g * 4);\n    noisecolhsv.b = sin(noisecol.b * 5);\n    noisecol = hsv_2_rgb(noisecolhsv);\n    // shuffle values and do some sin or mod stuff\n    noisecol = vec3( \n        sin(noisecol.r * noisecol.g / noisecol.b) * noiser,\n        (noisecol.g * noisecol.b / noisecol.r) * noiseg,\n        mod(noisecol.b * noisecol.r / noisecol.g, 1.0) * noiseb\n    );\n    // switch to hsv to rotate color based on some sound variable\n    noisecol = rgb_2_hsv(noisecol);\n    noisecol.r += syn_BPMSin4 + 0.5 - syn_BassHits;\n    noisecol = hsv_2_rgb(noisecol);\n    return vec4(noisecol.r,noisecol.g,noisecol.b,1.0);\n}\n\nbool getthreshold(in vec4 userimage) {\n    // escape conditions first\n    if (userimage.a < 0.2) { return false;}\n \n    // color similarity threshold \n    float threshold_factor = THRESHOLD + ((threshold_vol * syn_BassLevel + threshold_vol * syn_MidHighLevel) / 2.0);\n    vec3 color_to_keep = keep_color;\n    if (random_keep_color > 0.5) {\n        color_to_keep = vec3(randomR, randomG, randomB); // get randomizing color from javascript\n    }\n    if (abs(userimage.r - color_to_keep.r) < threshold_factor &&\n        abs(userimage.g - color_to_keep.g) < threshold_factor &&\n        abs(userimage.b - color_to_keep.b) < threshold_factor) {\n            return true;\n    }\n    return false;\n}\n\nvec3 palette( in float brightness, in vec3 bias, in vec3 amp, in vec3 freq, in vec3 phase ) {\n    return bias + amp*cos( twopies*(freq*brightness+phase) );\n}\n\n\nvec3 palletize(inout vec3 color) {\n  float grayscale = color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\n  if (current_pallete == 0) color = palette(grayscale, vec3(randomR1-0.5, randomG1-0.5, randomB1-0.5),vec3(randomR2 * 2.0, randomG2 * 2.0, randomB2 * 2.0),vec3(randomR3, randomG3, randomB3),vec3(randomR4, randomG4, randomB4) );\n  if (current_pallete == 1) color = palette(grayscale, \n    vec3(0.5),vec3(0.5),vec3(1.0,1.0,1.0),vec3( abs(_uv.x - 0.5) * sin(syn_Time * TIME * 0.001) - abs(_uv.y - 0.5) * sin(syn_BassTime * TIME * 0.001),mod(syn_Time / 100.0 + TIME / 600.0, 1.0),sin(syn_Time / 200.0 + TIME / 900.0)) );\n  if (current_pallete == 2) color = palette(grayscale, \n    vec3(0.5),vec3(0.5),vec3(sin(syn_BassTime * 0.01) + 1.0,sin(syn_MidTime * 0.01) + 1.0,sin(syn_HighTime * 0.01) + 1.0),vec3(TIME * 0.01) );\n  if (current_pallete == 3) color = palette(mod(grayscale * 4.0 * abs(_uv.x - 0.5) * abs(_uv.y - 0.5), 1.0), \n    vec3(mod(TIME * 0.0001, 1.0)),vec3(mod(TIME * -0.0001, 1.0)),vec3(1.0,1.0,0.5),vec3(\n        syn_BassLevel * 3.0,\n        syn_MidHighLevel * 3.0, \n        syn_HighPresence * 3.0 ) );\n  if (current_pallete == 4) color = palette(grayscale, \n    vec3(1.0),vec3(1.0),vec3(_uv.x * 10.0, _uv.y, 20.0),vec3( _uv.x + TIME * 0.1 * (100.0 / syn_BassTime) ) );\n  if (current_pallete == 5) color = palette(grayscale, \n    vec3(0.5),vec3(0.5),vec3(11.1 + syn_HighLevel / 5.0, 11.2, 11.3 + syn_BassLevel / 5.0),vec3(TIME) );\n  return color;\n}\n// pass 0, generate image and save to buffer\nvoid bufferImage1( out vec4 fragColor, in vec2 fragCoord ){\n    // load user image at the start, we'll need it later\n    vec3 oldcolors = texture(buffA,_uv).rgb;\n    // offset for bump to beat\n    _uv = _uv;\n    // bump to beat\n    _uv = ( ( _uv - 0.5 ) / ( 1.0 + (syn_MidLevel * zoom_to_volume) ) + 0.5 );\n    // tone movement\n    oldcolors = rgb_2_hsv(oldcolors);\n    oldcolors.r += TIME / 100.0;\n    oldcolors = hsv_2_rgb(oldcolors);\n    _uv.x += oldcolors.r * 0.005 + (syn_BassPresence * tone_movement*movementDir);\n    _uv.y += oldcolors.g * 0.005 + (syn_Presence * tone_movement*movementDir);\n    _uv -= oldcolors.b * 0.005 + (syn_MidHighPresence * tone_movement*movementDir);\n    vec3 colors = texture(buffA,_uv).rgb;\n    vec3 hsv_colors = rgb_2_hsv(colors);\n    hsv_colors.r += color_spin;\n    hsv_colors.g += saturate_adjust * 2.0;\n    if (bright_adjust_auto > 0.5) {\n        hsv_colors.b += 1.0 - rgb_2_hsv(keep_color).b * 0.05;\n    } else {\n        hsv_colors.b += bright_adjust * 2.0;\n    }\n    colors = hsv_2_rgb(hsv_colors);\n    if (palletize_before > 0.5) colors = palletize(colors);\n    fragColor = vec4(colors,1.0);\n}\nvec4 mainpass(in vec2 _uv) {    \n    vec4 fragColor;\n    // should we snag this frame?\n    bool snagthisframe = false;\n    if (get_frame > 0.5) snagthisframe = true;\n    if (play_media > 0.5) snagthisframe = true;\n    if (auto_get_frame > 0.5 && syn_Hits > 0.8) snagthisframe = true;\n    if (auto_get_frame > 0.5 && play_media > 0.5 && syn_Hits < 0.8) snagthisframe = false;\n    if (snagthisframe) {\n        if (_exists(syn_UserImage)) { // check if user has media available\n            fragColor = _loadUserImage();\n        } else {\n            fragColor = defaultSynth(_xy);\n        }\n        if ( !getthreshold(fragColor)) bufferImage1(fragColor, _xy);\n    } else {\n        bufferImage1(fragColor, _xy);\n    }\n    return fragColor; \n}\n// framework / main loop\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){ \n      if (bufferglitch > 0.5) {\n        return texture(fkry,_uv);\n      } else {\n        return mainpass(_uv);\n      } \n  } else if (PASSINDEX == 1.0){ // store buffer for feedback\n      if (bufferglitch > 0.5) {\n        return mainpass(_uv);\n      } else {\n        return texture(fkry,_uv);\n      } \n  } else if (PASSINDEX == 2.0){ // another pass for final tweaks\n    //output\n    vec4 color4 = texture(buffA,_uv);\n    vec3 color = vec3(color4.r, color4.g, color4.b); \n    if (palletize_after > 0.5) color = palletize(color);\n    return vec4(vec3(color),1.0);\n  }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Thresholder","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"up for more media, down for more feedback","MAX":1.10000002384186,"MIN":0,"NAME":"THRESHOLD","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback threshold"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"volume increases threshold","MAX":1,"MIN":0,"NAME":"threshold_vol","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback threshold"},{"DEFAULT":[0.800000011920929,0.100000001490116,0.100000001490116],"DESCRIPTION":"this color will be the middle of the threshold range","MAX":[1,1,1],"MIN":[0,0,0],"NAME":"keep_color","TYPE":"color","UI_GROUP":"feedback threshold"},{"DEFAULT":0,"DESCRIPTION":"randomize color","MAX":1,"MIN":0,"NAME":"random_keep_color","TYPE":"toggle","UI_GROUP":"feedback threshold"},{"DEFAULT":0.00400000018998981,"DESCRIPTION":"tone effects movements","MAX":0.00999999977648258,"MIN":0,"NAME":"tone_movement","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback motion"},{"DEFAULT":0.00300000002607703,"DESCRIPTION":"zoom on the beat","MAX":0.0199999995529652,"MIN":0,"NAME":"zoom_to_volume","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback motion"},{"DEFAULT":0,"DESCRIPTION":"introduces literal glitches. great for prolonged feedback","MAX":1,"MIN":0,"NAME":"bufferglitch","TYPE":"toggle","UI_GROUP":"feedback motion"},{"DEFAULT":0,"DESCRIPTION":"brightness/value adjustment","MAX":0.0020000000949949,"MIN":-0.0020000000949949,"NAME":"bright_adjust","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback hsv"},{"DEFAULT":0.00499999988824129,"DESCRIPTION":"hue adjustment","MAX":0.0299999993294477,"MIN":0.00100000004749745,"NAME":"color_spin","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback hsv"},{"DEFAULT":0,"DESCRIPTION":"saturation adjustment","MAX":0.0020000000949949,"MIN":-0.0020000000949949,"NAME":"saturate_adjust","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"feedback hsv"},{"DEFAULT":0,"DESCRIPTION":"adjusts brightness based on current keep color. may strobe wildly","MAX":1,"MIN":0,"NAME":"bright_adjust_auto","TYPE":"toggle","UI_GROUP":"feedback hsv"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"palletize_after","TYPE":"toggle","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"palletize_before","TYPE":"toggle","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"random","MAX":1,"MIN":0,"NAME":"random_palette","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"audioreactive 1. DEFAULT","MAX":1,"MIN":0,"NAME":"palette1","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"audioreactive 2","MAX":1,"MIN":0,"NAME":"palette2","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"+","MAX":1,"MIN":0,"NAME":"palette3","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"color bands","MAX":1,"MIN":0,"NAME":"palette4","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"rainbow blast. requires sound","MAX":1,"MIN":0,"NAME":"palette5","TYPE":"bang","UI_GROUP":"palettes"},{"DEFAULT":0,"DESCRIPTION":"snags a single frame of media or videosynth","MAX":1,"MIN":0,"NAME":"get_frame","TYPE":"bang","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"plays incoming media or videosynth","MAX":1,"MIN":0,"NAME":"play_media","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"snags frames on the beat","MAX":1,"MIN":0,"NAME":"auto_get_frame","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0.25,"DESCRIPTION":"scale of video synth","MAX":1,"MIN":0,"NAME":"synthScale","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"videosynth"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"scales the videosynths RGB channels","MAX":1,"MIN":0,"NAME":"synthMacro","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"videosynth"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"synth speed","MAX":1,"MIN":0,"NAME":"synthSpeed","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"videosynth"}],"CREDIT":"Kyle Grover","DESCRIPTION":"Behold the threshold on hold","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\thresholder_dup.synScene","GPU":0,"HARD_TRANSITIONS":[{"UNIFORM":"movementDir","VALUES":[-1,1]}],"HEIGHT":1080,"ID":"Thresholder_dup","IMAGES":null,"IMAGE_PATH":"thresholder_dup.synScene\\thresholder_dup.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"up for more media, down for more feedback\",\n\t\t\t\"MAX\" : 1.1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"THRESHOLD\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback threshold\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.2,\n\t\t\t\"DESCRIPTION\" : \"volume increases threshold\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"threshold_vol\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback threshold\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.8,\n\t\t\t\t0.1,\n\t\t\t\t0.1\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"this color will be the middle of the threshold range\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"keep_color\",\n\t\t\t\"TYPE\" : \"color\",\n\t\t\t\"UI_GROUP\" : \"feedback threshold\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"randomize color\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"random_keep_color\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"feedback threshold\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.004,\n\t\t\t\"DESCRIPTION\" : \"tone effects movements\",\n\t\t\t\"MAX\" : 0.01,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"tone_movement\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback motion\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.003,\n\t\t\t\"DESCRIPTION\" : \"zoom on the beat\",\n\t\t\t\"MAX\" : 0.02,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"zoom_to_volume\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback motion\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"introduces literal glitches. great for prolonged feedback\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"bufferglitch\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"feedback motion\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"brightness/value adjustment\",\n\t\t\t\"MAX\" : 0.002,\n\t\t\t\"MIN\" : -0.002,\n\t\t\t\"NAME\" : \"bright_adjust\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback hsv\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.005,\n\t\t\t\"DESCRIPTION\" : \"hue adjustment\",\n\t\t\t\"MAX\" : 0.03,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"color_spin\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback hsv\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"saturation adjustment\",\n\t\t\t\"MAX\" : 0.002,\n\t\t\t\"MIN\" : -0.002,\n\t\t\t\"NAME\" : \"saturate_adjust\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback hsv\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"adjusts brightness based on current keep color. may strobe wildly\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"bright_adjust_auto\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"feedback hsv\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palletize_after\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palletize_before\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"random\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"random_palette\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"audioreactive 1. DEFAULT\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palette1\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"audioreactive 2\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palette2\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"+\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palette3\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"color bands\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palette4\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"rainbow blast. requires sound\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"palette5\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"palettes\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"snags a single frame of media or videosynth\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"get_frame\",\n\t\t\t\"TYPE\" : \"bang\",\n\t\t\t\"UI_GROUP\" : \"media\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"plays incoming media or videosynth\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"play_media\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"media\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"snags frames on the beat\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"auto_get_frame\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"media\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.25,\n\t\t\t\"DESCRIPTION\" : \"scale of video synth\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"synthScale\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"videosynth\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.4,\n\t\t\t\"DESCRIPTION\" : \"scales the videosynths RGB channels\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"synthMacro\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"videosynth\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.1,\n\t\t\t\"DESCRIPTION\" : \"synth speed\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"synthSpeed\",\n\t\t\t\"PARAMS\" : 0.1,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"videosynth\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"Kyle Grover\",\n\t\"DESCRIPTION\" : \"Behold the threshold on hold\",\n\t\"GPU\" : 0,\n\t\"HARD_TRANSITIONS\" : \n\t[\n\t\t{\n\t\t\t\"UNIFORM\" : \"movementDir\",\n\t\t\t\"VALUES\" : \n\t\t\t[\n\t\t\t\t-1,\n\t\t\t\t1\n\t\t\t]\n\t\t}\n\t],\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"thresholder_dup.png\",\n\t\"PASSES\" : \n\t[\n\t\t{\n\t\t\t\"FLOAT\" : true,\n\t\t\t\"HEIGHT\" : 1080,\n\t\t\t\"TARGET\" : \"fkry\",\n\t\t\t\"WIDTH\" : 1920\n\t\t},\n\t\t{\n\t\t\t\"FLOAT\" : true,\n\t\t\t\"HEIGHT\" : 1080,\n\t\t\t\"TARGET\" : \"buffA\",\n\t\t\t\"WIDTH\" : 1920\n\t\t}\n\t],\n\t\"TITLE\" : \"Thresholder_dup\",\n\t\"WIDTH\" : 1920\n}","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"fkry","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"buffA","WIDTH":1920}],"SCRIPT_CODE":"function SynthTime() {\n    this.x = Math.random() * 10000;\n    this.y = Math.random() * 10000;\n    this.z = Math.random() * 10000;\n}\nSynthTime.prototype.tick = function() {\n    noiseTime = {\n        r: Math.sin(inputs.synthMacro * 15.01), \n        g: Math.sin(inputs.synthMacro * 11.54), \n        b: Math.sin(inputs.synthMacro * 6.02)\n    };\n    noiseTimeExp = {\n        r: noiseTime.r * noiseTime.r * noiseTime.r * 5,\n        g: noiseTime.g * noiseTime.g * noiseTime.g * 5,\n        b: noiseTime.b * noiseTime.b * noiseTime.b * 5\n    }\n    synthTimeDelta = {\n        r: inputs.syn_HighLevel * noiseTimeExp.b * inputs.synthScale * inputs.synthSpeed,\n        g: inputs.syn_MidLevel * noiseTimeExp.b * inputs.synthScale * inputs.synthSpeed,\n        b: inputs.syn_BassLevel * noiseTimeExp.b * inputs.synthScale * inputs.synthSpeed\n    };\n    this.x += synthTimeDelta.r;\n    this.y += synthTimeDelta.g;\n    this.z += synthTimeDelta.b;\n}\n\nfunction Freezes() {\n    this.hits = [];\n}\nFreezes.prototype.addhit = function() {\n    this.hits.push(1);\n}\nFreezes.prototype.tick = function() {\n    for (var index = 0; index < this.hits.length; index++) {\n        this.hits[index] -= 0.01;\n        if (this.hits[index] < 0.01) this.hits.splice(index,1);        \n    }\n}\n\nvar synthTime = new SynthTime();\nuniforms.synthTime = synthTime;\nvar freezes = new Freezes();\nuniforms.freezes = freezes\nuniforms.randomR = Math.random();\nuniforms.randomG = Math.random();\nuniforms.randomB = Math.random();\n\n\nuniforms.current_pallete = 1;\nfunction randomizeAllColors() {\n    uniforms.randomR1 = Math.random();\n    uniforms.randomG1 = Math.random();\n    uniforms.randomB1 = Math.random();        \n    uniforms.randomR2 = Math.random();\n    uniforms.randomG2 = Math.random();\n    uniforms.randomB2 = Math.random();        \n    uniforms.randomR3 = Math.random();\n    uniforms.randomG3 = Math.random();\n    uniforms.randomB3 = Math.random();        \n    uniforms.randomR4 = Math.random();\n    uniforms.randomG4 = Math.random();\n    uniforms.randomB4 = Math.random();\n}\nrandomizeAllColors();\n\n\nfunction update(data) {\n    synthTime.tick();\n    if (inputs.syn_Hits > 0.9) {\n        uniforms.randomR = Math.random();\n        uniforms.randomG = Math.random();\n        uniforms.randomB = Math.random();\n    }\n    freezes.addhit();\n    freezes.tick();\n    \n    if (inputs.random_palette > 0.5) {\n        randomizeAllColors();\n        uniforms.current_pallete = 0;\n    }\n    if (inputs.palette1 > 0.5) uniforms.current_pallete = 1;\n    if (inputs.palette2 > 0.5) uniforms.current_pallete = 2;\n    if (inputs.palette3 > 0.5) uniforms.current_pallete = 3;\n    if (inputs.palette4 > 0.5) uniforms.current_pallete = 4;\n    if (inputs.palette5 > 0.5) uniforms.current_pallete = 5;\n}","SHADER_CODE":"const float twopies = 6.28318530718;\n//helper functions\nvec3 hsv_2_rgb( in vec3 c ){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb_2_hsv( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nfloat plot(vec2 st, float pct, float width){\n  return  smoothstep( pct-width, pct, st.x) -\n          smoothstep( pct, pct+width, st.x);\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec4 defaultSynth(in vec2 fragCoord ) {    \n    vec2 synthuv = _uv - 0.5;\n    synthuv *= (0.02 + (synthScale * synthScale * 8));\n\n    vec2 noisescaleR = vec2(\n        sin(synthMacro * 12.015), \n        sin(synthMacro * 12.522)\n    ) * 10.0;\n    vec2 noisescaleG = vec2(\n        sin(synthMacro * 13.04), \n        sin(synthMacro * 13.3)\n    ) * 10.0;\n    vec2 noisescaleB = vec2(\n        sin(synthMacro * 14.08), \n        sin(synthMacro * 14.55)\n    ) * 10.0; \n\n    vec3 synthTimeNow = synthTime;\n    float noiser = cnoise( vec3(\n        synthuv.x * noisescaleR.x, \n        synthuv.y * noisescaleR.y, \n        synthTimeNow.r\n    ));\n    float noiseg = cnoise( vec3(\n        synthuv.x * noisescaleG.x, \n        synthuv.y * noisescaleG.y, \n        synthTimeNow.g\n    ));\n    float noiseb = cnoise( vec3(\n        synthuv.x * noisescaleB.x, \n        synthuv.y * noisescaleB.y, \n        synthTimeNow.b\n    ));\n    vec3 noisecol = vec3(noiser, noiseg, noiseb);\n    vec3 noisecolhsv = rgb_2_hsv(noisecol);\n    noisecolhsv.r = sin(noisecol.r * 3);\n    noisecolhsv.g = sin(noisecol.g * 4);\n    noisecolhsv.b = sin(noisecol.b * 5);\n    noisecol = hsv_2_rgb(noisecolhsv);\n    // shuffle values and do some sin or mod stuff\n    noisecol = vec3( \n        sin(noisecol.r * noisecol.g / noisecol.b) * noiser,\n        (noisecol.g * noisecol.b / noisecol.r) * noiseg,\n        mod(noisecol.b * noisecol.r / noisecol.g, 1.0) * noiseb\n    );\n    // switch to hsv to rotate color based on some sound variable\n    noisecol = rgb_2_hsv(noisecol);\n    noisecol.r += syn_BPMSin4 + 0.5 - syn_BassHits;\n    noisecol = hsv_2_rgb(noisecol);\n    return vec4(noisecol.r,noisecol.g,noisecol.b,1.0);\n}\n\nbool getthreshold(in vec4 userimage) {\n    // escape conditions first\n    if (userimage.a < 0.2) { return false;}\n \n    // color similarity threshold \n    float threshold_factor = THRESHOLD + ((threshold_vol * syn_BassLevel + threshold_vol * syn_MidHighLevel) / 2.0);\n    vec3 color_to_keep = keep_color;\n    if (random_keep_color > 0.5) {\n        color_to_keep = vec3(randomR, randomG, randomB); // get randomizing color from javascript\n    }\n    if (abs(userimage.r - color_to_keep.r) < threshold_factor &&\n        abs(userimage.g - color_to_keep.g) < threshold_factor &&\n        abs(userimage.b - color_to_keep.b) < threshold_factor) {\n            return true;\n    }\n    return false;\n}\n\nvec3 palette( in float brightness, in vec3 bias, in vec3 amp, in vec3 freq, in vec3 phase ) {\n    return bias + amp*cos( twopies*(freq*brightness+phase) );\n}\n\n\nvec3 palletize(inout vec3 color) {\n  float grayscale = color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\n  if (current_pallete == 0) color = palette(grayscale, vec3(randomR1-0.5, randomG1-0.5, randomB1-0.5),vec3(randomR2 * 2.0, randomG2 * 2.0, randomB2 * 2.0),vec3(randomR3, randomG3, randomB3),vec3(randomR4, randomG4, randomB4) );\n  if (current_pallete == 1) color = palette(grayscale, \n    vec3(0.5),vec3(0.5),vec3(1.0,1.0,1.0),vec3( abs(_uv.x - 0.5) * sin(syn_Time * TIME * 0.001) - abs(_uv.y - 0.5) * sin(syn_BassTime * TIME * 0.001),mod(syn_Time / 100.0 + TIME / 600.0, 1.0),sin(syn_Time / 200.0 + TIME / 900.0)) );\n  if (current_pallete == 2) color = palette(grayscale, \n    vec3(0.5),vec3(0.5),vec3(sin(syn_BassTime * 0.01) + 1.0,sin(syn_MidTime * 0.01) + 1.0,sin(syn_HighTime * 0.01) + 1.0),vec3(TIME * 0.01) );\n  if (current_pallete == 3) color = palette(mod(grayscale * 4.0 * abs(_uv.x - 0.5) * abs(_uv.y - 0.5), 1.0), \n    vec3(mod(TIME * 0.0001, 1.0)),vec3(mod(TIME * -0.0001, 1.0)),vec3(1.0,1.0,0.5),vec3(\n        syn_BassLevel * 3.0,\n        syn_MidHighLevel * 3.0, \n        syn_HighPresence * 3.0 ) );\n  if (current_pallete == 4) color = palette(grayscale, \n    vec3(1.0),vec3(1.0),vec3(_uv.x * 10.0, _uv.y, 20.0),vec3( _uv.x + TIME * 0.1 * (100.0 / syn_BassTime) ) );\n  if (current_pallete == 5) color = palette(grayscale, \n    vec3(0.5),vec3(0.5),vec3(11.1 + syn_HighLevel / 5.0, 11.2, 11.3 + syn_BassLevel / 5.0),vec3(TIME) );\n  return color;\n}\n// pass 0, generate image and save to buffer\nvoid bufferImage1( out vec4 fragColor, in vec2 fragCoord ){\n    // load user image at the start, we'll need it later\n    vec3 oldcolors = texture(buffA,_uv).rgb;\n    // offset for bump to beat\n    _uv = _uv;\n    // bump to beat\n    _uv = ( ( _uv - 0.5 ) / ( 1.0 + (syn_MidLevel * zoom_to_volume) ) + 0.5 );\n    // tone movement\n    oldcolors = rgb_2_hsv(oldcolors);\n    oldcolors.r += TIME / 100.0;\n    oldcolors = hsv_2_rgb(oldcolors);\n    _uv.x += oldcolors.r * 0.005 + (syn_BassPresence * tone_movement*movementDir);\n    _uv.y += oldcolors.g * 0.005 + (syn_Presence * tone_movement*movementDir);\n    _uv -= oldcolors.b * 0.005 + (syn_MidHighPresence * tone_movement*movementDir);\n    vec3 colors = texture(buffA,_uv).rgb;\n    vec3 hsv_colors = rgb_2_hsv(colors);\n    hsv_colors.r += color_spin;\n    hsv_colors.g += saturate_adjust * 2.0;\n    if (bright_adjust_auto > 0.5) {\n        hsv_colors.b += 1.0 - rgb_2_hsv(keep_color).b * 0.05;\n    } else {\n        hsv_colors.b += bright_adjust * 2.0;\n    }\n    colors = hsv_2_rgb(hsv_colors);\n    if (palletize_before > 0.5) colors = palletize(colors);\n    fragColor = vec4(colors,1.0);\n}\nvec4 mainpass(in vec2 _uv) {    \n    vec4 fragColor;\n    // should we snag this frame?\n    bool snagthisframe = false;\n    if (get_frame > 0.5) snagthisframe = true;\n    if (play_media > 0.5) snagthisframe = true;\n    if (auto_get_frame > 0.5 && syn_Hits > 0.8) snagthisframe = true;\n    if (auto_get_frame > 0.5 && play_media > 0.5 && syn_Hits < 0.8) snagthisframe = false;\n    if (snagthisframe) {\n        if (_exists(syn_UserImage)) { // check if user has media available\n            fragColor = _loadUserImage();\n        } else {\n            fragColor = defaultSynth(_xy);\n        }\n        if ( !getthreshold(fragColor)) bufferImage1(fragColor, _xy);\n    } else {\n        bufferImage1(fragColor, _xy);\n    }\n    return fragColor; \n}\n// framework / main loop\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0.0){ \n      if (bufferglitch > 0.5) {\n        return texture(fkry,_uv);\n      } else {\n        return mainpass(_uv);\n      } \n  } else if (PASSINDEX == 1.0){ // store buffer for feedback\n      if (bufferglitch > 0.5) {\n        return mainpass(_uv);\n      } else {\n        return texture(fkry,_uv);\n      } \n  } else if (PASSINDEX == 2.0){ // another pass for final tweaks\n    //output\n    vec4 color4 = texture(buffA,_uv);\n    vec3 color = vec3(color4.r, color4.g, color4.b); \n    if (palletize_after > 0.5) color = palletize(color);\n    return vec4(vec3(color),1.0);\n  }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Thresholder_dup","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Automatically swing the camera back and forth","MAX":1,"MIN":0,"NAME":"auto_camera","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Remove depth of field for fully focused scene","MAX":1,"MIN":0,"NAME":"focused","PARAMS":0.100000001490116,"TYPE":"toggle smooth","UI_GROUP":"camera"},{"DEFAULT":[0,0],"DESCRIPTION":"Control where the camera is pointed","MAX":[1,1],"MIN":[-1,-1],"NAME":"cam_look","PARAMS":0.00499999988824129,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Field of View of the perspective of the camera","MAX":3,"MIN":0.100000001490116,"NAME":"FOV","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Quick 'zoom in' field of view hit","MAX":0.400000005960464,"MIN":0,"NAME":"FOV_bump","PARAMS":0.0750000029802322,"TYPE":"bang smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Add flashes scanning along X-axis in scene","MAX":1,"MIN":0,"NAME":"scan_x","PARAMS":0.200000002980232,"TYPE":"bang smooth","UI_GROUP":"walls_coloration"},{"DEFAULT":0,"DESCRIPTION":"Add flashes scanning along Z-axis in scene","MAX":1,"MIN":0,"NAME":"scan_z","PARAMS":0.0199999995529652,"TYPE":"bang smooth","UI_GROUP":"walls_coloration"},{"DEFAULT":1,"DESCRIPTION":"Adjust the size of the pixels that form the walls","MAX":3,"MIN":0,"NAME":"pixelation","TYPE":"slider","UI_GROUP":"walls_coloration"},{"DEFAULT":0,"DESCRIPTION":"Whether media that paints the pixel walls is scrolling or not","MAX":1,"MIN":0,"NAME":"media_scrolling","TYPE":"toggle","UI_GROUP":"walls_coloration"},{"DEFAULT":0,"DESCRIPTION":"Adds flashes to the media on the walls","MAX":1,"MIN":0,"NAME":"auto_flasher","TYPE":"toggle","UI_GROUP":"walls_coloration"},{"DEFAULT":0,"DESCRIPTION":"Remove side walls for a flat plane above and below","MAX":1,"MIN":0,"NAME":"flat_space","PARAMS":0.0399999991059303,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Rotate the planes around the camera","MAX":2,"MIN":0,"NAME":"rotate_planes","PARAMS":0.0399999991059303,"TYPE":"knob smooth","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Make the wall pixels circles instead of squares","MAX":1.5,"MIN":0,"NAME":"small_circles","PARAMS":0.100000001490116,"TYPE":"knob smooth","UI_GROUP":"geometry"}],"CREDIT":"Shane","DESCRIPTION":"A multipass reflective box tunnel with some random reflective ray scattering thrown in. Basically, it's just a remake of W23's \"Path Racer\" and NuSan's \"Corridor Travel\" examples.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\traced_tunnel.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Traced Tunnel","IMAGES":[{"NAME":"image3","PATH":"images/3.jpg"},{"NAME":"image48","PATH":"images/48.jpg"}],"IMAGE_PATH":"traced_tunnel.synScene\\traced_tunnel.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Automatically swing the camera back and forth\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_camera\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Remove depth of field for fully focused scene\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"focused\",\n         \"TYPE\" : \"toggle smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Control where the camera is pointed\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"cam_look\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.005,\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Field of View of the perspective of the camera\",\n         \"MAX\" : 3,\n         \"MIN\" : 0.1,\n         \"NAME\" : \"FOV\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.05,\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Quick 'zoom in' field of view hit\",\n         \"MAX\" : 0.4,\n         \"MIN\" : 0,\n         \"NAME\" : \"FOV_bump\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.075,\n         \"UI_GROUP\" : \"camera\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Add flashes scanning along X-axis in scene\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"scan_x\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"walls_coloration\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Add flashes scanning along Z-axis in scene\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"scan_z\",\n         \"TYPE\" : \"bang smooth\",\n         \"PARAMS\":0.02,\n         \"UI_GROUP\" : \"walls_coloration\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Adjust the size of the pixels that form the walls\",\n         \"MAX\" : 3,\n         \"MIN\" : 0,\n         \"NAME\" : \"pixelation\",\n         \"TYPE\" : \"slider\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"walls_coloration\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Whether media that paints the pixel walls is scrolling or not\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"media_scrolling\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"walls_coloration\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Adds flashes to the media on the walls\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_flasher\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"walls_coloration\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Remove side walls for a flat plane above and below\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flat_space\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.04,\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Rotate the planes around the camera\",\n         \"MAX\" : 2,\n         \"MIN\" : 0,\n         \"NAME\" : \"rotate_planes\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.04,\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Make the wall pixels circles instead of squares\",\n         \"MAX\" : 1.5,\n         \"MIN\" : 0,\n         \"NAME\" : \"small_circles\",\n         \"TYPE\" : \"knob smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"geometry\"\n      }\n   ],\n   \"CREDIT\" : \"Shane\",\n   \"DESCRIPTION\" : \"A multipass reflective box tunnel with some random reflective ray scattering thrown in. Basically, it's just a remake of W23's \\\"Path Racer\\\" and NuSan's \\\"Corridor Travel\\\" examples.\",\n   \"HEIGHT\" : 1080,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image3\",\n         \"PATH\" : \"images/3.jpg\"\n      },\n      {\n         \"NAME\" : \"image48\",\n         \"PATH\" : \"images/48.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"traced_tunnel.png\",\n   \"TITLE\" : \"Traced Tunnel\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"// var time = 0;\nfunction update(dt) {\n  // time += dt*inputs.speed_in;\n  // uniforms.script_time = time;\n}","SHADER_CODE":"/*\n\n\tTraced Tunnel\n\t-------------\n\n\tThis initially started as a simple textured square tube, but then I took\n\ta look at W23's \"Past Racer\" example and wanted to emulate the awesome\n\treflective... pseudo-pathtraced style of that. NuSan also has a really\n\tnice example on here, based on the same, that provided inspiration as well --\n    That one is well worth a look as the coloring is beautiful.\n\n\tI wrote this from scratch, but have used elements from the aforementioned\n    examples. I love the camera \"tick\" function in Nusan's example, so stuck \n    with that, and I like the way W23 gave certain random tiles more of an \n    opaque factor than others, so continued with that theme.\n\n\tIn regard to my own elements, I abandoned the box formula for four simple\n\tplane traces, since I needed a bit more control. I've also put in squarish \n    polar mapped textures to give more of a wrapped feel. Other than that, I \n    haven't brought anything particularly new to the table.\n\n\tI initially went to the trouble to raytrace octagonal walls, only to \n    discover that light bounces off rectangular walls in a cleaner -- and more \n    interesting --  way, so reverted back to the original arrangement.\n\n    This contains elements of path tracing, but I won't go as far as to call it\n\tthat, so I'll simply call it a reflective ray scattering demonstration. I've \n    basically patched in code here and there, but here's a quick explanation as \n    to what's happening:\n\n    I think most know how to raytrace a square tunnel with a single pass or \n    more -- Raytrace, retrieve the hit point, then use that to color the pixel.\n    With extra reflective passes, you calculate the reflected unit direction \n    ray at the hit point (ref = relflect(r, n)), raytrace to the surface again \n    from there, retrieve the color at the new hit point, then combine it with \n    the previous color -- How you do that is up to you; addition, mixing, or \n    whatever you choose. If you want more bounces, continue the process. Simple.\n    \n    However, pure reflections don't really reflect (no pun intended) the way real \n    surfaces behave. As you could imagine, they're rough at a microscopic level,\n\tso don't perfectly reflect rays in one direction; There's some randomness\n\tto it. Essentially, rough surfaces scatter the reflective rays in a way that \n    give the appearance of graded opaqueness, and smoother polished surfaces look \n    more reflective. There's more to it, but that's the gist of it.\n\n    To put this into practice, you simply add some randomness to the reflected \n    ray, which is based on the roughness of the surface. In a similar way to W23 \n    and NuSan's examples, I've textured square grids to the walls of the tunnel, \n    then randomly assigned roughness levels to each. This causes each grid cell \n    to look opaque, completely reflective, or somewhere in-between. The\n    reflected rays on the right-angled geometry gives a see-through impression, \n    but that's not the case.\n\t\n\n\tInspired largely by the following:\n\n    // The simple renderer is great, but it's the camera work that I love most.\n    past racer by jetlag - w23\n\thttps://www.shadertoy.com/view/Wts3W7\n\n    // Simple, but georgeous lighting and colors.\n\tCorridor Travel - NuSan\n    https://www.shadertoy.com/view/3sXyRN\n\n*/\n\n\n// Pure reflections looks pretty cool, and clean, but lack the subtlety of a\n// randomly reflected ray.\n// #define PURE_REFLECTION\n\n// Full rotational movement.\n//#define CAM_ROTATION\n\n// Camera swing.\n#define CAM_SWING\n\n// Depth of field.\n#define DEPTH_OF_FIELD\n\n// Motion blur: Temporal blending of samples.\n//#define MOTION_BLUR\n\n\n\n// Sample number: Higher is better, but slower. Eight is enough. :)\nconst int sampleNum = 12;\n\n\n// 2D rotation.\nmat2 r2(float a){ return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// Random functions: All based on IQ's originals.\n\n// vec2 to float hash.\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(425.215, 714.388)))*45758.5453);\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(72.927, 98.283)), dot(p, vec2(41.295, 57.263))))\n                  *vec2(43758.5453, 23421.6361));\n}\n\n// vec2 to vec3 hash.\nvec3 hash23(vec2 p){\n    return fract(sin(vec3(dot(p, vec2(12.989, 78.233)), dot(p, vec2(51.898, 56.273)),\n                      dot(p, vec2(41.898, 57.263)))) *vec3(43758.5453, 23421.6361, 65426.6357));\n}\n\n// Also from NuSan's example. I tried other variations, but\n// this just seems to work better.\nfloat tick(float t, float d) {\n  \n  float m = fract(t/d);\n  m = smoothstep(0., 1., m);\n  m = smoothstep(0., 1., m);\n  return (floor(t/d) + m)*d;\n}\n\n// NuSan's cool camera tick function.\nfloat tickTime(float t){ return t*2. + tick(t, 4.)*.25; }\n\n\n// Camera movement. Adapted from NuSan's example.\nvoid cam(inout vec3 p, float tm, float tTime) {\n  \n    if (auto_camera > 0.5) {\n        // p.xy *= r2(tm/4.);\n        // p.xz *= r2(tm/2.);\n    \n        // #ifdef CAM_SWING\n  \t     p.xz *= r2(sin(syn_Time*0.15*.3)*.4);\n  \t     p.xy *= r2(sin(syn_Time*0.15*.1)*2.);\n        // #endif\n    }\n\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y+s*p.z, -s*p.y+c*p.z);\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\n// Plane intersection: Old formula, and could do with some tidying up.\n// The tiny \"9e-7\" figure is something I hacked in to stop near plane \n// artifacts from appearing. I don't like it at all, but not a single \n// formula I found deals with the problem. There definitely has to be\n// a better way, so if someone knows of a more robust formula, I'd \n// love to use it.\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n, float d){\n    rd = rotateZ(rd, rotate_planes*PI);\n\n    float t = 1e8;\n    //float retval = 0.; // Inside or outside the object. Not used here.\n\n\tfloat ndotdir = dot(rd, n);\n    \n\tif (ndotdir < 0.){\n\t\n\t\tfloat dist = (-d - dot(ro, n) + 9e-7)/ndotdir;\t// + 9e-7\n   \t\t\n\t\tif (dist>0. && dist<t){ \n            t = dist; \n            //retval = 1.;\n\t\t}\n\t}\n    \n    return t;\n\n}\n\nfloat udBox(in vec2 p, in vec2 b){\n\treturn mix(length(max(abs(p) - b + .1, 0.)) - .1, length(p)-0.5+(max(small_circles, 1.0)-1), min(small_circles, 1.0));\n}\n\n// Used for polar mapping various shapes.\nfloat uvShape(vec2 p){\n    // Polar mapping a square wall.\n    p = abs(p);\n    return max(p.x, p.y);\n    \n    // Mapping hexagon walls.\n    //p *= r2(-3.14159/12.);\n    //p = abs(p);\n    //return max(p.x*.8660254 + p.y*.5, p.y);\n    \n}\n\nvec4 texMirror(sampler2D samplerIn, vec2 uvIn){\n  if (mod(uvIn.x, 2.0) > 1.0){\n    uvIn.x = 1.0-uvIn.x;\n  }\n  if (mod(uvIn.y, 2.0) > 1.0){\n    uvIn.y = 1.0-uvIn.y;\n  }\n  return texture(samplerIn, uvIn);\n}\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n  \n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - RENDERSIZE.xy*.5)/RENDERSIZE.y;\n    \n\n    // Depth of field (DOF) amount, and the DOF distance. In this\n    // case, a figure of 3 will bring everything into focus three units \n    // down the tunnel, but camera blur things around it.\n    float clarityTime = _pulse(fract(TIME*0.1), 0.1, 0.05);\n    float DOF = mix((1.0-syn_Presence)*0.1, 0.001, focused);\n    float DOFDist = 3.0-syn_Presence*1.0;\n    \n    // Global time, and tick time, which in this case is regular time, with\n    // a lurching tick on it. I think it's great, but it might not be for\n    // those who are prone to motion sickness.\n    float tm = syn_BassTime*0.2+TIME*0.1;\n    float tickTm = tickTime(tm);\n    \n    // Initial camera position. The tick time variable gives the camera a\n    // slight lurching motion along Z.\n    vec3 ca = vec3(0, 0, tickTm);\n    \n    \n    // Initialize the scene color to zero.\n     vec3 col = vec3(0);\n\n\n    // Taking a few samples, which is not much different to standard antialiasing. The main \n    // difference is that you set up your unit direction ray with UV coordinates randomly \n    // sampled around the pixel area. The average of all returned colors gives you a nice \n    // antialiased look... provided you take enough costly samples, of course. In this case, \n    // we're taking just 8 -- Not ideal, but good enough for the purpose of this example.\n    for(int j = 0; j<sampleNum; j++) {\n\n        // Pixel offset.\n        vec2 offs = hash22(uv + float(j)*74.542 + 35.877) - .5;\n\n        #ifdef MOTION_BLUR\n        // Motion blur: Just a simple temporal blending of samples. In case it isn't\n        // obvious, you're advancing global time a little with each sample, which results \n        // in frames further in time being blended with the present. You could go \n        // backwards instead, if the idea of looking into the future bothers you. :D\n        tm = TIME + float(j)*.05/float(sampleNum);\n        tickTm = tickTime(tm);\n        #endif\n \n        vec3 ro = vec3(0);\n        #ifdef DEPTH_OF_FIELD\n        // Depth of field. Spreading out the sample, according to screen depth.\n        ro.xy += offs*DOF;\n        vec3 r = normalize(vec3(_uvc - offs*DOF/DOFDist, FOV+FOV_bump));\n        #else\n        vec3 r = normalize(vec3(uv - offs/RENDERSIZE.y, 1));\n        #endif\n\n        // Camera movement. Rotation, swivle, etc.\n        cam(ro, tm, tickTm);\n        cam(r, tm, tickTm);\n        \n        r = rotateX(r, cam_look.y*PI);\n        r = rotateY(r, -cam_look.x*PI);\n\n        ro.z += ca.z;\n\n        // Alpha, for blending layers.\n        float alpha = 1.;\n\n        // Fog distance.\n        float fogD = 1e5;\n\n\n        // Reflective bounces. Just three here.\n        for(int i = 0; i<3; i++) {\n\n\n            // Tracing the four planes, then determining the closet.\n            // I'll tidy this up later.; \n            //\n            vec4 pl; // Vector storage for the four planes.\n            pl.x = rayPlane(ro, r, vec3(0, 1, 0), 1.); // Bottom.\n            pl.y = rayPlane(ro, r, vec3(0, -1, 0), 1.); // Top.\n            pl.z = mix(rayPlane(ro, r, vec3(1, 0, 0), 1.), 100.0, flat_space*flat_space); // Left.\n            pl.w = mix(rayPlane(ro, r, vec3(-1, 0, 0), 1.), 100.0, flat_space*flat_space); // Right.\n           \n            // Minimum plane distance.\n            float d = min(min(pl.x, pl.y), min(pl.z, pl.w));\n    \n            // Set the fog distance on the first pass.\n            if(i==0) fogD = d;\n\n            // Hit position.\n            vec3 p = ro + r*d;\n            // Determine the UV coordinates for texturing, and the normal,\n            // for lighting and other things.\n            //\n            // Set the normal and UVs to the bottom or top planes.\n            vec3 n = vec3(0,  pl.x<pl.y? 1 : -1, 0);\n            vec2 tuv = p.xz + vec2(0, n.y);\n\n            // If we've hit the side walls instead, change the normal and \n            // UVs accordingly.\n            if(min(pl.z, pl.w)<min(pl.x, pl.y)) {\n             \n                n = vec3(pl.z<pl.w? 1 : -1, 0, 0);\n                \n                tuv = p.yz + vec2(n.x, 0); // Left walls.\n            }\n\n            // Texture scaling for texturing.\n            float sc = 12.0*pixelation*pixelation;\n            tuv *= sc;\n            tuv += sc*0.5;\n            \n            \n            // Sample color.\n            vec3 sampleCol = vec3(1);\n            \n            // Grid square ID and local coordinates.\n            vec2 id = floor(tuv);\n            tuv -= id + .5;\n            \n            float sqSize = 0.5+0.5*sin(syn_BPMSin2+p.z*0.4);\n             /////\n            // Use the UV coordinates to create a whitish colored rounded box grid.\n            float patDist = udBox(tuv, vec2(.2+sqSize*0.7));\n            // Use the square grid shape for shading.\n            float sh = clamp(.5 - patDist/.2, 0., 1.);\n       \n            // Subtle coloring.\n            vec3 sqCol = .85 + .3*cos((hash21(id + .2)*2.)*6.2831 + vec3(0, 1, 2));\n            sampleCol = mix(vec3(0), sqCol*sh, (1. - smoothstep(0., .005, patDist)));\n \n            ////\n            // Perform a squarish polar mapping (of sorts), read in to some textures, then\n            // color them up, etc.\n            //\n            // Quantized squarish polar mapping.\n            const vec2 txSc = vec2(2, 1./2.); // Texture scale.\n            vec3 ip3 = (floor(p*sc) + .0)/sc; // Quantizing... as opposed to continuous values.\n            float ang = atan(ip3.x, ip3.y)/6.2831; // Angle of grid cell from the tube center.\n            vec2 tnuv = vec2(uvShape(ip3.xy)*ang*txSc.x, ip3.z*txSc.y); // Square polar UVs.\n            //\n            // Smooth squarish polar mapping.\n            const vec2 txSc2 = vec2(1, 1./4.); // Texture scale.\n    \t\tvec3 p3 = mix(p, (floor(p*sc) + .0)/sc, .8); // Slightly smooth quantized values.\n            float ang2 = atan(p3.x, p3.y)/6.2831; // Angle of grid cell from the tube center.\n            vec2 tnuv2 = vec2(uvShape(p3.xy)*ang2*txSc2.x, p3.z*txSc2.y);  // Square polar UVs.\n\n            // Reading the texel values, and manipulating a bit. Note the squaring of the value,\n            // (tx *= tx) which is a rough sRGB to linear conversion.\n            vec3 tx = texture(image48, fract(tnuv - .5 - vec2(syn_MidHighTime*0.5/(sc)/2., 0)*media_scrolling)).xyz; tx *= tx;\n\n            tx = mix(tx, vec3(dot(tx, vec3(.299, .587, .114))), .75);\n            tx = smoothstep(.1, .55, tx);\n            // tx = mix(tx, vec3(0.0, 0.75, 1.0), tnuv2.x);\n            vec3 tx2 = vec3(0.0);\n            if (syn_MediaType > 0.5){\n                tx2 = _contrast(_invertImage(vec4(texMirror(syn_UserImage, tnuv2 - .5 - vec2(syn_HighTime*0.5/(sc)/2., 0)*media_scrolling).xyz,0.0)),_Media_Contrast).rgb;\n                tx2 = smoothstep(.18, .5, tx2);//*vec3(1.1, 1, .9); \n            } else {\n                tx2 = texture(image3, fract(tnuv2 - .5 - vec2(syn_HighTime*0.5/(sc)/2., 0)*media_scrolling)).xyz; tx2 *= tx2;\n                tx2 = smoothstep(.18, .5, tx2);//*vec3(1.1, 1, .9); \n            }\n            // col = tx;\n            // break;\n            \n            // Apply the textures to the sample color. \n            sampleCol *= tx*tx2*3.*mix(1.0, syn_HighHits, auto_flasher*(0.5+0.5*sin(length(p.xz)*0.25+syn_BassTime*0.4))); \n            \n            sampleCol += sampleCol*500.0*scan_x*_pulse(p.x*0.1, scan_x, 0.1);\n\n            sampleCol = mix(sampleCol, 20.0*sampleCol.brg, scan_z*_pulse(1.0-p.z*0.1+ro.z*0.1, scan_z, 0.1));\n\n            // Some fakish point lighting. \n            // Light direction vector. The light is 3 units up from the camera, which\n            // coincides with the depth of field distance.\n            vec3 ld = normalize(ca + vec3(0, 0, 3) - p);\n            float dif = max(dot(ld, n), 0.); // Diffuse.\n            float spe = pow(max(dot(reflect(ld, -n), -r), 0.), 8.); // Specular.\n            float fre = pow(max(1. - abs(dot(r, n))*.5, 0.), 1.); // Fresnel.\n            \n            sampleCol *= (dif + vec3(1, .9, .7)*spe*4. + vec3(.5, .7, 1)*fre);\n                \n            \n            // W23's chromatic effect. It looks good in his artsy black and white\n            // example, but there's too much color here for it to be effective.\n            \n            // float patDistL = udBox(tuv - vec2(.05, 0), vec2(.4));\n            // float patDistR = udBox(tuv - vec2(0, .05), vec2(.4));\n            // sampleCol *= step(0., -vec3(patDistL, patDist, patDistR) - .025);\n            \n            \n            // Applying some fog.\n            sampleCol *= vec3(1.35+syn_BassLevel*2.5, 1.35, 1.35)/(1. + fogD*fogD*.05);\n         \n\n            \n            // Add the sample color to overall accumulated scene color.\n            //col += sampleCol*alpha*fre*exp(-fogD*.2);\n            col += sampleCol*alpha*fre;\n            \n            // Reduce the alpha factor by a bit and mix in the Fresnel factor as well.\n            alpha *= 0.9;\n\n   \n            // Calculate the reflection vector for the next pass.\n            \n            #ifdef PURE_REFLECTION\n            \n            // Pure reflection overide. It's definitely cleaner, but less interesting.\n            r = reflect(r,n);\n            \n            #else\n            \n            // Just some randomized reflection, based on certain heuristics. There are\n            // various ways to create a randomized relective vector, but it's mainly\n            // common sense. \n            float h = hash21(id)*smoothstep(0., .005, -patDist + .15);\n          \n            // Purely reflected vector.\n            vec3 ref = reflect(r,n);\n            // Random vector.\n            r = normalize(hash23(uv + float(j)*74.524 + float(i)*35.712) - .5);\n            // Mixing the purely reflected vector with the random vector according\n            // to some heuristics. In this case, a random opaque factor for the \n            // tile, the tile shade, pattern border, fog... I made it up as I \n            // went along. :)\n            r = normalize(mix(ref, r, (hash21(tuv)*.0 + h*.1*sh)*exp(-fogD*.05)));\n            \n            // Ensuring random reflection. I normally use other logic, but it works\n            // well enough in W23 and Nusan's examples, so it'll do. :)\n            r = dot(r, n)<0.? -r : r;\n            #endif\n\n            // Advance the position to the new hit point. Also be sure to bump\n            // the ray off the surface to avoid self collision... If I had a\n            // dollar for every time I've forgotten to do this... :)\n            ro = p + n*.0011;\n        }\n\n    }\n    \n    // Divide by the total number of samples.\n    col /= float(sampleNum);\n    \n\n    // Use this to tone down highlight extrema... However, if you like to live on\n    // the edge and burn your eyes, then leave it as is. :D\n    //col = 1. - exp(-col);\n    \n    \n    // Gamma correction and screen presentation.\n    fragColor = vec4(pow(max(col, 0.), vec3(0.4545)), 1);\n    \n\treturn fragColor; \n } \n\n\n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Traced Tunnel","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Add in juicy colors.","MAX":1,"MIN":0,"NAME":"colorize","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Bright, watery caustics look.","MAX":1,"MIN":0,"NAME":"watery_tex","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"Digital green/blue/yellow.","MAX":1,"MIN":0,"NAME":"digital_tex","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":[0,0],"DESCRIPTION":"Turn the camera to look around.","MAX":[1,1],"MIN":[-1,-1],"NAME":"camera_direction","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Horizontal slices. Turn OFF if using voxelate or beat slice.","MAX":1,"MIN":0,"NAME":"always_sliced","TYPE":"toggle","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Split space into 3D pixels for a lo-fi glitchy look.","MAX":1,"MIN":0,"NAME":"voxelate","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":10,"DESCRIPTION":"Size of voxels when using 'voxelate'.","MAX":0.100000001490116,"MIN":50,"NAME":"size_voxels","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Turn ON for a reactive horizontal slicing effect. 'always sliced' must be OFF.","MAX":1,"MIN":0,"NAME":"beat_slice","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0.5,"DESCRIPTION":"Turn off for pure black/white. Turn up for mid-responsive color.","MAX":1,"MIN":0,"NAME":"mids_color","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"reactivity"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Bass causes the geometry to morph. Turn up for more effect, off for none.","MAX":1,"MIN":0,"NAME":"bass_morph","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"reactivity"},{"DEFAULT":0.400000005960464,"DESCRIPTION":"Adds extra flashing on high percussion.","MAX":1,"MIN":0,"NAME":"flashing","PARAMS":0.5,"TYPE":"slider smooth","UI_GROUP":"reactivity"},{"DEFAULT":0.00999999977648258,"DESCRIPTION":"","MAX":0.100000001490116,"MIN":-0.100000001490116,"NAME":"rate_in","PARAMS":0.5,"TYPE":"knob smooth","UI_GROUP":"time"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.100000001490116,"MIN":-0.100000001490116,"NAME":"bass_rate","PARAMS":0.5,"TYPE":"knob smooth","UI_GROUP":"time"}],"CREDIT":"Shane","DESCRIPTION":"A transparent organic field partitioned horizontally into 2D isosurface slices.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\transparent_isoslices.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Transparent Isoslices","IMAGES":[{"NAME":"texIn","PATH":"images/img.jpg"},{"NAME":"texIn2","PATH":"images/img2.jpg"}],"IMAGE_PATH":"transparent_isoslices.synScene\\transparent_isoslices.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Add in juicy colors.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"colorize\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Bright, watery caustics look.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"watery_tex\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Digital green/blue/yellow.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"digital_tex\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"color\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn the camera to look around.\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"camera_direction\",\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"camera\"\n      },{\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Horizontal slices. Turn OFF if using voxelate or beat slice.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"always_sliced\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Split space into 3D pixels for a lo-fi glitchy look.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"voxelate\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 10,\n         \"DESCRIPTION\" : \"Size of voxels when using 'voxelate'.\",\n         \"MAX\" : 0.1,\n         \"MIN\" : 50,\n         \"NAME\" : \"size_voxels\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"geometry\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Turn ON for a reactive horizontal slicing effect. 'always sliced' must be OFF.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"beat_slice\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Turn off for pure black/white. Turn up for mid-responsive color.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"mids_color\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"Bass causes the geometry to morph. Turn up for more effect, off for none.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"bass_morph\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"reactivity\"\n      },{\n         \"DEFAULT\" : 0.4,\n         \"DESCRIPTION\" : \"Adds extra flashing on high percussion.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"flashing\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"reactivity\"\n      },\n      {\n         \"DEFAULT\" : 0.01,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.1,\n         \"MIN\" : -0.1,\n         \"NAME\" : \"rate_in\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"knob smooth\",\n         \"UI_GROUP\" : \"time\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.1,\n         \"MIN\" : -0.1,\n         \"NAME\" : \"bass_rate\",\n         \"PARAMS\" : 0.5,\n         \"TYPE\" : \"knob smooth\",\n         \"UI_GROUP\" : \"time\"\n      }\n   ],\n   \"CREDIT\" : \"Shane\",\n   \"DESCRIPTION\" : \"A transparent organic field partitioned horizontally into 2D isosurface slices.\",\n   \"HEIGHT\" : 720,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"texIn\",\n         \"PATH\" : \"images/img.jpg\"\n      },\n      {\n         \"NAME\" : \"texIn2\",\n         \"PATH\" : \"images/img2.jpg\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"transparent_isoslices.png\",\n   \"TITLE\" : \"Transparent Isoslices\",\n   \"WIDTH\" : 1280\n}\n","PASSES":null,"SCRIPT_CODE":"var t = 0;\nvar tMorph = 0;\n\nfunction update(dt) {\n  t = t + inputs.rate_in + inputs.syn_BassLevel*inputs.syn_BassLevel*inputs.bass_rate;\n  tMorph = tMorph + inputs.syn_BassLevel*inputs.syn_BassLevel*inputs.bass_morph*inputs.bass_morph;\n\n  uniforms.script_time = t;\n  uniforms.morph_time = tMorph;\n\n}","SHADER_CODE":"vec4 iMouse = vec4(720, 720, 0.0, 0.0); \n\n\n //    Transparent Isoslices\n\t// ---------------------\n\n\t// Quasi diffuse-lit transparent isosurface slices. I had to get a little inventive -\n\t// both with the character shuffling and the methodology - to make this work.\n\n\t// I don't know if anyone's noticed this, but 280 characters is not a lot to work \n\t// with. :) I mean, you could order a beer in under two tweets, but you couldn't chat \n\t// up the bar maid... OK, some people on Shadertoy probably could. :D\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Cheap organic distance field - partitioned into horizontal slices.\n//\nfloat m(vec3 p)\n{ \n    // Moving the scene itself forward - as opposed to the camera - to save on some lighting\n    // calculations later on. IQ does it in one of his small examples. \"TIME\" - IQ's suggestion.\n    // I didn't know that was an option... I need to read more. :)\n    // p.xy = _rotate(p.xy, p.z*roto_amt*sin(TIME+p.z));\n    p.z += script_time; \n\n    \n    // Chopping the field into horizontal strips. It's quite a brutal approach, and it only works\n    // because of the volumetric-like traversal. By the way, if you comment the line out, the \n    // isolines disappear, along with 22 characters, but it wasn't the look I was after.\n    p.y += 1/24.0;\n    p.y = mix(p.y, ceil(p.y*12.0)/12.0, mix(sqrt(syn_OnBeat)*beat_slice, 1.0, always_sliced));\n    // p.xy += 1/size_voxels*0.5;\n    p = mix(p, ceil(0.5+p*size_voxels)/size_voxels, 1.0*voxelate);\n\n    // Based on Public_int_i's suggestion. Saves a bunch of characters. If it matches the above\n    // speedwise, I'll be using it.\n    // p.y -= mod(p.y, .08); \n   \n    // Very cheap organic distortion. This line can be amalgamated below... I was a little suspicious\n    // about compilation order, but Greg Rostami is OK with it, so I am too. :)\n    // p /= _triWave(p.z+bumpIn_scr*10.0-bumpOut_scr*10.0, 100.0);\n    // p.z += syn_BPMTwitcher*0.1;\n\t// p = mix(p, floor(p)+smoothstep(vec3(0.0), vec3(1.0), fract(p)), ridges);\n    // p *= _triWave(p.z+bumpIn_scr*10.0-bumpOut_scr*10.0, 100.0);\n    // Return the absolute field value to ensure that the ray doesn't backtrack.\n    float dist = abs(dot(p = cos(p*.6 + sin(p.zxy*1.8-morph_time*0.05)+sin(p.z*0.1+morph_time*0.1)), p) - 1.1);\n    // dist = mix(dist, sdTorus(p, vec2(10.0))*0.1, ridges);\n    return dist;\n}\n\nvec4 renderMain(){\n    vec4 c = vec4(0.0);\n    vec2 u = _xy;\n\n    // The loosely centered and normalized unit direction ray, and the origin - initialized\n    // to zero. Characters can be saved by dropping \"d\" directly into the loop, but this way\n    // feels cleaner to me.\n    vec3 d = vec3(u/RENDERSIZE.y - .6, 1), o = d - d;\n    d.xz = _rotate(d.xz, camera_direction.x*0.7);\n    d.yz = _rotate(d.yz, camera_direction.y);\n\n    // Initializing \"c\" to zero... in a less than satisfactory way.\n    c -= c;\n    \n\t// Loop variables. Declaring the loop iteration variable, \"i,\" outside of the loop in a \n    // shader environment makes me a little nervous, but things seem to be compiling.\n    float j, i = 0.;\n    \n    // In order to save characters, it's customary to dispense with the early break.\n    // Of course, that means we're effectively calling the function for the entire loop\n    // count. Therefore, I figured I may as well try to take advantage of that... in as\n    // few characters as possible. :)\n\n    // Compiler's nightmare loop. :)\n    //\n    // Sketchy way to write a 100-count loop. Thanks to Aeikick for reminding me of that.\n    // It's tempting to stick the first line after the second semicolon, but I think it'll be\n    // skipped on the first iteration.\n    //for(int i=99; i-->0;)\n    // Slower \"float\" based loop, but uses fewer charaters. \"i\" is declared with \"j\"... It was \n    // BigWings's suggestion to  Nesvi7, so if it doesn't work, blame him. D\n    //for(; i++<1e2;) \n    for (int i = 0; i<50; i++) // Cleaner Web 2.0 suggestion, but Abje.\n        \n        // The distance function. Normally, the \"/3.\" wouldn't be there, but things have \n        // been shuffled around to save a few characters. By the way, the return distance, \"m(o),\"\n        // is absolute to ensure that the ray continues travelling forward.    \n        j = m(o)/3.,\n        \n        // If the distance to the surface comes within a certain threshold, add some lighting\n        // based on said distance. The \"m(o + const)\" is an old trick. It's kind of a meld between \n        // directional derivative lighting and occlusion... Something like that anyway. \"j\" is\n        // represetative of the current ray-to-surface distance. \"o.z\" is a rough approximation\n        // of the total distance, and is used for attenuation. Using \"o.z\" has the added benefit of\n        // giving the lighting a slight parallax feel.\n        //\n        // On a side note, using an \"if\" statement cuts down on characters, but I wanted this to\n        // be branchless to save a few cycles.\n        //\n        // IQ's suggestion: Faster, and saves some characters. I'd originally used a step function,\n        // which is apparently slower than the following. I read somewhere that the ternary \n        // operator isn't guaranteed not to branch on nontrivial calculations, but chances are\n        // minimal, or something to that effect. I've also read that it never branches with certain\n        // shader languages? ... I'll leave the debate to the experts. :)\n        // Fabrice suggested a couple of obvious changes to cut it down some more.\n        c -= j<.01 ? (j - .01)*m(o + .1)/(.02 + o.z/2e2) : 0.,\n        // Advance the ray in such a way that it encourages it to pass closely to the surface, but\n        // continue on its way.\n        o += max(.01, j)*d;\n                           \n\n    // Cheap color... I'd need to cut this down further to fit it in, but I prefer the black and \n    // white look anyway.\n    c.xyz += (d/o.z)*(syn_MidPresence+syn_MidLevel*syn_MidPresence+syn_MidLevel)*0.5*mids_color;\n    c.zyx += (.1 + o*.2*sin(o.z))*colorize; //Etc.\n    c += _loadImage(texIn, sin(_uv*10.0+TIME)*0.1+o.xy*0.2*(0.8+0.2*sin(TIME+_uvc.y*PI+_uv.x))+vec2(TIME*0.05, 0.0))*watery_tex;\n    c += texture(texIn2, 0.5+o.xy*0.1*(0.8+0.2*sin(TIME+_uvc.y*PI+_uv.x))+vec2(TIME*0.05, 0.0))*digital_tex;\n    // c += _loadImage(texIn, o.xy*0.2);\n\n    if (syn_MediaType > 0.5){\n        c += texture(syn_UserImage, 0.5+o.xy*0.1*(0.8+0.2*sin(TIME+_uvc.y*PI+_uv.x))+vec2(TIME*0.05, 0.0));\n    }\n\n    c += pow(c, vec4(3.0))*syn_HighHits*50.0*_pulse(sin(o.z*1.0-syn_HighTime), 1.0, 0.1)*flashing;\n    // c *= (0.25+syn_FadeInOut*0.75);\n\treturn c; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Transparent Isoslices","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0.200000002980232,0.200000002980232],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"spin","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":91.4499969482422,"DESCRIPTION":"","MAX":433,"MIN":11,"NAME":"seedX","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":243.210006713867,"DESCRIPTION":"","MAX":439,"MIN":17,"NAME":"seedY","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":6,"DESCRIPTION":"","MAX":10,"MIN":0.100000001490116,"NAME":"grid","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.850000023841858,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"spotlight","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":7.5,"DESCRIPTION":"","MAX":12,"MIN":1,"NAME":"edge","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":21,"DESCRIPTION":"","MAX":24,"MIN":1,"NAME":"glow","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"","MAX":0.5,"MIN":0,"NAME":"fill","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.990000009536743,"DESCRIPTION":"","MAX":1,"MIN":0.899999976158142,"NAME":"freq","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.29999995231628,"DESCRIPTION":"","MAX":2,"MIN":0.5,"NAME":"pulse","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":5,"MIN":0.100000001490116,"NAME":"pulserate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.20000004768372,"DESCRIPTION":"","MAX":5,"MIN":-5,"NAME":"thickness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"","MAX":1,"MIN":0.00999999977648258,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":3,"DESCRIPTION":"","MAX":5,"MIN":1,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\truchetduallevelspin.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"TruchetDualLevelSpin","IMAGES":null,"IMAGE_PATH":"truchetduallevelspin.synScene\\truchetduallevelspin.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.2,\n\t\t\t\t0.2\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"spin\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 91.45,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 433,\n\t\t\t\"MIN\" : 11,\n\t\t\t\"NAME\" : \"seedX\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 243.21,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 439,\n\t\t\t\"MIN\" : 17,\n\t\t\t\"NAME\" : \"seedY\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 6,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"grid\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.85,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"spotlight\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 7.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 12,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"edge\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 21,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 24,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"glow\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"fill\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.99,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.9,\n\t\t\t\"NAME\" : \"freq\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"pulse\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"pulserate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : -5,\n\t\t\t\"NAME\" : \"thickness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"truchetduallevelspin.png\",\n\t\"TITLE\" : \"TruchetDualLevelSpin\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n////////////////////////////////////////////////////////////////////\n// TruchetDualLevelSpin  by mojovideotech\n//\n// based on :\n// shadertoy.com\\/view\\/ltcfz2 by Shane\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////////////\n\n\n\n#define     twpi    6.2831853   // two pi, 2*pi\n\nvec2 hash22(vec2 p) { \n    return fract(sin(vec2(262144, 32768))*sin(dot(p*vec2(seedX,seedY), vec2(57, 27))));\n}\n \nvec2 rot( vec2 p ) {\n    float c = cos(TIME*spin.x), s = sin(TIME*spin.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec2(m*p.xy);\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n    float T = TIME * rate;             \n    float iRy = min(RENDERSIZE.y, 600.0);\n    vec2 uv = (_xy.xy - RENDERSIZE.xy*0.5)/iRy;\n    uv = rot(uv); \n    vec2 oP = uv*12.0 + vec2(0.5, T*0.5);\n    vec2 d = vec2(1e5), rndTh = vec2(freq, 1.0);\n    float dim = scale;    \n    for(int k=0; k<2; k++) {\n\t\tvec2 ip = floor(oP*dim);\n        vec2 rnd = hash22(ip);\n        if(rnd.x<rndTh[k]) {\n        \tfloat hd = 0.5/dim;\n            vec2 p = oP - (ip + 0.5)/dim;\n \t\t    d.y = abs(max(abs(p.x), abs(p.y)) - hd) - 0.333/grid;\n            p.y *= rnd.y>0.5? 1.0 : -1.0;\n            float aw = 0.5/3.0/dim;\n            p = p.x>-p.y? p : -p.yx;\n            d.x = abs(length(p - hd) - hd) - aw;\n            d.x *= k==1? -1.0 : 1.0;\n            d.x = min(d.x, (length(abs(p) - hd) - aw));\n            d.x -= 0.05*thickness;\n            d.x -= (sin(TIME*pulserate)*0.075*pulse);\n            break;\n        } \n        dim *= 2.0;\n    }\n    \n    vec3 col = vec3(0.0);\n    float fo = (10.1-grid)/iRy;\n    col = mix(col, vec3(0.0), (1.0 - smoothstep(0.0, fo*5.0, d.y - 0.1))*0.15); \n    col = mix(col, vec3(1.0), (1.0 - smoothstep(0.0, fo, d.y))*0.15);\n    fo = glow/iRy/sqrt(dim);\n    float sh = max(0.75 - d.x*edge, 0.0); \n    sh *= clamp(-sin(d.x*twpi*edge) + 1.0, 0.25, 1.0) + 0.0025; \n    col = mix(col, vec3(0.0), (1.0 - smoothstep(0.0, fo*5.0, d.x))*0.5); \n    col = mix(col, vec3(0.0), 1.0 - smoothstep(0.0, fo, d.x));    \n    col = mix(col, vec3(0.3)*sh, 1.0 - smoothstep(0.0, fo, d.x + 0.51-fill)); \n    col = mix(col, vec3(0.2, 0.3, 0.9)*sh, 1.0 - smoothstep(0.0, fo, abs(d.x + 0.12) - 0.02));\n    col = mix(col, col.gbr, uv.y*0.5 + 0.5);\n    col = mix(col, col*max(1.1 - length(uv)*0.95, 0.0), spotlight);\n    \n    out_FragColor = vec4(sqrt(max(col, 0.0)), 1.0);\n\nreturn out_FragColor; \n } \n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"TruchetDualLevelSpin","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.349999994039536,"DESCRIPTION":"Diameter of the tunnel. Default: 35%.","MAX":1,"MIN":0,"NAME":"diameter","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"transforms"},{"DEFAULT":1,"DESCRIPTION":"Change from a spiral to a flat cave.","MAX":0,"MIN":1,"NAME":"flatten","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"transforms"},{"DEFAULT":1,"DESCRIPTION":"Fewer ridges. Also clears up noise when tunnel diameter is widest.","MAX":0,"MIN":1,"NAME":"simplify","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"transforms"},{"DEFAULT":0,"DESCRIPTION":"Modifies the rotation ridges, can give you noise if you aren't careful.","MAX":1,"MIN":0,"NAME":"churner","TYPE":"slider","UI_GROUP":"transforms"},{"DEFAULT":0,"DESCRIPTION":"Field of View for the camera, a sort of zoom. Default 20%.","MAX":2.70000004768372,"MIN":-0.899999976158142,"NAME":"fov_in","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":[0,0],"DESCRIPTION":"XY Position in the tunnel for the camera.","MAX":[1,1],"MIN":[-1,-1],"NAME":"xyOffset","PARAMS":0.0500000007450581,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":[0,0],"DESCRIPTION":"Change direction the camera looks in a hemisphere. To look all the way backwards, you have to use 'look back' toggle.","MAX":[1,1],"MIN":[-1,-1],"NAME":"xyLook","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"Smoothly change to looking backwards. Make sure you move xyLook away from center before using this toggle, or it will be jerky!","MAX":1,"MIN":0,"NAME":"look_back","PARAMS":0.00999999977648258,"TYPE":"toggle smooth","UI_GROUP":"camera"},{"DEFAULT":0.300000011920929,"DESCRIPTION":"Scene fully lit up, or fully dark and flashing.","MAX":1,"MIN":0,"NAME":"col_presence","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0.00100000004749745,"DESCRIPTION":"Earthy color scheme, or move up for deeper, more complex colors.","MAX":2,"MIN":0.00100000004749745,"NAME":"deeper_colors","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"color"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Media must be on! Defines how much of the tunnel the media covers.","MAX":1,"MIN":0,"NAME":"media_width","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"color"}],"CREDIT":"aiekick","DESCRIPTION":"i have the limit of the float after a certain time, and some noise appears :)\nyou can increase the iteration at line 86 to have better shape but more slow too :) ","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\tunnel_beauty_6.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Tunnel Beauty 6","IMAGES":null,"IMAGE_PATH":"tunnel_beauty_6.synScene\\tunnel_beauty_6.png","JSON_CODE":"{\n   \"CONTROLS\" : \n   [\n      {\n         \"NAME\":\"diameter\",\n         \"UI_GROUP\":\"transforms\",\n         \"TYPE\":\"slider smooth\",\n         \"DESCRIPTION\":\"Diameter of the tunnel. Default: 35%.\",\n         \"MIN\":0.0,\n         \"MAX\":1.0,\n         \"PARAMS\":0.1,\n         \"DEFAULT\":0.35\n      },{\n         \"NAME\":\"flatten\",\n         \"TYPE\":\"slider smooth\",\n         \"DEFAULT\":1.0,\n         \"MAX\":0.0,\n         \"MIN\":1.0,\n         \"PARAMS\":0.01,\n         \"DESCRIPTION\":\"Change from a spiral to a flat cave.\",\n         \"UI_GROUP\":\"transforms\"\n      },{\n         \"NAME\":\"simplify\",\n         \"UI_GROUP\":\"transforms\",\n         \"TYPE\":\"slider smooth\",\n         \"MAX\":0.0,\n         \"DEFAULT\":1.0,\n         \"DESCRIPTION\":\"Fewer ridges. Also clears up noise when tunnel diameter is widest.\",\n         \"MIN\":1.0\n      },{\n         \"NAME\":\"churner\",\n         \"TYPE\":\"slider\",\n         \"UI_GROUP\":\"transforms\",\n         \"DESCRIPTION\":\"Modifies the rotation ridges, can give you noise if you aren't careful.\",\n         \"PARAMS\":0.01\n      },{\n         \"NAME\":\"fov_in\",\n         \"TYPE\":\"slider smooth\",\n         \"MIN\":-0.9,\n         \"MAX\":2.7,\n         \"DEFAULT\":0.0,\n         \"PARAMS\":0.05,\n         \"DESCRIPTION\":\"Field of View for the camera, a sort of zoom. Default 20%.\",\n         \"UI_GROUP\":\"camera\"\n      },{\n         \"NAME\":\"xyOffset\",\n         \"TYPE\":\"xy smooth\",\n         \"MIN\":-1.0,\n         \"MAX\":1.0,\n         \"DEFAULT\":0.0,\n         \"PARAMS\":0.05,\n         \"DESCRIPTION\":\"XY Position in the tunnel for the camera.\",\n         \"UI_GROUP\":\"camera\"\n      },{\n         \"NAME\":\"xyLook\",\n         \"TYPE\":\"xy smooth\",\n         \"MIN\":-1.0,\n         \"MAX\":1.0,\n         \"DEFAULT\":0.0,\n         \"PARAMS\":0.01,\n         \"DESCRIPTION\":\"Change direction the camera looks in a hemisphere. To look all the way backwards, you have to use 'look back' toggle.\",\n         \"UI_GROUP\":\"camera\"\n      },{\n         \"NAME\":\"look_back\",\n         \"TYPE\":\"toggle smooth\",\n         \"MIN\":0.0,\n         \"MAX\":1.0,\n         \"DEFAULT\":0.0,\n         \"DESCRIPTION\":\"Smoothly change to looking backwards. Make sure you move xyLook away from center before using this toggle, or it will be jerky!\",\n         \"UI_GROUP\":\"camera\"\n      },{\n         \"NAME\":\"col_presence\",\n         \"UI_GROUP\":\"color\",\n         \"TYPE\":\"slider smooth\",\n         \"PARAMS\":0.2,\n         \"MAX\":1.0,\n         \"DEFAULT\":0.3,\n         \"MIN\":0.0,\n         \"DESCRIPTION\":\"Scene fully lit up, or fully dark and flashing.\"\n      },{\n         \"NAME\":\"deeper_colors\",\n         \"UI_GROUP\":\"color\",\n         \"TYPE\":\"slider smooth\",\n         \"MAX\":2.0,\n         \"DEFAULT\":0.001,\n         \"MIN\":0.001,\n         \"DESCRIPTION\":\"Earthy color scheme, or move up for deeper, more complex colors.\"\n      },{\n         \"NAME\":\"media_width\",\n         \"UI_GROUP\":\"color\",\n         \"TYPE\":\"slider smooth\",\n         \"PARAMS\":0.2,\n         \"MAX\":1.0,\n         \"DEFAULT\":0.2,\n         \"MIN\":0.0,\n         \"DESCRIPTION\":\"Media must be on! Defines how much of the tunnel the media covers.\"\n      }\n   ]\n\n\n   ,\n   \"CREDIT\" : \"aiekick\",\n   \"DESCRIPTION\" : \"i have the limit of the float after a certain time, and some noise appears :)\\nyou can increase the iteration at line 86 to have better shape but more slow too :) \",\n   \"HARD_TRANSITIONS\" : null,\n   \"IMAGES\" : null,\n   \"IMAGE_PATH\" : \"tunnel_beauty_6.png\",\n   \"PASSES\" : [\n   {\n      \"TARGET\":\"toFilter\",\n      \"WIDTH\":640,\n      \"HEIGHT\":360\n   }\n   ],\n   \"SMOOTH_TRANSITIONS\" : null,\n   \"TITLE\" : \"Tunnel Beauty 6\",\n   \"HEIGHT\":1080,\n   \"WIDTH\":1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":360,"TARGET":"toFilter","WIDTH":640}],"SCRIPT_CODE":"","SHADER_CODE":"vec4 iMouse = vec4(720, 720, 0.0, 0.0); \n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z); \n    return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n}\n\nvec3 filter_() {\n  vec2 delta = 1. / RENDERSIZE;\n  \n  vec3 val = texture(toFilter, _uv).xyz;\n\n\n  vec3 l = texture(toFilter, _uv + vec2(0., delta.y)).xyz;\n  vec3 r = texture(toFilter, _uv - vec2(0., delta.y)).xyz;\n  vec3 u = texture(toFilter, _uv + vec2(delta.x, 0.)).xyz;\n  vec3 d = texture(toFilter, _uv - vec2(delta.x, 0.)).xyz;\n\n  vec3 n = vec3(_rand(_uvc+fract(TIME))) - 0.5;\n  \n  vec3 bloom = max(val, max(max(l, r), max( u, d)));\n  bloom = bloom  + l + r + u + d;\n  bloom /= 5.; // orlando;\n  return bloom + n/9.;\n\n}\n// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 2D path displacement.\nvec2 path(in float x){\n    \n    //return vec2(0); // Trivial, straight path.\n    //return vec2(cos(x*0.25)*1.8 + cos(x*0.15)*2., 0); // Perturbing \"X\" only.\n    // return vec2(cos(x*0.25)*1.8 + cos(x*0.15)*1.5, sin(x*0.25)*1.2 + sin(x*0.15) + tan(x*0.5)); // Perturbing \"X\" and \"Y.\"\n    return vec2(cos(x*0.25)*1.8 + cos(x*0.15)*1.5, sin(x*0.25)*1.2 + sin(x*0.15)); // Perturbing \"X\" and \"Y.\"\n\n}\n\n// Camera path. Arranged to coincide with the frequency of the tunnel.\nvec3 camPath(float t){\n  \n    return vec3(path(t), t*15.0);\n    \n}\n\nmat3 RotZ(float a)\n{\n    return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);\n}\n\nfloat df(vec3 p)\n{\n\tvec3 q = p;\n\n  q.xy += cos(TIME * 1.0+syn_HighTime);\n\tq *= RotZ(q.z * 0.1);\n  q += mix(vec3(0.0), sin(q.zxy * 0.5) * 0.5, simplify);\n\tq = mix(q, q*RotZ(q.z * 0.2), simplify);\n  q = sin(q.zxy * 0.2) * 1.5;\n  p += q;\n\n\tp = mix(p, p*RotZ(p.z * 0.045+q.x*churner), flatten);\n  return diameter*40.0 - abs(p.y*0.5);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy) - df(pos-eps.xyy),\n\t    df(pos+eps.yxy) - df(pos-eps.yxy),\n\t    df(pos+eps.yyx) - df(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 560100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 10.) col *= Temp/10.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 10;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += df(surfPoint);\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn df(p - n * s);\t\t\t\t\t\t// ratio between df step and constant step\n}\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n\tvec2 g = fragCoord;\n\tvec2 si = RENDERSIZE.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\n\tvec3 ro = vec3(0,0, syn_BassTime*0.4 * 15.); \n\tro.xy += vec2(sin(ro.z));\n  vec3 cv = ro + vec3(0,0,1); \n\tvec3 cu = normalize(vec3(0,1,0));\n\tvec3 z = normalize(cv-ro);\n  vec3 x = normalize(cross(cu,z));\n\tvec3 y = cross(z,x);\n  float fov = .9+fov_in;\n\tvec3 rd = normalize(fov * (uv.x * x + uv.y * y) + z);\n\t\n\tfloat perturbedAmt = pow(syn_Presence,1.5);\n\n\tfloat s = 1., d = 0.;\n\tfor (int i=0; i<90; i++) \n\t{\n\t\tro = vec3(xyOffset*50.0, syn_BassTime*0.4 * 15.); \n\t\tro.xy += vec2(sin(d*0.25),cos(d*0.25))*5.0*perturbedAmt;\n\t\tcv = ro + vec3(0,0,1)+vec3(xyLook*PI,-2.0*look_back); \n\t\tcu = normalize(vec3(0,1,0));\n\t\tz = normalize(cv-ro);\n\t\tx = normalize(cross(cu,z));\n\t\ty = cross(z,x);\n\t\tfov = .9+fov_in;\n\t\trd = normalize(fov * (uv.x * x + uv.y * y) + z);\n\t\tif (log(d*d/s/1e5)>0.) break;\n\t\td += (s=df(ro+rd*d))*.2;\n\t}\n\t\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tvec3 lid = normalize(ro-p); \t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, 0.1);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat diff = clamp( dot( n, lid ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, lid ), 0.0, 1.0 ),16.);\t\t// specular\n\tvec3 col = vec3(.8,.5,.2);\n    \n    // here the magic happen\n\tfloat sss = df(p - n*pow(deeper_colors,2.0))/0.1;\t\t\t\t\t\t\t\t// quick sss 0.001 of subsurface\n\t\n\tfloat sb = SubDensity(p, 0.01, 0.1);\t\t\t\t\t\t\t// deep subdensity from 0.01 to 0.1 (10 iterations)\n\tvec3 bb = clamp(blackbody(200. * sb),0.,1.);\t\t\t\t\t// blackbody color\n\tfloat sss2 = 0.8 - SubDensity(p, 3.); \t\t\t\t\t\t\t// one step sub density of df of 3 of subsurface\n\n  fragColor.rgb = (diff + fre + bb * sss2 * .8 + col * sss * .2) * 0.25 + spe * 1.2;\n\n  // fragColor.rgb*=0.5;\n  if (sb>0.05){\n  \tfragColor.rgb*=mix(syn_BassPresence*_pulse(fract(TIME+p.z*0.01)*1.5, 0.8, 0.2),1.0,col_presence);\n  }\n  if (sb<0.05){\n  \tfragColor.rgb*=mix(syn_OnBeat,1.0,col_presence);\n  }\n  fragColor.rgb += tex3D(syn_UserImage, p*0.01+0.5, n)*syn_Presence*0.9*_pulse(fract(-syn_BPMSin4+p.z*0.01), 0.5, media_width);\n\n\t// vigneting from iq Shader Mike : https://www.shadertoy.com/view/MsXGWr\n  vec2 q = g/si;\n  fragColor.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.55 );\n\n\treturn fragColor; \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n\tif (PASSINDEX == 1){\n\t\t// return texture()\n\t\treturn vec4(filter_(), 1.0);\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Tunnel Beauty 6","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1,"DESCRIPTION":"Toggle off for manual control of the fluid growth.","MAX":1,"MIN":0,"NAME":"auto_growth","TYPE":"toggle","UI_GROUP":"rate"},{"DEFAULT":0.899999976158142,"DESCRIPTION":"Manually control rate of growth","MAX":1,"MIN":0,"NAME":"manual_growth","TYPE":"slider","UI_GROUP":"rate"},{"DEFAULT":1,"DESCRIPTION":"Reset simulation","MAX":1,"MIN":0,"NAME":"reset","PARAMS":0.25,"TYPE":"bang smooth","UI_GROUP":"field"},{"DEFAULT":0,"DESCRIPTION":"Enable flashing arc pattern to chop up simulation.","MAX":1,"MIN":0,"NAME":"disrupt_field","TYPE":"toggle","UI_GROUP":"field"},{"DEFAULT":1,"DESCRIPTION":"This runs the simulation twice per frame. Turn it off for a slower simulation that is easier on your GPU.","MAX":1,"MIN":0,"NAME":"run_twice_fps","TYPE":"toggle","UI_GROUP":"field"},{"DEFAULT":-1.60000002384186,"DESCRIPTION":"Shifts the simulation between a smoke effect and finger like patterns","MAX":3,"MIN":-3,"NAME":"meltyDetail","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"field"},{"DEFAULT":0,"DESCRIPTION":"Scatter the simulation to add extra turbulence.","MAX":2,"MIN":0,"NAME":"scatter","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"field"},{"DEFAULT":1,"DESCRIPTION":"Increases the texture size, resulting in faster movement.","MAX":5,"MIN":0.0500000007450581,"NAME":"size_modifier","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"field"},{"DEFAULT":-1,"DESCRIPTION":"Increase to add smaller details to the scene, decrease to make larger details.","MAX":-2,"MIN":-0.100000001490116,"NAME":"curl_scale","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"field"},{"DEFAULT":0,"DESCRIPTION":"50% is default no zooming. Move up to zoom in, down to zoom out.","MAX":1.5,"MIN":-1.5,"NAME":"zooming","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"field"},{"DEFAULT":1,"DESCRIPTION":"Select from 3 color palettes","MAX":2,"MIN":0,"NAME":"color_palette","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"coloring"},{"DEFAULT":0,"DESCRIPTION":"Turn on for auto-rotating color palette","MAX":1,"MIN":0,"NAME":"color_rotate","TYPE":"toggle","UI_GROUP":"coloring"},{"DEFAULT":[0,0],"DESCRIPTION":"When on, automatically pulses the logo/media","MAX":[1,1],"MIN":[-1,-1],"NAME":"light_pos","PARAMS":0.100000001490116,"TYPE":"xy smooth","UI_GROUP":"coloring"},{"DEFAULT":0,"DESCRIPTION":"100% is full opacity for the media effect, 0% is just the normal simulation, no media.","MAX":1,"MIN":0,"NAME":"media_color_mix","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"media_color"},{"DEFAULT":0.5,"DESCRIPTION":"Affects how much the video is refracted by the simulation.","MAX":1,"MIN":0,"NAME":"media_refraction","PARAMS":0.0649999976158142,"TYPE":"slider smooth","UI_GROUP":"media_color"},{"DEFAULT":1,"DESCRIPTION":"When off, ignores the underlying 'color palette' and just uses the media. When on, multiplies the two.","MAX":1,"MIN":0,"NAME":"media_multiply","TYPE":"toggle","UI_GROUP":"media_color"},{"DEFAULT":0,"DESCRIPTION":"Pulse the media to add it to the feedback field","MAX":1,"MIN":0,"NAME":"media_pulse","PARAMS":0.0500000007450581,"TYPE":"bang smooth","UI_GROUP":"media_feedback"},{"DEFAULT":0,"DESCRIPTION":"When on, automatically pulses the logo/media","MAX":1,"MIN":0,"NAME":"media_pulse_auto","TYPE":"toggle","UI_GROUP":"media_feedback"},{"DEFAULT":0,"DESCRIPTION":"Add the media to the field in a different, more subtle way","MAX":1,"MIN":0,"NAME":"media_hint","TYPE":"slider","UI_GROUP":"media_feedback"},{"DEFAULT":0,"DESCRIPTION":"Toggle to add audio reactive tracers that dart around the scene.","MAX":1,"MIN":0,"NAME":"Tracers_on","TYPE":"toggle","UI_GROUP":"tracers"},{"DEFAULT":0.5,"DESCRIPTION":"Affects the speed of tracers when enabled.","MAX":1,"MIN":0.100000001490116,"NAME":"tracer_intensity","TYPE":"slider","UI_GROUP":"tracers"},{"DEFAULT":25,"DESCRIPTION":"Affects the size of tracers when enabled.","MAX":50,"MIN":10,"NAME":"tracer_size","TYPE":"slider","UI_GROUP":"tracers"},{"DEFAULT":[0,0],"DESCRIPTION":"Affects the position of tracers when enabled.","MAX":[1,1],"MIN":[-1,-1],"NAME":"tracer_control","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"tracers"}],"CREDIT":"cornusammonis","DESCRIPTION":"Fake fluid dynamical system that creates viscous-fingering-like flow patterns, and suturing patterns along boundaries. Original by cornusammonis from shadertoy","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\turbo_encabulator_fluid.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Turbo Encabulator Fluid","IMAGES":null,"IMAGE_PATH":"turbo_encabulator_fluid.synScene\\turbo_encabulator_fluid.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Toggle off for manual control of the fluid growth.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_growth\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"rate\"\n      },{\n         \"DEFAULT\" : 0.9,\n         \"DESCRIPTION\" : \"Manually control rate of growth\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"manual_growth\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"rate\"\n      },{\n         \"NAME\": \"reset\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"DEFAULT\":1.0,\n         \"PARAMS\": 0.25,\n         \"TYPE\": \"bang smooth\",\n         \"DESCRIPTION\": \"Reset simulation\",\n         \"UI_GROUP\" : \"field\"\n       },{\n          \"NAME\": \"disrupt_field\",\n          \"MAX\" : 1.0,\n          \"MIN\" : 0.0,\n          \"DEFAULT\":0.0,\n          \"TYPE\": \"toggle\",\n          \"DESCRIPTION\": \"Enable flashing arc pattern to chop up simulation.\",\n          \"UI_GROUP\" : \"field\"\n        },{\n           \"DEFAULT\" : 1.0,\n           \"DESCRIPTION\" : \"Select from 3 color palettes\",\n           \"MAX\" : 2.0,\n           \"MIN\" : 0.0,\n           \"NAME\" : \"color_palette\",\n           \"TYPE\" : \"slider smooth\",\n           \"PARAMS\":0.1,\n           \"UI_GROUP\" : \"coloring\"\n        },{\n           \"DEFAULT\" : 0,\n           \"DESCRIPTION\" : \"Turn on for auto-rotating color palette\",\n           \"MAX\" : 1.0,\n           \"MIN\" : 0.0,\n           \"NAME\" : \"color_rotate\",\n           \"TYPE\" : \"toggle\",\n           \"PARAMS\":0.1,\n           \"UI_GROUP\" : \"coloring\"\n        },{\n          \"DEFAULT\" : 0.0,\n          \"DESCRIPTION\" : \"When on, automatically pulses the logo/media\",\n          \"MAX\" : 1.0,\n          \"MIN\" : -1.0,\n          \"NAME\" : \"light_pos\",\n          \"TYPE\" : \"xy smooth\",\n          \"PARAMS\":0.1,\n          \"UI_GROUP\" : \"coloring\"\n        },{\n           \"DEFAULT\" : 0,\n           \"DESCRIPTION\" : \"100% is full opacity for the media effect, 0% is just the normal simulation, no media.\",\n           \"MAX\" : 1,\n           \"MIN\" : 0,\n           \"NAME\" : \"media_color_mix\",\n           \"PARAMS\" : 0.2,\n           \"TYPE\" : \"slider smooth\",\n           \"UI_GROUP\" : \"media_color\"\n        },      {\n           \"DEFAULT\" : 0.5,\n           \"DESCRIPTION\" : \"Affects how much the video is refracted by the simulation.\",\n           \"MAX\" : 1,\n           \"MIN\" : 0,\n           \"NAME\" : \"media_refraction\",\n           \"PARAMS\" : 0.065,\n           \"TYPE\" : \"slider smooth\",\n           \"UI_GROUP\" : \"media_color\"\n        },\n        {\n           \"DEFAULT\" : 1,\n           \"DESCRIPTION\" : \"When off, ignores the underlying 'color palette' and just uses the media. When on, multiplies the two.\",\n           \"MAX\" : 1,\n           \"MIN\" : 0,\n           \"NAME\" : \"media_multiply\",\n           \"TYPE\" : \"toggle\",\n           \"UI_GROUP\" : \"media_color\"\n        },{\n           \"DEFAULT\" : 1.0,\n           \"DESCRIPTION\" : \"This runs the simulation twice per frame. Turn it off for a slower simulation that is easier on your GPU.\",\n           \"MAX\" : 1.0,\n           \"MIN\" : 0.0,\n           \"NAME\" : \"run_twice_fps\",\n           \"TYPE\" : \"toggle\",\n           \"UI_GROUP\" : \"field\"\n        },\n        {\n           \"DEFAULT\" : -1.6,\n           \"DESCRIPTION\" : \"Shifts the simulation between a smoke effect and finger like patterns\",\n           \"MAX\" : 3.0,\n           \"MIN\" : -3.0,\n           \"NAME\" : \"meltyDetail\",\n           \"TYPE\" : \"slider smooth\",\n           \"UI_GROUP\" : \"field\"\n        },\n        {\n           \"DEFAULT\" : 0.0,\n           \"DESCRIPTION\" : \"Scatter the simulation to add extra turbulence.\",\n           \"MAX\" : 2,\n           \"MIN\" : 0,\n           \"NAME\" : \"scatter\",\n           \"TYPE\" : \"bang smooth\",\n           \"UI_GROUP\" : \"field\"\n        },\n        {\n           \"DEFAULT\" : 1.0,\n           \"DESCRIPTION\" : \"Increases the texture size, resulting in faster movement.\",\n           \"MAX\" : 5.0,\n           \"MIN\" : 0.05,\n           \"NAME\" : \"size_modifier\",\n           \"TYPE\" : \"slider smooth\",\n           \"UI_GROUP\" : \"field\"\n        },\n        {\n           \"DEFAULT\" : -1.0,\n           \"DESCRIPTION\" : \"Increase to add smaller details to the scene, decrease to make larger details.\",\n           \"MAX\" : -2.0,\n           \"MIN\" : -0.1,\n           \"NAME\" : \"curl_scale\",\n           \"TYPE\" : \"slider smooth\",\n           \"UI_GROUP\" : \"field\"\n        },\n        {\n           \"DEFAULT\" : 0,\n           \"DESCRIPTION\" : \"50% is default no zooming. Move up to zoom in, down to zoom out.\",\n           \"MAX\" : 1.5,\n           \"MIN\" : -1.5,\n           \"NAME\" : \"zooming\",\n           \"PARAMS\" : 0.00999999977648258,\n           \"TYPE\" : \"slider smooth\",\n           \"UI_GROUP\" : \"field\"\n        },\n        {\n          \"DEFAULT\" : 0.0,\n          \"DESCRIPTION\" : \"Pulse the media to add it to the feedback field\",\n          \"MAX\" : 1.0,\n          \"MIN\" : 0.0,\n          \"NAME\" : \"media_pulse\",\n          \"TYPE\" : \"bang smooth\",\n          \"UI_GROUP\" : \"media_feedback\",\n          \"PARAMS\" : 0.05\n        },\n        {\n          \"DEFAULT\" : 0.0,\n          \"DESCRIPTION\" : \"When on, automatically pulses the logo/media\",\n          \"MAX\" : 1.0,\n          \"MIN\" : 0.0,\n          \"NAME\" : \"media_pulse_auto\",\n          \"TYPE\" : \"toggle\",\n          \"UI_GROUP\" : \"media_feedback\"\n        },\n        {\n          \"DEFAULT\" : 0.0,\n          \"DESCRIPTION\" : \"Add the media to the field in a different, more subtle way\",\n          \"MAX\" : 1.0,\n          \"MIN\" : 0.0,\n          \"NAME\" : \"media_hint\",\n          \"TYPE\" : \"slider\",\n          \"UI_GROUP\" : \"media_feedback\"\n        },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Toggle to add audio reactive tracers that dart around the scene.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"Tracers_on\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"tracers\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Affects the speed of tracers when enabled.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0.1,\n         \"NAME\" : \"tracer_intensity\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"tracers\"\n      },\n      {\n         \"DEFAULT\" : 25,\n         \"DESCRIPTION\" : \"Affects the size of tracers when enabled.\",\n         \"MAX\" : 50,\n         \"MIN\" : 10,\n         \"NAME\" : \"tracer_size\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"tracers\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Affects the position of tracers when enabled.\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"tracer_control\",\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"tracers\"\n      }\n   ],\n   \"CREDIT\" : \"cornusammonis\",\n   \"DESCRIPTION\" : \"Fake fluid dynamical system that creates viscous-fingering-like flow patterns, and suturing patterns along boundaries. Original by cornusammonis from shadertoy\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"turbo_encabulator_fluid.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 900,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 1600\n      },      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 900,\n         \"TARGET\" : \"BuffB\",\n         \"WIDTH\" : 1600\n      }\n   ],\n   \"TITLE\" : \"Turbo Encabulator Fluid\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":900,"TARGET":"BuffA","WIDTH":1600},{"FLOAT":true,"HEIGHT":900,"TARGET":"BuffB","WIDTH":1600}],"SCRIPT_CODE":"","SHADER_CODE":"vec3 _grad3(vec3 col1, vec3 col2, vec3 col3, float mixVal){\n    mixVal *= 2.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    return mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n}\n\nvec3 _grad4(vec3 col1, vec3 col2, vec3 col3, vec3 col4, float mixVal){\n    mixVal *= 3.0;\n    float mix1 = clamp(mixVal,0.0,1.0);\n    float mix2 = clamp(mixVal-1.0, 0.0, 1.0);\n    float mix3 = clamp(mixVal-2.0, 0.0, 1.0);\n    vec3 firstTwo = mix(mix(col1, col2, mix1), mix(col2, col3, mix2), step(1.0, mixVal));\n    return mix(firstTwo, mix(col3, col4, mix3), step(2.0, mixVal));\n}\n\n\t\t\t//******** BuffA Code Begins ********\nvec3 components;\nvec3 tx;\nvec3 txPlain;\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// Begin IQ's simplex noise:\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\n}\n\n// End IQ's simplex noise\n\n//arc flashing functions\nfloat uvrand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat arc(vec2 coord)\n{\n    const float pi = 3.1415926;\n    float t = syn_BeatTime * 7.3962;\n\n    vec2 sc = coord;\n    float phi = atan(sc.y, sc.x + 1e-6);\n    vec2 pc = vec2(fract(phi / (pi * 2) + syn_BassTime*0.01), length(sc));\n\n    vec2 org = vec2(0.5+0.5*sin(syn_BeatTime), 0.5+0.5*sin(syn_BeatTime));\n    vec2 wid = vec2(0.5, 0.5);\n\n    for (int i = 0; i < 4; i++)\n    {\n        if (uvrand(org + t) < 0.04 * i) break;\n        wid *= 0.5;\n        org += wid * (step(org, pc) * 2 - 1);\n    }\n\n    return uvrand(org);\n}\n\nfloat arcGridPattern()\n{\n    vec4 delta = vec4(-1, -1, 1, 1) * 0.5;\n    delta *= (1/RENDERSIZE.y);\n\n    // neightbor four samples\n    float c1 = arc(abs(_uvc)*0.4 + delta.xy);\n    float c2 = arc(abs(_uvc)*0.4 + delta.zy);\n    float c3 = arc(abs(_uvc)*0.4 + delta.xw);\n    float c4 = arc(abs(_uvc)*0.4 + delta.zw);\n\n    // roberts cross operator\n    float gx = c1 - c4;\n    float gy = c2 - c3;\n    float g = sqrt(gx * gx + gy * gy);\n\n    return g*4;\n}\n\n\nvec2 pattern(vec2 p)\n{\n  p = fract(p);\n  float r = 10.123;\n  float v = 0.0, g = 0.0;\n  r = fract(r * 9184.928);\n  float cp, d;\n\n  d = p.x;\n  g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n  d = p.y;\n  g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n  d = p.x - 1.0;\n  g += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n  d = p.y - 1.0;\n  g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\n  const int iter = 12;\n  for(int i = 0; i < iter; i ++)\n  {\n    cp = 0.5 + (r - 0.5) * 0.9;\n    d = p.x - cp;\n    g += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n    if(d > 0.0) {\n      r = fract(r * 4829.013);\n      p.x = (p.x - cp) / (1.0 - cp);\n      v += 1.0;\n    }\n    else {\n      r = fract(r * 1239.528);\n      p.x = p.x / cp;\n    }\n    p = p.yx;\n  }\n  v /= float(iter);\n  return vec2(g, v);\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec3 advect(sampler2D buff, vec2 ab, vec2 vUv, vec2 step, float sc) {\n\n    vec2 aUv = vUv - ab * sc * step;\n\n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n\n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec3 uv =    texture(buff, fract(aUv)).xyz;\n    aUv -= _pulse(uv.z, -0.8, 0.2)*ab*0.2*syn_BPMTri2/syn_BPMConfidence;\n    vec3 uv_n =  texture(buff, fract(aUv+n)).xyz;\n    vec3 uv_e =  texture(buff, fract(aUv+e)).xyz;\n    vec3 uv_s =  texture(buff, fract(aUv+s)).xyz;\n    vec3 uv_w =  texture(buff, fract(aUv+w)).xyz;\n    vec3 uv_nw = texture(buff, fract(aUv+nw)).xyz;\n    vec3 uv_sw = texture(buff, fract(aUv+sw)).xyz;\n    vec3 uv_ne = texture(buff, fract(aUv+ne)).xyz;\n    vec3 uv_se = texture(buff, fract(aUv+se)).xyz;\n\n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nfloat pulseMedia = (media_pulse)*0.15 + media_pulse_auto*(sin(syn_BPMTwitcher*PI)*0.15);\nfloat sizeMod = mix(1.0, 0.5+(sin(_uvc.x*5.0+TIME*0.1)*_uv.y+cos(_uvc.x*4.7-TIME*0.47)+cos(_uvc.x*11.0+TIME*0.89)*(1.0-_uv.y))/6.0, 1.0);\n\n\nvec4 renderPassA(sampler2D buff) {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n  const float _K0 = -20.0/6.0; // center weight\n  const float _K1 = 4.0/6.0;   // edge-neighbors\n  const float _K2 = 1.0/6.0;   // vertex-neighbors\n\tfloat cs = curl_scale; // curl scale\n\n  float ls = 0.3-syn_BassPresence*0.295;  // laplacian scale\n  float ps = meltyDetail - (cos(syn_BeatTime*0.1) * 0.5);  // laplacian of divergence scale\n  float ds = -abs(0.13 - (syn_ToggleOnBeat/50.)); // divergence scale\n  const float dp = -0.04; // divergence update scale\n  const float pl = 0.3;   // divergence smoothing\n  float ad = 4. + syn_Level*2.0 - syn_HighHits*2.0;   // advection distance scale\n  ad = mix(ad, 6.0*manual_growth, 1.0-auto_growth);\n\n  const float pwr = 1.0;  // power when deriving rotation angle from curl\n  const float amp = 1.0;  // self-amplification\n  float upd = 0.7 - (syn_BassHits/3.)*0.6;  // update smoothing\n  upd = mix(upd, 0.9-manual_growth*0.6, 1.0-auto_growth);\n  float sq2 = 0.6 + scatter;  // diagonal weight\n\n\n\n\tvec2 vUv = _uv;\n  vec2 texel = sizeMod*size_modifier / RENDERSIZE.xy;\n\tvUv -= _uvc*0.0005*zooming;\n\n  // 3x3 neighborhood coordinates\n  float step_x = texel.x;\n  float step_y = texel.y;\n  vec2 n  = vec2(0.0, step_y);\n  vec2 ne = vec2(step_x, step_y);\n  vec2 e  = vec2(step_x, 0.0);\n  vec2 se = vec2(step_x, -step_y);\n  vec2 s  = vec2(0.0, -step_y);\n  vec2 sw = vec2(-step_x, -step_y);\n  vec2 w  = vec2(-step_x, 0.0);\n  vec2 nw = vec2(-step_x, step_y);\n\n\t// uv.x and uv.y are the x and y components, uv.z is divergence\n  vec3 uv =    texture(buff, fract(vUv)).xyz;\n  vec3 uv_n =  texture(buff, fract(vUv+n)).xyz;\n  vec3 uv_e =  texture(buff, fract(vUv+e)).xyz;\n  vec3 uv_s =  texture(buff, fract(vUv+s)).xyz;\n  vec3 uv_w =  texture(buff, fract(vUv+w)).xyz;\n  vec3 uv_nw = texture(buff, fract(vUv+nw)).xyz;\n  vec3 uv_sw = texture(buff, fract(vUv+sw)).xyz;\n  vec3 uv_ne = texture(buff, fract(vUv+ne)).xyz;\n  vec3 uv_se = texture(buff, fract(vUv+se)).xyz;\n  // float pat = pattern(_toPolar((_uv-0.5)*vec2(RENDERSIZE.x/RENDERSIZE.y,1.0))*vec2(1.0, 1.0)+vec2(-syn_BassTime*0.005, 0.0)).r;\n  // pat = clamp(step(1.4, pat), 0.0, 1.0)*_pulse(length(_uvc), 0.5, 0.35);\n  vec3 blurUv = (uv_n+uv_s+uv_w+uv_e)/4.0;\n\n  float pat = arcGridPattern();\n\n\tvec3 arcFlash = vec3(1.0)*pat*syn_OnBeat*disrupt_field;\n\n    // laplacian of all components\n    vec3 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    float sp = ps * lapl.z;\n\n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n\n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n\n\n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    float sd = uv.z + dp * div + pl * lapl.z;\n\n    vec2 norm = normz(uv.xy);\n    vec3 ab = advect(buff, vec2(uv.x, uv.y), vUv, texel, ad);\n\n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * sp + uv.x * ds * sd;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * sp + uv.y * ds * sd;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n\n    uv = mix(uv, blurUv, syn_BPMTri2/syn_BPMConfidence);\n    float addSpot = 1/(0.5+distance(_uvc, vec2(0.5*sin(TIME), 0.5*cos(TIME))));\n    // uv.z += (-0.5+(syn_BPMTri2/syn_BPMConfidence))*0.05*addSpot*_pulse(uv.z, 0.0, 0.1);\n    vec3 abd = upd*uv + (1.0-upd)*vec3(a,b,sd);\n\n\t\t//add arc flashing\n\t\tabd.xy += (normz(arcFlash.xy))*mix(-1.0, 1.0, syn_OnBeat)*normalize(_uvc);\n\n\t\tfloat mediaLum = 0.5-(dot(txPlain.rgb, vec3(1.0))/3.0);\n\n\t\tabd.xy -= 1.0*mediaLum*pulseMedia;\n\n    abd.z -= mediaLum*media_hint*media_hint*media_hint*media_hint*0.5;\n\n\t\t//Tracers\n\t\tif(Tracers_on > 0.5)\n\t\t{\n\t\t\tvec2 d = fragCoord.xy;\n\t\t\tfloat maxTracers = 8.;\n\t\t\tvec2 flowVec = vec2(0.);\n\t\t\tfor(int i = 0; i < maxTracers; i++)\n\t\t\t{\n\t\t\t\tflowVec = vec2(abs(sin(syn_Time*2*PI*0.004*(syn_Presence*sin(i))*tracer_intensity)),abs(cos(syn_HighTime*2*PI*0.008*(syn_HighPresence*cos(i))+i*tracer_intensity)));\n\t\t\t\tflowVec += tracer_control;\n\t\t\t\td  = fragCoord.xy - smoothstep(-0.1, 1.1, flowVec)*RENDERSIZE.xy;\n\t\t\t\tfloat m = exp(-length(d) / (tracer_size + i - syn_BassHits));\n\t\t\t\tabd.xy += m * normz(d);\n\t\t\t}\n\t\t}\n\n    // initialize with noise\n    if(FRAMECOUNT<3 || reset > 0.5) {\n\t\tvec3 rnd = vec3(noise(7.0 * vUv + 1.1 * syn_HighLevel), noise(9.0 * vUv + 2.2 * syn_BassLevel), noise(8.0 * vUv + 3.3 * syn_MidLevel));\n\t\t\tfragColor = vec4(rnd, 1);\n    } else {\n      abd.z = clamp(abd.z, -1.0, 1.0);\n      abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n      abd.xy = abd.xy;\n      fragColor = vec4(abd, 1.0);\n    }\n\n\treturn fragColor;\n }\n\n// Visualization of the system in Buffer A\nvec4 renderMainImage(sampler2D buff) {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n    vec2 uv = fragCoord.xy / RENDERSIZE.xy;\n    float freq = 5.0;\n    // vec2 warp = 0.5000*cos( uv.xy*1.0*freq + vec2(0.0,1.0) + TIME*0.2 ) +\n    //             0.2500*cos( uv.yx*2.3*freq + vec2(1.0,2.0) + TIME*0.2 ) +\n    //             0.1250*cos( uv.xy*4.1*freq + vec2(5.0,3.0) + TIME*0.2 ) +\n    //             0.0625*cos( uv.yx*7.9*freq + vec2(3.0,4.0) + TIME*0.2 );\n\n    // uv += warp*0.01;\n    vec3 c = texture(buff, uv).xyz;\n    vec3 norm = normalize(c);\n\t\t//Color assignment\n\t\t//TODO: fine tune colors\n\t\tfloat color1 = _pulse(color_palette, 0.0, 1.0);\n\t\tfloat color2 = _pulse(color_palette, 1.0, 1.0);\n\t\tfloat color3 = _pulse(color_palette, 2.0, 1.0);\n\n    vec3 rbcol =  0.2 - 0.75*cross(norm.xyz, vec3(color1, -color2, color3));\n\t\t// vec3 rbcol = 0.4 + color_tuning * cross(norm.xyz, vec3(0.5, -0.4, 0.5));\n    // rbcol = vec3(0.0);\n    // vec3 texCol = _loadUserImage().rgb;\n    norm.xy = _rotate(norm.xy, syn_HighTime*0.4*color_rotate);\n    // float lum = pow(dot(texCol, vec3(1.0))/3.0,2.0)*2.0;\n    // lum = clamp(lum, 0.0, 1.0);\n    rbcol += norm.x*vec3(0.1,0.6,0.7)*(1.0+0.3*syn_HighHits)*0.5;\n    rbcol += norm.y*vec3(0.9,0.6,0.0)*0.5;\n    rbcol += vec3(pow(dot(norm,vec3(light_pos, 0.0)),3.0))*0.75;\n    // rbcol *= mix(1.0, pow(clamp(c.b, 0.0, 1.0), 0.15), dark_valleys);\n    // rbcol += texCol;\n    // col += texCol*texCol*0.25;\n\n    // col += f*pow(threeColMix(vec3(0.0), vec3(1.0,0.0,0.0), vec3(0.0,0.0,1.0), pow(f,10.0)),vec3(2.0));\n    // col += _pulse(f, 1.0, 0.01)*syn_HighHits*noise(vec3(_uvc*15.0,TIME*2.0))*1.5;\n    // col += 2.0*f*pow(_palette(diff, vec3(0.500, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.500, 0.250, 0.750), vec3(0.500, 0.500, 0.500)),vec3(2.0));\n\n\n\t\t//attempts at color tuning\n    // rbcol = _rgb2hsv(rbcol);\n\t\t// rbcol.x -= color3/2;\n\t\t// fragColor = vec4(_hsv2rgb(rbcol), 1.);\n\n\t\tfragColor = vec4(rbcol, 1.);\n\t\tfragColor = _gamma(fragColor, 1.1);\n\t\tfragColor = clamp(fragColor, 0.0, 1.0);\n\t\t//mix in media for final image\n\n    vec3 texCol = vec3(0.0);\n\n    if (media_multiply > 0.5){\n        texCol = fragColor.rgb*tx*1.2;\n    } else {\n        texCol = 2.0*tx*dot(fragColor.rgb, vec3(1.0))/3.0;\n    }\n\n    fragColor.rgb = mix(fragColor.rgb, texCol, media_color_mix);\n\treturn fragColor;\n }\n\n\nvec4 renderMain(){\n  components = texture(BuffA, _uv).xyz;\n  tx = _loadUserImage(vec2(components.z*media_refraction*media_refraction)).xyz;\n  txPlain = _loadUserImage().xyz;\n\n\tif(PASSINDEX == 0){\n\t\treturn renderPassA(BuffB);\n\t}\n\tif(PASSINDEX == 1){\n\t\tif (run_twice_fps > 0.5){\n\t\t\treturn renderPassA(BuffA);\n\t\t} else {\n\t\t\treturn texture(BuffA, _uv);\n\t\t}\n\t}\n\tif(PASSINDEX == 2){\n\t\treturn renderMainImage(BuffA);\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Turbo Encabulator Fluid","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":1.5,"DESCRIPTION":"","MAX":5,"MIN":0.25,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":7,"DESCRIPTION":"","MAX":16,"MIN":1,"NAME":"loops","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":0.999000012874603,"MIN":0.00100000004749745,"NAME":"phase","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"rot_bool","TYPE":"toggle","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"sparse_bool","TYPE":"toggle","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"based on http://glslsandbox.com/e#42684.2","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\twistycoloredbars.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"TwistyColoredBars","IMAGES":null,"IMAGE_PATH":"twistycoloredbars.synScene\\twistycoloredbars.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 5,\n\t\t\t\"MIN\" : 0.25,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 7,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 16,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"loops\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.999,\n\t\t\t\"MIN\" : 0.001,\n\t\t\t\"NAME\" : \"phase\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rot_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"sparse_bool\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"based on http://glslsandbox.com/e#42684.2\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"twistycoloredbars.png\",\n\t\"TITLE\" : \"TwistyColoredBars\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"bool sparse = (sparse_bool > 0.5); \nbool rot = (rot_bool > 0.5); \n\n\n////////////////////////////////////////////////////////////\n// TwistyColoredBars  by mojovideotech\n//\n// based on :\n// Twisting Bars  by @hintz\n// glslsandbox.com/\\e#42684.4\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 o = ((_xy.xy - RENDERSIZE.xy/2.0)*scale)/RENDERSIZE.y;\n\tif (rot) o.xy = o.yx; \n\tfloat T = TIME * rate, p = 0.5+floor(5.0*o.x), q;\n\tif (sparse) q = 0.4; \n\t\telse q = 0.2; \n\to.x = mod(o.x, q) - 0.1;\n\to.y+=p;\n\tvec4 s = 0.1*cos(1.6*vec4(0,1,2,3)+p*phase*T+sin(o.y*loops+p*loops+cos(T))),\n\te = s.yzwx, \n\tf = min(o.x-s,e-o.x);\n\tout_FragColor = dot(clamp(-1.0+f*RENDERSIZE.y,0.0,1.0),28.0*(s-e))*(s-0.22)+f*0.5;\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"TwistyColoredBars","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[3,3],"MIN":[-3,-3],"NAME":"center","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":3,"MIN":0.5,"NAME":"zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.0500000007450581,"DESCRIPTION":"","MAX":0.100000001490116,"MIN":0.00999999977648258,"NAME":"offset","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":3,"DESCRIPTION":"","MAX":9,"MIN":0,"NAME":"glow","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00124999997206032,"DESCRIPTION":"","MAX":0.00249999994412065,"MIN":0.000500000023748726,"NAME":"intensity","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":40,"DESCRIPTION":"","MAX":100,"MIN":10,"NAME":"trace","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":24,"DESCRIPTION":"","MAX":60,"MIN":6,"NAME":"runtime","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":2,"MIN":-2,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\ultimatekalicircuits.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"UltimateKaliCircuits","IMAGES":null,"IMAGE_PATH":"ultimatekalicircuits.synScene\\ultimatekalicircuits.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t3,\n\t\t\t\t3\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-3,\n\t\t\t\t-3\n\t\t\t],\n\t\t\t\"NAME\" : \"center\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0.5,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.05,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.1,\n\t\t\t\"MIN\" : 0.01,\n\t\t\t\"NAME\" : \"offset\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 9,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"glow\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.00125,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.0025,\n\t\t\t\"MIN\" : 0.0005,\n\t\t\t\"NAME\" : \"intensity\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 40,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 10,\n\t\t\t\"NAME\" : \"trace\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 24,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 60,\n\t\t\t\"MIN\" : 6,\n\t\t\t\"NAME\" : \"runtime\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 2,\n\t\t\t\"MIN\" : -2,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"ultimatekalicircuits.png\",\n\t\"TITLE\" : \"UltimateKaliCircuits\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n////////////////////////////////////////////////////////////\n// UltimateKaliCircuits  by mojovideotech\n//\n// based on :\n// shadertoy/XlX3Rj  by Kali\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////\n\n\n\n#define \tpisq  \t9.869604401089359\t// pi squared, pi^2\n#define \ttwpi  \t6.283185307179586  \t// two pi, 2*pi\n#define \tphicu  \t4.236067977499791 \t// phi cubed, phi^3\n#define \tcuphi  \t1.173984996705329   // cube root of phi\n#define \trctwpi  0.159154943091895\t// reciprocal of twpi, 1/twpi      \n#define\t\tr36\t\t0.027777777777778\n\n\nvec3 color = vec3(0.0,0.5,0.0);\nfloat S = glow;\nfloat T = rate*TIME*0.005;\n\nvec2 hash22(vec2 p) { return fract(vec2(21.0, 97.0)*sin(dot(p, vec2(92.0, 61.0)))); }\n\nvoid formula(vec2 z, float f) \n{\n\tfloat m = 0.0; \n\tfloat o, ot2, ot=ot2=10000.0;\n\tfor (int i=0; i<9; i++) {\n\t\tz = abs(z)/clamp(dot(z,z), 0.1, 0.5)-f;\n\t\tfloat l = length(z);\n\t\to = min(max(abs(min(z.x, z.y)),-l+0.25), abs(l-0.25));\n\t\tot = min(ot, o);\n\t\tot2 = min(l*0.1, ot2);\n\t\tm = max(m, float(i)*(1.0-abs(sign(ot-o))));\n\t}\n\tm += 1.0;\n\tfloat w = intensity*m*2.0;\n\tfloat circ = pow(max(0.0,w-ot2)/w,6.0);\n\tS += max(pow(max(0.0,w-ot)/w,0.25),circ);\n\tvec3 col = vec3(hash22(z),f);\n    color += col*(0.4+mod(m/9.0-T*trace+ot2*2.0, 1.0)*1.6);\n\tcolor += vec3(1.0, 0.7, 0.3)*circ*(10.0-m)*3.0\n\t\t\t *smoothstep(0.0, 0.5, vec3(f, _uv));\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 pos = 2.0 * _xy.xy - RENDERSIZE.xy;\n\tpos /= max(RENDERSIZE.x,RENDERSIZE.y);\n\tvec2 uv = pos-center;\n\tuv *= 4.0-zoom;\n\tfloat a = T + mod(T, floor(runtime))*cuphi;\n\tfloat b = a*phicu;\n\tuv *= mat2(cos(b),sin(b),-sin(b),cos(b));\n\tuv += vec2(sin(a),cos(a*cuphi))*pisq;\n\tuv *= offset;\n\tfloat pix = cuphi/RENDERSIZE.x*offset;\n\tfloat c = 1.5+mod(floor(T), 16.0)*0.125;\n\tfor (int aa=0; aa<36; aa++) {\n\t\tvec2 aauv = floor(vec2(float(aa)*rctwpi, mod(float(aa), twpi)));\n\t\tformula(uv+aauv*pix, c);\n\t}\n\tS *= r36, color *= r36;\n\tvec3 colo = mix(vec3(0.025), color, S)*(1.5-length(pos)); \t\n\tcolo *= vec3(1.2, 1.1, 1.0);\n\tout_FragColor = vec4(colo, 1.0);\n\nreturn out_FragColor; \n } \n\n\n\n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"UltimateKaliCircuits","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"v1","MAX":1,"MIN":0,"NAME":"v1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"v2","MAX":1,"MIN":0,"NAME":"v2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"v3","MAX":1,"MIN":0,"NAME":"v3","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.628319978713989,"DESCRIPTION":"v4","MAX":0.628319978713989,"MIN":0,"NAME":"v4","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.600000023841858,"DESCRIPTION":"v5","MAX":0.899999976158142,"MIN":0.300000011920929,"NAME":"v5","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.00499999988824129,"DESCRIPTION":"v6","MAX":0.0500000007450581,"MIN":0.00499999988824129,"NAME":"v6","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"","DESCRIPTION":"Automatically converted from http://glslsandbox.com/e#36696.0","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\untitled_sketch.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Untitled Sketch","IMAGES":null,"IMAGE_PATH":"untitled_sketch.synScene\\untitled_sketch.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"v1\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"v1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"v2\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"v2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"v3\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"v3\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.62832,\n\t\t\t\"DESCRIPTION\" : \"v4\",\n\t\t\t\"MAX\" : 0.62832,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"v4\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.6,\n\t\t\t\"DESCRIPTION\" : \"v5\",\n\t\t\t\"MAX\" : 0.9,\n\t\t\t\"MIN\" : 0.3,\n\t\t\t\"NAME\" : \"v5\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.005,\n\t\t\t\"DESCRIPTION\" : \"v6\",\n\t\t\t\"MAX\" : 0.05,\n\t\t\t\"MIN\" : 0.005,\n\t\t\t\"NAME\" : \"v6\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"\",\n\t\"DESCRIPTION\" : \"Automatically converted from http://glslsandbox.com/e#36696.0\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"untitled_sketch.png\",\n\t\"TITLE\" : \"Untitled Sketch\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 p = (_xy.xy*2.0-RENDERSIZE)/min(RENDERSIZE.x,RENDERSIZE.y);\n\tfloat ratio = (RENDERSIZE.x/2.)/(RENDERSIZE.y);\n\tvec3 destColor = vec3(v5);\n\tfloat f = 0.1;\n\tfor(float i = 0.0; i < 10.0; i++){\n        \tfloat s = sin(i * v4) * v2 * sin(TIME);\n        \tfloat c = cos(i * v4) * v3 * sin(TIME);\n\t\tf += v6 / abs(length(p + vec2(c, s)) - v1);\n\t}\n\tout_FragColor = vec4(destColor*f, 1.0);\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Untitled Sketch","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Sends a pulse outward from the center, leaving a dark hole in the middle of the screen after it passes.","MAX":1,"MIN":0,"NAME":"pulse_out","PARAMS":0.00499999988824129,"TYPE":"bang smooth","UI_GROUP":"simulation"},{"DEFAULT":0,"DESCRIPTION":"Sends a pulse through all the veins on screen at once, changing and rotating their shape.","MAX":1,"MIN":0,"NAME":"full_pulse","PARAMS":0.100000001490116,"TYPE":"bang smooth","UI_GROUP":"simulation"},{"DEFAULT":0,"DESCRIPTION":"When on, pulls all the veins backwards, making it much more minimal/amorphous.","MAX":1,"MIN":0,"NAME":"retract","TYPE":"toggle","UI_GROUP":"simulation"},{"DEFAULT":0,"DESCRIPTION":"When on, devolves into a sort of random chaos of ripples and bursts.","MAX":1,"MIN":0,"NAME":"devolve","TYPE":"toggle","UI_GROUP":"simulation"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"Heartbeat, or breathing, that oscillates in and out every other bar. This affects the intensity.","MAX":0.5,"MIN":0.100000001490116,"NAME":"heartbeat_intensity","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"simulation"},{"DEFAULT":4,"DESCRIPTION":"Select from one of 5 color palettes. From bottom to top: Blood, Firey Orange/Blue, Green Forest, Blue Sky, Black/White.","MAX":0,"MIN":4,"NAME":"color_palette","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"coloration"},{"DEFAULT":0,"DESCRIPTION":"50% is default: no melting up or down. Move up to melt up and in, down to melt down and out.","MAX":1.5,"MIN":-1.5,"NAME":"melt_up_or_down","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"distortion"},{"DEFAULT":0,"DESCRIPTION":"50% is default no zooming. Move up to zoom in, down to zoom out.","MAX":1.5,"MIN":-1.5,"NAME":"zooming","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"distortion"},{"DEFAULT":0,"DESCRIPTION":"When ON, paint1 is enabled. Audio-reactive paintbrush that drips extra fluid onto the simulation.","MAX":1,"MIN":0,"NAME":"paint1_on","TYPE":"toggle","UI_GROUP":"paint1"},{"DEFAULT":[0,0],"DESCRIPTION":"Mirrored painting for better effect.","MAX":[1,1],"MIN":[-1,-1],"NAME":"paint1XY","PARAMS":0.025000000372529,"TYPE":"xy smooth","UI_GROUP":"paint1"},{"DEFAULT":1,"DESCRIPTION":"Size & intensity of the effect for paint1.","MAX":0.300000011920929,"MIN":2,"NAME":"brush_size1","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"paint1"},{"DEFAULT":0,"DESCRIPTION":"When ON, paint2 is enabled. Pulls around the simulation like a dipping your finger into liquid.","MAX":1,"MIN":0,"NAME":"paint2_on","TYPE":"toggle","UI_GROUP":"paint2"},{"DEFAULT":[0,0],"DESCRIPTION":"Mirrored painting, but also TWO KINDS of brushes in one XY pad. On left half of the pad = a wide brush. Right half = more simple circular brush.","MAX":[1,1],"MIN":[-1,-1],"NAME":"paint2XY","PARAMS":0.025000000372529,"TYPE":"xy smooth","UI_GROUP":"paint2"},{"DEFAULT":0,"DESCRIPTION":"Grabs a frame from the underlying media and resets the simulation based on the brightness.","MAX":1,"MIN":0,"NAME":"grab_frame","TYPE":"bang","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"100% is full opacity for the media effect, 0% is just the normal simulation, no media.","MAX":1,"MIN":0,"NAME":"opacity","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0.5,"DESCRIPTION":"Affects how much the video is refracted by the simulation.","MAX":1,"MIN":0,"NAME":"refraction","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"When off, ignores the underlying 'color palette' and just uses the media. When on, multiplies the two.","MAX":1,"MIN":0,"NAME":"combine_colors","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Resets the simulation back to its initial state. The panic button when you don't like what is going on.","MAX":1,"MIN":0,"NAME":"reset_sim","TYPE":"bang","UI_GROUP":"reset"}],"CREDIT":"cornusammonis","DESCRIPTION":"A dendritic dynamical system. Click to paint.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\vein_melter.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":720,"ID":"Vein Melter","IMAGES":[{"NAME":"image45","PATH":"images/45.jpg"},{"NAME":"image16","PATH":"images/16.png"}],"IMAGE_PATH":"vein_melter.synScene\\vein_melter.png","JSON_CODE":"{\n   \"TITLE\" : \"Vein Melter\",\n   \"CREDIT\" : \"cornusammonis\",\n   \"DESCRIPTION\" : \"A dendritic dynamical system. Click to paint.\",\n   \"WIDTH\" : 1280,\n   \"HEIGHT\" : 720,\n   \"IMAGES\" : [\n      {\n         \"NAME\" : \"image45\",\n         \"PATH\" : \"images/45.jpg\"\n      },\n      {\n         \"NAME\" : \"image16\",\n         \"PATH\" : \"images/16.png\"\n      }\n   ],\n   \"IMAGE_PATH\" : \"vein_melter.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 432,\n         \"TARGET\" : \"BuffA\",\n         \"WIDTH\" : 768\n      },{\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 432,\n         \"TARGET\" : \"BuffA2\",\n         \"WIDTH\" : 768\n      }\n   ],\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pulse_out\",\n         \"TYPE\" : \"bang smooth\",\n         \"DESCRIPTION\":\"Sends a pulse outward from the center, leaving a dark hole in the middle of the screen after it passes.\",\n         \"PARAMS\":0.005,\n         \"UI_GROUP\" : \"simulation\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"full_pulse\",\n         \"TYPE\" : \"bang smooth\",\n         \"DESCRIPTION\":\"Sends a pulse through all the veins on screen at once, changing and rotating their shape.\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"simulation\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0.0,\n         \"NAME\" : \"retract\",\n         \"DESCRIPTION\":\"When on, pulls all the veins backwards, making it much more minimal/amorphous.\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"simulation\"\n      },{\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"devolve\",\n         \"TYPE\" : \"toggle\",\n         \"PARAMS\":0.05,\n         \"DESCRIPTION\":\"When on, devolves into a sort of random chaos of ripples and bursts.\",\n         \"UI_GROUP\" : \"simulation\"\n      },\n      {\n         \"DEFAULT\" : 0.2,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.5,\n         \"MIN\" : 0.1,\n         \"NAME\" : \"heartbeat_intensity\",\n         \"TYPE\" : \"slider smooth\",\n         \"DESCRIPTION\":\"Heartbeat, or breathing, that oscillates in and out every other bar. This affects the intensity.\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"simulation\"\n      },\n      {\n         \"DEFAULT\" : 4.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.0,\n         \"MIN\" : 4.0,\n         \"NAME\" : \"color_palette\",\n         \"DESCRIPTION\":\"Select from one of 5 color palettes. From bottom to top: Blood, Firey Orange/Blue, Green Forest, Blue Sky, Black/White.\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"coloration\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.5,\n         \"MIN\" : -1.5,\n         \"NAME\" : \"melt_up_or_down\",\n         \"DESCRIPTION\":\"50% is default: no melting up or down. Move up to melt up and in, down to melt down and out.\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"distortion\"\n      },{\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.5,\n         \"MIN\" : -1.5,\n         \"NAME\" : \"zooming\",\n         \"TYPE\" : \"slider smooth\",\n         \"DESCRIPTION\":\"50% is default no zooming. Move up to zoom in, down to zoom out.\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"distortion\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"paint1_on\",\n         \"DESCRIPTION\":\"When ON, paint1 is enabled. Audio-reactive paintbrush that drips extra fluid onto the simulation.\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"paint1\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : -1.0,\n         \"NAME\" : \"paint1XY\",\n         \"DESCRIPTION\":\"Mirrored painting for better effect.\",\n         \"TYPE\" : \"xy smooth\",\n         \"PARAMS\":0.025,\n         \"UI_GROUP\" : \"paint1\"\n      },\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 0.3,\n         \"MIN\" : 2.0,\n         \"NAME\" : \"brush_size1\",\n         \"DESCRIPTION\":\"Size & intensity of the effect for paint1.\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"UI_GROUP\" : \"paint1\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"paint2_on\",\n         \"TYPE\" : \"toggle\",\n         \"DESCRIPTION\":\"When ON, paint2 is enabled. Pulls around the simulation like a dipping your finger into liquid.\",\n         \"UI_GROUP\" : \"paint2\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"paint2XY\",\n         \"TYPE\" : \"xy smooth\",\n         \"DESCRIPTION\":\"Mirrored painting, but also TWO KINDS of brushes in one XY pad. On left half of the pad = a wide brush. Right half = more simple circular brush.\",\n         \"PARAMS\":0.025,\n         \"UI_GROUP\" : \"paint2\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1.0,\n         \"MIN\" : 0,\n         \"NAME\" : \"grab_frame\",\n         \"TYPE\" : \"bang\",\n         \"DESCRIPTION\":\"Grabs a frame from the underlying media and resets the simulation based on the brightness.\",\n         \"PARAMS\":0.2,\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 1.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"opacity\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.2,\n         \"DESCRIPTION\":\"100% is full opacity for the media effect, 0% is just the normal simulation, no media.\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"refraction\",\n         \"TYPE\" : \"slider smooth\",\n         \"PARAMS\":0.1,\n         \"DESCRIPTION\":\"Affects how much the video is refracted by the simulation.\",\n         \"UI_GROUP\" : \"media\"\n      },\n      {\n         \"DEFAULT\" : 0.0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"combine_colors\",\n         \"TYPE\" : \"toggle\",\n         \"DESCRIPTION\":\"When off, ignores the underlying 'color palette' and just uses the media. When on, multiplies the two.\",\n         \"UI_GROUP\" : \"media\"\n      },      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"reset_sim\",\n         \"TYPE\" : \"bang\",\n         \"DESCRIPTION\":\"Resets the simulation back to its initial state. The panic button when you don't like what is going on.\",\n         \"UI_GROUP\" : \"reset\"\n      }\n   ]\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":432,"TARGET":"BuffA","WIDTH":768},{"FLOAT":true,"HEIGHT":432,"TARGET":"BuffA2","WIDTH":768}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nvar bpmcount = new BPMCounter();\n\nvar decimator = 0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM/4.0;\n  bpmcount.updateTime(bpm, dt);\n\n  uniforms.beat_time = bpmcount.time;\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"\t\t\t//******** BuffA2 Code Begins ********\nfloat STEPS = 40;  // advection steps\n\nfloat ts  =  0.2;   // advection curl\nfloat cs  = -2.0;   // curl scale\nfloat ls  =  0.05;   // laplacian scale\nfloat ps  = -2.0;   // laplacian of divergence scale\nfloat ds  = -0.4;   // divergence scale\nfloat dp  = -0.03;  // divergence update scale\nfloat pl  =  0.3;   // divergence smoothing\nfloat amp =  1.0*(1.0-retract*0.1);   // self-amplification\nfloat upd =  0.4;   // update smoothing\n\nfloat _D = 0.6;   // diagonal weight\n\n#define _K0 -20.0/6.0 // laplacian center weight\n#define _K1 4.0/6.0   // laplacian edge-neighbors\n#define _K2 1.0/6.0   // laplacian vertex-neighbors\n\n#define _G0 0.25      // gaussian center weight\n#define _G1 0.125     // gaussian edge-neighbors\n#define _G2 0.0625    // gaussian vertex-neighbors\n\nbool reset() {\n    return reset_sim > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0) ? vec2(0.0) : normalize(x);\n}\n\n#define T(d) texture(BuffA2, fract(aUv+d)).xyz\n\nvec3 advect(vec2 ab, vec2 vUv, vec2 texel, out float curl, out float div, out vec3 lapl, out vec3 blur) {\n    \n    vec2 aUv = vUv - ab * texel;\n    vec4 t = vec4(texel, -texel.y, 0.0);\n\n    vec3 uv =    T( t.ww); vec3 uv_n =  T( t.wy); vec3 uv_e =  T( t.xw);\n    vec3 uv_s =  T( t.wz); vec3 uv_w =  T(-t.xw); vec3 uv_nw = T(-t.xz);\n    vec3 uv_sw = T(-t.xy); vec3 uv_ne = T( t.xy); vec3 uv_se = T( t.xz);\n    \n    curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + _D * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + _D * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    lapl = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    blur = _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    return uv;\n}\n\nvec2 rot(vec2 v, float th) {\n\treturn vec2(dot(v, vec2(cos(th), -sin(th))), dot(v, vec2(sin(th), cos(th)))); \n}\n\nvec4 renderPassA() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n\n    vec2 vUv = fragCoord.xy / RENDERSIZE.xy;\n    vUv -= vec2(-(1.0-_uv.y)*(-0.5+_uv.x)*pow(abs(-0.5+_uv.x)*2.0, 2.0)*3.0, length(_uvc))*melt_up_or_down*0.001;\n    // vUv= mix(vUv, vUv/(1.0+length(_uvc)*distort_amt*2.0*distort), 0.001);\n\n    vUv -= _uvc*0.0005*zooming;\n\n\n   if (paint2_on > 0.5) {\n        vec2 d = vec2(abs(_uvc.x), _uvc.y)-paint2XY;\n        if (paint2XY.x < 0.0){\n            d = vec2(-abs(_uvc.x), _uvc.y)-paint2XY;\n        }\n        if (_uvc.x < 0.0){\n            d.x = -d.x;\n            // d = vec2(-abs(_uvc.x), _uvc.y)-paint2XY;\n        }\n        vec2 m = 2.0 * normz(d) * exp(-length(d) / 0.03);\n        vUv += m*0.2;\n        // div += pow(length(m)*3.0,2.0);\n    }\n\n    vec2 texel = 1. / RENDERSIZE.xy;\n    \n    vec3 lapl, blur;\n    float curl, div;\n    \n    vec3 uv = advect(vec2(0), vUv, texel, curl, div, lapl, blur);\n\n    float sp = ps * lapl.z;\n    float sc = cs * curl;\n\tfloat sd = uv.z + dp * div + pl * lapl.z;\n    vec2 norm = normz(uv.xy);\n\n    vec2 off = uv.xy;\n    vec2 offd = off;\n    vec3 ab = vec3(0);\n\n    for(int i = 0; i < STEPS; i++) {\n        advect(off, vUv, texel, curl, div, lapl, blur);\n        offd = rot(offd,ts*curl);\n        off += offd;\n    \tab += blur / float(STEPS);  \n    }\n    \n    vec2 tab = amp * ab.xy + ls * lapl.xy + norm * sp + uv.xy * ds * sd;    \n    vec2 rab = rot(tab,sc);\n    \n    vec3 abd = mix(vec3(rab,sd), uv, upd);\n    \n    if (paint1_on>0.5) {\n    \tvec2 d = vec2(abs(_uvc.x), _uvc.y)-paint1XY;\n        if (paint1XY.x < 0.0){\n            d = vec2(-abs(_uvc.x), _uvc.y)-paint1XY;\n        }\n\n        // vec2 m = 0.1 * normz(d) * exp(-length(d) / 0.02);\n        abd.xy += syn_HighHits*normz(d)*exp(-length(d)*50.0*brush_size1);\n        abd.xy -= pow(syn_BassLevel,2.0)*normz(d)*exp(-length(d)*50.0*brush_size1);\n\n    }\n\n    abd = mix(abd, 1.0-abd, _pulse(length(_uvc)*0.9-0.01-length(abd)*0.1, 1.0-pulse_out, 0.01));\n    abd = mix(abd, -abd, _pulse(length(_uvc)*1.0-0.01-length(abd)*0.1, 1.0-pulse_out, 0.01));\n\n    // abd.xy += blur.xy*heartbeat_intensity*_pulse(length(_uvc)*0.5+length(abd)*0.2, 0.5+0.5*sin(beat_time*PI), heartbeat_intensity*0.1+0.02)*(0.5+0.5*sin(beat_time*PI*0.5));\n    // abd.xy -= blur.xy*heartbeat_intensity*_pulse(length(_uvc)*0.5+length(abd)*0.2, 0.5+0.5*sin(beat_time*PI), heartbeat_intensity*0.1+0.02)*(0.5+0.5*sin(beat_time*PI*0.5+PI));\n\n    vec2 hbAmt = blur.xy*heartbeat_intensity*_pulse(length(_uvc)+_fbm(vec3(_uvc*20.0,length(abd)*0.5+TIME*0.1)), (0.5+0.5*sin(beat_time*PI))+0.5, heartbeat_intensity*0.1+0.02);\n    abd.xy += mix(hbAmt, -hbAmt*1.5, 0.5+0.5*sin(beat_time*PI-PI/2));\n    // abd.xy -= blur.xy*heartbeat_intensity*_pulse(length(_uvc)+length(abd)*0.2, 0.5+0.5*sin(beat_time*PI), heartbeat_intensity*0.1+0.02);\n\n    float lum = dot(_loadUserImage().rgb, vec3(1.0))/3.0;\n    abd.xy = mix(abd.xy, _rotate(vec2(0.0,1.0),lum*PI*2.0), grab_frame*lum);\n    abd.z = mix(abd.z, (-1.0+lum*2.0)*0.2, grab_frame);\n\n    abd.xy = _rotate(abd.xy, full_pulse*0.3);\n    abd.xy *= 1.0+full_pulse*0.3;\n\n    // abd.xy = mix(abd.xy, vec2(0.0), _pulse(length(_uvc)+length(abd)*0.4, 1.0-pulse3, length(abd)*0.4));\n\n\n    // initialize with noise\n    vec3 init = texture(image16, vUv, 5.0).xyz;\n    if(uv == vec3(0) && init != vec3(0) || reset()) {\n        fragColor = 1.0 * vec4(-0.5 + init, 1);\n    } else {\n        abd.z = clamp(abd.z, -1.0, 1.0);\n        abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n        fragColor = vec4(abd, 0.0);\n    }\n    fragColor = mix(fragColor, vec4(0.0), pow(_fbm(vec3(_uvc*2.0,TIME*0.1)),3.0)*devolve);\n\treturn fragColor; \n } \n\n\nvec4 renderMainImage(){\n    vec2 uv = _uv;\n        vec3 components = texture(BuffA2, uv).xyz;\n    vec3 norm = normalize(components);\n    float c1 = clamp(pow(norm.z,0.4), 0.0, 1.0);\n    float c2 = clamp(pow(norm.z, 1.8), 0.0, 1.0);\n    float c3 =  clamp(dot(norm.xy, vec2(sin(TIME), cos(TIME))), 0.0, 1.0);\n    // fragColor = vec4(red, green, blue, 1);\n    // float d = length(texture(BuffA2, uv).xy);\n    // vec3 tx = texture(image45, uv, 1.0).xyz;\n    // vec3 col = mix(0.25 * (tx + 3.0 * vec3(1,0.85,0.7)), vec3(0.4,0,0.1), 5.0*d);\n\t// fragColor = vec4(col, 1.);\n\n    float colMixer = color_palette;\n    vec3 col1 = _normalizeRGB(255, 255, 255);\n    vec3 col2 = vec3(-1.0);\n    vec3 col3 = _normalizeRGB(255, 255, 255);\n    float mixHue = 0.0;\n    float mixSat = 0.0;\n\n    // *** Color Regime 1 ***\n    float cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n    col1 = mix(col1, -vec3(0.1, 0.2, 0.3)*5.0, cm);\n    col2 = mix(col2, vec3( 1.0, 1.0, 1.0), cm);\n    col3 = mix(col3, vec3( 1.4, 1.3, 1.0), cm);\n    mixHue = mix(mixHue, 0.5, cm);\n    mixSat = mix(mixSat, -0.5, cm);\n\n    // *** Color Regime 2 ***\n    colMixer = colMixer-1.0;\n    cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n    col1 = mix(col1, vec3(0,0.62,0.56), cm);\n    col2 = mix(col2, vec3(-1.0)*0.5, cm);\n    col3 = mix(col3, vec3(1.0,0.56,0.0), cm);\n    mixHue = mix(mixHue, 0.0, cm);\n    mixSat = mix(mixSat, 0.0, cm);\n\n    // *** Color Regime 3 ***\n    colMixer = colMixer-1.0;\n    cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n\n    col1 = mix(col1, vec3(0.1,0.5,1.3), cm);\n    col2 = mix(col2, -vec3(0.0,0.5,1.0), cm);\n    col3 = mix(col3, vec3(1.9,0.7,0.0), cm);\n    mixHue = mix(mixHue, 0.0, cm);\n    mixSat = mix(mixSat, 0.2, cm);\n\n    // *** Color Regime 4 ***\n    colMixer = colMixer-1.0;\n    cm = smoothstep(0.15, 0.85, clamp(colMixer, 0.0, 1.0));\n    col1 = mix(col1, vec3( 2.6, 0.7, 0.9)*0.7, cm);\n    col2 = mix(col2, -vec3(2.0, 2.0, 1.0)*0.9, cm);\n    col3 = mix(col3, vec3(-0.9, 0.8, 1.4)*0.7, cm);\n    mixHue = mix(mixHue, 0.0, cm);\n    mixSat = mix(mixSat, -0.05, cm);\n    float extra_red = cm;\n\n\n    vec3 finalCol = col1*c1 + col2*c2 + col3*c3;\n    finalCol *= vec3(1.0-finalCol.b*extra_red*0.3,1.0-finalCol.r*0.5*extra_red-finalCol.b*extra_red*0.3,1.0+finalCol.b*extra_red*0.2);\n\n    // finalCol = _hueSaturationContrast(vec4(finalCol,1.0), mixHue, mixSat, 1.0).rgb;\n    finalCol.rgb = _rgb2hsv(finalCol.rgb);\n    finalCol.r += mixHue;\n    finalCol.g += mixSat;\n    finalCol.rgb = _hsv2rgb(finalCol.rgb);\n    vec2 pos = _correctImageCoords(textureSize(syn_UserImage, 0));\n\n    vec3 tx = texture(syn_UserImage, _invertYAxisVideo(pos)+components.z*pow(refraction,2.0)).xyz;\n    if (syn_MediaType>0.5){\n        vec3 texCol = vec3(0.0);\n        if (combine_colors > 0.5){\n            texCol = finalCol*tx*1.2;\n        } else {\n            texCol = 2.0*tx*dot(finalCol.rgb, vec3(1.0))/3.0;\n        }\n        finalCol = mix(finalCol, texCol, opacity);\n    }\n\n\treturn vec4(finalCol, 1.0); \n } \n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderPassA();\n\t}\n    if(PASSINDEX == 1){\n        return texture(BuffA, _uv);\n    }\n\tif(PASSINDEX == 2){\n        // return texture(BuffA2, _uv)*4.0;\n\t\treturn renderMainImage();\n\t}\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Vein Melter","WIDTH":1280,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"Mix in the unaffected media. Don't forget to use 'media' meta controls, too!","MAX":1,"MIN":0,"NAME":"normal_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the edge detection effect, modified by controls in 'edge detect'.","MAX":1,"MIN":0,"NAME":"edge_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the rgb split effect, modified by controls in 'rgb split'.","MAX":1,"MIN":0,"NAME":"rgb_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the pixelate effect, modified by controls in 'pixelate'.","MAX":1,"MIN":0,"NAME":"pixelate_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the feedback effect. Needs other channels. Try edge detect to get extra trippy!","MAX":1,"MIN":0,"NAME":"feedback_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Subtracts the normal video, instead of adding, for darker looks.","MAX":1,"MIN":0,"NAME":"subtract","TYPE":"toggle","UI_GROUP":"normal media"},{"DEFAULT":0,"DESCRIPTION":"Edge detection tends to make colors pure R, G, B, this readjusts them to the original media.","MAX":1,"MIN":0,"NAME":"expand","TYPE":"slider","UI_GROUP":"edge detect"},{"DEFAULT":0,"DESCRIPTION":"Expands and duplicates the edges.","MAX":1,"MIN":0,"NAME":"color_fix","TYPE":"toggle","UI_GROUP":"edge detect"},{"DEFAULT":0.75,"DESCRIPTION":"desc","MAX":1.5,"MIN":0,"NAME":"split_amount","TYPE":"slider","UI_GROUP":"rgb split"},{"DEFAULT":1,"DESCRIPTION":"Bass-reactive RGB split effect. Toggle OFF for non-reactive.","MAX":1,"MIN":0,"NAME":"auto_split","TYPE":"toggle","UI_GROUP":"rgb split"},{"DEFAULT":0,"DESCRIPTION":"Channels constantly move in a chaotic way, instead of orderly.","MAX":1,"MIN":0,"NAME":"woozy","TYPE":"toggle","UI_GROUP":"rgb split"},{"DEFAULT":0.5,"DESCRIPTION":"Affects how fast the 'woozy' effect will run.","MAX":10,"MIN":0,"NAME":"woozy_speed","TYPE":"slider","UI_GROUP":"rgb split"},{"DEFAULT":1,"DESCRIPTION":"Simple, square pixels. Turn OFF to use other pixel types.","MAX":1,"MIN":0,"NAME":"square_pix","TYPE":"toggle","UI_GROUP":"pixelate"},{"DEFAULT":0,"DESCRIPTION":"Triangular pixels. Turn OFF to use other pixel types.","MAX":1,"MIN":0,"NAME":"tri_pix","TYPE":"toggle","UI_GROUP":"pixelate"},{"DEFAULT":0,"DESCRIPTION":"Circular pixels. Turn OFF to use other pixel types.","MAX":1,"MIN":0,"NAME":"circle_pix","TYPE":"toggle","UI_GROUP":"pixelate"},{"DEFAULT":2.5,"DESCRIPTION":"Size of the pixels while mix on the pixelate effect is turned up.","MAX":1,"MIN":3,"NAME":"pixel_size","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"pixelate"},{"DEFAULT":1,"DESCRIPTION":"Helps limit white-out/black-out, but modifies how some feedback behaves.","MAX":1,"MIN":0,"NAME":"clamp_color","TYPE":"toggle","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Additive instead of mixing. Turn up for extra echoes and a more pronounced effect.","MAX":1,"MIN":0,"NAME":"extra_bright","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":[0,0],"DESCRIPTION":"XY offset for feedback.","MAX":[3,3],"MIN":[-3,-3],"NAME":"fb_motion","PARAMS":0.200000002980232,"TYPE":"xy smooth","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Zoom in/out offset for feedback.","MAX":1,"MIN":-1,"NAME":"fb_zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Rotational offset for feedback.","MAX":0.100000001490116,"MIN":-0.100000001490116,"NAME":"fb_rotate","PARAMS":0.00999999977648258,"TYPE":"knob smooth","UI_GROUP":"feedback"}],"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\videofx_1.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"VideoFX_1","IMAGES":null,"IMAGE_PATH":"videofx_1.synScene\\videofx_1.png","JSON_CODE":"{\n   \"CONTROLS\" : [\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Mix in the unaffected media. Don't forget to use 'media' meta controls, too!\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"normal_mix\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"master mixer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Mix in the edge detection effect, modified by controls in 'edge detect'.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"edge_mix\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"master mixer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Mix in the rgb split effect, modified by controls in 'rgb split'.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"rgb_mix\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"master mixer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Mix in the pixelate effect, modified by controls in 'pixelate'.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"pixelate_mix\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"master mixer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Mix in the feedback effect. Needs other channels. Try edge detect to get extra trippy!\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"feedback_mix\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"master mixer\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Subtracts the normal video, instead of adding, for darker looks.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"subtract\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"normal media\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Edge detection tends to make colors pure R, G, B, this readjusts them to the original media.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"expand\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"edge detect\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Expands and duplicates the edges.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"color_fix\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"edge detect\"\n      },\n      {\n         \"DEFAULT\" : 0.75,\n         \"DESCRIPTION\" : \"desc\",\n         \"MAX\" : 1.5,\n         \"MIN\" : 0,\n         \"NAME\" : \"split_amount\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"rgb split\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Bass-reactive RGB split effect. Toggle OFF for non-reactive.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"auto_split\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"rgb split\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Channels constantly move in a chaotic way, instead of orderly.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"woozy\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"rgb split\"\n      },\n      {\n         \"DEFAULT\" : 0.5,\n         \"DESCRIPTION\" : \"Affects how fast the 'woozy' effect will run.\",\n         \"MAX\" : 10,\n         \"MIN\" : 0,\n         \"NAME\" : \"woozy_speed\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"rgb split\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Simple, square pixels. Turn OFF to use other pixel types.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"square_pix\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"pixelate\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Triangular pixels. Turn OFF to use other pixel types.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"tri_pix\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"pixelate\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Circular pixels. Turn OFF to use other pixel types.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"circle_pix\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"pixelate\"\n      },\n      {\n         \"DEFAULT\" : 2.5,\n         \"DESCRIPTION\" : \"Size of the pixels while mix on the pixelate effect is turned up.\",\n         \"MAX\" : 1,\n         \"MIN\" : 3,\n         \"NAME\" : \"pixel_size\",\n         \"PARAMS\" : 0.20000000298023224,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"pixelate\"\n      },\n      {\n         \"DEFAULT\" : 1,\n         \"DESCRIPTION\" : \"Helps limit white-out/black-out, but modifies how some feedback behaves.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"clamp_color\",\n         \"TYPE\" : \"toggle\",\n         \"UI_GROUP\" : \"feedback\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Additive instead of mixing. Turn up for extra echoes and a more pronounced effect.\",\n         \"MAX\" : 1,\n         \"MIN\" : 0,\n         \"NAME\" : \"extra_bright\",\n         \"TYPE\" : \"slider\",\n         \"UI_GROUP\" : \"feedback\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"XY offset for feedback.\",\n         \"MAX\" : 3,\n         \"MIN\" : -3,\n         \"NAME\" : \"fb_motion\",\n         \"PARAMS\" : 0.2,\n         \"TYPE\" : \"xy smooth\",\n         \"UI_GROUP\" : \"feedback\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Zoom in/out offset for feedback.\",\n         \"MAX\" : 1,\n         \"MIN\" : -1,\n         \"NAME\" : \"fb_zoom\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"slider smooth\",\n         \"UI_GROUP\" : \"feedback\"\n      },\n      {\n         \"DEFAULT\" : 0,\n         \"DESCRIPTION\" : \"Rotational offset for feedback.\",\n         \"MAX\" : 0.1,\n         \"MIN\" : -0.1,\n         \"NAME\" : \"fb_rotate\",\n         \"PARAMS\" : 0.01,\n         \"TYPE\" : \"knob smooth\",\n         \"UI_GROUP\" : \"feedback\"\n      }\n   ],\n   \"CREDIT\" : \"Synesthesia\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"videofx_1.png\",\n   \"PASSES\" : [\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"noMedia\",\n         \"WIDTH\" : 1920\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"userImgFB\",\n         \"WIDTH\" : 1920\n      },\n      {\n         \"FLOAT\" : true,\n         \"HEIGHT\" : 1080,\n         \"TARGET\" : \"fxApplied\",\n         \"WIDTH\" : 1920\n      }\n   ],\n   \"TITLE\" : \"VideoFX_1\",\n   \"WIDTH\" : 1920\n}\n","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"noMedia","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"userImgFB","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"fxApplied","WIDTH":1920}],"SCRIPT_CODE":"","SHADER_CODE":"\n//Stack to apply all video aspect/metacontrol corrections\n\n  // vec2 uv = _correctImageCoords(textureSize(tex, 0));\n\n  // uv = _invertYAxisVideo(uv);\n  \n  // if (uv.x < 0.0 || uv.y < 0.0 || uv.y > 1.0 || uv.x > 1.0) {\n  //   return vec4(0.0);\n  // } \n  \n// vec4 _loadUserImage(sampler2D sampIn) {\n//   return _contrast(_invertImage(_loadImage(sampIn, vec2(0.0), 1.0)),__Media_Contrast);\n// }\n\n\nvec4 noMediaPattern(vec2 uvIn) {\n\n  vec2 p = 2.0*( _uv )-1.0;\n  p.x *= RENDERSIZE.x/RENDERSIZE.y; \n  vec3 col = vec3(0);\n  \n  \n  float c = sin(p.y*4.0+syn_CurvedTime+clamp(1.0/(30.0*abs(length(p.xy)-0.8)), 0.0, 1.0)*2.0);\n  return vec4(c,(c>0.0)?c*c:0.0, 0.3, 1.0); \n}\n\n/**\n * Detects edges using the Sobel equation\n * @name syn_pass_edgeDetectSobel\n * @param  {sampler2D} smp texture you wish to detect edges on\n * @returns {float} edges\n */\n\nvec4 sobelIntensity(in vec4 color){\n  return color;\n  // return sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n}\nvec4 sobelHelper(float stepx, float stepy, vec2 center, sampler2D tex){\n  // get samples around pixel\n  vec4 tleft = sobelIntensity(texture(tex,clamp(center + vec2(-stepx,stepy), 0.0, 1.0)));\n  vec4 left = sobelIntensity(texture(tex,clamp(center + vec2(-stepx,0), 0.0, 1.0)));\n  vec4 bleft = sobelIntensity(texture(tex,clamp(center + vec2(-stepx,-stepy), 0.0, 1.0)));\n  vec4 top = sobelIntensity(texture(tex,clamp(center + vec2(0,stepy), 0.0, 1.0)));\n  vec4 bottom = sobelIntensity(texture(tex,clamp(center + vec2(0,-stepy), 0.0, 1.0)));\n  vec4 tright = sobelIntensity(texture(tex,clamp(center + vec2(stepx,stepy), 0.0, 1.0)));\n  vec4 right = sobelIntensity(texture(tex,clamp(center + vec2(stepx,0), 0.0, 1.0)));\n  vec4 bright = sobelIntensity(texture(tex,clamp(center + vec2(stepx,-stepy), 0.0, 1.0)));\n\n  vec4 x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n  vec4 y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n  vec4 color = sqrt((x*x) + (y*y));\n  return color;\n}\nvec4 edgeDetectSobel(sampler2D tex){\n\tfloat stepSize = 1.0+expand*40.0;\n  vec2 uv = _uv;\n  if (uv.x < 0.0 || uv.y < 0.0 || uv.y > 1.0 || uv.x > 1.0) {\n    return vec4(0.0);\n  } \n\n  return sobelHelper(stepSize/RENDERSIZE.x, stepSize/RENDERSIZE.y, uv, tex);\n}\n\n/**\n * Shifts the RGB channels away from each other in the x and y axes.\n * @name syn_pass_rgbShift\n * @param  {sampler2D} smp texture you wish to affect\n * @param  {float} intensity how much you want to shift by.\n * @param  {float|vec2|vec3} speed speed of the shifted movement. 1 is a good default.\n * @returns {float} rgb shifted texture based on intensity\n */\n\nvec4 rgbShift(sampler2D smp, float intensity, float speed){\n\n  vec2 uv = _uv;\n\n  float intensity_ = intensity*.1;\n  float timeVariable = TIME*speed*.01;\n\n  vec2 rPos = uv;\n  vec2 gPos = uv;\n  vec2 bPos = uv;\n\n  if (woozy > 0.5) {\n\t  vec2 modifiedCenterR = vec2(\n\t    _statelessContinuousChaotic(timeVariable),\n\t    _statelessContinuousChaotic(timeVariable*1.3)\n\t    ) * intensity_;\n\t  vec2 modifiedCenterG = vec2(\n\t    _statelessContinuousChaotic(timeVariable*1.1),\n\t    _statelessContinuousChaotic(timeVariable*1.4)\n\t    ) * intensity_;\n\t  vec2 modifiedCenterB = vec2(\n\t    _statelessContinuousChaotic(timeVariable*1.2),\n\t    _statelessContinuousChaotic(timeVariable*1.5)\n\t    ) * intensity_;\n\n\n\n\t  rPos = (uv - modifiedCenterR*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split));\n\t  gPos = (uv - modifiedCenterG*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split));\n\t  bPos = (uv - modifiedCenterB*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split));\n\n\t} else {\n\t\trPos = (uv - _rotate(vec2(intensity_*(-1)*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split), 0.0), syn_CurvedTime*0.1));\n\t  gPos = (uv - _rotate(vec2(intensity_*0*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split), 0.0), syn_CurvedTime*0.1));\n\t  bPos = (uv - _rotate(vec2(intensity_*1*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split), 0.0), syn_CurvedTime*0.1));\n\t}\n\n  vec3 col;\n  col.r = texture(smp, rPos).r;\n  col.g = texture(smp, gPos).g;\n  col.b = texture(smp, bPos).b;\n\n  // vec2 minEdge = min(min(rPos, gPos), bPos);\n  // vec2 maxEdge = max(max(rPos, gPos), bPos);\n\n  // if (edges_fix > 0.5){\n\t //  if (minEdge.x < 0.0 || minEdge.y < 0.0 || maxEdge.y > 1.0 || maxEdge.x > 1.0) {\n\t //    col = vec3(0.0);\n\t //  } \n  // }\n\n return vec4(col,1.0);\n}\n\n\nvec2 trianglePix(vec2 posIn, float sizeIn)\n{\n  vec2 tile_num = vec2(2.0,1.0)*sizeIn;\n  vec2 uv = posIn;\n  vec2 uv2 = floor(uv*tile_num)/tile_num;\n  uv -= uv2;\n  uv *= tile_num;\n  vec2 posOut = uv2 + vec2(step(1.0-uv.y,uv.x)/(2.0*tile_num.x),                                          \n                           step(uv.x,uv.y)/(2.0*tile_num.y));\n  return posOut;\n}\n\nvec2 circlePix(vec2 posIn, float sizeIn)\n{\n        posIn *= RENDERSIZE;\n        posIn.x *= 0.57735*2.0;\n        posIn.y += mod(floor(posIn.x), 2.0)*0.5;\n        posIn = abs((mod(posIn, 1.0) - 0.5));\n        // posIn = vec2(posIn.x*1.5 + posIn.y, posIn.y*2.0);\n        return posIn;\n        // return abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\nvec4 pixelate(sampler2D sampIn) \n{ \n  vec2 uv = _uv;\n\n  float aspect = RENDERSIZE.y/RENDERSIZE.x;\n  float sizeFixed = pow(pixel_size, 5.0);\n  if (square_pix > 0.5){\n    uv = vec2(_pixelate(uv.x, sizeFixed/aspect), _pixelate(uv.y, sizeFixed));\n  } \n  if (tri_pix > 0.5){\n    uv = trianglePix(_uv, sizeFixed);\n  }\n  vec4 col = vec4(0.0);\n  if (circle_pix < 0.5){\n    col = texture(sampIn, clamp(uv,0.0,1.0));\n  } else {\n    vec2 uv = _uv;\n    vec2 imgSize = textureSize(sampIn, 0);\n    float aspectImg = imgSize.x/imgSize.y;\n    float sizeFixed = pow(pixel_size, 2.0)*0.8;\n    vec2 smallGridSpace = mod(_uvc*4.5*pow(2, ceil(sizeFixed)), 2.0)-1.0;\n    float smallXDiv = 4.0*pow(2, ceil(sizeFixed));\n    float smallYDiv = 2.25*pow(2, ceil(sizeFixed));\n    vec2 smallIndex = vec2(floor(uv.x*smallXDiv), floor((uv.y-0.5)*smallYDiv));\n    // if (aspectImg < 16.0/9.0){\n    //   smallXDiv *= aspect;\n    // } else {\n    //   smallYDiv *= aspect;\n    // }\n    // float smallXDivImg = aspectImg*9.0/4.0*pow(2, ceil(sizeFixed));\n    // float smallYDivImg = 1/aspectImg*16.0/2.25*pow(2, ceil(sizeFixed));\n    vec3 image = texture(sampIn, vec2(_pixelate(uv.x, smallXDiv), _pixelate(uv.y, smallYDiv))).rgb;\n    float imgBri = dot(image, vec3(1.0))/3.0;\n\n    float circSmall = 1.0-smoothstep((0.0+sqrt(imgBri*0.8*(0.5+syn_HighHits*syn_HighHits*0.7))), (0.05+sqrt(imgBri*0.8*(0.5+syn_HighHits*syn_HighHits*0.7))), \n    length(smallGridSpace));  \n    col = vec4(vec3(circSmall*image), 1.0);\n  }\n\n  return col;\n}\nvec2 rotateCenter(vec2 uvIn, float amount){\n  uvIn.y += (RENDERSIZE.x-RENDERSIZE.y)/RENDERSIZE.x;\n  uvIn*=vec2(1.0, RENDERSIZE.y/RENDERSIZE.x);\n  _uv2uvc(uvIn);\n  uvIn = _rotate(uvIn, amount);\n  _uvc2uv(uvIn);\n  uvIn/=vec2(1.0, RENDERSIZE.y/RENDERSIZE.x);\n  uvIn.y -= (RENDERSIZE.x-RENDERSIZE.y)/RENDERSIZE.x;\n  return uvIn;\n}\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0){\n    return _contrast(_invertImage(noMediaPattern(_uv)), _Media_Contrast);\n  } else if (PASSINDEX == 1){\n    vec4 img = vec4(0.0);\n    if (syn_MediaType < 0.5){\n      img = texture(noMedia, _uv);\n    } else {\n      img = _loadUserImage(); \n    }\n    vec4 col = mix(img, img*extra_bright+texture(fxApplied, rotateCenter(_uv, fb_rotate*PI)-sign(fb_motion)*fb_motion*fb_motion*0.1+(_uvc)*fb_zoom*fb_zoom*sign(fb_zoom)*0.05), feedback_mix);\n    return clamp_color > 0.5 ? clamp(col, 0.0, 1.0) : col;\n  } else if (PASSINDEX == 2){\n  \tvec4 finalCol = vec4(0.0);\n\n  \t//Normal Image\n  \tvec4 normalCol = texture(userImgFB, _uv);\n    vec4 edges = clamp(edgeDetectSobel(userImgFB), 0.0, 1.0);\n    \n    vec4 edgesCol = vec4(0.0);\n    if (color_fix > 0.5){\n      edgesCol = normalCol*edges*2.0;\n    } else {\n      edgesCol = edges;\n    }\n\n  \tvec4 pixelateCol = pixelate(userImgFB);\n\n  \tfinalCol += normalCol*(1.0-subtract*2.0)*normal_mix;\n\n  \tfinalCol += edgesCol*edge_mix;\n\n  \tfinalCol += pixelateCol*pixelate_mix;\n\n    vec4 rgbCol = rgbShift(userImgFB, pow(split_amount,3.0)*0.5, woozy_speed);\n\n    finalCol += rgbCol*rgb_mix;\n\n  \treturn finalCol;\n  } else if (PASSINDEX == 3.0){\n    return texture(fxApplied, _uv);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"VideoFX_1","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"Mix in the unaffected media. Don't forget to use 'media' meta controls, too!","MAX":1,"MIN":0,"NAME":"normal_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the edge detection effect, modified by controls in 'edge detect'.","MAX":1,"MIN":0,"NAME":"edge_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the rgb split effect, modified by controls in 'rgb split'.","MAX":1,"MIN":0,"NAME":"rgb_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the pixelate effect, modified by controls in 'pixelate'.","MAX":1,"MIN":0,"NAME":"pixelate_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Mix in the feedback effect. Needs other channels. Try edge detect to get extra trippy!","MAX":1,"MIN":0,"NAME":"feedback_mix","TYPE":"slider","UI_GROUP":"master mixer"},{"DEFAULT":0,"DESCRIPTION":"Subtracts the normal video, instead of adding, for darker looks.","MAX":1,"MIN":0,"NAME":"subtract","TYPE":"toggle","UI_GROUP":"normal media"},{"DEFAULT":0,"DESCRIPTION":"Edge detection tends to make colors pure R, G, B, this readjusts them to the original media.","MAX":1,"MIN":0,"NAME":"expand","TYPE":"slider","UI_GROUP":"edge detect"},{"DEFAULT":0,"DESCRIPTION":"Expands and duplicates the edges.","MAX":1,"MIN":0,"NAME":"color_fix","TYPE":"toggle","UI_GROUP":"edge detect"},{"DEFAULT":0.75,"DESCRIPTION":"desc","MAX":1.5,"MIN":0,"NAME":"split_amount","TYPE":"slider","UI_GROUP":"rgb split"},{"DEFAULT":1,"DESCRIPTION":"Bass-reactive RGB split effect. Toggle OFF for non-reactive.","MAX":1,"MIN":0,"NAME":"auto_split","TYPE":"toggle","UI_GROUP":"rgb split"},{"DEFAULT":0,"DESCRIPTION":"Channels constantly move in a chaotic way, instead of orderly.","MAX":1,"MIN":0,"NAME":"woozy","TYPE":"toggle","UI_GROUP":"rgb split"},{"DEFAULT":0.5,"DESCRIPTION":"Affects how fast the 'woozy' effect will run.","MAX":10,"MIN":0,"NAME":"woozy_speed","TYPE":"slider","UI_GROUP":"rgb split"},{"DEFAULT":1,"DESCRIPTION":"Simple, square pixels. Turn OFF to use other pixel types.","MAX":1,"MIN":0,"NAME":"square_pix","TYPE":"toggle","UI_GROUP":"pixelate"},{"DEFAULT":0,"DESCRIPTION":"Triangular pixels. Turn OFF to use other pixel types.","MAX":1,"MIN":0,"NAME":"tri_pix","TYPE":"toggle","UI_GROUP":"pixelate"},{"DEFAULT":0,"DESCRIPTION":"Circular pixels. Turn OFF to use other pixel types.","MAX":1,"MIN":0,"NAME":"circle_pix","TYPE":"toggle","UI_GROUP":"pixelate"},{"DEFAULT":2.5,"DESCRIPTION":"Size of the pixels while mix on the pixelate effect is turned up.","MAX":1,"MIN":3,"NAME":"pixel_size","PARAMS":0.200000002980232,"TYPE":"slider smooth","UI_GROUP":"pixelate"},{"DEFAULT":1,"DESCRIPTION":"Helps limit white-out/black-out, but modifies how some feedback behaves.","MAX":1,"MIN":0,"NAME":"clamp_color","TYPE":"toggle","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Additive instead of mixing. Turn up for extra echoes and a more pronounced effect.","MAX":1,"MIN":0,"NAME":"extra_bright","TYPE":"slider","UI_GROUP":"feedback"},{"DEFAULT":[0,0],"DESCRIPTION":"XY offset for feedback.","MAX":[3,3],"MIN":[-3,-3],"NAME":"fb_motion","PARAMS":0.200000002980232,"TYPE":"xy smooth","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Zoom in/out offset for feedback.","MAX":1,"MIN":-1,"NAME":"fb_zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"feedback"},{"DEFAULT":0,"DESCRIPTION":"Rotational offset for feedback.","MAX":0.100000001490116,"MIN":-0.100000001490116,"NAME":"fb_rotate","PARAMS":0.00999999977648258,"TYPE":"knob smooth","UI_GROUP":"feedback"}],"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\videofx_1_dup.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"VideoFX_1_dup","IMAGES":null,"IMAGE_PATH":"videofx_1_dup.synScene\\videofx_1_dup.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"Mix in the unaffected media. Don't forget to use 'media' meta controls, too!\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"normal_mix\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"master mixer\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Mix in the edge detection effect, modified by controls in 'edge detect'.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"edge_mix\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"master mixer\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Mix in the rgb split effect, modified by controls in 'rgb split'.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rgb_mix\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"master mixer\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Mix in the pixelate effect, modified by controls in 'pixelate'.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"pixelate_mix\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"master mixer\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Mix in the feedback effect. Needs other channels. Try edge detect to get extra trippy!\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"feedback_mix\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"master mixer\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Subtracts the normal video, instead of adding, for darker looks.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"subtract\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"normal media\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Edge detection tends to make colors pure R, G, B, this readjusts them to the original media.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"expand\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"edge detect\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Expands and duplicates the edges.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"color_fix\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"edge detect\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.75,\n\t\t\t\"DESCRIPTION\" : \"desc\",\n\t\t\t\"MAX\" : 1.5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"split_amount\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"rgb split\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Bass-reactive RGB split effect. Toggle OFF for non-reactive.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"auto_split\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"rgb split\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Channels constantly move in a chaotic way, instead of orderly.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"woozy\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"rgb split\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"Affects how fast the 'woozy' effect will run.\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"woozy_speed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"rgb split\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Simple, square pixels. Turn OFF to use other pixel types.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"square_pix\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"pixelate\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Triangular pixels. Turn OFF to use other pixel types.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"tri_pix\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"pixelate\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Circular pixels. Turn OFF to use other pixel types.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"circle_pix\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"pixelate\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.5,\n\t\t\t\"DESCRIPTION\" : \"Size of the pixels while mix on the pixelate effect is turned up.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 3,\n\t\t\t\"NAME\" : \"pixel_size\",\n\t\t\t\"PARAMS\" : 0.2,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"pixelate\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"Helps limit white-out/black-out, but modifies how some feedback behaves.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"clamp_color\",\n\t\t\t\"TYPE\" : \"toggle\",\n\t\t\t\"UI_GROUP\" : \"feedback\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Additive instead of mixing. Turn up for extra echoes and a more pronounced effect.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"extra_bright\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"feedback\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"XY offset for feedback.\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t3,\n\t\t\t\t3\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-3,\n\t\t\t\t-3\n\t\t\t],\n\t\t\t\"NAME\" : \"fb_motion\",\n\t\t\t\"PARAMS\" : 0.2,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Zoom in/out offset for feedback.\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"fb_zoom\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"Rotational offset for feedback.\",\n\t\t\t\"MAX\" : 0.1,\n\t\t\t\"MIN\" : -0.1,\n\t\t\t\"NAME\" : \"fb_rotate\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"knob smooth\",\n\t\t\t\"UI_GROUP\" : \"feedback\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"Synesthesia\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"videofx_1_dup.png\",\n\t\"PASSES\" : \n\t[\n\t\t{\n\t\t\t\"FLOAT\" : true,\n\t\t\t\"HEIGHT\" : 1080,\n\t\t\t\"TARGET\" : \"noMedia\",\n\t\t\t\"WIDTH\" : 1920\n\t\t},\n\t\t{\n\t\t\t\"FLOAT\" : true,\n\t\t\t\"HEIGHT\" : 1080,\n\t\t\t\"TARGET\" : \"userImgFB\",\n\t\t\t\"WIDTH\" : 1920\n\t\t},\n\t\t{\n\t\t\t\"FLOAT\" : true,\n\t\t\t\"HEIGHT\" : 1080,\n\t\t\t\"TARGET\" : \"fxApplied\",\n\t\t\t\"WIDTH\" : 1920\n\t\t}\n\t],\n\t\"TITLE\" : \"VideoFX_1_dup\",\n\t\"WIDTH\" : 1920\n}","PASSES":[{"FLOAT":true,"HEIGHT":1080,"TARGET":"noMedia","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"userImgFB","WIDTH":1920},{"FLOAT":true,"HEIGHT":1080,"TARGET":"fxApplied","WIDTH":1920}],"SCRIPT_CODE":"","SHADER_CODE":"\n//Stack to apply all video aspect/metacontrol corrections\n\n  // vec2 uv = _correctImageCoords(textureSize(tex, 0));\n\n  // uv = _invertYAxisVideo(uv);\n  \n  // if (uv.x < 0.0 || uv.y < 0.0 || uv.y > 1.0 || uv.x > 1.0) {\n  //   return vec4(0.0);\n  // } \n  \n// vec4 _loadUserImage(sampler2D sampIn) {\n//   return _contrast(_invertImage(_loadImage(sampIn, vec2(0.0), 1.0)),__Media_Contrast);\n// }\n\n\nvec4 noMediaPattern(vec2 uvIn) {\n\n  vec2 p = 2.0*( _uv )-1.0;\n  p.x *= RENDERSIZE.x/RENDERSIZE.y; \n  vec3 col = vec3(0);\n  \n  \n  float c = sin(p.y*4.0+syn_CurvedTime+clamp(1.0/(30.0*abs(length(p.xy)-0.8)), 0.0, 1.0)*2.0);\n  return vec4(c,(c>0.0)?c*c:0.0, 0.3, 1.0); \n}\n\n/**\n * Detects edges using the Sobel equation\n * @name syn_pass_edgeDetectSobel\n * @param  {sampler2D} smp texture you wish to detect edges on\n * @returns {float} edges\n */\n\nvec4 sobelIntensity(in vec4 color){\n  return color;\n  // return sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n}\nvec4 sobelHelper(float stepx, float stepy, vec2 center, sampler2D tex){\n  // get samples around pixel\n  vec4 tleft = sobelIntensity(texture(tex,clamp(center + vec2(-stepx,stepy), 0.0, 1.0)));\n  vec4 left = sobelIntensity(texture(tex,clamp(center + vec2(-stepx,0), 0.0, 1.0)));\n  vec4 bleft = sobelIntensity(texture(tex,clamp(center + vec2(-stepx,-stepy), 0.0, 1.0)));\n  vec4 top = sobelIntensity(texture(tex,clamp(center + vec2(0,stepy), 0.0, 1.0)));\n  vec4 bottom = sobelIntensity(texture(tex,clamp(center + vec2(0,-stepy), 0.0, 1.0)));\n  vec4 tright = sobelIntensity(texture(tex,clamp(center + vec2(stepx,stepy), 0.0, 1.0)));\n  vec4 right = sobelIntensity(texture(tex,clamp(center + vec2(stepx,0), 0.0, 1.0)));\n  vec4 bright = sobelIntensity(texture(tex,clamp(center + vec2(stepx,-stepy), 0.0, 1.0)));\n\n  vec4 x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n  vec4 y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n  vec4 color = sqrt((x*x) + (y*y));\n  return color;\n}\nvec4 edgeDetectSobel(sampler2D tex){\n\tfloat stepSize = 1.0+expand*40.0;\n  vec2 uv = _uv;\n  if (uv.x < 0.0 || uv.y < 0.0 || uv.y > 1.0 || uv.x > 1.0) {\n    return vec4(0.0);\n  } \n\n  return sobelHelper(stepSize/RENDERSIZE.x, stepSize/RENDERSIZE.y, uv, tex);\n}\n\n/**\n * Shifts the RGB channels away from each other in the x and y axes.\n * @name syn_pass_rgbShift\n * @param  {sampler2D} smp texture you wish to affect\n * @param  {float} intensity how much you want to shift by.\n * @param  {float|vec2|vec3} speed speed of the shifted movement. 1 is a good default.\n * @returns {float} rgb shifted texture based on intensity\n */\n\nvec4 rgbShift(sampler2D smp, float intensity, float speed){\n\n  vec2 uv = _uv;\n\n  float intensity_ = intensity*.1;\n  float timeVariable = TIME*speed*.01;\n\n  vec2 rPos = uv;\n  vec2 gPos = uv;\n  vec2 bPos = uv;\n\n  if (woozy > 0.5) {\n\t  vec2 modifiedCenterR = vec2(\n\t    _statelessContinuousChaotic(timeVariable),\n\t    _statelessContinuousChaotic(timeVariable*1.3)\n\t    ) * intensity_;\n\t  vec2 modifiedCenterG = vec2(\n\t    _statelessContinuousChaotic(timeVariable*1.1),\n\t    _statelessContinuousChaotic(timeVariable*1.4)\n\t    ) * intensity_;\n\t  vec2 modifiedCenterB = vec2(\n\t    _statelessContinuousChaotic(timeVariable*1.2),\n\t    _statelessContinuousChaotic(timeVariable*1.5)\n\t    ) * intensity_;\n\n\n\n\t  rPos = (uv - modifiedCenterR*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split));\n\t  gPos = (uv - modifiedCenterG*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split));\n\t  bPos = (uv - modifiedCenterB*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split));\n\n\t} else {\n\t\trPos = (uv - _rotate(vec2(intensity_*(-1)*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split), 0.0), syn_CurvedTime*0.1));\n\t  gPos = (uv - _rotate(vec2(intensity_*0*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split), 0.0), syn_CurvedTime*0.1));\n\t  bPos = (uv - _rotate(vec2(intensity_*1*mix(1.0, syn_BassLevel*syn_BassLevel, auto_split), 0.0), syn_CurvedTime*0.1));\n\t}\n\n  vec3 col;\n  col.r = texture(smp, rPos).r;\n  col.g = texture(smp, gPos).g;\n  col.b = texture(smp, bPos).b;\n\n  // vec2 minEdge = min(min(rPos, gPos), bPos);\n  // vec2 maxEdge = max(max(rPos, gPos), bPos);\n\n  // if (edges_fix > 0.5){\n\t //  if (minEdge.x < 0.0 || minEdge.y < 0.0 || maxEdge.y > 1.0 || maxEdge.x > 1.0) {\n\t //    col = vec3(0.0);\n\t //  } \n  // }\n\n return vec4(col,1.0);\n}\n\n\nvec2 trianglePix(vec2 posIn, float sizeIn)\n{\n  vec2 tile_num = vec2(2.0,1.0)*sizeIn;\n  vec2 uv = posIn;\n  vec2 uv2 = floor(uv*tile_num)/tile_num;\n  uv -= uv2;\n  uv *= tile_num;\n  vec2 posOut = uv2 + vec2(step(1.0-uv.y,uv.x)/(2.0*tile_num.x),                                          \n                           step(uv.x,uv.y)/(2.0*tile_num.y));\n  return posOut;\n}\n\nvec2 circlePix(vec2 posIn, float sizeIn)\n{\n        posIn *= RENDERSIZE;\n        posIn.x *= 0.57735*2.0;\n        posIn.y += mod(floor(posIn.x), 2.0)*0.5;\n        posIn = abs((mod(posIn, 1.0) - 0.5));\n        // posIn = vec2(posIn.x*1.5 + posIn.y, posIn.y*2.0);\n        return posIn;\n        // return abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\nvec4 pixelate(sampler2D sampIn) \n{ \n  vec2 uv = _uv;\n\n  float aspect = RENDERSIZE.y/RENDERSIZE.x;\n  float sizeFixed = pow(pixel_size, 5.0);\n  if (square_pix > 0.5){\n    uv = vec2(_pixelate(uv.x, sizeFixed/aspect), _pixelate(uv.y, sizeFixed));\n  } \n  if (tri_pix > 0.5){\n    uv = trianglePix(_uv, sizeFixed);\n  }\n  vec4 col = vec4(0.0);\n  if (circle_pix < 0.5){\n    col = texture(sampIn, clamp(uv,0.0,1.0));\n  } else {\n    vec2 uv = _uv;\n    vec2 imgSize = textureSize(sampIn, 0);\n    float aspectImg = imgSize.x/imgSize.y;\n    float sizeFixed = pow(pixel_size, 2.0)*0.8;\n    vec2 smallGridSpace = mod(_uvc*4.5*pow(2, ceil(sizeFixed)), 2.0)-1.0;\n    float smallXDiv = 4.0*pow(2, ceil(sizeFixed));\n    float smallYDiv = 2.25*pow(2, ceil(sizeFixed));\n    vec2 smallIndex = vec2(floor(uv.x*smallXDiv), floor((uv.y-0.5)*smallYDiv));\n    // if (aspectImg < 16.0/9.0){\n    //   smallXDiv *= aspect;\n    // } else {\n    //   smallYDiv *= aspect;\n    // }\n    // float smallXDivImg = aspectImg*9.0/4.0*pow(2, ceil(sizeFixed));\n    // float smallYDivImg = 1/aspectImg*16.0/2.25*pow(2, ceil(sizeFixed));\n    vec3 image = texture(sampIn, vec2(_pixelate(uv.x, smallXDiv), _pixelate(uv.y, smallYDiv))).rgb;\n    float imgBri = dot(image, vec3(1.0))/3.0;\n\n    float circSmall = 1.0-smoothstep((0.0+sqrt(imgBri*0.8*(0.5+syn_HighHits*syn_HighHits*0.7))), (0.05+sqrt(imgBri*0.8*(0.5+syn_HighHits*syn_HighHits*0.7))), \n    length(smallGridSpace));  \n    col = vec4(vec3(circSmall*image), 1.0);\n  }\n\n  return col;\n}\nvec2 rotateCenter(vec2 uvIn, float amount){\n  uvIn.y += (RENDERSIZE.x-RENDERSIZE.y)/RENDERSIZE.x;\n  uvIn*=vec2(1.0, RENDERSIZE.y/RENDERSIZE.x);\n  _uv2uvc(uvIn);\n  uvIn = _rotate(uvIn, amount);\n  _uvc2uv(uvIn);\n  uvIn/=vec2(1.0, RENDERSIZE.y/RENDERSIZE.x);\n  uvIn.y -= (RENDERSIZE.x-RENDERSIZE.y)/RENDERSIZE.x;\n  return uvIn;\n}\n\nvec4 renderMain(void)\n{\n  if (PASSINDEX == 0){\n    return _contrast(_invertImage(noMediaPattern(_uv)), _Media_Contrast);\n  } else if (PASSINDEX == 1){\n    vec4 img = vec4(0.0);\n    if (syn_MediaType < 0.5){\n      img = texture(noMedia, _uv);\n    } else {\n      img = _loadUserImage(); \n    }\n    vec4 col = mix(img, img*extra_bright+texture(fxApplied, rotateCenter(_uv, fb_rotate*PI)-sign(fb_motion)*fb_motion*fb_motion*0.1+(_uvc)*fb_zoom*fb_zoom*sign(fb_zoom)*0.05), feedback_mix);\n    return clamp_color > 0.5 ? clamp(col, 0.0, 1.0) : col;\n  } else if (PASSINDEX == 2){\n  \tvec4 finalCol = vec4(0.0);\n\n  \t//Normal Image\n  \tvec4 normalCol = texture(userImgFB, _uv);\n    vec4 edges = clamp(edgeDetectSobel(userImgFB), 0.0, 1.0);\n    \n    vec4 edgesCol = vec4(0.0);\n    if (color_fix > 0.5){\n      edgesCol = normalCol*edges*2.0;\n    } else {\n      edgesCol = edges;\n    }\n\n  \tvec4 pixelateCol = pixelate(userImgFB);\n\n  \tfinalCol += normalCol*(1.0-subtract*2.0)*normal_mix;\n\n  \tfinalCol += edgesCol*edge_mix;\n\n  \tfinalCol += pixelateCol*pixelate_mix;\n\n    vec4 rgbCol = rgbShift(userImgFB, pow(split_amount,3.0)*0.5, woozy_speed);\n\n    finalCol += rgbCol*rgb_mix;\n\n  \treturn finalCol;\n  } else if (PASSINDEX == 3.0){\n    return texture(fxApplied, _uv);\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"VideoFX_1_dup","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Rotation of each layer of the blur","MAX":1,"MIN":-1,"NAME":"roto","PARAMS":0.0500000007450581,"TYPE":"slider smooth","UI_GROUP":"blur"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"Amount of zoom between each layer of the blur","MAX":0.300000011920929,"MIN":0,"NAME":"zoom_amt","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"blur"},{"DEFAULT":0,"DESCRIPTION":"Gamma of each layer of the blur","MAX":2,"MIN":0,"NAME":"blur_gamma","PARAMS":0.200000002980232,"TYPE":"knob smooth","UI_GROUP":"blur"},{"DEFAULT":40,"DESCRIPTION":"Number of levels of zoom. If you have FPS issues lower this.","MAX":60,"MIN":0,"NAME":"zoom_levels","TYPE":"slider","UI_GROUP":"blur"},{"DEFAULT":1,"DESCRIPTION":"Brightness of each layer of the blur","MAX":3,"MIN":0,"NAME":"brightness","PARAMS":0.0500000007450581,"TYPE":"knob smooth","UI_GROUP":"blur"},{"DEFAULT":0,"DESCRIPTION":"Adds an audio-reactive pulsing effect lighting up each layer of blur","MAX":1,"MIN":0,"NAME":"audio_zoom","TYPE":"toggle","UI_GROUP":"action"},{"DEFAULT":[0,0],"DESCRIPTION":"Adjusts the position of the zoom, giving a 3D effect","MAX":[1,1],"MIN":[-1,-1],"NAME":"zoom_pos","PARAMS":0.100000001490116,"TYPE":"xy smooth","UI_GROUP":"position"},{"DEFAULT":1,"DESCRIPTION":"Changes whether the zoom pos XY pad has a small or large effect","MAX":1,"MIN":0,"NAME":"micro_adjust","PARAMS":0.0500000007450581,"TYPE":"toggle smooth","UI_GROUP":"position"},{"DEFAULT":0,"DESCRIPTION":"Turn this on for auto audio-reactive zoom pos control","MAX":1,"MIN":0,"NAME":"auto_direction","TYPE":"toggle","UI_GROUP":"position"},{"DEFAULT":[0,0],"DESCRIPTION":"This lets you scroll the underlying media while keeping the directional blur effect constant","MAX":[1,1],"MIN":[-1,-1],"NAME":"media_pos","PARAMS":0.0199999995529652,"TYPE":"xy smooth","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Turn off if you want the media to tile normally, instead of mirrored","MAX":1,"MIN":0,"NAME":"mirror_tile","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":0.0299999993294477,"DESCRIPTION":"This affects the thickness of the grid lines that show up when no media is selected","MAX":0.200000002980232,"MIN":0,"NAME":"thickness_grid","PARAMS":0.0399999991059303,"TYPE":"slider smooth","UI_GROUP":"no_media"}],"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\videofx_directionalblur.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"VideoFX_DirectionalBlur","IMAGES":null,"IMAGE_PATH":"videofx_directionalblur.synScene\\videofx_directionalblur.png","JSON_CODE":"{\n\t\"CONTROLS\":[\n\t\t{\"NAME\":\"roto\", \n\t\t\"DESCRIPTION\":\"Rotation of each layer of the blur\",\n\t\t\"TYPE\":\"slider smooth\",\n\t\t\"PARAMS\":0.05,\n\t\t\"UI_GROUP\":\"blur\",\n\t\t\"MIN\":-1.0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":0.0},\n\t\t{\"NAME\":\"zoom_amt\", \n\t\t\"DESCRIPTION\":\"Amount of zoom between each layer of the blur\",\n\t\t\"TYPE\":\"slider smooth\",\n\t\t\"PARAMS\":0.1,\n\t\t\"UI_GROUP\":\"blur\",\n\t\t\"MIN\":0.0,\n\t\t\"MAX\":0.3,\n\t\t\"DEFAULT\":0.1\n\t\t},\n\t\t{\"NAME\":\"blur_gamma\", \n\t\t\"DESCRIPTION\":\"Gamma of each layer of the blur\",\n\t\t\"TYPE\":\"knob smooth\",\n\t\t\"PARAMS\":0.2,\n\t\t\"UI_GROUP\":\"blur\",\n\t\t\"MIN\":0,\n\t\t\"MAX\":2.0,\n\t\t\"DEFAULT\":0.0\n\t\t},\n\t\t{\"NAME\":\"zoom_levels\", \n\t\t\"DESCRIPTION\":\"Number of levels of zoom. If you have FPS issues lower this.\",\n\t\t\"TYPE\":\"slider\",\n\t\t\"UI_GROUP\":\"blur\",\n\t\t\"MIN\":0,\n\t\t\"MAX\":60.0,\n\t\t\"DEFAULT\":40.0\n\t\t},\n\t\t{\"NAME\":\"brightness\", \n\t\t\"DESCRIPTION\":\"Brightness of each layer of the blur\",\n\t\t\"TYPE\":\"knob smooth\",\n\t\t\"UI_GROUP\":\"blur\",\n\t\t\"PARAMS\":0.05,\n\t\t\"MIN\":0.0,\n\t\t\"MAX\":3.0,\n\t\t\"DEFAULT\":1.0\n\t\t},\n\t\t{\"NAME\":\"audio_zoom\", \n\t\t\"DESCRIPTION\":\"Adds an audio-reactive pulsing effect lighting up each layer of blur\",\n\t\t\"TYPE\":\"toggle\",\n\t\t\"UI_GROUP\":\"action\",\n\t\t\"MIN\":0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":0.0\n\t\t},\n\t\t{\"NAME\":\"zoom_pos\", \n\t\t\"DESCRIPTION\":\"Adjusts the position of the zoom, giving a 3D effect\",\n\t\t\"TYPE\":\"xy smooth\",\n\t\t\"PARAMS\":0.1,\n\t\t\"UI_GROUP\":\"position\",\n\t\t\"MIN\":-1.0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":0.0\n\t\t},\n\t\t{\"NAME\":\"micro_adjust\", \n\t\t\"DESCRIPTION\":\"Changes whether the zoom pos XY pad has a small or large effect\",\n\t\t\"TYPE\":\"toggle smooth\",\n\t\t\"PARAMS\":0.05,\n\t\t\"UI_GROUP\":\"position\",\n\t\t\"MIN\":0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":1.0\n\t\t},{\"NAME\":\"auto_direction\", \n\t\t\"DESCRIPTION\":\"Turn this on for auto audio-reactive zoom pos control\",\n\t\t\"TYPE\":\"toggle\",\n\t\t\"UI_GROUP\":\"position\",\n\t\t\"MIN\":0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":0.0\n\t\t},\n\t\t{\"NAME\":\"media_pos\", \n\t\t\"DESCRIPTION\":\"This lets you scroll the underlying media while keeping the directional blur effect constant\",\n\t\t\"TYPE\":\"xy smooth\",\n\t\t\"PARAMS\":0.02,\n\t\t\"UI_GROUP\":\"media\",\n\t\t\"MIN\":-1.0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":0.0\n\t\t},\n\t\t{\"NAME\":\"mirror_tile\", \n\t\t\"DESCRIPTION\":\"Turn off if you want the media to tile normally, instead of mirrored\",\n\t\t\"TYPE\":\"toggle\",\n\t\t\"UI_GROUP\":\"media\",\n\t\t\"MIN\":0.0,\n\t\t\"MAX\":1.0,\n\t\t\"DEFAULT\":1.0\n\t\t},\n\t\t{\"NAME\":\"thickness_grid\", \n\t\t\"DESCRIPTION\":\"This affects the thickness of the grid lines that show up when no media is selected\",\n\t\t\"TYPE\":\"slider smooth\",\n\t\t\"UI_GROUP\":\"no_media\",\n\t\t\"PARAMS\":0.04,\n\t\t\"MIN\":0.0,\n\t\t\"MAX\":0.2,\n\t\t\"DEFAULT\":0.03\n\t\t}\n\t],\n   \"CREDIT\" : \"Synesthesia\",\n   \"DESCRIPTION\" : \"\",\n   \"HEIGHT\" : 1080,\n   \"IMAGE_PATH\" : \"videofx_directionalblur.png\",\n   \"TITLE\" : \"VideoFX_DirectionalBlur\",\n   \"WIDTH\" : 1920\n}\n","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"vec4 texMirror(sampler2D samplerIn, vec2 uvIn, float isMediaIn){\n\tvec2 uvInM = uvIn;\n\tif (mirror_tile>0.5){\n\t\tif (mod(uvInM.x, 2.0) > 1.0){\n\t\t\tuvInM.x = 1.0-uvInM.x;\n\t\t}\n\t\tif (mod(uvInM.y, 2.0) > 1.0){\n\t\t\tuvInM.y = 1.0-uvInM.y;\n\t\t}\n\t}\n\tvec4 tex = texture(samplerIn, uvInM);\n\tvec4 col = vec4(0.0);\n\tcol += _sqPulse(fract(uvInM.x), 0.0, 0.01+thickness_grid);\n\tcol += _sqPulse(fract(uvInM.y), 0.0, 0.01+thickness_grid);\n\treturn mix(col, tex, isMediaIn);\n}\n\nvec2 _rotateAboutCenter(vec2 uvIn, float amt){\n  vec2 uvNew = uvIn;\n  _uv2uvc(uvNew);\n  uvNew = _rotate(uvNew, amt);\n  _uvc2uv(uvNew);\n  return uvNew;\n}\n\nvec4 renderMain(void) {\n\tfloat isMedia = float(_exists(syn_UserImage));\n\tvec2 lookupPos = mix(_uvc*20.0, _correctImageCoords(textureSize(syn_UserImage,0)), isMedia);\n\tfloat zoomAmt = zoom_amt*zoom_amt;\n\tvec3 radialBlur = vec3(0.0);\n\tint numIters = int(zoom_levels);\n\tvec2 zoompos = mix(zoom_pos, vec2(sin(syn_Time*0.25+syn_ToggleOnBeat*0.5*PI), (-0.5+1.0*_statelessContinuousChaotic(syn_ToggleOnBeat*0.009+syn_Time*0.0033)))*0.5, auto_direction);\n\tfor(int i = 0; i < numIters+1; i++){\n\t\tvec3 video = _contrast(_invertImage(vec4(texMirror(syn_UserImage, _invertYAxisVideo(lookupPos+media_pos), isMedia).rgb,0.0)),_Media_Contrast).rgb;\n\t\tlookupPos = lookupPos*(1.0-zoomAmt);\n\t\tlookupPos += vec2(zoomAmt, zoomAmt)*0.5-zoompos*mix(0.025, 0.0025, micro_adjust)*mix(20.0,1.0,isMedia);\n\t\tlookupPos *= vec2(RENDERSIZE.x/RENDERSIZE.y, 1.0);\n\t\t//0.218 magic number that keeps it centered? wat?\n\t\tlookupPos -= vec2(0.218*RENDERSIZE.x/RENDERSIZE.y, 0.0);\n\t\tlookupPos = _rotateAboutCenter(lookupPos, sign(roto)*roto*roto*2*PI);\n\t\tlookupPos += vec2(0.218*RENDERSIZE.x/RENDERSIZE.y, 0.0);\n\t\tlookupPos /= vec2(RENDERSIZE.x/RENDERSIZE.y, 1.0);\n\n\t\tif (audio_zoom > 0.5){\n\t\t\tradialBlur += video*brightness*5.0*(0.5+0.5*sin(-syn_BassTime*1.5-TIME*0.75+4*PI*float(i)/numIters));\n\t\t} else {\n\t\t\tradialBlur += video*brightness;\n\t\t}\n\t}\n\tradialBlur = pow(radialBlur/(numIters+1), vec3(1.0+blur_gamma));\n\t// vec3 finalColor = pow(loopOut/(numIters*0.8+1), vec3(2.0));\n\t// finalColor += _sqPulse(_uv.x, 0.5, 0.001);\n\tvec3 finalColor = radialBlur;\n  return vec4(finalColor, 1.0);\n}\n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"VideoFX_DirectionalBlur","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Causes a bright pulse to emanate from the center.","MAX":1,"MIN":0,"NAME":"pulse","PARAMS":0.00999999977648258,"TYPE":"bang smooth","UI_GROUP":"reactivity"},{"DEFAULT":2,"DESCRIPTION":"Affects the speed of the crystal gyration.","MAX":5,"MIN":0,"NAME":"speed_motion","TYPE":"slider","UI_GROUP":"reactivity"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"grid_growth","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"highs_shimmer","TYPE":"toggle","UI_GROUP":"reactivity"},{"DEFAULT":0,"DESCRIPTION":"Zooms the camera in or out. Fully out causes it to take on a 'planetoid' look.","MAX":1,"MIN":-1,"NAME":"elevation","PARAMS":0.025000000372529,"TYPE":"slider smooth","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Whether or not the camera is rotating.","MAX":1,"MIN":0,"NAME":"spinning","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"OFF: Standard, angular crystals. ON: Grid-like crystals using the manhattan distance.","MAX":1,"MIN":0,"NAME":"alternate_crystals","TYPE":"toggle","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"Deforms the surface, distorting the edges in glitchy ways.","MAX":0.100000001490116,"MIN":-0.100000001490116,"NAME":"rot_distort","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"Default, geode-looking red texture. TURN OFF to use other backgrounds.","MAX":1,"MIN":0,"NAME":"red_geode","TYPE":"toggle","UI_GROUP":"background"},{"DEFAULT":1,"DESCRIPTION":"Green, circuit-like texture. TURN OFF to use other backgrounds.","MAX":1,"MIN":0,"NAME":"green_circuits","TYPE":"toggle","UI_GROUP":"background"}],"CREDIT":"Shane","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\voronoi_geode.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":648,"ID":"Voronoi Geode","IMAGES":[{"NAME":"agate2","PATH":"images/agate2.jpg"},{"NAME":"agate1","PATH":"images/agate1.jpg"}],"IMAGE_PATH":"voronoi_geode.synScene\\voronoi_geode.png","JSON_CODE":"{\n  \"CREDIT\": \"Shane\",\n  \"TITLE\": \"Voronoi Geode\",\n  \"IMAGE_PATH\": \"voronoi_geode.png\",\n  \"IMAGES\": [{\"NAME\": \"agate2\", \"PATH\":\"images/agate2.jpg\"},{\"NAME\": \"agate1\", \"PATH\":\"images/agate1.jpg\"}],\n  \"WIDTH\": 1152,\n  \"HEIGHT\":648,\n  \"CONTROLS\":[\n    {\"NAME\": \"pulse\", \"TYPE\": \"bang smooth\", \"UI_GROUP\": \"reactivity\", \"PARAMS\":0.01,\n    \"DESCRIPTION\":\"Causes a bright pulse to emanate from the center.\"},\n    {\"NAME\": \"speed_motion\", \"TYPE\": \"slider\", \"MIN\": 0.0, \"MAX\": 5.0, \"DEFAULT\": 2.0, \"UI_GROUP\":\"reactivity\",\n    \"DESCRIPTION\":\"Affects the speed of the crystal gyration.\"},\n    {\"NAME\": \"grid_growth\", \"TYPE\": \"toggle\", \"DEFAULT\": 1.0, \"UI_GROUP\": \"reactivity\",\n    \"DESCRIPTION\":\"\"},\n    {\"NAME\": \"highs_shimmer\", \"TYPE\": \"toggle\", \"DEFAULT\": 1.0, \"UI_GROUP\": \"reactivity\",\n    \"DESCRIPTION\":\"\"},\n    {\"NAME\": \"elevation\", \"TYPE\": \"slider smooth\", \"MIN\": -1.0, \"MAX\": 1.0, \"DEFAULT\": 0.0, \"UI_GROUP\": \"camera\", \"PARAMS\": 0.025,\n    \"DESCRIPTION\":\"Zooms the camera in or out. Fully out causes it to take on a 'planetoid' look.\"},\n    {\"NAME\": \"spinning\", \"TYPE\": \"toggle\", \"DEFAULT\": 1.0, \"UI_GROUP\": \"camera\",\n    \"DESCRIPTION\":\"Whether or not the camera is rotating.\"},\n    {\"NAME\": \"alternate_crystals\", \"TYPE\": \"toggle\", \"UI_GROUP\": \"geometry\",\n    \"DESCRIPTION\":\"OFF: Standard, angular crystals. ON: Grid-like crystals using the manhattan distance.\"},\n    {\"NAME\": \"rot_distort\", \"TYPE\": \"slider smooth\", \"UI_GROUP\": \"geometry\", \"MIN\":-0.1, \"DEFAULT\": 0.0, \"MAX\":0.1, \"PARAMS\":0.1,\n    \"DESCRIPTION\":\"Deforms the surface, distorting the edges in glitchy ways.\"},\n    {\"NAME\": \"red_geode\", \"TYPE\": \"toggle\", \"UI_GROUP\": \"background\", \"DEFAULT\": 1.0,\n    \"DESCRIPTION\":\"Default, geode-looking red texture. TURN OFF to use other backgrounds.\"},\n    {\"NAME\": \"green_circuits\", \"TYPE\": \"toggle\", \"UI_GROUP\": \"background\", \"DEFAULT\": 1.0,\n    \"DESCRIPTION\":\"Green, circuit-like texture. TURN OFF to use other backgrounds.\"}\n]\n}\n","PASSES":null,"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = 0.25*bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count !== Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  }\n  this.timeWithinBeat = this.time-this.count;\n}\n\nfunction Timer () {\n  this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function(rate, val, dt) {\n  this.time = this.time+rate*dt*val;\n}\n\n// var bpmcount = new BPMCounter();\n// var downrot = new SmoothCounter();\n// var rightrot = new SmoothCounter();\n\nvar timevar = new Timer();\n\nvar decimator = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  try {\n    timevar.updateTime(inputs.speed_motion*inputs.speed_motion, Math.pow(inputs.syn_HighHits,2.0)*2.0, dt);\n    uniforms.script_time = timevar.time;\n  }  \n  catch (e){\n    print(e);\n  }\n\n  // timevar.updateTime(inputs.rate_in, 0.1+inputs.syn_Level+inputs.syn_HighLevel+inputs.syn_Hits*0.5, dt);\n  // downrot.update(dt, inputs.down_rot, 0.1);\n  // rightrot.update(dt, inputs.right_rot, 0.1);\n\n  // uniforms.down_rot_scr = downrot.currentValue;\n  // uniforms.right_rot_scr = rightrot.currentValue;\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(pulse_pos[0]);\n  // }\n\n}","SHADER_CODE":"  // Perspex Web Lattice\n  // -------------------\n  \n  // I felt that Shadertoy didn't have enough Voronoi examples, so I made another one. :) I'm\n  // not exactly sure what it's supposed to be... My best guess it that an Alien race with no \n  // common sense designed a monitor system with physics defying materials. :)\n\n  // Technically speaking, there's not much to it. It's just some raymarched 2nd order Voronoi.\n  // The dark perspex-looking web lattice is created by manipulating the Voronoi value slightly \n  // and giving the effected region an ID value so as to color it differently, but that's about\n  // it. The details are contained in the \"heightMap\" function.\n\n  // There's also some subtle edge detection in order to give the example a slight comic look. \n  // 3D geometric edge detection doesn't really differ a great deal in concept from 2D pixel \n  // edge detection, but it obviously involves more processing power. However, it's possible to \n  // combine the edge detection with the normal calculation and virtually get it for free. Kali \n  // uses it to great effect in his \"Fractal Land\" example. It's also possible to do a\n  // tetrahedral version... I think Nimitz and some others may have done it already. Anyway, \n  // you can see how it's done in the \"nr\" (normal) function.\n\n  // Geometric edge related examples:\n\n  // Fractal Land - Kali\n  // https://www.shadertoy.com/view/XsBXWt\n\n  // Rotating Cubes - Shau\n  // https://www.shadertoy.com/view/4sGSRc\n\n  // Voronoi mesh related:\n\n  //   // I haven't really looked into this, but it's interesting.\n  // Weaved Voronoi - FabriceNeyret2 \n  //   https://www.shadertoy.com/view/ltsXRM\n\n\n\n#define FAR 2.\n\nint id = 0; // Object ID - Red perspex: 0; Black lattice: 1.\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2), .001);\n    n /= (n.x + n.y + n.z ); // Roughly normalized.\n    vec3 col;\n    if (red_geode > 0.5){\n      col = (texture(agate1, p.yz)*n.x + texture(agate1, p.zx)*n.y + texture(agate1, p.xy)*n.z).xyz;\n    } else if (green_circuits > 0.5){\n      col = pow((texture(agate2, p.yz*0.5)*n.x + texture(agate2, p.zx*1.0)*n.y + texture(agate2, p.xy*0.75)*n.z).xyz, vec3(1.8))*2.0;\n    } else {\n      col = vec3(0);\n    }\n    if (syn_MediaType > 0.5){\n      col = (texture(syn_UserImage, p.yz*0.25-vec2(0.5,0.5))*n.x + texture(syn_UserImage, p.zx*0.25-vec2(0.5,0.5))*n.y + texture(syn_UserImage, p.xy*0.25-vec2(0.5,0.5))*n.z).xyz;\n    }\n    \n    // Loose sRGB to RGB conversion to counter final value gamma correction...\n    // in case you're wondering.\n    return col*col;\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n  float retVal = _pulse(fract(p.z*p.z*10.0), 0.5, 0.1);\n  const vec3 s = vec3(7, 157, 113);\n  vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    float var = mix(h.x, h.y, p.z);\n    return mix(var, var*(0.7+syn_HighHits*0.5), highs_shimmer); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    p = sin( p*6.2831853 + script_time*0.5)*.45 + .5; \n    return mix(p, vec2(0.0), grid_growth*(1.0-syn_Presence));\n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n  vec2 g = floor(p), o; p -= g;\n  \n  vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n  // g.xy += _pulse(dot(_uvc, _uvc)*0.25, 1.0-pulseCrystal, 0.2)*0.000001;\n  \n  for(int y = -1; y <= 1; y++){\n    for(int x = -1; x <= 1; x++){\n            \n      o = vec2(x, y);\n      o += hash22(g + o) - p;\n      d.z = dot(o, o); \n            // More distance metrics.\n            o = abs(o);\n            // d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            if (alternate_crystals > 0.5){\n              d.z = max(o.x, o.y);\n            }\n            // d.z = (o.x*.7 + o.y*.7);\n\n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n    }\n  }\n    d.xy -= _pulse(dot(_uvc, _uvc)*0.25, 0.95-pulse, 0.15)*4.0;\n    // d.xy -= syn_BassLevel*pow(distance(_uv, vec2(sin(TIME), cos(TIME))),3.0)*1.0*bass_pulse;\n\n    return (max(d.y/1.2 - d.x*1., 0.)/1.2)*2.0;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\n// The height map values. In this case, it's just a Voronoi variation. By the way, I could\n// optimize this a lot further, but it's not a particularly taxing distance function, so\n// I've left it in a more readable state.\nfloat heightMap(vec3 p){\n    // p.xy -= _uvc*_pulse(dot(_uvc, _uvc)*0.25, 1.0-pulseCrystal, 0.2)*0.1;\n\n    id =0;\n    float c = Voronoi(p.xy*6.); // The fiery bit.\n\n    // For lower values, reverse the surface direction, smooth, then\n    // give it an ID value of one. Ie: this is the black web-like\n    // portion of the surface.\n    if (c<.07) {c = smoothstep(0.7, 1., mix(1.-c, c, 0.0))*.2; id = 1; }\n    return c;\n}\n\n// Standard back plane height map. Put the plane at vec3(0, 0, 1), then add some height values.\n// Obviously, you don't want the values to be too large. The one's here account for about 10%\n// of the distance between the plane and the camera.\nfloat m(vec3 p){\n   \n    float h = heightMap(p); // texture(iChannel0, p.xy/2.).x; // Texture work too.\n    \n    return 1. - p.z - h*.1;\n    \n}\n\n// // Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\n// vec3 nr(in vec3 p){\n\n//     // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n//     vec2 e = vec2(0.005, -0.005); \n//     return normalize(e.xyy * m(p + e.xyy) + e.yyx * m(p + e.yyx) + e.yxy * m(p + e.yxy) + e.xxx * m(p + e.xxx));\n// }\n\n\n// // Standard normal function - for comparison with the one below.\n// vec3 nr(in vec3 p) {\n//   const vec2 e = vec2(0.005, 0);\n//   return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy), m(p + e.yyx) - m(p - e.yyx)));\n// }\n\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n  \n    vec2 e = vec2(.005, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n  float d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n  float d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n  float d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n  float d = m(p)*2.;  // The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n  \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n/*\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n  float sca = 3., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = m(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n*/\n\n\n// Standard hue rotation formula... compacted down a bit.\n// vec3 rotHue(vec3 p, float a){\n\n//     vec2 cs = sin(vec2(1.570796, 0) + a);\n\n//     mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n//             mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n//             mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n               \n//     return clamp(p*hr, 0., 1.);\n// }\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= syn_Time*.1;\n    rd *= 3.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = (n3D(rd)*.57 + n3D(rd*2.)*.28)*1.2; // Noise value.\n    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.\n    col *= vec3(1.0, syn_BassHits*3.0, 1.0);\n\n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\nvec4 renderMain(){\n    vec4 c = vec4(0.0);\n    // Unit direction ray, camera origin and light position.\n    vec3 r = normalize(vec3(_xy - RENDERSIZE.xy*.5, RENDERSIZE.y)), \n         o = vec3(0, 0, elevation), \n         l = o + vec3(0, 0, -1);\n   \n    // Rotate the canvas. Note that sine and cosine are kind of rolled into one.\n    vec2 a = sin(vec2(1.570796, 0) + TIME*spinning/8.); // Fabrice's observation.\n    r.xy = mat2(a, -a.y, a.x) * r.xy;\n\n    \n    // Standard raymarching routine. Raymarching a slightly perturbed back plane front-on\n    // doesn't usually require many iterations. Unless you rely on your GPU for warmth,\n    // this is a good thing. :)\n    float d, t = 0.;\n    \n    for(int i=0; i<32;i++){\n      if (i%2 == 0){\n        r.xy = _rotate(r.xy, d*d*rot_distort*500.0);\n\n      }\n\n        d = m(o + r*t);\n        // There isn't really a far plane to go beyond, but it's there anyway.\n        if(abs(d)<0.001 || t>FAR) break;\n        t += d*0.99;\n\n    }\n    \n    t = min(t, FAR);\n    \n    // Set the initial scene color to black.\n    c = vec4(0);\n    \n    float edge = 0.; // Edge value - to be passed into the normal.\n    \n    if(t<FAR){\n    \n        vec3 p = o + r*t, n = nr(p, edge);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n \n        // Obtain the height map (destorted Voronoi) value, and use it to slightly\n        // shade the surface. Gives a more shadowy appearance.\n        float hm = heightMap(p);\n\n        // Texture value at the surface. Use the heighmap value above to distort the\n        // texture a bit.\n        vec3 tx = tex3D((p*2. + hm*(0.2+syn_MediaType*0.2)), n);\n        // tx = floor(tx*15.999)/15.; // Quantized cartoony colors, if you get bored enough.\n\n        c.xyz = vec3(1.)*(hm*.8 + .2); // Applying the shading to the final color.\n        \n        c.xyz *= vec3(1.5)*tx; // Multiplying by the texture value and lightening.\n        \n        \n        // Color the cell part with a fiery (I incorrectly spell it firey all the time) \n        // palette and the latticey web thing a very dark color.\n        //\n        c.x = dot(c.xyz, vec3(.299, .587, .114)); // Grayscale.\n        if (id==0){\n          if ((syn_MediaType > 0.5)&&(red_geode < 0.5)&&(green_circuits < 0.5)){\n            c.xyz += tx;\n          } else {\n            c.xyz *= vec3(min(c.x*1.5, 1.), pow(c.x, 5.), pow(c.x, 24.))*2.;\n            if ((green_circuits > 0.5)&&(red_geode < 0.5)){\n              c.rgb = c.brg;\n            }\n          }\n        } else{\n          c.xyz = c.xyz*0.1;\n        }\n        \n        // Hue rotation, for anyone who's interested.\n        // c.xyz = rotHue(c.xyz, mod(TIME*0.5/16., 6.283));\n       \n        \n        float df = max(dot(l, n), 0.); // Diffuse.\n        float sp = pow(max(dot(reflect(-l, n), -r), 0.), 32.); // Specular.\n        \n        if(id == 1) sp *= sp; // Increase specularity on the dark lattice.\n        \n    // Applying some diffuse and specular lighting to the surface.\n        c.xyz = c.xyz*(df + .75) + vec3(1, .97, .92)*sp + vec3(.5, .7, 1)*pow(sp, 32.);\n        \n        // Add the fake environmapping. Give the dark surface less reflectivity.\n        vec3 em = eMap(reflect(r, n), n); // Fake environment mapping.\n        if(id == 1) em *= .5;\n        c.xyz += em*(0.0+0.9*syn_Level);\n        \n        // Edges.\n        //if(id == 0)c.xyz += edge*.1; // Lighter edges.\n        c.xyz *= 1. - edge*.8; // Darker edges.\n        \n        // Attenuation, based on light to surface distance.    \n        c.xyz *= 1./(1. + d*d*.125);\n        \n        // AO - The effect is probably too subtle, in this case, so we may as well\n        // save some cycles.\n        //c.xyz *= cAO(p, n);\n        c.rgb += smoothstep(0.5,1.0,edge)*1.0*0.0;\n    }\n    \n    \n    // Vignette.\n    //vec2 uv = u/RENDERSIZE.xy;\n    //c.xyz = mix(c.xyz, vec3(0, 0, .5), .1 -pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)*.1);\n    c = mix(c, pow(c, vec4(1.5))*2.0, abs(rot_distort)*10.0);\n    // Apply some statistically unlikely (but close enough) 2.0 gamma correction. :)\n    return vec4(sqrt(clamp(c.xyz, 0., 1.)), 1.);\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Voronoi Geode","WIDTH":1152,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[40,40],"DESCRIPTION":"","MAX":[500,500],"MIN":[1,1],"NAME":"scramble","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":155,"DESCRIPTION":"","MAX":233,"MIN":34,"NAME":"seed1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":377,"DESCRIPTION":"","MAX":987,"MIN":89,"NAME":"seed2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":10,"DESCRIPTION":"","MAX":20,"MIN":0,"NAME":"scale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":3,"MIN":0.100000001490116,"NAME":"rate","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"C","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"M","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"Y","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2.5,"DESCRIPTION":"","MAX":3,"MIN":0,"NAME":"Sat","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\voronoicubes.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"VoronoiCubes","IMAGES":null,"IMAGE_PATH":"voronoicubes.synScene\\voronoicubes.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t40,\n\t\t\t\t40\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t500,\n\t\t\t\t500\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"NAME\" : \"scramble\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 155,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 233,\n\t\t\t\"MIN\" : 34,\n\t\t\t\"NAME\" : \"seed1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 377,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 987,\n\t\t\t\"MIN\" : 89,\n\t\t\t\"NAME\" : \"seed2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 10,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"scale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"rate\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"C\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"M\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"Y\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 3,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"Sat\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"voronoicubes.png\",\n\t\"TITLE\" : \"VoronoiCubes\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n////////////////////////////////////////////////////////////////////\n// VoronoiCubes  by mojovideotech\n//\n// based on :\n// shadertoy.com/\\MdSGRc\n// glslsandbox.com\\/e#47085.0\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n////////////////////////////////////////////////////////////////////\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n\n#define    c30    0.866025       // cos 30\n#define    twpi   6.283185       // two pi, 2*pi\n\nfloat n1(float n) { return fract(sin(n) * seed1 + seed2); }\n\nvec2 n2(vec2 n) { return fract(sin(n) * seed1 * seed2); }\n\nvec2  n3(vec2  p) { \n\tp = vec2(dot(p, n2(vec2(seed1, seed2))), dot(p, vec2(seed2, seed1))); \n\treturn n2(p); }\n\nvec4 voronoi( in vec2 x, float mode ) {\n    vec2 n = floor(x), f = fract(x);\n    vec3 m = vec3(8.0);\n\tfloat m2 = 0.0;\t\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ ) {\n        vec2 g = vec2( float(i),float(j));\n        vec2 o = n3( n + g );\n        o = 0.5 + 0.5 * sin((TIME*rate) + twpi * o);\n\t\tvec2 r = g - f + o;\n\t\tvec2 d0 = vec2( sqrt(dot(r,r)), 1.0 );\n\t\tvec2 d2 = vec2( max(abs(r.x) * c30 + r.y * 0.5, -r.y), \n\t\t\t\t        step(0.0, 0.5 * abs(r.x) + c30 * r.y) * (1.0 + step(0.0, r.x)));\n    \tvec2 d = mix( d2, d0, fract(mode));\n        if( d.x<m.x ) {\n\t\t\tm2 = m.x;\n            m.x = d.x;\n            m.y = n1( dot(n + g, scramble));\n\t\t\tm.z = d.y;\n        }\n\t\telse if( d.x<m2 ) {\tm2 = d.x; }\n    }\n    return vec4( m, m2-m.x );\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tfloat mode = mod(TIME / 5.0, 3.0);\n\tmode = floor(mode) + smoothstep(0.8, 1.0, fract(mode));\n    vec2 p = _xy.xy/RENDERSIZE.xx;\n    vec4 c = voronoi((24.0 - scale) * p, 2.0);\n    vec3 col = 0.5 + 0.5 * sin(c.y * Sat + vec3(C, M, Y));\n    col *= sqrt(clamp(1.0 - c.x, 0.0, 1.0));\n\tcol *= clamp(0.5 + (1.0 - c.z / 2.0) * 0.5, 0.0, 1.0);\n    out_FragColor = vec4( col, 1.0 );\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"VoronoiCubes","WIDTH":1920,"isDisabled":false},{"CONTROLS":null,"CREDIT":"by mojovideotech","DESCRIPTION":"Automatically converted from http://glslsandbox.com/e#15588.0","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\voronoilines.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"VoronoiLines","IMAGES":null,"IMAGE_PATH":"voronoilines.synScene\\voronoilines.png","JSON_CODE":"{\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"Automatically converted from http://glslsandbox.com/e#15588.0\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"voronoilines.png\",\n\t\"TITLE\" : \"VoronoiLines\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\n\n// Shader by Nicolas Robert [NRX]\n// Latest version: http://glsl.heroku.com/e#15513\n// Concept from: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat iGlobalTime = TIME*.25;\nvec3 iResolution = vec3 (RENDERSIZE, 0.0);\n\n#define SIZE \t\t8\n#define SQRT2\t\t1.41421356237\n#define HASH_MAGNITUDE\t(2.0 * SQRT2 - 1.0) // Ok if: HASH_MAGNITUDE <= KERNEL * SQRT (2) - 1\n#define KERNEL\t\t2 // Ok if: KERNEL >= (HASH_MAGNITUDE + 1) / SQRT (2)\n#define BORDER\n\nfloat hash (in int index) {\n\tfloat x = float (index);\n\treturn HASH_MAGNITUDE * 0.5 * sin (sin (x) * x + sin (x * x) * iGlobalTime);\n}\n\nvec2 pointInCell (in ivec2 cell) {\n\tint index = cell.x + cell.y * SIZE;\n\treturn vec2 (cell) + vec2 (hash (index), hash (index + 1));\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec2 p = float (SIZE) * (_xy.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tivec2 pCell = ivec2 (floor (p + 0.5));\n\n\tfloat dMin = 2.0 * HASH_MAGNITUDE;\n\tvec2 pqMin;\n\tivec2 minCell;\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\tfloat d = dot (pq, pq);\n\t\t\tif (d < dMin) {\n\t\t\t\tdMin = d;\n\t\t\t\tpqMin = pq;\n\t\t\t\tminCell = qCell;\n\t\t\t}\n\t\t}\n\t}\n\tdMin = sqrt (dMin)+5000.0;\n\tint col = minCell.x + minCell.y * SIZE;\n\tvec4 color = 0.6 + vec4 (hash (col), hash (col + 1), hash (col + 2), 0.0) * 0.8 / HASH_MAGNITUDE;\n\n\t#ifdef BORDER\n\tfor (int y = -KERNEL; y <= KERNEL; ++y) {\n\t\tfor (int x = -KERNEL; x <= KERNEL; ++x) {\n\t\t\tivec2 qCell = pCell + ivec2 (x, y);\n\t\t\tif (qCell != minCell) {\n\t\t\t\tvec2 pq = pointInCell (qCell) - p;\n\t\t\t\tdMin = min (dMin, dot (0.5 * (pqMin + pq), normalize (pq - pqMin)));\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\n\tout_FragColor = color * min(dMin* 8.0, 1.0) * ( .5 + .5*sin (TIME*-10.+dMin * .5*iResolution.y / float (SIZE)));\n\nreturn out_FragColor; \n } \n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"VoronoiLines","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.25,"DESCRIPTION":"Rate of the effect.","MAX":1,"MIN":0,"NAME":"rate","PARAMS":0.00999999977648258,"TYPE":"knob smooth","UI_GROUP":"effect"},{"DEFAULT":0.5,"DESCRIPTION":"Scale of the effect on the input media.","MAX":1,"MIN":0.100000001490116,"NAME":"scale","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"effect"},{"DEFAULT":0.5,"DESCRIPTION":"How dramatically the effect modifies the input media.","MAX":1,"MIN":0,"NAME":"intensity","TYPE":"slider","UI_GROUP":"effect"},{"DEFAULT":[0,0],"DESCRIPTION":"Nudge effect in any direction.","MAX":[-2,-2],"MIN":[2,2],"NAME":"direction","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"effect"},{"DEFAULT":[0,0],"DESCRIPTION":"Pan input media in any direction.","MAX":[-1,-1],"MIN":[1,1],"NAME":"position","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"media"},{"DEFAULT":0,"DESCRIPTION":"Zoom in and out of the input media.","MAX":1,"MIN":0,"NAME":"zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"media"}],"CREDIT":"Shady Headstash","DESCRIPTION":"Distort media with noise.","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\waterly.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Waterly","IMAGES":[{"NAME":"image10","PATH":"images/watertex.png"}],"IMAGE_PATH":"waterly.synScene\\waterly.png","JSON_CODE":"{\n    \"CONTROLS\": [\n        {\n            \"DEFAULT\": 0.25,\n            \"DESCRIPTION\": \"Rate of the effect.\",\n            \"IS_META\": false,\n            \"MAX\": 1,\n            \"MIN\": 0,\n            \"NAME\": \"rate\",\n            \"TYPE\": \"knob smooth\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0.5,\n            \"DESCRIPTION\": \"Scale of the effect on the input media.\",\n            \"IS_META\": false,\n            \"MAX\": 1.0,\n            \"MIN\": 0.1,\n            \"NAME\": \"scale\",\n            \"TYPE\": \"slider smooth\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0.5,\n            \"DESCRIPTION\": \"How dramatically the effect modifies the input media.\",\n            \"IS_META\": false,\n            \"MAX\": 1,\n            \"MIN\": 0,\n            \"NAME\": \"intensity\",\n            \"TYPE\": \"slider\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0,\n            \"DESCRIPTION\": \"Nudge effect in any direction.\",\n            \"IS_META\": false,\n            \"MAX\": -2,\n            \"MIN\": 2,\n            \"NAME\": \"direction\",\n            \"TYPE\": \"xy smooth\",\n            \"UI_GROUP\": \"effect\"\n        },\n        {\n            \"DEFAULT\": 0,\n            \"DESCRIPTION\": \"Pan input media in any direction.\",\n            \"IS_META\": false,\n            \"MAX\": -1,\n            \"MIN\": 1,\n            \"NAME\": \"position\",\n            \"TYPE\": \"xy smooth\",\n            \"UI_GROUP\": \"media\"\n        },\n        {\n            \"DEFAULT\": 0.0,\n            \"DESCRIPTION\": \"Zoom in and out of the input media.\",\n            \"IS_META\": false,\n            \"MAX\": 1.0,\n            \"MIN\": 0.0,\n            \"NAME\": \"zoom\",\n            \"TYPE\": \"slider smooth\",\n            \"UI_GROUP\": \"media\"\n        }\n    ],\n    \"CREDIT\": \"Shady Headstash\",\n    \"DESCRIPTION\": \"Distort media with noise.\",\n    \"HEIGHT\": 1080,\n    \"IMAGES\": [\n        {\n            \"NAME\": \"image10\",\n            \"PATH\": \"images/watertex.png\"\n        }\n    ],\n    \"IMAGE_PATH\": \"waterly.png\",\n    \"TITLE\": \"Waterly\",\n    \"WIDTH\": 1920\n}\n","PASSES":null,"SCRIPT_CODE":"function Timer() {\n    this.time = 0.0;\n}\n\nTimer.prototype.updateTime = function (rate, val, dt) {\n    this.time = this.time + rate * dt * val;\n}\n\nvar bassTimevar = new Timer();\nvar timevar = new Timer();\n\nfunction update(dt) {\n\n    try {\n        bassTimevar.updateTime(1.0, inputs.rate + inputs.rate * (inputs.syn_Level * 2.0 + inputs.syn_Presence + inputs.syn_Hits + inputs.syn_BassPresence + inputs.syn_BassHits * 2.0), dt);\n        timevar.updateTime(1.0, inputs.rate, dt);\n\n        uniforms.script_time = timevar.time;\n        uniforms.bass_time = bassTimevar.time;\n    }\n\n    catch (e) {\n        print(e);\n    }\n\n}\n","SHADER_CODE":"// --- Original \"waterly video - test\" shader by FabriceNeyret2 from https://www.shadertoy.com/view/MdlGDM\n// Modified by Mikael Ems (Shady Headstash)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 texMirror(sampler2D samplerIn, vec2 uvIn){\n    if (mod(uvIn.x, 2.0) > 1.0){\n        uvIn.x = 1.0-uvIn.x;\n    }\n    if (mod(uvIn.y, 2.0) > 1.0){\n        uvIn.y = 1.0-uvIn.y;\n    }\n    return texture(samplerIn, mod(_invertYAxisVideo(uvIn), 1.0));\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of: Created by inigo quilez --------------------\nfloat mynoise ( vec3 p)\n{\n    return noise(p*scale)*(6.0*intensity);\n}\nfloat myfbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*mynoise( p ); p = m*p*2.02;\n    f += 0.2500*mynoise( p ); p = m*p*2.03;\n    f += 0.1250*mynoise( p ); p = m*p*2.01;\n    f += 0.0625*mynoise( p ); p = m*p*2.05;\n    f += 0.0625/2.*mynoise( p ); p = m*p*2.02;\n    f += 0.0625/4.*mynoise( p );\n    return f;\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle));\n}\n\nvec4 renderMainImage() {\n\tvec4 fragColor = vec4(0.0);\n\tvec2 fragCoord = _xy;\n\n\tvec2 uv = fragCoord.xy / RENDERSIZE.xy;\n    uv.xy += direction.xy;\n\n    uv = rotate2d(1*-PI) * uv;\n\n\tvec3 v;\n\tvec3 p = 4.*vec3(uv,0.)+bass_time*0.1*(.1,.7,1.2);\n\tfloat x = myfbm(p);\n\t//v = vec3(x);\n\tv = (.5+.5*sin(x*vec3(30.,20.,10.)*1.))/1.;\n\tfloat g = 1.;\n\t//g = pow(length(v),1.);\n\tg =  .5*noise(8.*m*m*m*p)+.5; g = 2.*pow(g,3.);\n\tv *= g;\n\n    vec3 Ti = texMirror(_exists(syn_UserImage) ? syn_UserImage : image10, .02*v.xy+position.xy+(fragCoord.xy / RENDERSIZE.xy)*(1.0-zoom)*0.99-0.5*(1.0-zoom)*0.99+0.5).rgb*1.4-.2;\n    vec3 T=Ti;\n    //T = Ti+(1.-Ti)*Tf;\n\tvec3 T1,T2;\n\tT1 = vec3(0.,0.,0.); T1 *= .5*(T+1.);\n\tT2 = vec3(1.,1.,1.); //T2 = 1.2*Ti*vec3(1.,.8,.6)-.2;\n\tv = mix(T1,T2,T);\n\tfragColor = vec4(v,1.0);\n\n\treturn fragColor;\n }\n\n\nvec4 renderMain(){\n\tif(PASSINDEX == 0){\n\t\treturn renderMainImage();\n\t}\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Waterly","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.600000023841858,"DESCRIPTION":"","MAX":20,"MIN":-20,"NAME":"amp","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-3,"DESCRIPTION":"","MAX":0,"MIN":-20,"NAME":"glow","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"mod1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"mod2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":4,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"rotateCanvas","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"scroll","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"pos","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"twisted","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"Joseph Fiola","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\wavelines.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"WaveLines","IMAGES":null,"IMAGE_PATH":"wavelines.synScene\\wavelines.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.6,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 20,\n\t\t\t\"MIN\" : -20,\n\t\t\t\"NAME\" : \"amp\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -3,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0,\n\t\t\t\"MIN\" : -20,\n\t\t\t\"NAME\" : \"glow\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mod1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"mod2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 4,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rotateCanvas\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"scroll\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"pos\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"twisted\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"Joseph Fiola\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"wavelines.png\",\n\t\"TITLE\" : \"WaveLines\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"// SaturdayShader Week 29 : Wave Lines\r\n// by Joseph Fiola (http://www.joefiola.com)\r\n// 2016-03-05\r\n\r\n// Based on \"WAVES\" Shadertoy by bonniem\r\n// https://www.shadertoy.com/view/4dsGzH\r\n\r\n\r\n\r\n\r\n#define PI 3.14159265359\r\n#define TWO_PI 6.28318530718\r\n\r\nmat2 rotate2d(float _angle){\r\n    return mat2(cos(_angle),-sin(_angle),\r\n                sin(_angle),cos(_angle));\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tvec2 uv = _xy.xy / RENDERSIZE.xy;\r\n\tuv -= vec2(pos);\r\n\tuv.x *= RENDERSIZE.x/RENDERSIZE.y;\r\n\tuv *= zoom; // Scale the coordinate system\r\n\tuv = rotate2d(rotateCanvas*-TWO_PI) * uv; \r\n\t\r\n\t\r\n\t// waves\r\n\tvec3 wave_color = vec3(0.0);\r\n\t\r\n\tfloat wave_width = 0.01;\r\n\tfor(int i = 0; i < 10; ++i) {\r\n\t\t\r\n\t\tuv = rotate2d(twisted*-TWO_PI) * uv; \r\n\r\n\t\tuv.y +=  sin(sin(TIME/5 * PI) * sin(uv.x + float(i)*mod1 + (scroll * TWO_PI) ) * amp + (mod2 * PI));\r\n\t\twave_width = abs(1.0 / (50.0 * uv.y * glow));\r\n\t\twave_color += vec3(wave_width, wave_width, wave_width);\r\n\t}\r\n\t\r\n\tout_FragColor = vec4(wave_color, 1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"WaveLines","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"no_motion","TYPE":"toggle","UI_GROUP":"ungrouped"}],"CREDIT":"Synesthesia","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\default\\welcome_scene.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Welcome Scene","IMAGES":[{"NAME":"logo","PATH":"images/logo.png"},{"NAME":"text","PATH":"images/text.png"}],"IMAGE_PATH":"welcome_scene.synScene\\welcome_scene.png","JSON_CODE":"{\n \"TITLE\": \"Welcome Scene\",\n \"CREDIT\": \"Synesthesia\",\n \"IMAGE_PATH\":\"welcome_scene.png\",\n \"IMAGES\": [\n {\"NAME\":\"logo\", \"PATH\":\"images/logo.png\"},\n {\"NAME\":\"text\", \"PATH\":\"images/text.png\"}\n ],\n \"CONTROLS\":[\n {\"NAME\":\"no_motion\", \"TYPE\":\"toggle\", \"DEFAULT\":0.0}\n ],\n \"PASSES\":[{\"TARGET\":\"logoPass\"}]\n\n }","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"logoPass","WIDTH":0}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nvar bpmcount = new BPMCounter();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar bpmTime = 0;\nvar bassT = 0.0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM;\n  bpmcount.updateTime(bpm, dt*Math.pow(inputs.syn_FadeInOut,2.0));\n\n  uniforms.script_time = (bpmcount.count + Math.pow(bpmcount.timeWithinBeat, 0.2));\n\n  // if (bpmcount.didIncrement == 1.0){\n  //   tAtLast0 = bpmTime;\n  // }\n  // bpmTime = tAtLast0;\n  // bpmTime += (1. - Math.exp(-bpmcount.timeWithinBeat*3.))*inputs.amount_to_step;\n  // uniforms.script_time = bpmTime;\n\n  bassT = bassT + Math.pow(inputs.syn_BassLevel*0.5,2.0);\n  uniforms.script_bass_time = bassT;\n\n\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"\nvec2 resolution = RENDERSIZE;\nfloat time = syn_Time / 6.0;\n\nvec2 quadrantToPolar(vec2 uv){\n  float r = length(uv);\n  float theta = 0.0;\n  float real = uv.x;\n  float imag = uv.y;\n  if (real >  0 && imag >= 0) theta = atan(imag/real);\n  if (real <= 0 && imag >  0) theta = -1*atan(real/imag)+PI/2;\n  if (real <  0 && imag <= 0) theta = atan(imag/real)+PI;\n  if (real >= 0 && imag <  0) theta = -1*atan(real/imag)+3*PI/2;\n  theta = theta/(2*PI);\n  return vec2(r, theta);\n}\n\nstruct ring\n{\n  float index;\n  float radOut;\n  float radIn;\n  float squishVal;\n  vec2 trans;\n};\n\nvec3 colRings[7];\n\nring ring1 = ring(1.0, 0.445, 0.405, 0.92, vec2(0.0,-0.01));\nring ring2 = ring(2.0, 0.38, 0.34, 0.925, vec2(0.0,-0.01));\nring ring3 = ring(3.0, 0.33, 0.29, 0.95, vec2(0.0,-0.005));\nring ring4 = ring(4.0, 0.281, 0.245, 1.0, vec2(0.002,-0.000));\nring ring5 = ring(5.0, 0.245, 0.203, 1.0, vec2(0.002,-0.000));\nring ring6 = ring(6.0, 0.202, 0.167, 1.0, vec2(0.002,-0.000));\nring ring7 = ring(7.0, 0.1225, 0.094, 1.0, vec2(0.002,-0.000));\n\nring white = ring(1.0, 0.203, 0.094+syn_BassLevel*0.015+syn_BassPresence*0.015, 1.0, vec2(0.002,-0.000));\nring pupil = ring(1.0, 0.093, 0.0, 1.0, vec2(0.002,-0.000));\nring pupilShine = ring(0.0, 0.083, 0.053, 1.0, vec2(0.002,-0.000));\n\n\n\nfloat map(vec2 p) {\n  for(int i = 0; i < 100; i++) {\n    float a = sin(float(i * 10) + (p.x * p.y) + time) + cos(p.y);\n    if(a > 0.0) return a;\n  }\n  return 0.0;\n}\n\n\nfloat effect( void ) {\n  vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n  float color = map(uv * 10.0);\n  color = clamp(color-0.5, 0.0, 1.0);\n  color *= 0.2;\n  return color;\n}\n\nfloat genRing(ring ringIn, float modVal, bool modIfTrue){\n  vec2 polPos = _toPolar(2.0*_uvc*vec2(ringIn.squishVal,1.0)+ringIn.trans);\n  float retVal = 0.0;\n  float modder = 0.0;\n  if (modIfTrue){\n    modder = 1.0;\n  }\n  vec2 polPos2 = _toPolarTrue(1.5*_uvc);\n  vec2 polPos3 = _toPolarTrue(_rotate(1.5*_uvc, PI));\n  vec2 mixerPos = _toPolarTrue(_rotate(1.5*_uvc, PI/2));\n\n  float pushOut = pow((1.0+ringIn.index/7.0),2.0)*pow(syn_MidPresence,2.0)*0.05*modder;\n  float ripples = pow(ringIn.radIn,1.8)*(syn_HighPresence+syn_MidHighPresence)*pow(syn_HighHits,1.7)*_rand(mix(polPos2*vec2(1.0,10.0), polPos3*vec2(1.0,3.0), abs(polPos2.y-0.5)*2.0)+syn_HighTime)*0.1;\n  // pushOut = 0.0;\n  if (polPos.x>ringIn.radIn+pushOut+ripples && polPos.x<ringIn.radOut+pushOut+ripples){\n    retVal = 1.0;\n  }\n  return retVal;\n}\n\nvec3 genRingCols(vec3 ringColsIn[7], float ringSpacesIn[7], float whiteSpace){\n  vec3 retCol = vec3(0.0);\n  for (int i=0; i<7; i++){\n    retCol += ringColsIn[i]*ringSpacesIn[i];\n    whiteSpace = whiteSpace - ringSpacesIn[i];\n  }\n  retCol += clamp(vec3(1.0)*whiteSpace, vec3(0.0), vec3(1.0));\n  return retCol;\n}\n\nfloat ring1Gaps[4] = float[4](0.16, 0.34, 0.585, 0.92);\nfloat ring2Gaps[4] = float[4](0.14, 0.365, 0.57, 0.937);\nfloat ring3Gaps[6] = float[6](0.13, 0.3, 0.57, 0.63, 0.81, 0.844);\nfloat ring4Gaps[2] = float[2](0.645, 0.9);\nfloat ring5Gaps[2] = float[2](0.667, 0.965);\nfloat ring6Gaps[2] = float[2](0.175, 0.49);\nfloat ring7Gaps[2] = float[2](0.53, 0.88);\nfloat pupilShineGaps[2] = float[2](0.06, 0.2);\n\nvec2 correctImageCoords(vec2 uv, vec2 imageSize){\n  float wr = RENDERSIZE.x/imageSize.x;\n  float hr = RENDERSIZE.y/imageSize.y;\n  float ratio = _ratioFix(wr, hr);\n\n  uv.y *= hr/ratio;\n  uv.x *= wr/ratio;\n\n  uv.x += -wr/ratio/2 + 0.5;\n  uv.y += -hr/ratio/2 + 0.5;\n\n  return uv;\n}\n\nvec4 renderLogo() {\n  vec2 pos = _uvc;\n  pos += vec2(0.5,0.5);\n  pos = clamp(pos, vec2(0.0, 0.0), vec2(1.0, 1.0));\n\n  vec2 polarPos = quadrantToPolar(_uvc);\n\n  float rotTime = script_time;\n\n  float ring1Space = genRing(ring1, 2.11, true);\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.02, floor(rotTime*0.02), pow(1.0-syn_FadeInOut, 3.0)));\n  if (((polarPos.y > ring1Gaps[0])&&(polarPos.y < ring1Gaps[1]))||((polarPos.y > ring1Gaps[2])&&(polarPos.y < ring1Gaps[3]))) {\n    ring1Space *= 0.0;\n  }\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.02, floor(rotTime*0.02), pow(1.0-syn_FadeInOut, 3.0)));\n  float ring2Space = genRing(ring2, 3.17, true);\n  if (((polarPos.y > ring2Gaps[0])&&(polarPos.y < ring2Gaps[1]))||((polarPos.y > ring2Gaps[2])&&(polarPos.y < ring2Gaps[3]))) {\n    ring2Space *= 0.0;\n  }\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.02, floor(rotTime*0.02), pow(1.0-syn_FadeInOut, 3.0)));\n  float ring3Space = genRing(ring3, 3.47, true);\n  if (((polarPos.y > ring3Gaps[0])&&(polarPos.y < ring3Gaps[1]))||((polarPos.y > ring3Gaps[2])&&(polarPos.y < ring3Gaps[3]))||((polarPos.y > ring3Gaps[4])&&(polarPos.y < ring3Gaps[5]))) {\n    ring3Space *= 0.0;\n  }\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.04, floor(rotTime*0.04), pow(1.0-syn_FadeInOut, 3.0)));\n  float ring4Space = genRing(ring4, 2.2, true);\n  if ((polarPos.y > ring4Gaps[0])&&(polarPos.y < ring4Gaps[1])) {\n    ring4Space *= 0.0;\n  }\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.04, floor(rotTime*0.04), pow(1.0-syn_FadeInOut, 4.0)));\n  float ring5Space = genRing(ring5, 1.3, true);\n  if ((polarPos.y > ring5Gaps[0])&&(polarPos.y < ring5Gaps[1])) {\n    ring5Space *= 0.0;\n  }\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.08, floor(rotTime*0.08), pow(1.0-syn_FadeInOut, 4.0)));\n  float ring6Space = genRing(ring6, 1.1, true);\n  if ((polarPos.y > ring6Gaps[0])&&(polarPos.y < ring6Gaps[1])) {\n    ring6Space *= 0.0;\n  }\n  polarPos.y = fract(polarPos.y + mix(rotTime*0.16, floor(rotTime*0.16), pow(1.0-syn_FadeInOut, 4.0)));\n  float ring7Space = genRing(ring7, 0.537, true);\n  if ((polarPos.y > ring7Gaps[0])&&(polarPos.y < ring7Gaps[1])) {\n    ring7Space *= 0.0;\n  }\n\n  float whiteSpace = genRing(white, 0.0, false);\n  float pupilSpace = genRing(pupil, 0.0, false);\n  float pupilShineSpace = genRing(pupilShine, syn_HighHits+1.0, false);\n  if ((polarPos.y < pupilShineGaps[0])||(polarPos.y > pupilShineGaps[1])) {\n    pupilShineSpace *= 0.0;\n  }\n  float ringSpaces[7] = float[7](ring1Space, ring2Space, ring3Space, ring4Space, ring5Space, ring6Space, ring7Space);\n\n  vec3 ringCol = genRingCols(colRings, ringSpaces, whiteSpace);\n  ringCol += pupilShineSpace;\n\n  vec3 colLogo = texture(logo, clamp(pos*2.0-vec2(0.5),0.0,1.0)).rgb;\n  // colLogo *= (0.5);\n\n\n  vec3 finalCol = mix(ringCol, colLogo, no_motion);\n\n  return vec4(finalCol, 1.0);\n}\n\nvec4 renderMain(){\n  colRings = vec3[7](_normalizeRGB(46, 191, 239), _normalizeRGB(97, 164, 147), _normalizeRGB(102, 84, 164), \n  _normalizeRGB(238, 38, 141), _normalizeRGB(245, 135, 56), _normalizeRGB(248, 239, 36), _normalizeRGB(46, 191, 239));\n\n  if (PASSINDEX == 0.0){\n    return renderLogo();\n  } else if (PASSINDEX == 1.0){\n    vec2 coords = correctImageCoords(_uv*4.5-vec2(1.44,0.55)*(4.5/3.7), textureSize(text, 0));\n    vec3 textCol = texture(text, clamp(coords,0.0,1.0)).rgb;\n    if ((coords.x > 0.91)||(coords.x < 0.09)||(coords.t < 0.2)||(coords.t > 0.8)){\n      textCol = vec3(0.0);\n    }\n    return texture(logoPass, _uv-vec2(0.0,0.15))+vec4(textCol,0.0)*mix(1.0, 0.0, pow(syn_FadeInOut,0.2)*(1.0-no_motion));\n  }\n}\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Welcome Scene","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[-1,-1],"NAME":"rot","PARAMS":0.00999999977648258,"TYPE":"xy smooth","UI_GROUP":"ungrouped"},{"DEFAULT":[0,0],"DESCRIPTION":"","MAX":[1,1],"MIN":[-1,-1],"NAME":"vect","TYPE":"xy","UI_GROUP":"ungrouped"}],"CREDIT":"by mojovideotech","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\wessels.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Wessels","IMAGES":null,"IMAGE_PATH":"wessels.synScene\\wessels.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t],\n\t\t\t\"NAME\" : \"rot\",\n\t\t\t\"PARAMS\" : 0.01,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t],\n\t\t\t\"NAME\" : \"vect\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by mojovideotech\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"wessels.png\",\n\t\"TITLE\" : \"Wessels\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\r\n\r\n// Wessels by mojovideotech\r\n// based on :\r\n// glslsandbox.com/e#32687.0\r\n\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nfloat noise(vec3 x)\t{\treturn mod(mod(x.x, PI )*x.y, atan(x.z)/3.0);\t}\r\n\r\nfloat map(vec3 p) {\r\n\tp.z += syn_BassTime*0.1;\r\n\tfloat n = abs(dot(cos(p.yzx*PI), sin(p*PI)));\r\n\treturn 0.45 - n * 0.35 + 0.02*noise(p*sin(p.z)*3.0) - 0.019*noise(p*sin(p.z)*3.1) ; //0.43 - n*.34 + 0.02*noise(p) + 0.02*noise(20.0*p);\r\n}\r\n\r\nfloat march(vec3 ro, vec3 rd) {\r\n\tfloat t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 90; i++) {\r\n\t\tfloat h = map(ro + rd*t);\r\n\t\tif(abs(h) < 0.001 || t >= 10.0) break;\r\n\t\tt += h*0.5;\r\n\t}\r\n\t\r\n\treturn t;\r\n}\r\n\r\nvec3 normal(vec3 p) {\r\n\tvec2 h = vec2(0.01, 0.0);\r\n\tvec3 n = vec3(\r\n\t\tmap(p + h.xyy) - map(p - h.xyy),\r\n\t\tmap(p + h.yxy) - map(p - h.yxy),\r\n\t\tmap(p + h.yyx) - map(p - h.yyx)\r\n\t);\r\n\treturn normalize(n);\r\n}\r\n\r\n\r\nmat3 camera(vec3 eye, vec3 lat) {\r\n\tvec3 ww = normalize(lat - eye);\r\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\r\n\tvec3 vv = normalize(cross(ww, uu));\r\n\t\r\n\treturn mat3(uu, vv, ww);\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tvec2 uv = -1.0 + 2.0*(_xy.xy/RENDERSIZE);\r\n\tuv.x *= RENDERSIZE.x/RENDERSIZE.y;\r\n\tvec3 col = vec3(0);\r\n\tvec3 ro = vec3(rot.y, rot.x, vect.x)*syn_Time/120;\r\n\tvec3 rd = camera(ro, vec3(-rot.x, -rot.y, vect.y))*normalize(vec3(uv, 0.95));\r\n\tfloat i = march(ro, rd);\r\n\t\r\n\tif(i < 16.0) {\r\n\t\tvec3 pos = ro + rd*i;\r\n\t\tvec3 nor = normal(pos);\r\n\t\tvec3 lig = normalize(vec3(0.8, 0.7, -0.2));\r\n\t\tfloat amb = 0.5 + 0.5*nor.y;\r\n\t\tfloat dif = clamp(dot(lig, nor), 0.3, 0.1);\r\n\t\tcol  = 0.5*amb*vec3(1);\r\n\t\tvec3 mat = vec3(0.4, 0.3, 0.2);\r\n\t\tmat = mix(mat, vec3(1.0, 0.2, 0.2), smoothstep(0.0, 1.0, 60.0));\r\n\t\tcol *= mat;\r\n\t\tcol += 0.2*vec3(1)*dif;\r\n\t}\r\n\t\r\n\tcol = mix(col, vec3(1.0, 0.8, 0.9), 1.0 - exp(-i*0.09));\r\n\t\r\n\tout_FragColor = vec4(col, 1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Wessels","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":100,"DESCRIPTION":"","MAX":200,"MIN":1,"NAME":"lines","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"linesStartOffset","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.100000001490116,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"amp","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":-6,"DESCRIPTION":"","MAX":0,"MIN":-40,"NAME":"glow","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"mod1","PARAMS":0.158000007271767,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0.00999999977648258,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"mod2","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.0199999995529652,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"twisted","PARAMS":0.27700001001358,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":11,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"zoom","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"rotateCanvas","PARAMS":0.167999997735023,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"scroll","PARAMS":0.178000003099442,"TYPE":"slider smooth","UI_GROUP":"ungrouped"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"pos","PARAMS":0.190999999642372,"TYPE":"xy smooth","UI_GROUP":"ungrouped"}],"CREDIT":"","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\wisps.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Wisps","IMAGES":null,"IMAGE_PATH":"wisps.synScene\\wisps.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 100,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 200,\n\t\t\t\"MIN\" : 1,\n\t\t\t\"NAME\" : \"lines\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"linesStartOffset\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"amp\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : -6,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0,\n\t\t\t\"MIN\" : -40,\n\t\t\t\"NAME\" : \"glow\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"mod1\",\n\t\t\t\"PARAMS\" : 0.158,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.01,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : -1,\n\t\t\t\"NAME\" : \"mod2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.02,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"twisted\",\n\t\t\t\"PARAMS\" : 0.277,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 11,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"zoom\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"rotateCanvas\",\n\t\t\t\"PARAMS\" : 0.168,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"scroll\",\n\t\t\t\"PARAMS\" : 0.178,\n\t\t\t\"TYPE\" : \"slider smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"pos\",\n\t\t\t\"PARAMS\" : 0.191,\n\t\t\t\"TYPE\" : \"xy smooth\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"wisps.png\",\n\t\"TITLE\" : \"Wisps\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"// SaturdayShader Week 30 : Wisps\r\n// by Joseph Fiola (http://www.joefiola.com)\r\n// 2016-03-12\r\n\r\n// Based on Week 29 Saturday Shader + \"WAVES\" Shadertoy by bonniem\r\n// https://www.shadertoy.com/view/4dsGzH\r\n\r\n#define TWO_PI 6.28318530718\r\n\r\nmat2 rotate2d(float _angle){\r\n    return mat2(cos(_angle),-sin(_angle),\r\n                sin(_angle),cos(_angle));\r\n}\r\n\r\nvec4 renderMain() { \r\n \tvec4 out_FragColor = vec4(0.0);\r\n\r\n\tvec2 uv = _xy.xy / RENDERSIZE.xy;\r\n\tuv -= vec2(pos);\r\n\tuv.x *= RENDERSIZE.x/RENDERSIZE.y;\r\n\tuv *= zoom; // Scale the coordinate system\r\n\tuv = rotate2d(rotateCanvas*-TWO_PI) * uv; \r\n\t\r\n\t\r\n\t// waves\r\n\tvec3 wave_color = vec3(0.0);\r\n\t\r\n\tfloat wave_width = 0.01;\r\n\t//uv  = -1.0 + 2.0 * uv;\r\n\t//uv.y += 0.1;\r\n\tfor(float i = 0.0; i < 200.0; i++) {\r\n\t\t\r\n\t\tuv = rotate2d(twisted*-TWO_PI) * uv; \r\n\t\tif (lines <= i) break;\r\n\t\t\r\n\t\tuv.y +=  sin(sin((TIME/12+syn_BassTime/20.) * PI)*12.*sin(uv.x + i*mod1 + (scroll * TWO_PI) ) * amp + (mod2 * PI));\r\n\r\n\t\t\r\n\t\tif(lines * linesStartOffset - 1.0 <= i) {\r\n\t\t\twave_width = abs(1.0 / (50.0 * uv.y * glow));\r\n\t\t\twave_color += vec3(wave_width, wave_width, wave_width);\r\n\t\t}\r\n\t}\r\n\t\r\n\tout_FragColor = vec4(wave_color, 1.0);\r\n\r\nreturn out_FragColor; \r\n } \r\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Wisps","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":2,"DESCRIPTION":"","MAX":10,"MIN":0.000500000023748726,"NAME":"lineScale","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":2,"DESCRIPTION":"","MAX":200,"MIN":0,"NAME":"harmonic","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":100,"MIN":0,"NAME":"lineOffsetSpeed","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":1.5,"DESCRIPTION":"","MAX":10,"MIN":0.100000001490116,"NAME":"brightness","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.5,"MIN":0,"NAME":"contrast","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.5,"MIN":-0.5,"NAME":"contrastShift","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":43759,"DESCRIPTION":"","MAX":50000,"MIN":0,"NAME":"randomMultiply","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":[12.9899997711182,12.9899997711182],"DESCRIPTION":"","MAX":[100,100],"MIN":[0,0],"NAME":"randomAmt","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[0.5,0.5],"DESCRIPTION":"","MAX":[1,1],"MIN":[0,0],"NAME":"origin","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[6,6],"DESCRIPTION":"","MAX":[100,100],"MIN":[0,0],"NAME":"xyStretch","TYPE":"xy","UI_GROUP":"ungrouped"},{"DEFAULT":[10,10],"DESCRIPTION":"","MAX":[100,100],"MIN":[0,0],"NAME":"xyNoiseFactor","TYPE":"xy","UI_GROUP":"ungrouped"}],"CREDIT":"Joseph Fiola","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\zebre.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"Zebre","IMAGES":null,"IMAGE_PATH":"zebre.synScene\\zebre.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0.0005,\n\t\t\t\"NAME\" : \"lineScale\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 2,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 200,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"harmonic\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 100,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"lineOffsetSpeed\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 1.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 10,\n\t\t\t\"MIN\" : 0.1,\n\t\t\t\"NAME\" : \"brightness\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"contrast\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 0.5,\n\t\t\t\"MIN\" : -0.5,\n\t\t\t\"NAME\" : \"contrastShift\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 43759,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 50000,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"randomMultiply\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t12.99,\n\t\t\t\t12.99\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t100,\n\t\t\t\t100\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"randomAmt\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t0.5,\n\t\t\t\t0.5\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"origin\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t6,\n\t\t\t\t6\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t100,\n\t\t\t\t100\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"xyStretch\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : \n\t\t\t[\n\t\t\t\t10,\n\t\t\t\t10\n\t\t\t],\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : \n\t\t\t[\n\t\t\t\t100,\n\t\t\t\t100\n\t\t\t],\n\t\t\t\"MIN\" : \n\t\t\t[\n\t\t\t\t0,\n\t\t\t\t0\n\t\t\t],\n\t\t\t\"NAME\" : \"xyNoiseFactor\",\n\t\t\t\"TYPE\" : \"xy\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"Joseph Fiola\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"zebre.png\",\n\t\"TITLE\" : \"Zebre\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"// SaturdayShader Week 16 : Zebre\n// by Joseph Fiola (http://www.joefiola.com)\n// 2015-12-05\n// Based on Patricio Gonzalez Vivo's \"Wood Texture\" example on http://patriciogonzalezvivo.com/2015/thebookofshaders/edit.html#11/wood.frag @patriciogv ( patriciogonzalezvivo.com ) - 2015\n\n\n\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(randomAmt.x,randomAmt.y))) \n                * randomMultiply);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n\n    vec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle *xyNoiseFactor.x),-sin(angle),\n                sin(angle * xyNoiseFactor.y),cos(angle));\n}\n\n\nfloat lines(in vec2 pos, float b){\n    float scale = lineScale;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))* brightness);\n}\n\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n    vec2 st = _xy.xy/RENDERSIZE.xy;\n    st -= vec2(origin);\n    st.y *= RENDERSIZE.y/RENDERSIZE.x;\n\n    vec2 pos = st.yx*vec2(xyStretch);\n\n    float pattern = pos.x;\n\n    // Add noise\n    pos = rotate2d( noise(pos) ) * pos * harmonic + (TIME * lineOffsetSpeed);\n    \n    // Draw lines\n    pattern = lines(pos,0.5);\n    \n    //adjust contrast\n\tpattern += smoothstep(0.0+contrast+contrastShift,1.0-contrast+contrastShift, pattern);\n\n    out_FragColor = vec4(vec3(pattern),1.0);\n\nreturn out_FragColor; \n } \n\n","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"Zebre","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"j","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0.5,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"k","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":8,"MIN":0,"NAME":"c0","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":8,"MIN":0,"NAME":"c1","TYPE":"slider","UI_GROUP":"ungrouped"},{"DEFAULT":0,"DESCRIPTION":"","MAX":8,"MIN":0,"NAME":"c2","TYPE":"slider","UI_GROUP":"ungrouped"}],"CREDIT":"by You","DESCRIPTION":"","FOLDER_PATH":"C:\\Users\\parkm\\Dropbox\\synScenes\\flythrough.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"flythrough","IMAGES":null,"IMAGE_PATH":"flythrough.synScene\\flythrough.png","JSON_CODE":"{\n\t\"CONTROLS\" : \n\t[\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"j\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0.5,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 1,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"k\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 8,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"c0\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 8,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"c1\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t},\n\t\t{\n\t\t\t\"DEFAULT\" : 0,\n\t\t\t\"DESCRIPTION\" : \"\",\n\t\t\t\"MAX\" : 8,\n\t\t\t\"MIN\" : 0,\n\t\t\t\"NAME\" : \"c2\",\n\t\t\t\"TYPE\" : \"slider\",\n\t\t\t\"UI_GROUP\" : \"ungrouped\"\n\t\t}\n\t],\n\t\"CREDIT\" : \"by You\",\n\t\"DESCRIPTION\" : \"\",\n\t\"GPU\" : 0,\n\t\"HEIGHT\" : 1080,\n\t\"IMAGE_PATH\" : \"flythrough.png\",\n\t\"TITLE\" : \"flythrough\",\n\t\"WIDTH\" : 1920\n}","PASSES":null,"SCRIPT_CODE":"","SHADER_CODE":"\n\nvec3   iResolution = vec3(RENDERSIZE, 1.0);\nfloat  iGlobalTime = TIME;\n\nconst int MAX_ITER = 20; // \n\nvec2 rotate(in vec2 v, in float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat torus(in vec3 p, in vec2 t)\n{\n\tvec2 q = abs(vec2(max(abs(p.x), abs(p.z))-t.x, p.y));\n\treturn max(q.x, q.y)-t.y;\n}\n\n\nfloat eval(in float x, in vec3 p) {\n\tif ( x < 1.0)\n\t\treturn abs(max(abs(p.z)-k, abs(p.x)-0.1))-0.01;\n\tif ( x < 2.0)\n\t\treturn length(max(abs(p.xy) - k/10.,0.0));\n\tif ( x < 3.0)\n\t\treturn length(p)-j;\n\tif ( x < 4.0)\n\t\treturn length(max(abs(p) - 0.35, 0.0));\n\tif ( x < 5.0)\n\t\treturn abs(length(p.xz)-0.2)-0.01;\n\tif ( x < 6.0)\n\t\treturn abs(min(torus(vec3(p.x, mod(p.y,0.4)-0.2, p.z), vec2(0.1, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005;\n\tif ( x < 7.0)\n\t\treturn abs(min(torus(p, vec2(0.3, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005;\n\tif ( x < 8.0)\n\treturn min(length(p.xz), min(length(p.yz), length(p.xy))) - 0.05;\n}\n\n// These are all equally interesting, but I could only pick one :(\nfloat trap(in vec3 p)\n{\n\tfloat a = eval(c0, p);\n\tfloat b = eval(c1, p);\n\tfloat c = eval(c2, p);\n\t\n\treturn  min(max(a, -b), c);\n\t//return  min(max(var1, -var3), var7);\n\t\n}\n\nfloat map(in vec3 p)\n{\n\tfloat cutout = dot(abs(p.yz),vec2(0.5))-0.035;\n\n\tvec3 z = abs(1.0-mod(p,2.0));\n\tfloat d = 999.0;\n\tfloat s = 1.0;\n\tfor (float i = 0.0; i <4.0; i++) {\n\t    z.zx = rotate(z.zx, radians(i*10.0+iGlobalTime));\n\t\tz.zy = rotate(z.yz, radians((i+1.0)*20.0+iGlobalTime*1.1234));\n\t\tz = abs(1.0-mod(z+i/3.0,2.0));\n\t\t\n\t\tz = z*2.0 - 0.3;\n\t\ts *= 0.5;\n\t\td = min(d, trap(z) * s);\n\t}\n\treturn max(d, -cutout);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 intersect(in vec3 rayOrigin, in vec3 rayDir)\n{\n\tfloat total_dist = 0.0;\n\tvec3 p = rayOrigin;\n\tfloat d = 1.0;\n\tfloat iter = 0.0;\n\tfloat mind = 3.14159;//+sin(iGlobalTime*0.1)*0.2;\n\t\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\t\t\n\t\tif (d < 0.001) continue;\n\t\t\n\t\td = map(p);\n\t\tp += d * rayDir;\n\t\tmind = min(mind, d);\n\t\ttotal_dist += d;\n\t\titer++;\n\t}\n\n\tvec3 color = vec3(0.0);\n\tfloat x = (iter/float(MAX_ITER));\n\n\tfloat q = 1. - x;\n\tcolor = hsv(d*5., 1.0,1.0) * q;\n\treturn color;\n}\n\nvec4 renderMain() { \n \tvec4 out_FragColor = vec4(0.0);\n\n\tvec3 upDirection = vec3(0, -1, 0);\n\tvec3 cameraDir = vec3(1,0,0);\n\tvec3 cameraOrigin = vec3(iGlobalTime*0.1, 0, 0);\n\n\t\n\tvec2 screenPos = -1.0 + 2.0 * _xy.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tvec3 rayDir = normalize(vec3(1.0, screenPos));\n\t\n\tout_FragColor = vec4(intersect(cameraOrigin, rayDir), 10.0);\n\nreturn out_FragColor; \n } \n ","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"flythrough","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"Center for no flight. Up to fly forward, down to fly backwards.","MAX":1,"MIN":0,"NAME":"fly_in_out","PARAMS":0.0500000007450581,"TYPE":"slider traveler","UI_GROUP":"camera"},{"DEFAULT":1,"DESCRIPTION":"Turn off to stop the forward progress on the beat.","MAX":1,"MIN":0,"NAME":"forward_on_beat","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"twitch","TYPE":"toggle","UI_GROUP":"camera"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"down_rot","TYPE":"bang counter","UI_GROUP":"rotate"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"right_rot","TYPE":"bang counter","UI_GROUP":"rotate"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"invert","TYPE":"toggle","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"aberration","TYPE":"toggle","UI_GROUP":"color"}],"CREDIT":"Anonymous","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\lattix.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"lattix","IMAGES":null,"IMAGE_PATH":"lattix.synScene\\lattix.png","JSON_CODE":"{\n \"CREDIT\": \"Anonymous\",\n \"TITLE\": \"lattix\",\n \"IMAGE_PATH\": \"lattix.png\",\n \"IMAGES\": [],\n \"PASSES\": [{\"TARGET\":\"firstBuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"fly_in_out\",\n    \"PARAMS\": 0.05,\n    \"TYPE\": \"slider traveler\",\n    \"UI_GROUP\":\"camera\",\n    \"DESCRIPTION\": \"Center for no flight. Up to fly forward, down to fly backwards.\"\n  },{\n    \"NAME\": \"forward_on_beat\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\":\"camera\",\n    \"DESCRIPTION\": \"Turn off to stop the forward progress on the beat.\"\n  },{\n    \"NAME\": \"twitch\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\":\"camera\"\n  },{\n    \"NAME\": \"down_rot\",\n    \"TYPE\": \"bang counter\",\n    \"UI_GROUP\":\"rotate\"\n  },{\n    \"NAME\": \"right_rot\",\n    \"TYPE\": \"bang counter\",\n    \"UI_GROUP\":\"rotate\"\n  },{\n    \"NAME\": \"invert\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"color\"\n  },{\n    \"NAME\": \"aberration\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"color\"\n  }]\n }","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"firstBuffer","WIDTH":0}],"SCRIPT_CODE":"function BPMCounter () {\n  this.time = 0.0;\n  this.count = 0.0;\n  this.timeWithinBeat = 0.0;\n  this.didIncrement = 0.0;\n}\n\nBPMCounter.prototype.updateTime = function(bpm, dt) {\n  this.didIncrement = 0.0;\n  var amountToStepThroughBeat = 0.5*bpm*dt/60.0;\n  this.time = this.time+amountToStepThroughBeat;\n  if(this.count != Math.floor(this.time)){\n    this.count = Math.floor(this.time);\n    this.didIncrement = 1.0;\n  };\n  this.timeWithinBeat = this.time-this.count;\n}\n\nfunction SmoothCounter () {\n  this.oldCount = 0.0;\n  this.isGoing = 0.0;\n  this.currentValue = 0.0;\n}\n\nSmoothCounter.prototype.update = function(dt, newCount, speed) {\n  this.currentValue = this.currentValue+(newCount-this.currentValue)*speed;\n}\n\nvar bpmcount = new BPMCounter();\nvar downrot = new SmoothCounter();\nvar rightrot = new SmoothCounter();\n\nvar decimator = 0;\nvar tAtLast0 = 0;\nvar t = 0;\n\nfunction update(dt) {\n\n  var bpm = inputs.syn_BPM;\n  bpmcount.updateTime(bpm, dt);\n\n  if (bpmcount.didIncrement == 1.0){\n    tAtLast0 = t;\n  }\n  t = tAtLast0;\n  t += (1. - Math.exp(-bpmcount.timeWithinBeat*5.));\n  uniforms.script_time = t;\n\n  downrot.update(dt, inputs.down_rot, 0.1);\n  rightrot.update(dt, inputs.right_rot, 0.1);\n\n  uniforms.down_rot_scr = downrot.currentValue;\n  uniforms.right_rot_scr = rightrot.currentValue;\n\n  // decimator++;\n  // if (decimator%10==0){\n  //   print(t);\n  // }\n\n}\nfunction transition() {\n  //log(5);\n}\n","SHADER_CODE":"float time = TIME;\nvec2 mouse = vec2(0.5);\nvec2 resolution = RENDERSIZE;\n\nconst int ite_max = 50;\nconst float dist_coeff = 1.00;\nconst float dist_min = 0.01;\nconst float dist_max = 1000.0;\nconst float inf = 999999999.0;\n\n\nfloat sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat crossline(vec3 p, float s) {\n    float da = box(p.xyz, vec3(inf, s, s));\n    float db = box(p.xyz, vec3(s, inf, s));\n    float dc = box(p.xyz, vec3(s, s, inf));\n    return min(da,min(db,dc));\n}\n\nfloat sub(float a, float b) {\n    return max(-a,b);\n}\n\n\nfloat modcross(vec3 p) {\n    return sub(sphere(p, 0.14), crossline( p, 0.02 ) );\n}\n\n\nfloat repeatCrossline( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5 * c;\n    return modcross( q );\n}\n\n\nfloat map(vec3 p) {\n    float t = dist_max;\n    float w = 0.0;\n    \n    // w = box(p, vec3(0.2));\n    w = repeatCrossline(p+vec3(p.x,p.y,0.0)*(0.025+syn_OnBeat*0.03)*twitch*2.0, vec3(0.5+syn_Presence*0.5, 0.5+syn_Presence*0.5, 0.5));\n    t = min(t,w);\n    return t;\n}\n\n\nvec3 intersect(vec3 pos, vec3 dir){\n    float t = 0.0;\n    float hit = 0.0;\n\n    for(int i=0; i < ite_max; i++) {\n        float ttemp = map(t * dir + pos);\n        if(ttemp < dist_min){\n        hit = 1.0;\n        break;\n        } \n        \n        t += ttemp * dist_coeff;\n    }\n    vec3 col = vec3(0.6)*t;\n    if (syn_MediaType > 0.5){\n        col = _loadUserImage().rgb*t;\n    }\n    return col;\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n  float ca = cos(angle); float sa = sin(angle);\n  return v*mat3(\n                +ca, +.0, -sa,\n                +.0,+1.0, +.0,\n                +sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n  float ca = cos(angle); float sa = sin(angle);\n  return v*mat3(\n                +1.0, +.0, +.0,\n                +.0, +ca, -sa,\n                +.0, +sa, +ca);\n}\n\n\nvec4 renderMain( void ) {\n    if (PASSINDEX == 0.0){\n        vec2 uv = ( _xy / resolution.xy ) * 2.0 - 1.0;\n        \n        float aspect = resolution.x / resolution.y;\n        vec3 dir = normalize(vec3( uv * vec2(aspect, 1.0), 1.0)+vec3(sin(TIME), cos(TIME), 0.0)*syn_HighHits*0.1*twitch);\n        dir = rotate_y(dir, -PI*0.5*right_rot_scr);\n        dir = rotate_x(dir, PI*0.5*down_rot_scr);\n\n        vec3 pos = vec3(0,0,script_time*0.5*forward_on_beat+fly_in_out);\n            \n        vec3 color = intersect(pos, dir);\n        \n        return vec4(color, 1.0);\n    } else if (PASSINDEX == 1.0){\n        vec4 prevCol = texture(firstBuffer, _uv);\n\n        vec2 lookupSpot = _uvc*0.03*_rand(_uvc*100.0+TIME)*(0.5+syn_BassLevel)*aberration;\n\n        vec4 redCol = vec4(1.0,0.3,0.0,0.0)*texture(firstBuffer, _uv+lookupSpot*2.0);\n        vec4 ylwCol = vec4(0.6,0.8,0.1,0.0)*texture(firstBuffer, _uv+lookupSpot);\n        vec4 bluCol = vec4(0.0,0.4,1.0,0.0)*texture(firstBuffer, _uv-lookupSpot);\n        vec4 vioCol = vec4(0.0,0.05,1.0,0.0)*texture(firstBuffer, _uv-lookupSpot*2.0);\n\n        vec4 mixedCol = redCol + ylwCol*0.75 + bluCol*0.75 + vioCol;\n        mixedCol *= 0.25;\n        \n        vec4 finalCol = mixedCol;\n        if (invert>0.5){\n            finalCol = 1.0-finalCol;\n        }\n\n        // if (syn_MediaType > 0.5){\n        //     finalCol *= _loadUserImage();\n        // }\n\n        return finalCol;\n    }\n\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"lattix","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"This scene only works if you have selected 'Media' below!","MAX":1,"MIN":0,"NAME":"PICK_MEDIA","TYPE":"toggle","UI_GROUP":"media"},{"DEFAULT":1,"DESCRIPTION":"Automatically refresh based on the music, rather than manually control.","MAX":1,"MIN":0,"NAME":"auto_refresh","TYPE":"toggle","UI_GROUP":"refresh"},{"DEFAULT":1,"DESCRIPTION":"Reset the pixel sort with a new frame from the media","MAX":1,"MIN":0,"NAME":"refresh","PARAMS":0.25,"TYPE":"bang smooth","UI_GROUP":"refresh"},{"DEFAULT":3.09999990463257,"DESCRIPTION":"","MAX":5,"MIN":0,"NAME":"scale_liquid","TYPE":"slider","UI_GROUP":"liquid"},{"DEFAULT":1,"DESCRIPTION":"Automatically liquify based on the music, rather than manually control with the bang below.","MAX":1,"MIN":0,"NAME":"auto_liquid","TYPE":"toggle","UI_GROUP":"liquid"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"liquify","PARAMS":0.550000011920929,"TYPE":"bang smooth","UI_GROUP":"liquid"},{"DEFAULT":0,"DESCRIPTION":"Reset simulation to underlying media.","MAX":1,"MIN":0,"NAME":"invert","PARAMS":0.25,"TYPE":"bang smooth","UI_GROUP":"color"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"colorize","TYPE":"bang","UI_GROUP":"color"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":-1,"NAME":"reverse","TYPE":"toggle","UI_GROUP":"sort"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"blend","TYPE":"toggle","UI_GROUP":"sort"},{"DEFAULT":2,"DESCRIPTION":"","MAX":8,"MIN":0,"NAME":"speed","TYPE":"slider","UI_GROUP":"sort"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\pxl_sort_1.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"pxl_sort_1","IMAGES":null,"IMAGE_PATH":"pxl_sort_1.synScene\\pxl_sort_1.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"pxl_sort_1\",\n \"IMAGE_PATH\": \"pxl_sort_1.png\",\n \"PASSES\": [{\"TARGET\": \"backbuffer\"}],\n \"CONTROLS\": [{\n    \"NAME\": \"PICK_MEDIA\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"media\",\n    \"DESCRIPTION\": \"This scene only works if you have selected 'Media' below!\"\n  },{\n    \"NAME\": \"auto_refresh\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"refresh\",\n    \"DESCRIPTION\": \"Automatically refresh based on the music, rather than manually control.\"\n  },{\n    \"NAME\": \"refresh\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,    \n    \"PARAMS\": 0.25,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"refresh\",\n    \"DESCRIPTION\": \"Reset the pixel sort with a new frame from the media\"\n  },{\n    \"NAME\": \"scale_liquid\",\n    \"MAX\" : 5.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":3.1,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"liquid\"\n  },{\n    \"NAME\": \"auto_liquid\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"liquid\",\n    \"DESCRIPTION\": \"Automatically liquify based on the music, rather than manually control with the bang below.\"\n  },{\n    \"NAME\": \"liquify\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.55,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"liquid\"\n  },{\n    \"NAME\": \"invert\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":0.0,    \n    \"PARAMS\": 0.25,\n    \"TYPE\": \"bang smooth\",\n    \"UI_GROUP\": \"color\",\n    \"DESCRIPTION\": \"Reset simulation to underlying media.\"\n  },{\n    \"NAME\": \"colorize\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0,\n    \"DEFAULT\":0.0,\n    \"PARAMS\": 0.05,\n    \"TYPE\": \"bang\",\n    \"UI_GROUP\": \"color\"\n  },{\n    \"NAME\": \"reverse\",\n    \"MAX\" : 1.0,\n    \"MIN\" : -1.0,\n    \"DEFAULT\":1.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"sort\"\n  },{\n    \"NAME\": \"blend\",\n    \"MAX\" : 1.0,\n    \"MIN\" : 0,\n    \"DEFAULT\":0.0,\n    \"TYPE\": \"toggle\",\n    \"UI_GROUP\": \"sort\"\n  },{\n    \"NAME\": \"speed\",\n    \"MAX\" : 8.0,\n    \"MIN\" : 0.0,\n    \"DEFAULT\":2.0,\n    \"TYPE\": \"slider\",\n    \"UI_GROUP\": \"sort\"\n  }]\n }","PASSES":[{"FLOAT":true,"HEIGHT":0,"TARGET":"backbuffer","WIDTH":0}],"SCRIPT_CODE":"","SHADER_CODE":"vec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat noise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i / 42.) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n///\n//\n// END NOISE SNIPPET\n//\n\nvec4 renderMain()\n{\n    const float iters = 10.0;\n\n    if (PASSINDEX == 0.0){\n        float nMed = noise(_uvc*pow(scale_liquid,2.0) + TIME*100.0);\n        float nBig = _fbm(_uvc*10.0+_pixelate(TIME, 20));\n\n        vec4 newCol = vec4(0.0);\n        if (syn_MediaType > 0.5){\n          newCol = _loadUserImage();\n        }\n        vec4 oldCol = texture(backbuffer, _uv);\n        float oldNoise = oldCol.a;\n\n        float nextNoise = oldNoise + nMed*(liquify+step(0.5, syn_HighHits)*auto_liquid);\n\n\n        if ((refresh > 0.5)||(syn_OnBeat*auto_refresh > 0.5)||(FRAMECOUNT < 5)){\n            return newCol;\n        }\n\n        vec2 direction = vec2(0.0,1.0)*reverse;\n        // direction = floor(direction);\n        direction += _rotate(direction, nextNoise*2*PI);\n        direction *= pow(1.0+length(oldCol),2.0)*0.1*speed;\n        if (blend < 0.5){\n            direction = floor(direction);\n        }\n\n        vec4 nextCol = texture(backbuffer, _uv-direction/RENDERSIZE.y);\n        nextCol = mix(nextCol, 1.0-nextCol, step(0.5,invert));\n\n        vec3 moddedCol = nextCol.rgb*(1.0-colorize)+nextCol.rgb*vec3(1.0,0.0,0.0)*2.0*colorize;\n        moddedCol = _rgb2hsv(moddedCol);\n        moddedCol.r += colorize*moddedCol.b;\n        moddedCol = _hsv2rgb(vec3(_pixelate(moddedCol.rg,colorize*5.0),moddedCol.b));\n        moddedCol = clamp(moddedCol, 0.0, 1.0);\n        nextCol.rgb = mix(nextCol.rgb, moddedCol, step(0.5,colorize));\n\n        vec4 finalCol = nextCol;\n        finalCol.a = nextNoise;\n        return finalCol;\n    } else if (PASSINDEX == 1.0){\n        return texture(backbuffer, _uv);\n    }\n\n\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"pxl_sort_1","WIDTH":1920,"isDisabled":false},{"CONTROLS":[{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"circle_or_tri","PARAMS":0.100000001490116,"TYPE":"toggle smooth","UI_GROUP":"geometry"},{"DEFAULT":0,"DESCRIPTION":"","MAX":0.200000002980232,"MIN":-0.200000002980232,"NAME":"distort","PARAMS":0.100000001490116,"TYPE":"slider smooth","UI_GROUP":"geometry"},{"DEFAULT":1,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"layers_on","PARAMS":0.100000001490116,"TYPE":"toggle smooth","UI_GROUP":"layers"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"twist","PARAMS":0.00999999977648258,"TYPE":"toggle smooth","UI_GROUP":"layers"},{"DEFAULT":0,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"flashing","TYPE":"toggle","UI_GROUP":"layers"},{"DEFAULT":0.200000002980232,"DESCRIPTION":"","MAX":1,"MIN":0,"NAME":"power_zoom","PARAMS":0.00999999977648258,"TYPE":"slider smooth","UI_GROUP":"layers"},{"DEFAULT":1,"DESCRIPTION":"Use this scene with Media!","MAX":1,"MIN":0,"NAME":"media_on","PARAMS":0.200000002980232,"TYPE":"toggle smooth","UI_GROUP":"media"}],"CREDIT":"Meebs","DESCRIPTION":"","FOLDER_PATH":"C:\\Program Files (x86)\\Synesthesia\\release\\replik8.synScene","GPU":0,"HARD_TRANSITIONS":null,"HEIGHT":1080,"ID":"replik8","IMAGES":[{"NAME":"colornoise","PATH":"images/colornoise.jpg"}],"IMAGE_PATH":"replik8.synScene\\replik8.png","JSON_CODE":"{\n \"CREDIT\": \"Meebs\",\n \"TITLE\": \"replik8\",\n \"IMAGE_PATH\": \"replik8.png\",\n \"IMAGES\": [{\n    \"PATH\": \"images/colornoise.jpg\",\n    \"NAME\": \"colornoise\"\n  }],\n \"PASSES\": [{\"TARGET\": \"backbuffer\", \"WIDTH\": 1280, \"HEIGHT\":720}],\n \"CONTROLS\": [\n {\"NAME\":\"circle_or_tri\", \"TYPE\": \"toggle smooth\", \"UI_GROUP\": \"geometry\", \"PARAMS\": 0.1},\n {\"NAME\":\"distort\", \"TYPE\": \"slider smooth\", \"UI_GROUP\": \"geometry\", \"PARAMS\": 0.1, \"MIN\":-0.2, \"MAX\":0.2, \"DEFAULT\":0.0},\n {\"NAME\":\"layers_on\", \"TYPE\": \"toggle smooth\", \"UI_GROUP\": \"layers\", \"MAX\": 1.0, \"DEFAULT\": 1.0, \"PARAMS\":0.1},\n {\"NAME\":\"twist\", \"TYPE\": \"toggle smooth\", \"UI_GROUP\": \"layers\", \"MAX\": 1.0, \"DEFAULT\": 0.0},\n {\"NAME\":\"flashing\", \"TYPE\": \"toggle\", \"UI_GROUP\": \"layers\", \"MAX\": 1.0, \"DEFAULT\": 0.0},\n {\"NAME\":\"power_zoom\", \"TYPE\": \"slider smooth\", \"UI_GROUP\": \"layers\", \"MAX\": 1.0, \"DEFAULT\": 0.2},\n {\"NAME\":\"media_on\", \"TYPE\": \"toggle smooth\", \"UI_GROUP\": \"media\", \"MAX\": 1.0, \"DEFAULT\": 1.0, \"PARAMS\":0.2, \"DESCRIPTION\":\"Use this scene with Media!\"}\n ]\n }\n","PASSES":[{"FLOAT":true,"HEIGHT":720,"TARGET":"backbuffer","WIDTH":1280}],"SCRIPT_CODE":"","SHADER_CODE":"int iFrame = int(FRAMECOUNT);\nfloat time = TIME;\nvec2 resolution = RENDERSIZE;\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n  // finalCol *= palette(fract(redAmt + grnAmt + bluAmt), vec3(0.420, 0.500, 0.500), vec3(0.500, 0.500, 0.500), vec3(0.600, 0.250, 1.200), vec3(0.500, 0.450, 0.500));\n\nvec3 rotate(vec3, float);\nfloat distance_field(vec2);\nfloat p_circle(vec2, vec3);\nvec2 polar_cart(vec2);\nvec2 cart_polar(vec2);\nvec3 cwarp(vec3);\nvec3 rotate(vec3 c, float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec3((((c).x) * (ca)) - (((c).y) * (sa)), (((c).y) * (ca)) + (((c).x) * (sa)), (c).z);\n}\nfloat distance_field(vec2 p) {\n    float dist = max(p_circle(p, vec3(0.0, 0.0, 0.6+fract(p.x*10.0)*distort)), - (max(max(max(max(p_circle(p, vec3(0.0, 0.0, 0.4)), - (max(max(p_circle(p, rotate(vec3(0.13625, -0.04, 0.52221283975), 4.18878666667)), p_circle(p, rotate(vec3(-0.25375, 0.135, 0.464630229322), 4.18878666667))), - (p_circle(p, rotate(vec3(-0.2925, -0.10125, 0.46492270863), 4.18878666667)))))), - (max(max(p_circle(p, rotate(vec3(0.13625, -0.04, 0.52221283975), 2.09439333333)), p_circle(p, rotate(vec3(-0.25375, 0.135, 0.464630229322), 2.09439333333))), - (p_circle(p, rotate(vec3(-0.2925, -0.10125, 0.46492270863), 2.09439333333)))))), - (max(max(p_circle(p, rotate(vec3(0.13625, -0.04, 0.52221283975), 0.0)), p_circle(p, rotate(vec3(-0.25375, 0.135, 0.464630229322), 0.0))), - (p_circle(p, rotate(vec3(-0.2925, -0.10125, 0.46492270863), 0.0)))))), - (max(max(max(p_circle(p, vec3(0.0, 0.18375, 0.295047665641)), p_circle(p, rotate(vec3(0.0, 0.18375, 0.295047665641), 2.09439333333))), p_circle(p, rotate(vec3(0.0, 0.18375, 0.295047665641), 4.18878666667))), - (p_circle(p, vec3(0.0, 0.0, 0.0434))))))));\n    float sign = (dist) / (dist);\n    return (sin(((dist) * (50.0 + syn_Presence*50.0)) + ((syn_HighTime*0.25) * 5.0))) * (sign);\n}\nfloat p_circle(vec2 p, vec3 c) {\n    c = cwarp(c);\n    return (length(((c).xy) - (p))) - ((c).z);\n}\nvec2 polar_cart(vec2 p) {\n    return (vec2(cos((p).x), sin((p).x))) * ((p).y);\n}\nvec2 cart_polar(vec2 p) {\n    return vec2(atan((p).y, (p).x), length(p));\n}\nvec4 pattern(vec2 fragCoord) {\n    vec2 p = ((((((fragCoord).xy) / ((RENDERSIZE).xy)) * 2.0) - 1.0) * (vec2(1.0, ((RENDERSIZE).y) / ((RENDERSIZE).x)))) * (vec2(1.2, -1.2));\n    vec2 h = vec2(0.001, 0.0);\n    float d = clamp(((abs(distance_field(p))) / (length((vec2((distance_field((p) + (h))) - (distance_field((p) - (h))), (distance_field((p) + ((h).yx))) - (distance_field((p) - ((h).yx))))) / (2.0 * ((h).x))))) * 400.0, 0.0, 1.0);\n    return vec4(d, d, d, 1.0);\n}\nvec3 cwarp(vec3 c) {\n    float t = circle_or_tri;\n    return vec3(polar_cart((cart_polar(((c).xy) * (1.0 - (t)))) + (vec2(((t) * 3.14159) * -1.0, 0.0))), ((c).z) * (((t) * 2.5) + 1.2));\n}\n\nvec4 renderMain()\n{\n    if (PASSINDEX == 0.0){\n    vec2 uv = _xy.xy / RENDERSIZE;\n    vec4 fragColor = vec4(0.0);\n    fragColor = 1.0-pattern(_xy);\n    if (syn_MediaType>0.5){\n        fragColor *= mix(vec4(1.0),_loadUserImage(),media_on);\n    }\n\n     \n\n        \n        // use texture channel0 for color? why not.\n        // vec3 cexp = texture(colornoise, uv * 0.001).xyz * 3.0 + texture(colornoise, uv * 0.01).xyz;//vec3(1.0, 2.0, 4.0);\n        // cexp *= 1.4;\n        // vec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n        // fragColor = vec4(col, 1.0);\n\n        return fragColor;\n    }\n    else if (PASSINDEX == 1.0){\n        vec4 finalCol = vec4(0.0);\n        const int iters = 5;\n        vec4 last = vec4(1.0);\n        vec4 burn = vec4(0.0);\n        for(int j = 0; j < iters; j++){\n            \n            float index = mod((TIME*0.1+syn_BassTime*0.25) + j,iters);\n            // float zoom = 0.33+index*0.33;\n            float zoom = pow(1.0-index/iters,0.05+power_zoom);\n\n            float divisor = zoom;\n            vec2 uv2 = _uv;\n            uv2 -= 0.5;\n            // uv2 *= 2.0;\n            uv2 *= zoom;\n            uv2 *= vec2(RENDERSIZE.x/RENDERSIZE.y, 1.0);\n            uv2 = _rotate(uv2, j*0.2*syn_BassPresence*twist);\n            uv2 /= vec2(RENDERSIZE.x/RENDERSIZE.y, 1.0);\n\n            // uv2 += subber*0.1;\n            uv2 += 0.5;\n            // uv2 *= 0.5;\n\n\n            float mixer = (1.0-smoothstep(iters-1, iters, index))*smoothstep(0, 1, index);\n            vec4 new = texture(backbuffer, uv2);\n            last = new;\n            finalCol += new*mixer;\n        }\n\n        finalCol /= (iters*0.5);\n        if (syn_MediaType > 0.5){\n        \tfinalCol *= 2.0;\n        \tfinalCol = clamp(finalCol, 0.0, 1.0);\n        }\n\n        // finalCol = pow(burn,vec4(3.0));\n        finalCol += pow(finalCol,vec4(5.0))*syn_HighHits*flashing*100.0;\n\n        finalCol = mix(finalCol, texture(backbuffer, _uv), 1.0-layers_on);\n\n        return finalCol;\n    }\n}","SMOOTH_TRANSITIONS":null,"TAGS":[],"TITLE":"replik8","WIDTH":1920,"isDisabled":false}],"synVersionNum":"1.21.0.78"}
